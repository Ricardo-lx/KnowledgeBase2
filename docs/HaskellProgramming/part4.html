<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Part4 - KnowledgeBase</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../HaskellProgramming/HaskellProgramming.html"><strong aria-hidden="true">1.</strong> Haskell Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../HaskellProgramming/part1.html"><strong aria-hidden="true">1.1.</strong> Part1</a></li><li class="chapter-item expanded "><a href="../HaskellProgramming/part2.html"><strong aria-hidden="true">1.2.</strong> Part2</a></li><li class="chapter-item expanded "><a href="../HaskellProgramming/part3.html"><strong aria-hidden="true">1.3.</strong> Part3</a></li><li class="chapter-item expanded "><a href="../HaskellProgramming/part4.html" class="active"><strong aria-hidden="true">1.4.</strong> Part4</a></li><li class="chapter-item expanded "><a href="../HaskellProgramming/part5.html"><strong aria-hidden="true">1.5.</strong> Part5</a></li></ol></li><li class="chapter-item expanded "><a href="../csapp/csapp.html"><strong aria-hidden="true">2.</strong> csapp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../csapp/part1.html"><strong aria-hidden="true">2.1.</strong> Part1</a></li><li class="chapter-item expanded "><a href="../csapp/part2.html"><strong aria-hidden="true">2.2.</strong> Part2</a></li><li class="chapter-item expanded "><a href="../csapp/part3.html"><strong aria-hidden="true">2.3.</strong> Part3</a></li><li class="chapter-item expanded "><a href="../csapp/part4.html"><strong aria-hidden="true">2.4.</strong> Part4</a></li><li class="chapter-item expanded "><a href="../csapp/part5.html"><strong aria-hidden="true">2.5.</strong> Part5</a></li><li class="chapter-item expanded "><a href="../csapp/part6.html"><strong aria-hidden="true">2.6.</strong> Part6</a></li><li class="chapter-item expanded "><a href="../csapp/part7.html"><strong aria-hidden="true">2.7.</strong> Part7</a></li><li class="chapter-item expanded "><a href="../csapp/part8.html"><strong aria-hidden="true">2.8.</strong> Part8</a></li><li class="chapter-item expanded "><a href="../csapp/part9.html"><strong aria-hidden="true">2.9.</strong> Part9</a></li><li class="chapter-item expanded "><a href="../csapp/part10.html"><strong aria-hidden="true">2.10.</strong> Part10</a></li></ol></li><li class="chapter-item expanded "><a href="../combined_html_page.html"><strong aria-hidden="true">3.</strong> midjourney</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">KnowledgeBase</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>as the input value to the next. While dosyntax works with
any monad ‚Äî not just IO‚Äî it is most commonly seen when
usingIO. This section is going to talk about why dois sugar and
demonstrate what the joinofMonadcan do for us. We will be
using the IO Monad to demonstrate here, but later on we‚Äôll see
some examples of dosyntax without IO.
To begin, let‚Äôs look at some correspondences:
(<em>&gt;) :: Applicative f =&gt; f a -&gt; f b -&gt; f b
(&gt;&gt;) :: Monad m =&gt; m a -&gt; m b -&gt; m b
For our purposes, (</em>&gt;)and(&gt;&gt;)are the same thing: sequenc-
ing functions, but with two diÔ¨Äerent constraints. They should
in all cases do the same thing:
Prelude&gt; putStrLn &quot;Hello, &quot; &gt;&gt; putStrLn &quot;World!&quot;
Hello,
World!</p>
<p>CHAPTER 18. MONAD 1155
Prelude&gt; putStrLn &quot;Hello, &quot; <em>&gt; putStrLn &quot;World!&quot;
Hello,
World!
Not observably diÔ¨Äerent. Good enough for government
work!
We can see what dosyntax looks like after the compiler
desugars it for us by manually transforming it ourselves:
importControl.Applicative ((</em>&gt;))
sequencing ::IO()
sequencing = do
putStrLn &quot;blah&quot;
putStrLn &quot;another thing&quot;
sequencing' ::IO()
sequencing' =
putStrLn &quot;blah&quot;&gt;&gt;
putStrLn &quot;another thing&quot;
sequencing'' ::IO()
sequencing'' =
putStrLn &quot;blah&quot;*&gt;
putStrLn &quot;another thing&quot;</p>
<p>CHAPTER 18. MONAD 1156
You should have had the same results for each of the above.
We can do the same with the variable binding that dosyntax
includes:
binding ::IO()
binding = do
name&lt;-getLine
putStrLn name
binding' ::IO()
binding' =
getLine &gt;&gt;=putStrLn
Instead of naming the variable and passing that as an argu-
ment to the next function, we use &gt;&gt;=which passes it directly.
Whenfmapalone isn‚Äôt enough
Note that if you try to fmap putStrLn overgetLine , it won‚Äôt do
anything. Try typing this into your REPL:
Prelude&gt; putStrLn &lt;$&gt; getLine
You‚Äôve used getLine , so when you hit enter it should await
your input. Type something in, hit enter again and see what
happens.</p>
<p>CHAPTER 18. MONAD 1157
Whatever input you gave it didn‚Äôt print, although it seems
like it should have due to the putStrLn being mapped over the
getLine . We evaluated the IOaction that requests input, but not
the one that prints it. So, what happened?
Well, let‚Äôs start with the types. The type of what you tried
to do is this:
Prelude&gt; :t putStrLn &lt;$&gt; getLine
putStrLn &lt;$&gt; getLine :: IO (IO ())
We‚Äôre going to break it down a little bit so that we‚Äôll under-
stand why this didn‚Äôt work. First, getLine performs I/O to get
aString :
getLine ::IOString
AndputStrLn takes a String argument, performs I/O, and
returns nothing interesting ‚Äî parents of children with an
allowance can sympathize:
putStrLn ::String-&gt;IO()
What is the type of fmapas it concerns putStrLn andgetLine ?</p>
<p>CHAPTER 18. MONAD 1158
-- The type we start with
&lt;$&gt; ::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
-- Our (a -&gt; b) is putStrLn
(a -&gt;b )
putStrLn ::String-&gt;IO()
Thatùëègets specialized to the type IO (), which is going to
jam another IOactioninside of the I/O that getLine performs.
Perhaps this looks familiar from our demonstration of what
happens when you use fmapto map a function with type (a -&gt;
m b)instead of (a -&gt; b) ‚Äî that is what‚Äôs happening here. This
is what is happening with our types:
f::Functor f=&gt;fString-&gt;f (IO())
fx=putStrLn &lt;$&gt;x
g::(String-&gt;b)-&gt;IOb
gx=x&lt;$&gt;getLine
putStrLn &lt;$&gt;getLine ::IO(IO())
Okay...so, which IOis which, and why does it ask for input
but not print what we typed in?</p>
<p>CHAPTER 18. MONAD 1159
-- [1] [2] [3]
h::IO(IO())
h=putStrLn &lt;$&gt;getLine
1.This outermost IOstructure represents the eÔ¨Äects getLine
must perform to get you a String that the user typed in.
2.This inner IOstructure represents the eÔ¨Äects that would
be performed ifputStrLn was evaluated.
3.The unit here is the unit that putStrLn returns.
One of the strengths of Haskell is that we can refer to, com-
pose, and map over eÔ¨Äectful computations without perform-
ing them or bending over backwards to make that pattern
work. For a simpler example of how we can wait to evalu-
ateIOactions (or any computation in general), consider the
following:
Prelude&gt; let printOne = putStrLn &quot;1&quot;
Prelude&gt; let printTwo = putStrLn &quot;2&quot;
Prelude&gt; let twoActions = (printOne, printTwo)
Prelude&gt; :t twoActions
twoActions :: (IO (), IO ())
With that tuple of two IOactions defined, we can now grab
one and evaluate it:</p>
<p>CHAPTER 18. MONAD 1160
Prelude&gt; fst twoActions
1
Prelude&gt; snd twoActions
2
Prelude&gt; fst twoActions
1
Note that we are able to evaluate IOactions multiple times.
This will be significant later.
Back to our conundrum of why we can‚Äôt fmap putStrLn over
getLine . Perhaps you‚Äôve already figured out what we need to do.
We need to join those two IOlayers together. To get what we
want, we need the unique thing that MonadoÔ¨Äers:join. Watch
it work:
Prelude&gt; import Control.Monad (join)
Prelude&gt; join $ putStrLn &lt;$&gt; getLine
blah
blah
Prelude&gt; :t join $ putStrLn &lt;$&gt; getLine
join $ putStrLn &lt;$&gt; getLine :: IO ()
Whatjoindidhereis mergetheeÔ¨Äectsof getLine andputStrLn
into a single IOaction. This merged IOaction performs the
eÔ¨Äects in the order determined by the nesting of the IOactions.
As it happens, the cleanest way to express ordering in a lambda</p>
<p>CHAPTER 18. MONAD 1161
calculus without bolting on something unpleasant is through
nesting of expressions or lambdas.
That‚Äôs right. We still haven‚Äôt left the lambda calculus behind.
Monadic sequencing and dosyntax seem on the surface to
be very far removed from that. But they aren‚Äôt. As we said,
monadic actions are still pure, and the sequencing operations
we use here are ways of nesting lambdas. Now, IOis a bit dif-
ferent, as it does allow for side eÔ¨Äects, but since those eÔ¨Äects
are constrained within the IOtype, all the rest of it is still a
pure lambda calculus.
Sometimes it is valuable to suspend or otherwise not per-
form an I/O action until some determination is made, so types
likeIO (IO ()) aren‚Äôt necessarily invalid, but you should be
aware of what‚Äôs needed to make this example work.
Let‚Äôsgetbacktodesugaring dosyntaxwithournow-enriched
understanding of what monads do for us:</p>
<p>CHAPTER 18. MONAD 1162
bindingAndSequencing ::IO()
bindingAndSequencing = do
putStrLn &quot;name pls:&quot;
name&lt;-getLine
putStrLn ( &quot;y helo thar: &quot; ++name)
bindingAndSequencing' ::IO()
bindingAndSequencing' =
putStrLn &quot;name pls:&quot; &gt;&gt;
getLine &gt;&gt;=
\name-&gt;
putStrLn ( &quot;y helo thar: &quot; ++name)
As the nesting intensifies, you can see how dosyntax can
make things a bit cleaner and easier to read:
twoBinds ::IO()
twoBinds = do
putStrLn &quot;name pls:&quot;
name&lt;-getLine
putStrLn &quot;age pls:&quot;
age&lt;-getLine
putStrLn ( &quot;y helo thar: &quot;
++name++&quot; who is: &quot;
++age++&quot; years old.&quot; )</p>
<p>CHAPTER 18. MONAD 1163
twoBinds' ::IO()
twoBinds' =
putStrLn &quot;name pls:&quot; &gt;&gt;
getLine &gt;&gt;=
\name-&gt;
putStrLn &quot;age pls:&quot; &gt;&gt;
getLine &gt;&gt;=
\age-&gt;
putStrLn ( &quot;y helo thar: &quot;
++name++&quot; who is: &quot;
++age++&quot; years old.&quot; )
18.4 Examples of Monaduse
All right, we‚Äôve seen what is diÔ¨Äerent about Monadand seen a
small demonstration of what that does for us. What we need
now is to see how monads work in code, with Monads other than
IO.
List
We‚Äôve been starting oÔ¨Ä our examples of these typeclasses in
use with list examples because they can be quite easy to see
and understand. We will keep this section brief, though, as we
have more exciting things to show you.</p>
<p>CHAPTER 18. MONAD 1164
Specializing the types
This process should be familiar to you by now:
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b)-&gt;m b
(&gt;&gt;=)::[ ] a-&gt;(a-&gt;[ ] b)-&gt;[ ] b
-- or more syntactically common
(&gt;&gt;=)::[a]-&gt;(a-&gt;[b])-&gt;[b]
-- same as pure
return::Monadm=&gt;a-&gt;m a
return:: a-&gt;[ ] a
return:: a-&gt;[a]
Excellent. It‚Äôs like fmapexcept the order of arguments is
flipped and we can now generate more list (or an empty list)
inside of our mapped function. Let‚Äôs take it for a spin.
Example of the List Monadin use
Let‚Äôs start with a function and identify how the parts fit with
our monadic types:</p>
<p>CHAPTER 18. MONAD 1165
twiceWhenEven ::[Integer]-&gt;[Integer]
twiceWhenEven xs= do
x&lt;-xs
ifeven x
then[x<em>x, x</em>x]
else[x<em>x]
Thex &lt;- xs line binds individual values out of the list input,
like a list comprehension, giving us an ùëé. Theif-then-else is
oura -&gt; m b . It takes the individual ùëévalues that have been
bound out of our m aand can generate more values, thereby
increasing the size of the list.
Them athat is our first input will be the argument we pass
to it below:
Prelude&gt; twiceWhenEven [1..3]
[1,4,4,9]
Now try this:
twiceWhenEven ::[Integer]-&gt;[Integer]
twiceWhenEven xs= do
x&lt;-xs
ifeven x
then[x</em>x, x*x]
else[]</p>
<p>CHAPTER 18. MONAD 1166
And try giving it the same input as above (for easy compar-
ison). Was the result what you expected? Keep playing around
with this, forming hypotheses about what will happen and
why and testing them in the REPL to develop an intuition for
how monads are working on a simple example. The examples
in the next sections are longer and more complex.
Maybe Monad
Now we come to a more exciting demonstration of what we
can do with our newfound power.
Specializing the types
It is the season for examining the types:
-- type M = Maybe
-- m ~ Maybe
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b)-&gt;m b
(&gt;&gt;=)::
Maybea-&gt;(a-&gt;Maybeb)-&gt;Maybeb
-- same as pure
return::Monadm=&gt;a-&gt;m a
return:: a-&gt;Maybea</p>
<p>CHAPTER 18. MONAD 1167
There should have been nothing surprising there, so let‚Äôs
get to the meat of the matter.
Using the Maybe Monad
This example looks like the one from the Applicative chapter,
but it‚Äôs diÔ¨Äerent. We encourage you to compare the two, al-
though we‚Äôve been explicit about what exactly is happening
here. You developed some intutions above for dosyntax and
the listMonad; here we‚Äôll be quite explicit about what‚Äôs happen-
ing, and by the time we get to the Either demonstration below,
it should be clear. Let‚Äôs get started:
dataCow=Cow{
name::String
, age ::Int
, weight ::Int
}deriving (Eq,Show)
noEmpty ::String-&gt;MaybeString
noEmpty &quot;&quot;=Nothing
noEmpty str=Juststr
noNegative ::Int-&gt;MaybeInt
noNegative n|n&gt;=0=Justn
|otherwise =Nothing</p>
<p>CHAPTER 18. MONAD 1168
-- if Cow's name is Bess, must be under 500
weightCheck ::Cow-&gt;MaybeCow
weightCheck c=
letw=weight c
n=name c
in ifn==&quot;Bess&quot;&amp;&amp;w&gt;499
thenNothing
elseJustc
mkSphericalCow ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow name' age' weight' =
casenoEmpty name' of
Nothing -&gt;Nothing
Justnammy-&gt;
casenoNegative age' of
Nothing -&gt;Nothing
Justagey-&gt;
casenoNegative weight' of
Nothing -&gt;Nothing
Justweighty -&gt;
weightCheck
(Cownammy agey weighty)</p>
<p>CHAPTER 18. MONAD 1169
Prelude&gt; mkSphericalCow &quot;Bess&quot; 5 499
Just (Cow {name = &quot;Bess&quot;, age = 5, weight = 499})
Prelude&gt; mkSphericalCow &quot;Bess&quot; 5 500
Nothing
First, we‚Äôll clean it up with dosyntax, then we‚Äôll see why we
can‚Äôt do this with Applicative :
-- Do syntax isn't just for IO.
mkSphericalCow' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow' name' age' weight' = do
nammy&lt;-noEmpty name'
agey&lt;-noNegative age'
weighty &lt;-noNegative weight'
weightCheck ( Cownammy agey weighty)
And this works as expected.
Prelude&gt; mkSphericalCow' &quot;Bess&quot; 5 500
Nothing
Prelude&gt; mkSphericalCow' &quot;Bess&quot; 5 499
Just (Cow {name = &quot;Bess&quot;, age = 5, weight = 499})</p>
<p>CHAPTER 18. MONAD 1170
Can we write it with (&gt;&gt;=)? Sure!
-- Stack up the nested lambdas.
mkSphericalCow'' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow'' name' age' weight' =
noEmpty name' &gt;&gt;=
\nammy-&gt;
noNegative age' &gt;&gt;=
\agey-&gt;
noNegative weight' &gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)
So why can‚Äôt we do this with Applicative ? Because our
weightCheck function depends on the prior existence of a Cow
value and returns more monadic structure in its return type
Maybe Cow .
If your dosyntax looks like this:</p>
<p>CHAPTER 18. MONAD 1171
doSomething = do
a&lt;-f
b&lt;-g
c&lt;-h
pure (a, b, c)
You can rewrite it using Applicative . On the other hand, if
you have something like this:
doSomething' n= do
a&lt;-f n
b&lt;-g a
c&lt;-h b
pure (a, b, c)
You‚Äôre going to need Monadbecause ùëîand‚Ñéare producing
monadic structure based on values that can only be obtained
by depending on values generated from monadic structure.
You‚Äôll need jointo crunch the nesting of monadic structure
back down. If you don‚Äôt believe us, try translating doSomething'
toApplicative : so no resorting to &gt;&gt;=orjoin.
Here‚Äôs some code to kick that around:
f::Integer -&gt;MaybeInteger
f0=Nothing
fn=Justn</p>
<p>CHAPTER 18. MONAD 1172
g::Integer -&gt;MaybeInteger
gi=
ifeven i
thenJust(i+1)
elseNothing
h::Integer -&gt;MaybeString
hi=Just(&quot;10191&quot; ++show i)
doSomething' n= do
a&lt;-f n
b&lt;-g a
c&lt;-h b
pure (a, b, c)
The long and short of it:
1.With the Maybe Applicative , eachMaybecomputation fails
or succeeds independently of each other. You‚Äôre lifting
functions that are also JustorNothing overMaybevalues.
2.With the Maybe Monad , computations contributing to the
final result can choose to return Nothing based on previous
computations.</p>
<p>CHAPTER 18. MONAD 1173
Exploding a spherical cow
We said we‚Äôd be quite explicit about what‚Äôs happening in the
above, so let‚Äôs do this thing. Let‚Äôs get in the guts of this code
and how binding over Maybevalues works.
For once, this example instance is what‚Äôs in GHC‚Äôs base
library at time of writing:
instance MonadMaybewhere
return x =Justx
(Justx)&gt;&gt;=k=k x
Nothing &gt;&gt;= _ = Nothing
mkSphericalCow'' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow'' name' age' weight' =
noEmpty name' &gt;&gt;=
\nammy-&gt;
noNegative age' &gt;&gt;=
\agey-&gt;
noNegative weight' &gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)</p>
<p>CHAPTER 18. MONAD 1174
And what happens if we pass it some arguments?
-- Proceeding outermost to innermost.
mkSphericalCow'' &quot;Bess&quot;5499=
noEmpty &quot;Bess&quot;&gt;&gt;=
\nammy-&gt;
noNegative 5&gt;&gt;=
\agey-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)
-- &quot;Bess&quot; /= &quot;&quot;, so skipping this pattern
-- noEmpty &quot;&quot; = Nothing
noEmpty &quot;Bess&quot;=Just&quot;Bess&quot;
So we produced the value Just &quot;Bess&quot; ; however, nammywill
be theString and not also the Maybestructure because &gt;&gt;=passes
ùëéto the function it binds over the monadic value, not ùëöùëé. Here
we‚Äôll use the Maybe Monad instance to examine why:</p>
<p>CHAPTER 18. MONAD 1175
instance MonadMaybewhere
return x =Justx
(Justx)&gt;&gt;=k=k x
Nothing &gt;&gt;= _ = Nothing
noEmpty &quot;Bess&quot;&gt;&gt;=\nammy-&gt;
(restofthe computation)
-- noEmpty &quot;Bess&quot; evaluated
-- to Just &quot;Bess&quot;. So the first
-- Just case matches.
(Just&quot;Bess&quot;)&gt;&gt;=\nammy-&gt; ...
(Justx)&gt;&gt;=k=k x
-- k is \nammy et al.
-- x is &quot;Bess&quot; by itself.
Sonammyis bound to ‚ÄùBess‚Äù, and the following is the whole ùëò:
&quot;Bess&quot;-&gt;
noNegative 5&gt;&gt;=
\agey-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)</p>
<p>CHAPTER 18. MONAD 1176
Then how does the age check go?
mkSphericalCow'' &quot;Bess&quot;5499=
noEmpty &quot;Bess&quot;&gt;&gt;=
&quot;Bess&quot;-&gt;
noNegative 5&gt;&gt;=
\agey-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cow&quot;Bess&quot;agey weighty)
-- 5 &gt;= 0 is true, so we get Just 5
noNegative 5|5&gt;=0=Just5
|otherwise =Nothing
Again, although noNegative returns Just 5 , thebindfunction
will pass 5 on:</p>
<p>CHAPTER 18. MONAD 1177
mkSphericalCow'' &quot;Bess&quot;5499=
noEmpty &quot;Bess&quot;&gt;&gt;=
&quot;Bess&quot;-&gt;
noNegative 5&gt;&gt;=
\5-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cow&quot;Bess&quot;5weighty)
-- 499 &gt;= 0 is true, so we get Just 499
noNegative 499|499&gt;=0=Just499
|otherwise =Nothing
Passing 499 on:
mkSphericalCow'' &quot;Bess&quot;5499=
noEmpty &quot;Bess&quot;&gt;&gt;=
&quot;Bess&quot;-&gt;
noNegative 5&gt;&gt;=
\5-&gt;
noNegative 499&gt;&gt;=
\499-&gt;
weightCheck ( Cow&quot;Bess&quot;5499)</p>
<p>CHAPTER 18. MONAD 1178
weightCheck (Cow&quot;Bess&quot;5499)=
let499=weight ( Cow&quot;Bess&quot;5499)
&quot;Bess&quot;=name (Cow&quot;Bess&quot;5499)
-- fyi, 499 &gt; 499 is False.
in if&quot;Bess&quot;==&quot;Bess&quot;&amp;&amp;499&gt;499
thenNothing
elseJust(Cow&quot;Bess&quot;5499)
So in the end, we return Just (Cow &quot;Bess&quot; 5 499) .
Fail fast, like an overfunded startup
But what if we had failed? We‚Äôll dissect the following compu-
tation:
Prelude&gt; mkSphericalCow'' &quot;&quot; 5 499
Nothing
And how do the guts fall when we explode this poor bovine?</p>
<p>CHAPTER 18. MONAD 1179
mkSphericalCow'' &quot;&quot;5499=
noEmpty &quot;&quot;&gt;&gt;=
\nammy-&gt;
noNegative 5&gt;&gt;=
\agey-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)
-- &quot;&quot; == &quot;&quot;, so we get the Nothing case
noEmpty &quot;&quot;=Nothing
-- noEmpty str = Just str
After we‚Äôve evaluated noEmpty &quot;&quot; and gotten a Nothing value,
we use(&gt;&gt;=). How does that go?</p>
<p>CHAPTER 18. MONAD 1180
instance MonadMaybewhere
return x =Justx
(Justx)&gt;&gt;=k=k x
Nothing &gt;&gt;= _ = Nothing
-- noEmpty &quot;&quot; := Nothing
Nothing &gt;&gt;=
\nammy-&gt;
-- Just case doesn't match, so skip it.
-- (Just x) &gt;&gt;= k = k x
-- This is what we're doing.
Nothing &gt;&gt;= _ = Nothing
So it turns out that the bindfunction will drop the entire
rest of the computation on the floor the moment anyof the
functions participating in the Maybe Monad actions produce a
Nothing value:
mkSphericalCow'' &quot;&quot;5499=
Nothing &gt;&gt;=-- NOPE.
In fact, you can demonstrate to yourself that that stuÔ¨Ä never
gets used with bottom , but does with a Justvalue:</p>
<p>CHAPTER 18. MONAD 1181
Prelude&gt; Nothing &gt;&gt;= undefined
Nothing
Prelude&gt; Just 1 &gt;&gt;= undefined
*** Exception: Prelude.undefined
But why do we use the Maybe Applicative andMonad? Because
this:
mkSphericalCow' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow' name' age' weight' = do
nammy&lt;-noEmpty name'
agey&lt;-noNegative age'
weighty &lt;-noNegative weight'
weightCheck ( Cownammy agey weighty)
is a lot nicer than case matching the Nothing case over and
over just so we can say Nothing -&gt; Nothing a million times. Life
is too short for repetition when computers lovetaking care of
repetition.
Either
Whew. Let‚Äôs all be thankful that cow was full of Maybevalues
and not tripe. Moving along, we‚Äôre going to demonstrate use</p>
<p>CHAPTER 18. MONAD 1182
of theEither Monad , step back a bit, and let your intuitions and
what you learned about Maybeguide you through.
Specializing the types
As always, we present the types:
-- m ~ Either e
(&gt;&gt;=)::Monadm
=&gt; m a
-&gt;(a-&gt; m b)
-&gt; m b
(&gt;&gt;=)::Eithere a
-&gt;(a-&gt;Eithere b)
-&gt;Eithere b
-- same as pure
return::Monadm=&gt;a-&gt; m aq
return:: a-&gt;Eithere a
Why do we keep doing this? To remind you that the types
always show you the way, once you‚Äôve figured them out.
Using the Either Monad
Use what you know to go carefully through this code and
follow the types. First, we define our datatypes:</p>
<p>CHAPTER 18. MONAD 1183
moduleEitherMonad where
-- years ago
typeFounded =Int
-- number of programmers
typeCoders=Int
dataSoftwareShop =
Shop{
founded ::Founded
, programmers ::Coders
}deriving (Eq,Show)
dataFoundedError =
NegativeYears Founded
|TooManyYears Founded
|NegativeCoders Coders
|TooManyCoders Coders
|TooManyCodersForYears Founded Coders
deriving (Eq,Show)
Let‚Äôs bring some functions now:</p>
<p>CHAPTER 18. MONAD 1184
validateFounded
::Int
-&gt;EitherFoundedError Founded
validateFounded n
|n&lt;0=Left$NegativeYears n
|n&gt;500=Left$TooManyYears n
|otherwise =Rightn
-- Tho, many programmers <em>are</em> negative.
validateCoders
::Int
-&gt;EitherFoundedError Coders
validateCoders n
|n&lt;0=Left$NegativeCoders n
|n&gt;5000=Left$TooManyCoders n
|otherwise =Rightn</p>
<p>CHAPTER 18. MONAD 1185
mkSoftware
::Int
-&gt;Int
-&gt;EitherFoundedError SoftwareShop
mkSoftware years coders = do
founded &lt;-validateFounded years
programmers &lt;-validateCoders coders
ifprogrammers &gt;div founded 10
thenLeft$
TooManyCodersForYears
founded programmers
elseRight$Shopfounded programmers
Note that Either always short-circuits on the firstthing to
have failed. It mustbecause in the Monad, later values can depend
on previous ones:
Prelude&gt; mkSoftware 0 0
Right (Shop {founded = 0, programmers = 0})
Prelude&gt; mkSoftware (-1) 0
Left (NegativeYears (-1))
Prelude&gt; mkSoftware (-1) (-1)
Left (NegativeYears (-1))
Prelude&gt; mkSoftware 0 (-1)</p>
<p>CHAPTER 18. MONAD 1186
Left (NegativeCoders (-1))
Prelude&gt; mkSoftware 500 0
Right (Shop {founded = 500, programmers = 0})
Prelude&gt; mkSoftware 501 0
Left (TooManyYears 501)
Prelude&gt; mkSoftware 501 501
Left (TooManyYears 501)
Prelude&gt; mkSoftware 100 5001
Left (TooManyCoders 5001)
Prelude&gt; mkSoftware 0 500
Left (TooManyCodersForYears 0 500)
So, there is no MonadforValidation .Applicative andMonadin-
stances must have the same behavior. This is usually expressed
in the form:
importControl.Monad (ap)
(&lt;*&gt;)==ap
This is a way of saying the Applicative apply for a type must
not change behavior if derived from the Monadinstance‚Äôs bind</p>
<p>CHAPTER 18. MONAD 1187
operation.
-- Keeping in mind
(&lt;<em>&gt;)::Applicative f
=&gt;f (a-&gt;b)-&gt;f a-&gt;f b
ap::Monadm
=&gt;m (a-&gt;b)-&gt;m a-&gt;m b
Then deriving Applicative (&lt;</em>&gt;) from the stronger instance:
ap::(Monadm)=&gt;m (a-&gt;b)-&gt;m a-&gt;m b
apm m'= do
x&lt;-m
x'&lt;-m'
return (x x')
The problem is you can‚Äôt make a MonadforValidation that
accumulates the errors like the Applicative does. Instead, any
Monadinstance for Validation would be identical to Either ‚ÄôsMonad
instance.
Short Exercise: Either Monad
Implement the Either Monad .</p>
<p>CHAPTER 18. MONAD 1188
dataSuma b=
Firsta
|Secondb
deriving (Eq,Show)
instance Functor (Suma)where
fmap=undefined
instance Applicative (Suma)where
pure=undefined
(&lt;*&gt;)=undefined
instance Monad(Suma)where
return=pure
(&gt;&gt;=)=undefined
18.5 Monad laws
TheMonadtypeclass has laws, as the other typeclasses do. These
laws exist, as with all the other typeclass laws, to ensure that
your code does nothing surprising or harmful. If the Monad
instance you write for your type abides by these laws, then
your monads should work as you want them to. To write your
own instance, you only have to define a &gt;&gt;=operation, but you
want your binding to be as predictable as possible.</p>
<p>CHAPTER 18. MONAD 1189
Identity laws
Monadhas two identity laws:
-- right identity
m&gt;&gt;=return =m
-- left identity
returnx&gt;&gt;=f=f x
Basically both of these laws are saying that return should be
neutral and not perform any computation. We‚Äôll line them up
with the type of &gt;&gt;=to clarify what‚Äôs happening:
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b)-&gt;m b
-- [1] [2] [3]
First, right identity:
return::a-&gt;m a
m&gt;&gt;=return =m
-- [1] [2] [3]
Theùëödoes represent an m aandm b, respectively, so the
structure is there even if it‚Äôs not apparent from the way the
law is written.</p>
<p>CHAPTER 18. MONAD 1190
And left identity:
-- applying return to x gives us an
-- m a value to start
return x &gt;&gt;=f=f x
-- [1] [2] [3]
Likepure,return shouldn‚Äôt change any of the behavior of the
rest of the function; it is only there to put things into structure
when we need to, and the existence of the structure should
not aÔ¨Äect the computation.
Associativity
The law of associativity is not so diÔ¨Äerent from other laws of
associativity we have seen. It does look a bit diÔ¨Äerent because
of the nature of &gt;&gt;=:
(m&gt;&gt;=f)&gt;&gt;=g=m&gt;&gt;=(\x-&gt;f x&gt;&gt;=g)
Regrouping the functions should not have any impact on
the final result, same as the associativity of Monoid . The syntax
there, in which, for the right side of the equals sign, we had to
pass in an ùë•argument might seem confusing at first. So, let‚Äôs
look at it more carefully.
This side looks the way we expect it to:</p>
<p>CHAPTER 18. MONAD 1191
(m&gt;&gt;=f)&gt;&gt;=g
But remember that (&gt;&gt;=)allows the result value of one func-
tion to be passed as input to the next, like function application
but with our value at the left and successive functions proceed-
ing to the right. Remember this code?
getLine &gt;&gt;=putStrLn
The IO action for getLine is evaluated first, then putStrLn is
passed the input string that resulted from running getLine ‚Äôs
eÔ¨Äects. This left-to-right is partly down to the history of IOin
Haskell ‚Äî it‚Äôs so the ‚Äúorder‚Äù of the code reads top to bottom.
We‚Äôll explain this more later in the book.
When we reassociate them, we need to apply ùëìso thatùëîhas
an input value of type m ato start the whole thing oÔ¨Ä. So, we
pass in the argument ùë•via an anonymous function:
m&gt;&gt;=(\x-&gt;f x&gt;&gt;=g)
And bada bing, now nothing can slow this roll.
We‚Äôre doing that thing again
Out of mercy, we‚Äôll be using checkers (not Nixon‚Äôs dog) again.
The argument the Monad TestBatch wants is identical to the
Applicative , a tuple of three value types embedded in the struc-
tural type.</p>
<p>CHAPTER 18. MONAD 1192
Prelude&gt; quickBatch (monad [(1, 2, 3)])
monad laws:
left identity: +++ OK, passed 500 tests.
right identity: +++ OK, passed 500 tests.
associativity: +++ OK, passed 500 tests.
Going forward we‚Äôll be using this to validate Monadinstances.
Let‚Äôs write a bad Monadto see what it can catch for us.
BadMonads and their denizens
We‚Äôre going to write an invalid Monad(andFunctor ). You could
pretend it‚Äôs Identity with an integer thrown in which gets in-
cremented on each fmapor bind.
moduleBadMonad where
importTest.QuickCheck
importTest.QuickCheck.Checkers
importTest.QuickCheck.Classes</p>
<p>CHAPTER 18. MONAD 1193
dataCountMe a=
CountMe Integer a
deriving (Eq,Show)
instance Functor CountMe where
fmap f ( CountMe i a)=
CountMe (i+1) (f a)
instance Applicative CountMe where
pure=CountMe 0
CountMe n f&lt;*&gt;CountMe n' a=
CountMe (n+n') (f a)
instance MonadCountMe where
return=pure
CountMe n a&gt;&gt;=f=
letCountMe _b=f a
inCountMe (n+1) b</p>
<p>CHAPTER 18. MONAD 1194
instance Arbitrary a
=&gt;Arbitrary (CountMe a)where
arbitrary =
CountMe &lt;$&gt;arbitrary &lt;*&gt;arbitrary
instance Eqa=&gt;EqProp(CountMe a)where
(=-=)=eq
main= do
lettrigger ::CountMe (Int,String,Int)
trigger =undefined
quickBatch $functor trigger
quickBatch $applicative trigger
quickBatch $monad trigger
When we run the tests, the Functor andMonadwill fail top
to bottom. The Applicative technically only failed the laws
because Functor did; in the Applicative instance we were using
a proper monoid-of-structure.
Prelude&gt; main
functor:
identity: *** Failed! Falsifiable (after 1 test):
CountMe 0 0
compose: *** Failed! Falsifiable (after 1 test):</p>
<p>CHAPTER 18. MONAD 1195
<function>
<function>
CountMe 0 0
applicative:
identity: +++ OK, passed 500 tests.
composition: +++ OK, passed 500 tests.
homomorphism: +++ OK, passed 500 tests.
interchange: +++ OK, passed 500 tests.
functor: *** Failed! Falsifiable (after 1 test):
<function>
CountMe 0 0
monad laws:
left identity: *** Failed! Falsifiable (after 1 test):
<function>
0
right identity: *** Failed! Falsifiable (after 1 test):
CountMe 0 0
associativity: *** Failed! Falsifiable (after 1 test):
CountMe 0 0
We can reapply the weird, broken increment semantics and
get a broken Applicative as well.</p>
<p>CHAPTER 18. MONAD 1196
instance Applicative CountMe where
pure=CountMe 0
CountMe n f&lt;*&gt;CountMe _a=
CountMe (n+1) (f a)
Now it‚Äôs allbroken.
applicative:
identity:
*** Failed! Falsifiable (after 1 test):
CountMe 0 0
composition:
*** Failed! Falsifiable (after 1 test):
CountMe 0 <function>
CountMe 0 <function>
CountMe 0 0
homomorphism:
*** Failed! Falsifiable (after 1 test):
<function>
0
interchange:
*** Failed! Falsifiable (after 3 tests):
CountMe (-1) <function>
0
Understanding what makes sense structurally for a Functor ,
Applicative , andMonoid can tell you what is potentially an in-</p>
<p>CHAPTER 18. MONAD 1197
valid instance before you‚Äôve written any code. Incidentally,
even if you fix the Functor andApplicative instances, the Monad
instance is not yet fixed.
instance Functor CountMe where
fmap f ( CountMe i a)=CountMe i (f a)
instance Applicative CountMe where
pure=CountMe 0
CountMe n f&lt;*&gt;CountMe n' a=
CountMe (n+n') (f a)
instance MonadCountMe where
return=pure
CountMe _a&gt;&gt;=f=f a
This‚Äôll pass as a valid Functor andApplicative , but it‚Äôs not a
validMonad. The problem is that while puresetting the integer
value to zero is fine for the purposes of the Applicative , but it
violates the right identity law of Monad.
Prelude&gt; CountMe 2 &quot;blah&quot; &gt;&gt;= return
CountMe 0 &quot;blah&quot;
So ourpureis too opinionated. Still a valid Applicative and
Functor , but what if puredidn‚Äôt agree with the Monoid of the</p>
<p>CHAPTER 18. MONAD 1198
structure? The following will pass the Functor laws but it isn‚Äôt a
validApplicative .
instance Functor CountMe where
fmap f ( CountMe i a)=CountMe i (f a)
instance Applicative CountMe where
pure=CountMe 1
CountMe n f&lt;<em>&gt;CountMe n' a=
CountMe (n+n') (f a)
As it happens, if we change the monoid-of-structure to
match the identity such that we have addition and the number
zero, it‚Äôs a valid Applicative again.
instance Applicative CountMe where
pure=CountMe 0
CountMe n f&lt;</em>&gt;CountMe n' a=
CountMe (n+n') (f a)
As you gain experience with these structures, you‚Äôll learn to
identify what might have a valid Applicative but no valid Monad
instance. But how do we fix the Monadinstance? By fixing the
underlying Monoid !</p>
<p>CHAPTER 18. MONAD 1199
instance MonadCountMe where
return=pure
CountMe n a&gt;&gt;=f=
letCountMe n' b=f a
inCountMe (n+n') b
Once our Monadinstance starts summing the counts like the
Applicative did, it works fine! It can be easy at times to acciden-
tally write an invalid Monadthat typechecks, so it‚Äôs important to
useQuickCheck to validate your Monoid ,Functor ,Applicative , and
Monadinstances.
18.6 Application and composition
What we‚Äôve seen so far has been primarily about function
application. We probably weren‚Äôt thinking too much about the
relationship between function application and composition
because with Functor andApplicative it hadn‚Äôt mattered much.
Both concerned functions that looked like the usual (a -&gt; b)
arrangement, so composition ‚Äújust worked‚Äù and that this was
true was guaranteed by the laws of those typeclasses:</p>
<p>CHAPTER 18. MONAD 1200
fmapid=id
-- guarantees
fmapf.fmap g=fmap (f .g)
Which means composition under functors just works:
Prelude&gt; fmap ((+1) . (+2)) [1..5]
[4,5,6,7,8]
Prelude&gt; fmap (+1) . fmap (+2) $ [1..5]
[4,5,6,7,8]
WithMonadthe situation seems less neat at first. Let‚Äôs attempt
to define composition for monadic functions in a simple way:
mcomp::Monadm=&gt;
(b-&gt;m c)
-&gt;(a-&gt;m b)
-&gt;a-&gt;m c
mcompf g a=f (g a)
If we try to load this, we‚Äôll get an error like this:
Couldn't match expected type ‚Äòb‚Äô
with actual type ‚Äòm b‚Äô
‚Äòb‚Äô is a rigid type variable bound</p>
<p>CHAPTER 18. MONAD 1201
by the type signature for
mcomp :: Monad m =&gt;
(b -&gt; m c)
-&gt; (a -&gt; m b)
-&gt; a -&gt; m c
at kleisli.hs:21:9
Relevant bindings include
g :: a -&gt; m b (bound at kleisli.hs:22:8)
f :: b -&gt; m c (bound at kleisli.hs:22:6)
mcomp :: (b -&gt; m c)
-&gt; (a -&gt; m b)
-&gt; a -&gt; m c
(bound at kleisli.hs:22:1)
In the first argument of ‚Äòf‚Äô, namely ‚Äò(g a)‚Äô
In the expression: f (g a)
Failed, modules loaded: none.
Well, that didn‚Äôt work. That error message is telling us that
ùëìis expecting a ùëèfor its first argument, but ùëîis passing an m b
toùëì. So, how do we apply a function in the presence of some
context that we want to ignore? We use fmap. That‚Äôs going to
give us an m (m c) instead of an m c, so we‚Äôll want to jointhose
two monadic structures.</p>
<p>CHAPTER 18. MONAD 1202
mcomp::Monadm=&gt;
(b-&gt;m c)
-&gt;(a-&gt;m b)
-&gt;a-&gt;m c
mcompf g a=join (f &lt;$&gt;(g a))
But using joinandfmaptogether means we can go ahead
and use (&gt;&gt;=).
mcomp'' ::Monadm=&gt;
(b-&gt;m c)
-&gt;(a-&gt;m b)
-&gt;a-&gt;m c
mcomp'' f g a=g a&gt;&gt;=f
You don‚Äôt need to write anything special to make monadic
functions compose (as long as the monadic contexts are the
sameMonad) because Haskell has it covered: what you want is
Kleisli composition . Don‚Äôt sweat the strange name; it‚Äôs not as
weird as it sounds. As we saw above, what we need is function
composition written in terms of &gt;&gt;=to allow us to deal with
the extra structure, and that‚Äôs what the Kleisli fish gives us.
Let‚Äôs remind ourselves of the types of ordinary function
composition and &gt;&gt;=:</p>
<p>CHAPTER 18. MONAD 1203
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b)-&gt;m b
To get Kleisli composition oÔ¨Ä the ground, we have to flip
some arguments around to make the types work:
importControl.Monad
-- the order is flipped to match &gt;&gt;=
(&gt;=&gt;)
::Monadm
=&gt;(a-&gt;m b)-&gt;(b-&gt;m c)-&gt;a-&gt;m c
See any similarities to something you know yet?
(&gt;=&gt;)
::Monadm
=&gt;(a-&gt;m b)-&gt;(b-&gt;m c)-&gt;a-&gt;m c
flip(.)
::(a-&gt;b)-&gt;(b-&gt;c)-&gt;a-&gt;c
It‚Äôs function composition with monadic structure hanging
oÔ¨Ä the functions we‚Äôre composing. Let‚Äôs see an example!</p>
<p>CHAPTER 18. MONAD 1204
importControl.Monad ((&gt;=&gt;))
sayHi::String-&gt;IOString
sayHigreeting = do
putStrLn greeting
getLine
readM::Reada=&gt;String-&gt;IOa
readM=return.read
getAge::String-&gt;IOInt
getAge=sayHi&gt;=&gt;readM
askForAge ::IOInt
askForAge =
getAge&quot;Hello! How old are you? &quot;
We used return composed with readto turn it into some-
thing that provides monadic structure after being bound over
the output of sayHi. We needed the Kleisli composition opera-
tor to stitch sayHiandreadMtogether:</p>
<p>CHAPTER 18. MONAD 1205
sayHi::String-&gt;IOString
readM::Reada=&gt;String-&gt;IOa
-- [1] [2] [3]
(a-&gt;m b)
String-&gt;IOString
-- [4] [5] [6]
-&gt;(b-&gt;m c)
String-&gt;IOa
-- [7] [8] [9]
-&gt;a-&gt;m c
String IOa
1.The first type is the type of the input to sayHi,String .
2.TheIOthatsayHiperforms in order to present a greeting
and receive input.
3.TheString input from the user that sayHireturns.
4.TheString thatreadMexpects as an argument and which
sayHiwill produce.
5.TheIO readM returns into. Note that return/pure produce
IOvalues which perform no I/O.</p>
<p>CHAPTER 18. MONAD 1206
6.TheIntthatreadMreturns.
7.The original, initial String inputsayHiexpects so it knows
how to greet the user and ask for their age.
8.The final combined IOaction which performs all eÔ¨Äects
necessary to produce the final result.
9.The value inside of the final IOaction; in this case, this is
theIntvalue that readMreturned.
18.7 Chapter Exercises
WriteMonadinstancesforthefollowingtypes. Usethe QuickCheck
properties we showed you to validate your instances.
1.Welcome to the Nope Monad , where nothing happens and
nobody cares.
dataNopea=
NopeDotJpg
-- We're serious. Write it anyway.
2.dataPhhhbbtttEither b a=
Lefta
|Rightb</p>
<p>CHAPTER 18. MONAD 1207
3.Write a Monadinstance for Identity .
newtype Identity a=Identity a
deriving (Eq,Ord,Show)
instance Functor Identity where
fmap=undefined
instance Applicative Identity where
pure=undefined
(&lt;*&gt;)=undefined
instance MonadIdentity where
return=pure
(&gt;&gt;=)=undefined
4.This one should be easier than the Applicative instance
was. Remember to use the Functor thatMonadrequires, then
see where the chips fall.
dataLista=
Nil
|Consa (Lista)
Write the following functions using the methods provided
byMonadandFunctor . Using stuÔ¨Ä like identity and composition
is fine, but it has to typecheck with types provided.</p>
<p>CHAPTER 18. MONAD 1208
1.j::Monadm=&gt;m (m a) -&gt;m a
Expecting the following behavior:
Prelude&gt; j [[1, 2], [], [3]]
[1,2,3]
Prelude&gt; j (Just (Just 1))
Just 1
Prelude&gt; j (Just Nothing)
Nothing
Prelude&gt; j Nothing
Nothing
2.l1::Monadm=&gt;(a-&gt;b)-&gt;m a-&gt;m b
3.l2::Monadm
=&gt;(a-&gt;b-&gt;c)-&gt;m a-&gt;m b-&gt;m c
4.a::Monadm=&gt;m a-&gt;m (a-&gt;b)-&gt;m b
5.You‚Äôll need recursion for this one.
meh::Monadm
=&gt;[a]-&gt;(a-&gt;m b)-&gt;m [b]
6.Hint: reuse ‚Äúmeh‚Äù
flipType ::(Monadm)=&gt;[m a]-&gt;m [a]</p>
<p>CHAPTER 18. MONAD 1209
18.8 Definition
1.Monad is a typeclass reifying an abstraction that is com-
monly used in Haskell. Instead of an ordinary function of
typeùëétoùëè, you‚Äôre functorially applying a function which
produces more structure itself and using jointo reduce
the nested structure that results.
fmap::(a-&gt;b)-&gt;f a-&gt;f b
(&lt;*&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
(=&lt;&lt;)::(a-&gt;f b)-&gt;f a-&gt;f b
2.Amonadic function is one which generates more structure
after having been lifted over monadic structure. Contrast
the function arguments to fmapand(&gt;&gt;=)in:
fmap::(a-&gt;b)-&gt;f a-&gt;f b
(&gt;&gt;=)::m a-&gt;(a-&gt;m b)-&gt;m b
The significant diÔ¨Äerence is that the result is m band re-
quiresjoining the result after lifting the function over ùëö.
What does this mean? That depends on the Monadinstance.
The distinction can be seen with ordinary function com-
position and Kleisli composition as well:</p>
<p>CHAPTER 18. MONAD 1210
(.)
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
(&gt;=&gt;)
::Monadm
=&gt;(a-&gt;m b)-&gt;(b-&gt;m c)-&gt;a-&gt;m c
3.bindis unfortunately a somewhat overloaded term. You
first saw it used early in the book with respect to binding
variables to values, such as with the following:
letx=2inx+2
Where ùë•is a variable bound to 2. However, when we‚Äôre
talking about a Monadinstance typically bind will refer
to having used &gt;&gt;=to lift a monadic function over the
structure. The distinction being:
-- lifting (a -&gt; b) over f in f a
fmap::(a-&gt;b)-&gt;f a-&gt;f b
-- binding (a -&gt; m b) over m in m a
(&gt;&gt;=)::m a-&gt;(a-&gt;m b)-&gt;m b
You‚Äôll sometimes see us talk about the use of the bind
do-notation &lt;-or(&gt;&gt;=)as ‚Äúbinding over.‚Äù When we do, we</p>
<p>CHAPTER 18. MONAD 1211
mean that we lifted a monadic function and we‚Äôll even-
tuallyjoinor smush the structure back down when we‚Äôre
done monkeying around in the Monad.Don‚Äôtpanic if we‚Äôre a
little casual about describing the use of &lt;-as having bound
over/out some ùëéout ofm a.
18.9 Follow-up resources
1.What a Monad is not
https://wiki.haskell.org/What_a_Monad_is_not
2.Gabriel Gonzalez; How to desugar Haskell code
3.Stephen Diehl; What I wish I knew when Learning Haskell
http://dev.stephendiehl.com/hask/#monads
4.Stephen Diehl; Monads Made Difficult
http://www.stephendiehl.com/posts/monads.html
5.Brent Yorgey; Typeclassopedia
https://wiki.haskell.org/Typeclassopedia</p>
<p>Chapter 19
Applying structure
I often repeat repeat
myself, I often repeat
repeat. I don‚Äôt don‚Äôt know
why know why, I simply
know that I I I am am
inclined to say to say a lot
a lot this way this way- I
often repeat repeat
myself, I often repeat
repeat.
Jack Prelutsky
1212</p>
<p>CHAPTER 19. MONADS GONE WILD 1213
19.1 Applied structure
We thought you‚Äôd like to see Monoid,Functor ,Applicative , and
Monadin the wild as it were. Since we‚Äôd like to finish this book
before we have grandchildren, this will notbe accompanied
by the painstaking explanations and exercise regime you‚Äôve
experienced up to this point. Don‚Äôt understand something?
Figure it out! We‚Äôll do our best to leave a trail of breadcrumbs
for you to follow up on the code we show you. Consider this a
breezy survey of how Haskellers write code when they think
no one is looking and a pleasant break from your regularly
scheduled exercises. The code demonstrated will not always
include all necessary context to make it run, so don‚Äôt expect
to be able to load the snippets in GHCi and have them work.
If you don‚Äôt have a lot of previous programming experience
and some of the applications are difficult for you to follow,
you might prefer to return to this chapter at a later time, once
you start trying to read and use Haskell libraries for practical
projects.
19.2Monoid
Monoids are everywhere once you recognize the pattern and
start looking for them, but we‚Äôve tried to choose a few good
examples to illustrate typical use-cases.</p>
<p>CHAPTER 19. MONADS GONE WILD 1214
Templating content in Scotty
Here the scotty web framework‚Äôs ‚ÄúHello, World‚Äù example uses
mconcat to inject the parameter ‚Äúword‚Äù into the HTML page
returned:
{-# LANGUAGE OverloadedStrings #-}
importWeb.Scotty
importData.Monoid (mconcat)
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
html
(mconcat
[&quot;<h1>Scotty, &quot;
, beam
,&quot; me up!</h1>&quot; ])
If you‚Äôre interested in following up on this example, you
can find this example and a tutorial on the scotty Github repos-
itory.</p>
<p>CHAPTER 19. MONADS GONE WILD 1215
Concatenating connection parameters
The next example is from Aditya Bhargava‚Äôs ‚ÄúMaking A Web-
site With Haskell,‚Äù a blog post that walks you through several
steps for, well, making a simple website in Haskell. It also uses
thescotty web framework.
Here we‚Äôre using foldrandMonoid to concatenate connection
parameters for connecting to the database:
runDb::SqlPersist (ResourceT IO) a
-&gt;IOa
runDbquery= do
letconnStr =
foldr ((k,v) t -&gt;
t&lt;&gt;(encodeUtf8 $
k&lt;&gt;&quot;=&quot;&lt;&gt;v&lt;&gt;&quot; &quot;))
&quot;&quot;params
runResourceT
.withPostgresqlConn connStr
$runSqlConn query
If you‚Äôre interested in following up on this, this blog post
is one of many that shows you step by step how to use scotty ,
although many of them breeze through each step without a
great deal of explanation. It will be easier to understand scotty
in detail once you‚Äôve worked through monad transformers, but</p>
<p>CHAPTER 19. MONADS GONE WILD 1216
if you‚Äôd like to start playing around with some basic projects,
you may want to try them out.
Concatenating key configurations
The next example is going to be a bit meatier than the two
previous ones.
xmonad is a windowing system for X11 written in Haskell.
The configuration language is Haskell ‚Äî the binary that runs
your WM is compiled from your personal configuration. The
following is an example of using mappend to combine the default
configuration‚Äôs key mappings and a modification of those keys:</p>
<p>CHAPTER 19. MONADS GONE WILD 1217
importXMonad
importXMonad.Actions.Volume
importData.Map.Lazy (fromList )
importData.Monoid (mappend)
main= do
xmonad def { keys =
\c-&gt;fromList [
((0, xK_F6),
lowerVolume 4&gt;&gt;return()),
((0, xK_F7),
raiseVolume 4&gt;&gt;return())
] <code>mappend</code> keys defaultConfig c
}
The type of keysis a function:
keys:: !(XConfig Layout
-&gt;Map(ButtonMask ,KeySym) (X()))
You don‚Äôt need to get too excited about the exclamation
point right now; it‚Äôs the syntax for a nifty thing called a strictness
annotation , which makes a field in a product strict. That is, you
won‚Äôt be able to construct the record or product that contains
the value without also forcing that field to weak head normal
form. We‚Äôll explain this in more detail later in the book.</p>
<p>CHAPTER 19. MONADS GONE WILD 1218
The gist of the mainabove is that it allows your keymapping
to be based on the current configuration of your environment.
Whenever you type a key, xmonad will pass the current config to
yourkeysfunction in order to determine what (if any) action it
should take based on that. We‚Äôre using the Monoid here to add
new keyboard shortcuts for lowering and raising the volume
with F6 and F7. The monoid of the keysfunctions is combining
all of the key maps each function produces when applied to
theXConfig to produce a final canonical key map.
Say what?
This is a Monoid instance we hadn‚Äôt covered in the Monoid
chapter, so let‚Äôs take a look at it now:
instance Monoidb
=&gt;Monoid(a-&gt;b)
-- Defined in ‚ÄòGHC.Base‚Äô
This, friends, is the Monoid of functions.
But how does it work? First, let‚Äôs set up some very trivial
functions for demonstration:
Prelude&gt; import Data.Monoid
Prelude&gt; let f = const (Sum 1)
Prelude&gt; let g = const (Sum 2)
Prelude&gt; f 9001
Sum {getSum = 1}
Prelude&gt; g 9001</p>
<p>CHAPTER 19. MONADS GONE WILD 1219
Sum {getSum = 2}
Query the types of those functions and see how you think
they will match up to the Monoid instance above.
We know that whatever arguments we give to ùëìandùëî, they
will always return their first arguments, which are Summonoids.
So if we mappend ùëìandùëî, they‚Äôre going to ignore whatever argu-
ment we tried to apply them to and use the Monoid to combine
the results:
Prelude&gt; (f &lt;&gt; g) 9001
Sum {getSum = 3}
So this Monoid instance allows to mappend the results of two
function applications:
(a-&gt;b)&lt;&gt;(a-&gt;b)
Just as long as the ùëèhas aMonoid instance.
We‚Äôre going to oÔ¨Äer a few more examples that will get you
closer to what the particular use of mappend in thexmonad ex-
ample is doing. We mentioned Data.Map back in the Testing
chapter. It gives us ordered pairs of keys and values:
Prelude&gt; import qualified Data.Map as M
Prelude M&gt; :t M.fromList
M.fromList :: Ord k =&gt; [(k, a)] -&gt; Map k a</p>
<p>CHAPTER 19. MONADS GONE WILD 1220
Prelude M&gt; let f = M.fromList [('a', 1)]
Prelude M&gt; let g = M.fromList [('b', 2)]
Prelude M&gt; :t f
f :: Num a =&gt; Map Char a
Prelude M&gt; import Data.Monoid
Prelude M Data.Monoid&gt; f &lt;&gt; g
fromList [('a',1),('b',2)]
Prelude M Data.Monoid&gt; :t (f &lt;&gt; g)
(f &lt;&gt; g) :: Num a =&gt; Map Char a
Prelude M Data.Monoid&gt; mappend f g
fromList [('a',1),('b',2)]
Prelude M Data.Monoid&gt; f <code>mappend</code> g
fromList [('a',1),('b',2)]
-- but note what happens here:
Prelude&gt; f &lt;&gt; g
fromList [('a',1)]
So, returning to the xmonad configuration we started with.
Thekeysfield is a function which, given an XConfig , produces a
keymapping. It uses the monoid of functions to combine the
pre-existing function that generates the keymap to produce as
many maps as you have mappended functions, then combine
all the key maps into one.
This part:</p>
<p>CHAPTER 19. MONADS GONE WILD 1221
&gt;&gt;return()
says that the key assignment is performing some eÔ¨Äects and
only performing some eÔ¨Äects. Functions have to reduce to
some result, but sometimes their only purpose is to perform
someeÔ¨Äectsandyoudon‚Äôtwanttodoanythingwiththe‚Äúresult‚Äù
of evaluating the terms.
As we‚Äôve said and other people have noted as well, monoids
areeverywhere ‚Äî not just in Haskell but in all of programming.
19.3 Functor
There‚Äôs a reason we chose that Michael Neale quotation for
theFunctor chapter epigraph: lifting really is the cheat mode.
fmapis ubiquitous in Haskell, for all sorts of applications, but
we‚Äôve picked a couple that we found especially demonstrative
of why it‚Äôs so handy.
Lifting over IO
Herewe‚Äôretakingafunctionthatdoesn‚ÄôtperformI/O, addUTCTime ,
partially applying it to the oÔ¨Äset we‚Äôre going to add to the sec-
ond argument, then mapping it over the IOaction that gets us
the current time:</p>
<p>CHAPTER 19. MONADS GONE WILD 1222
importData.Time.Clock
offsetCurrentTime ::NominalDiffTime
-&gt;IOUTCTime
offsetCurrentTime offset=
fmap (addUTCTime (offset <em>24</em>3600))$
getCurrentTime
Context for the above:
1.NominalDiffTime is a newtype of Picoand has a Numinstance,
that‚Äôs why the arithmetic works.
addUTCTime ::NominalDiffTime
-&gt;UTCTime
-&gt;UTCTime
2.getCurrentTime ::IOUTCTime
3.fmap‚Äôs type got specialized.
fmap::(UTCTime -&gt;UTCTime)
-&gt;IOUTCTime
-&gt;IOUTCTime
Here we‚Äôre lifting some data conversion stuÔ¨Ä over the fact
that the UUID library has to touch an outside resource (ran-
dom number generation) to give us a random identifier. The</p>
<p>CHAPTER 19. MONADS GONE WILD 1223
UUID library used is named uuidon Hackage. The Textpack-
age used is named‚Ä¶ text:
import Data.Text (Text)
import qualified Data.Text asT
import qualified Data.UUID asUUID
import qualified Data.UUID.V4 asUUIDv4
textUuid ::IOText
textUuid =
fmap (T.pack.UUID.toString)
UUIDv4.nextRandom
1.nextRandom ::IOUUID
2.toString ::UUID-&gt;String
3.pack::String-&gt;Text
4.fmap::(UUID-&gt;Text)
-&gt;IOUUID
-&gt;IOText
Lifting over web app monads
Frequently when you write web applications, you‚Äôll have a
custom datatype to describe the web application which is also</p>
<p>CHAPTER 19. MONADS GONE WILD 1224
aMonad. It‚Äôs a Monadbecause your ‚Äúapp context‚Äù will have a
type parameter to describe what result was produced in the
course of a running web application. Often these types will
abstract out the availability of a request or other configuration
data with a Reader (explained in a later chapter), as well as the
performance of eÔ¨Äects via IO. In the following example, we‚Äôre
lifting over AppHandler andMaybe:
userAgent ::AppHandler (MaybeUserAgent )
userAgent =
(fmap.fmap) userAgent' getRequest
userAgent' ::Request -&gt;MaybeUserAgent
userAgent' req=
getHeader &quot;User-Agent&quot; req
We need the Functor here because while we can pattern
match on the Maybevalue, an AppHandler isn‚Äôt something we can
pattern match on. It‚Äôs a convention in this web framework
library, snap, to make a type alias for your web application type.
It usually looks like this:
typeAppHandler =Handler AppApp
The underlying infrastructure for snapis more complicated
than we can cover to any depth here, but suffice to say there
are a few things floating around:</p>
<p>CHAPTER 19. MONADS GONE WILD 1225
1.HTTP request which triggered the processing currently
occurring.
2.The current (possibly empty or default) response that will
be returned to the client when the handlers and middle-
ware are done.
3.A function for updating the request timeout.
4.A helper function for logging.
5.And a fair bit more than this.
The issue here is that your AppHandler is meant to be slotted
into a web application which requires the reading in of con-
figuration, initialization of a web server, and the sending of a
request to get everything in motion. This is essentially a bunch
of functions waiting for arguments ‚Äî waiting for something
to do. It doesn‚Äôt make sense to do all that yourself every time
you want a value that can only be obtained in the course of
the web application doing its thing. Accordingly, our Functor
is letting us write functions over structure which handles all
this work. It‚Äôs like we‚Äôre saying, ‚Äúhere‚Äôs a function, apply it to a
thing that resulted from an HTTP request coming down the
pipe, if one comes along.‚Äù</p>
<p>CHAPTER 19. MONADS GONE WILD 1226
19.4Applicative
Applicative is somewhat new to Haskell, but it‚Äôs useful enough,
particularlywithparsers, thatit‚Äôseasytofindexamples. There‚Äôs
a whole chapter on parsers coming up later, but we thought
these examples were mostly comprehensible even without
that context.
hgrev
This is an example from Luke Hoersten‚Äôs hgrevproject. The
example in the README is a bit dense, but uses Monoid and
Applicative to combine parsers of command line arguments:
jsonSwitch ::Parser(a-&gt;a)
jsonSwitch =
infoOption $(hgRevStateTH jsonFormat)
$long&quot;json&quot;
&lt;&gt;short'J'
&lt;&gt;help
&quot;Display JSON version information&quot;
parserInfo ::ParserInfo (a-&gt;a)
parserInfo =
info (helper &lt;*&gt;verSwitch &lt;*jsonSwitch)
fullDesc</p>
<p>CHAPTER 19. MONADS GONE WILD 1227
You might be wondering what the &lt;<em>operator is. It‚Äôs an-
other operator from the Applicative typeclass. It allows you to
sequence actions, discarding the result of the second argument.
Does this look familiar?
Prelude&gt; :t (&lt;</em>)
(&lt;<em>) :: Applicative f =&gt; f a -&gt; f b -&gt; f a
Prelude&gt; :t const
const :: a -&gt; b -&gt; a
Basically the (&lt;</em>)operator (like its sibling, (*&gt;), and the
monadic operator, &gt;&gt;) is useful when you‚Äôre emitting eÔ¨Äects.
In this case, you‚Äôve done something with eÔ¨Äects and want to
discard any value that resulted.
More parsing
Here we‚Äôre using Applicative to lift the data constructor for the
Payload type over the Parser returned by requesting a value by
key out of a JSON object, which is basically an association of
text keys to further more JSON values which may be strings,
numbers, arrays, or more JSON objects:</p>
<p>CHAPTER 19. MONADS GONE WILD 1228
parseJSON ::Value-&gt;Parsera
(.:)::FromJSON a
=&gt;Object
-&gt;Text
-&gt;Parsera
instance FromJSON Payload where
parseJSON ( Objectv)=
Payload &lt;$&gt;v.:&quot;from&quot;
&lt;<em>&gt;v.:&quot;to&quot;
&lt;</em>&gt;v.:&quot;subject&quot;
&lt;<em>&gt;v.:&quot;body&quot;
&lt;</em>&gt;v.:&quot;offset_seconds&quot;
parseJSON v =typeMismatch &quot;Payload&quot; v
This is the same as the JSON but for CSV1data:
parseRecord ::Record-&gt;Parsera
1CSV stands for comma-separated values, a common, though not entirely standard-
ized file format.</p>
<p>CHAPTER 19. MONADS GONE WILD 1229
instance FromRecord Release where
parseRecord v
|V.length v ==5=Release &lt;$&gt;v.!0
&lt;<em>&gt;v.!1
&lt;</em>&gt;v.!2
&lt;<em>&gt;v.!3
&lt;</em>&gt;v.!4
|otherwise =mzero
This one uses liftA2 to lift the tuple data constructor over
parseKey andparseValue to give key-value pairings. You can see
the(&lt;*)operator in there again as well, along with the infix
operator for fmapand=&lt;&lt;as well:</p>
<p>CHAPTER 19. MONADS GONE WILD 1230
instance Deserializeable ShowInfoResp where
parser=
e2err=&lt;&lt;convertPairs
.HM.fromList &lt;$&gt;parsePairs
where
parsePairs ::Parser[(Text,Text)]
parsePairs =
parsePair <code>sepBy</code> endOfLine
parsePair =
liftA2 (,) parseKey parseValue
parseKey =
takeTill ( ==':')&lt;*kvSep
kvSep=string&quot;: &quot;
parseValue =takeTill isEndOfLine
This one instance is a virtual cornucopia of applications
of the previous chapters and we believe it demonstrates how
much cleaner and more readable these can make your code.
And now for something diÔ¨Äerent
This next example is also using an applicative, but this is a bit
diÔ¨Äerent than the above examples. We‚Äôll spend more time</p>
<p>CHAPTER 19. MONADS GONE WILD 1231
explaining this one, as this pattern for writing utility functions
is common:
moduleWeb.Shipping.Utils ((&lt;||&gt;))where
importControl.Applicative (liftA2)
(&lt;||&gt;)::(a-&gt;Bool)
-&gt;(a-&gt;Bool)
-&gt;a
-&gt;Bool
(&lt;||&gt;)=liftA2 ( ||)
At first glance, this doesn‚Äôt seem too hard to understand,
but some examples will help you develop an understanding
of what‚Äôs going on. We start with the operator for boolean
disjunction, (||), which is an or:
Prelude&gt; True || False
True
Prelude&gt; False || False
False
Prelude&gt; (2 &gt; 3) || (3 == 3)
True
And now we want to be able to keep that as an infix operator
but lift it over some context, so we use liftA2 :</p>
<p>CHAPTER 19. MONADS GONE WILD 1232
Prelude&gt; import Control.Applicative
Prelude&gt; let (&lt;||&gt;) = liftA2 (||)
Andwe‚Äôllmakesometrivialfunctionsagainforthepurposes
of demonstration:
Prelude&gt; let f 9001 = True; f _ = False
Prelude&gt; let g 42 = True; g _ = False
Prelude&gt; :t f
f :: (Eq a, Num a) =&gt; a -&gt; Bool
Prelude&gt; f 42
False
Prelude&gt; f 9001
True
Prelude&gt; g 42
True
Prelude&gt; g 9001
False
We can compose the two functions ùëìandùëîto take one input
and give one summary result like this:
Prelude&gt; (\n -&gt; f n || g n) 0
False
Prelude&gt; (\n -&gt; f n || g n) 9001
True
Prelude&gt; :t (\n -&gt; f n || g n)</p>
<p>CHAPTER 19. MONADS GONE WILD 1233
(\n -&gt; f n || g n)
:: (Eq a, Num a) =&gt; a -&gt; Bool
But we have to pass in that argument ùëõin order to do it that
way. Our utility function gives us a cleaner way:
Prelude&gt; (f &lt;||&gt; g) 0
False
Prelude&gt; (f &lt;||&gt; g) 9001
True
It‚Äôs parallel application of the functions against an argument.
That application produces two values, so we monoidally com-
bine the two values so that we have a single value to return.
We‚Äôve set up an environment so that two (a -&gt; Bool) functions
that don‚Äôt have an ùëéargument yet can return a result based on
those two Boolvalues when the combined function is eventu-
ally applied against an ùëé.
19.5Monad
BecauseeÔ¨ÄectfulprogrammingisconstrainedinHaskellthrough
the use of IO, andIOhas an instance of Monad, examples of Monad
in practical Haskell code are everywhere. We tried to find
some examples that illustrate diÔ¨Äerent interesting use cases.</p>
<p>CHAPTER 19. MONADS GONE WILD 1234
Opening a network socket
Here we‚Äôre using dosyntax for IO‚ÄôsMonadin order to bind a
socket handle from the socket smart constructor, connect it
to an address, then return the handle for reading and writing.
This example is from haproxy-haskell by Michael Xavier. See
thenetwork library on Hackage for use and documentation:
importNetwork.Socket
openSocket ::FilePath -&gt;IOSocket
openSocket p= do
sock&lt;-socketAF_UNIX
Stream
defaultProtocol
connect sock sockAddr
return sock
wheresockAddr =
SockAddrUnix .encodeString $p
This isn‚Äôt too unlike anything you saw in previous chapters,
at least since we built the hangman game. The next example
is a bit richer.</p>
<p>CHAPTER 19. MONADS GONE WILD 1235
Binding over failure in initialization
Michael Xavier‚Äôs Seraph is a process monitor and has a main
entry point which is typical of more developed libraries and
applications. The outermost MonadisIO, but the monad trans-
former variant of Either , calledEitherT , is used to bind over the
possibility of failure in constructing an initialization function.
This possibility of failure centers on being able to pull up a
correct configuration:</p>
<p>CHAPTER 19. MONADS GONE WILD 1236
main::IO()
main= do
initAndFp &lt;-runEitherT $ do
fp&lt;-tryHead NoConfig =&lt;&lt;lift getArgs
initCfg &lt;-load' fp
return (initCfg, fp)
either bail (uncurry boot) initAndFp
where
boot initCfg fp =
void$runMVC mempty
oracleModel (core initCfg fp)
bailNoConfig =
errorExit &quot;Please pass a config&quot;
bail (InvalidConfig e)=
errorExit
(&quot;Invalid config &quot; ++show e)
load' fp =
hoistEither
.fmapLInvalidConfig
=&lt;&lt;lift (load fp)
If you found that very dense and difficult to follow at this
point, we‚Äôd encourage you to have another look at it after we‚Äôve
covered monad transformers.</p>
<p>CHAPTER 19. MONADS GONE WILD 1237
19.6 An end-to-end example: URL
shortener
In this section, we‚Äôre going to walk through an entire program,
beginning to end.2There are some pieces we are not going to
explain thoroughly; however, this is something you can build
and work with if you‚Äôre interested in doing so.
First, the .cabal file for the project:
name: shawty
version: 0.1.0.0
synopsis: URI shortener
description: Please see README.md
homepage: http://github.com/
license: BSD3
license-file: LICENSE
author: Chris Allen
maintainer: cma@bitemyapp.com
copyright: 2015, Chris Allen
category: Web
build-type: Simple
cabal-version: &gt;=1.10
executable shawty
2The code in this example can be found here: https://github.com/bitemyapp/
shawty-prime/blob/master/app/Main.hs</p>
<p>CHAPTER 19. MONADS GONE WILD 1238
hs-source-dirs: app
main-is: Main.hs
ghc-options: -threaded
build-depends: base
, bytestring
, hedis
, mtl
, network-uri
, random
, scotty
, semigroups
, text
, transformers
default-language: Haskell2010
And the project layout:
$ tree
.
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Setup.hs
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Main.hs
‚îú‚îÄ‚îÄ shawty.cabal
‚îî‚îÄ‚îÄ stack.yaml</p>
<p>CHAPTER 19. MONADS GONE WILD 1239
You may choose to use Stack or not. That is how we got the
template for the project in place. If you‚Äôd like to learn more,
check out Stack‚Äôs Github repo3and the Stack video tutorial4
we worked on together. The code following from this point is
inMain.hs .
We need to start our program oÔ¨Ä with a language extension:
{-# LANGUAGE OverloadedStrings #-}
OverloadedStrings is a way to make String literals polymor-
phic, the way numeric literals are polymorphic over the Num
typeclass. String literals are not ordinarily polymorphic; String
is a concrete type. Using OverloadedStrings allows us to use
String literals as TextandByteString values.
Brief aside about polymorphic literals
We mentioned that the integral number literals in Haskell
are typed Num a =&gt; a by default. Now that we have another
example to work with, it‚Äôs worth examining how they work
under the hood, so to speak. First, let‚Äôs look at a typeclass from
a module in base:
Prelude&gt; import Data.String
3Stack Github repo https://github.com/commercialhaskell/stack
4The video Stack mega-tutorial! The whole video is long, but covers a lot of abnormal
use cases. Use the time stamps to jump to what you need to learn. https://www.youtube.
com/watch?v=sRonIB8ZStw&amp;feature=youtu.be</p>
<p>CHAPTER 19. MONADS GONE WILD 1240
Prelude&gt; :info IsString
class IsString a where
fromString :: String -&gt; a
-- Defined in ‚ÄòData.String‚Äô
instance IsString [Char]
-- Defined in ‚ÄòData.String‚Äô
Then we may notice something in NumandFractional :
classNumawhere
-- irrelevant bits elided
fromInteger ::Integer -&gt;a
classNuma=&gt;Fractional awhere
-- elision again
fromRational ::Rational -&gt;a
OK, and what about our literals?
Prelude&gt; :set -XOverloadedStrings
Prelude&gt; :t 1
1 :: Num a =&gt; a
Prelude&gt; :t 1.0
1.0 :: Fractional a =&gt; a
Prelude&gt; :t &quot;blah&quot;
&quot;blah&quot; :: IsString a =&gt; a</p>
<p>CHAPTER 19. MONADS GONE WILD 1241
The basic design is that the underlying representation is
concrete, butGHCautomaticallywrapsitin fromString /fromInteger /fromRational .
So it‚Äôs as if:
{-# LANGUAGE OverloadedStrings #-}
&quot;blah&quot;::Text
==fromString ( &quot;blah&quot;::String)
1::Int
==fromInteger ( 1::Integer)
2.5::Double
==fromRational ( 2.5::Rational )
Librarieslike textandbytestring provideinstancesfor IsString
in order to perform the conversion. Assuming you have those
libraries installed, you can kick it around a little. Note that,
due to the monomorphism restriction, the following will work
in the REPL but would not work if we loaded it from a source
file (because it would default to a concrete type; we‚Äôve seen
this a couple times earlier in the book):
Prelude&gt; :set -XOverloadedStrings
Prelude&gt; let a = &quot;blah&quot;
Prelude&gt; a</p>
<p>CHAPTER 19. MONADS GONE WILD 1242
&quot;blah&quot;
Prelude&gt; :t a
a :: Data.String.IsString a =&gt; a
Then you can make it a TextorByteString value:
Prelude&gt; import Data.Text (Text)
Prelude&gt; :{
*Main| import Data.ByteString (ByteString)
*Main| :}
Prelude&gt; let t = &quot;blah&quot; :: Text
Prelude&gt; let bs = &quot;blah&quot; :: ByteString
Prelude&gt; t == bs
Couldn't match expected type ‚ÄòText‚Äô with
actual type ‚ÄòByteString‚Äô
In the second argument of ‚Äò(==)‚Äô,
namely ‚Äòbs‚Äô
In the expression: t == bs
OverloadedStrings is a convenience that originated in the
desire of working Haskell programmers to use String literals
forTextandByteString values. It‚Äôs not too big a deal, but it
can be nice and saves you manually wrapping each literal in
fromString .</p>
<p>CHAPTER 19. MONADS GONE WILD 1243
Back to the show
Next, the module name must be Mainas that is required for
anything exporting a mainexecutable to be invoked when the
program runs. We follow the OverloadedStrings extension with
our imports:
moduleMainwhere
importControl.Monad (replicateM )
importControl.Monad.IO.Class (liftIO)
import qualified Data.ByteString.Char8
asBC
importData.Text.Encoding
(decodeUtf8 ,encodeUtf8 )
import qualified Data.Text.Lazy asTL
import qualified Database.Redis asR
importNetwork.URI (URI,parseURI )
import qualified System.Random asSR
importWeb.Scotty
Where we import something ‚Äúqualified (‚Ä¶) as (‚Ä¶)‚Äù we are
doing two things. Qualifying the import means that we can
only refer to values in the module with the full module path,
and we use asto give the module that we want in scope a name.
For example, Data.ByteString.Char8.pack is a fully qualified ref-</p>
<p>CHAPTER 19. MONADS GONE WILD 1244
erence to pack. We qualify the import so that we don‚Äôt import
declarations that would conflict with bindings that already
exist in Prelude . By specifying a name using as, we can give the
value a shorter, more convenient name. Where we import the
module name followed by parentheses, such as with replicateM
orliftIO , we are saying we only want to import the functions
or values of that name and nothing else. In the case of import
Web.Scotty , we are importing everything Web.Scotty exports. An
unqualified and unspecific import should be avoided except in
those cases where the provenance of the imported functions
will be obvious, or when the import is a toolkit you must use
all together, such as scotty .
Next we need to generate our shortened URLs that will refer
to the links people post to the service. We will make a String
of the characters we want to select from:
alphaNum ::String
alphaNum =['A'..'Z']++['0'..'9']
Now we need to pick random elements from alphaNum . The
general idea here should be familiar from the hangman game.
First, we find the length of the list to determine a range to
select from, then get a random number in that range, using IO
to handle the randomness:</p>
<p>CHAPTER 19. MONADS GONE WILD 1245
randomElement ::String-&gt;IOChar
randomElement xs= do
letmaxIndex ::Int
maxIndex =length xs -1
-- Right of arrow is IO Int,
-- so randomDigit is Int
randomDigit &lt;-SR.randomRIO ( 0, maxIndex)
return (xs !!randomDigit)
Next, we apply randomElement toalphaNum to get a single ran-
domletterornumberfromouralphabet. Thenweuse replicateM
7to repeat this action 7 times, giving a list of 7 random letters
or numbers:
shortyGen ::IO[Char]
shortyGen =
replicateM 7(randomElement alphaNum)
For additional fun, see what replicateM 2 [1, 3] does and
whether you can figure out why. Compare it to the Prelude
function, replicate .
You may have noticed a mention of Redis in our imports
and wondered what was up. If you‚Äôre not already familiar with
it, Redis is in-memory, key-value data storage. The details
of how Redis works are well beyond the scope of this book
and they‚Äôre not very important here. Redis can be convenient</p>
<p>CHAPTER 19. MONADS GONE WILD 1246
for some common use cases like caching, or when you want
persistence without a lot of ceremony, as was the case here.
You will need to install and have Redis running in order for
the project to work; otherwise, the web server will throw an
error upon failing to connect to Redis.
This next bit is a function whose arguments are our con-
nection to Redis ( R.Connection ), the key we are setting in Redis,
and the value we are setting the key to. We also perform side
eÔ¨Äects in IOto getEither R.Reply R.Status as a result. The key
in this case is the randomly generated URI we created, and
the value is the URL the user wants the shortener to provide
at that address:
saveURI ::R.Connection
-&gt;BC.ByteString
-&gt;BC.ByteString
-&gt;IO(EitherR.ReplyR.Status)
saveURI conn shortURI uri =
R.runRedis conn $R.set shortURI uri
The next function, getURI , takes the connection to Redis and
the shortened URI key in order to get the URI associated with
that short URL and show users where they‚Äôre headed:</p>
<p>CHAPTER 19. MONADS GONE WILD 1247
getURI ::R.Connection
-&gt;BC.ByteString
-&gt;IO(EitherR.Reply
(MaybeBC.ByteString ))
getURIconn shortURI =
R.runRedis conn $R.get shortURI
Next some basic templating functions for returning output
to the web browser:
linkShorty ::String-&gt;String
linkShorty shorty=
concat
[&quot;&lt;a href= &quot;&quot;
, shorty
,&quot;&quot;&gt;Copy and paste your short URL</a>&quot;
]
The final output to scotty has to be a Textvalue, so we‚Äôre
concatenating lists of Textvalues to produce responses to the
browser:</p>
<p>CHAPTER 19. MONADS GONE WILD 1248
-- TL.concat :: [TL.Text] -&gt; TL.Text
shortyCreated ::Showa
=&gt;a
-&gt;String
-&gt;TL.Text
shortyCreated resp shawty =
TL.concat [ TL.pack (show resp)
,&quot; shorty is: &quot;
,TL.pack (linkShorty shawty)
]
shortyAintUri ::TL.Text-&gt;TL.Text
shortyAintUri uri=
TL.concat
[ uri
,&quot; wasn't a url,&quot;
,&quot; did you forget http://?&quot;
]
shortyFound ::TL.Text-&gt;TL.Text
shortyFound tbs=
TL.concat
[&quot;&lt;a href= &quot;&quot;
, tbs,&quot;&quot;&gt;&quot;
, tbs,&quot;</a>&quot;]</p>
<p>CHAPTER 19. MONADS GONE WILD 1249
Now we get to the bulk of web-appy bits in the form of our
application. We‚Äôll enumerate the application in chunks, but
they‚Äôre all in one appfunction:
app::R.Connection
-&gt;ScottyM ()
apprConn= do
-- [1]
get&quot;/&quot;$ do
-- [2]
uri&lt;-param&quot;uri&quot;
-- [3]
1.Redis connection that should‚Äôve been fired up before the
web server started.
2.getis a function that takes a RoutePattern , an action that
returns an HTTP response, and adds the route to the
Scotty server it‚Äôs embedded in. As you might suspect,
RoutePattern has anIsString instance so that the pattern
can be a String literal. The top-level route is expressed as
‚Äù/‚Äù, i.e., likegoingto https://google.com/ orhttps://bitemyapp.
com/. That final /character is what‚Äôs being expressed.
3.Theparamfunction is a means of getting‚Ä¶parameters.</p>
<p>CHAPTER 19. MONADS GONE WILD 1250
param::Parsable a
=&gt;Data.Text.Internal .Lazy.Text
-&gt;ActionM a
It‚Äôs sort of like Read, but it‚Äôs parsing a value of the type
you ask for. The paramfunction can find arguments via
URL path captures (see below with :short), HTML form
inputs, or query parameters. The first argument to param
is the ‚Äúname‚Äù or key for the input. We cannot explain the
entirety of HTTP and HTML here, but the following are
means of getting a param with the key name:
a)URL path capture
get&quot;/user/:name/view&quot; $ do
-- requesting the URL /user/Blah/view
-- would make name = &quot;Blah&quot;
-- such as:
-- http://localhost:3000/user/Blah/view
b)HTML input form. Here the name attribute for the
input field is ‚Äùname‚Äù.</p>
<form>
Name:<br>
<input type="text" name="name">
</form>
<p>CHAPTER 19. MONADS GONE WILD 1251
c)Query parameters for URIs are pairings of keys and
values following a question mark.
http://localhost:3000/?name=Blah
You can define more than one by using ampersand to
separate the key value pairs.
/?name=Blah&amp;state=Texas
Now for the next chunk of the appfunction:
letparsedUri ::MaybeURI
parsedUri =
parseURI ( TL.unpack uri)
caseparsedUri of
-- [1]
Just_ -&gt; do
shawty&lt;-liftIO shortyGen
-- [2]
letshorty=BC.pack shawty
-- [3]</p>
<p>CHAPTER 19. MONADS GONE WILD 1252
uri'=
encodeUtf8 ( TL.toStrict uri)
-- [4]
resp&lt;-
liftIO (saveURI rConn shorty uri')
-- [5]
html (shortyCreated resp shawty)
-- [6]
Nothing -&gt;text (shortyAintUri uri)
-- [7]
1.We test that the user gave us a valid URI by using the
network-uri library‚Äôs parseURI function. We don‚Äôt really
care about the datatype it got wrapped in, so when we
check if it‚Äôs JustorNothing , we drop it on the floor.
2.TheMonadhere is ActionM (an alias of ActionT ), which is a
datatype representing code that handles web requests
and returns responses. You can perform IOactions in
thisMonad, but you have to lift the IOaction over the addi-
tional structure. Conventionally, one uses MonadIO as a sort
of auto-lift for IOactions, but you could do it manually.
We won‚Äôt demonstrate this here. We will explain monad
transformers in a later chapter so that ActionT will be less
mysterious.</p>
<p>CHAPTER 19. MONADS GONE WILD 1253
3.ConvertingtheshortcodefortheURIintoa Char8ByteString
for storage in Redis.
4.Converting the URI the user provided from a lazy Text
value into a strict Textvalue, then encoding as a UTF-8 (a
common Unicode format) ByteString for storage in Redis.
5.Again using liftIO so that we can perform an IOaction
inside a scotty ActionM . In this case, we‚Äôre saving the short
code and the URI in Redis so that we can look things up
with the short code as a key, then get the URI back as a
value if it has been stored in the past.
6.The templated response we return when we successfully
saved the short code for the URI. This gives the user a
shortened URI to share.
7.Error response in case the user gave us a URI that wasn‚Äôt
valid.
The second handler handles requests to a shortened URI
and returns the unshortened URL to follow:</p>
<p>CHAPTER 19. MONADS GONE WILD 1254
get&quot;/:short&quot; $ do
-- [1]
short&lt;-param&quot;short&quot;
-- [2]
uri&lt;-liftIO (getURI rConn short)
-- [3]
caseuriof
Leftreply-&gt;
text (TL.pack (show reply))
-- [4] [5]
RightmbBS-&gt; case mbBSof
-- [6]
Nothing -&gt;text&quot;uri not found&quot;
-- [7]
Justbs-&gt;html (shortyFound tbs)
-- [8]
wheretbs::TL.Text
tbs=
TL.fromStrict
(decodeUtf8 bs)
-- [9]
1.This is the URL path capture we mentioned earlier, such
that requesting /blahfrom the server will cause it to get
the key ‚Äúblah‚Äù from Redis and, if there‚Äôs a value stored in</p>
<p>CHAPTER 19. MONADS GONE WILD 1255
that key, return that URI in the response. To do that in a
web browser or with curl/wget, you‚Äôd point your client at
http://localhost:3000/blah to test it.
2.Same parameter fetching as before. This time we expect
it to be part of the path capture rather than a query argu-
ment.
3.Lifting an IOaction inside ActionM again, this time to get
the short code as the lookup key from Redis.
4.Lefthere (in the Either we get back from Redis) signifies
some kind of failure, usually an error.
5.Textresponse returning an error in case we got Leftso that
the user knows what the error was, taking advantage of
Redis having Showable errors to render it in the response.
6.Happy path.
7.Just because an error didn‚Äôt happen doesn‚Äôt mean the key
was in the database.
8.Wefetchakeythatexistsinthedatabase, getthe ByteString
out of the Justdata constructor and render the URI in the
success template to show the user the URI we stored.
9.Going in the opposite direction we went in before ‚Äî de-
coding the ByteString on the assumption it‚Äôs encoded as</p>
<p>CHAPTER 19. MONADS GONE WILD 1256
UTF-8, then converting from a strict Textvalue to a lazy
Textvalue.
Now we come to the mainevent.mainreturns IO ()and acts as
the entry point for our web server when we start the executable.
We begin by invoking scotty 3000 , a helper function from the
scotty framework which, given a port to run on and a scotty
application, will listen for requests and respond to them:
main::IO()
main= do
rConn&lt;-R.connect R.defaultConnectInfo
scotty3000(app rConn)
And that is the entirety of this URL shortener. We have a
couple of exercises based on this code, and we encourage you
to come back to it after we‚Äôve covered monad transformers as
well and see how your comprehension is growing.
Exercise
In the URL shortener, an important step was omitted. We‚Äôre
not checking if we‚Äôre overwriting an existing short code, which
is entirely possible despite them being randomly generated.
We can calculate the odds of this by examining the cardinality
of the values.</p>
<p>CHAPTER 19. MONADS GONE WILD 1257
-- alphaNum = ['A'..'Z'] ++ ['0'..'9']
-- shortyGen =
-- replicateM 7 (randomElement alphaNum)
lengthalphaNum ^7==78364164096
So, the problem is, what if we accidentally clobber a previ-
ously generated short URI? There are a few ways of solving
this. One is to check to see if the short URI already exists in the
database before saving it and throwing an error if it does. This
is going to be vanishingly unlikely to happen unless you‚Äôve
suddenly become a very popular URI shortening service, but
it‚Äôd prevent the loss of any data. Your exercise is to devise
some means of making this less likely. The easiest way would
be to simply make the short codes long enough that you‚Äôd
need to run a computer until the heat death of the universe
to get a collision, but you should try throwing an error in the
first handler we showed you first.
19.7 That‚Äôs a wrap!
We hope this chapter gave you some idea of how Haskellers
use the typeclasses we‚Äôve been talking about in real code, to
handle various types of problems. In the next two chapters,
we‚Äôll be looking at Foldable andTraversable , two typeclasses
with some interesting properties that rely on these four alge-</p>
<p>CHAPTER 19. MONADS GONE WILD 1258
braic structures (monoid, functor, applicative, and monad),
so we encourage you to take some time to explore some of
the uses we‚Äôve demonstrated here. Consider going back to
anything you didn‚Äôt understand very well the first time you
went through those chapters.
19.8 Follow-up resources
1.The case of the mysterious explosion in space; Bryan
O‚ÄôSullivan; Explains how GHC handles string literals.</p>
<p>Chapter 20
Foldable
You gotta know when to
hold ‚Äôem, know when to
fold ‚Äôem, know when to
walk away, know when to
run.
Kenny Rogers
1259</p>
<p>CHAPTER 20. FOLDABLE 1260
20.1 Foldable
This typeclass has been appearing in type signatures at least
since Chapter 3, but for your purposes in those early chapters,
we said you could think of a Foldable thing as a list. As you
saw in the chapter on folds, lists are certainly foldable data
structures. But it is also true that lists are not the only foldable
data structures, so this chapter will expand on the idea of
catamorphisms and generalize it to many datatypes.
A list fold is a way to reduce the values inside a list to one
summary value by recursively applying some function. It is
sometimes difficult to appreciate that, as filtering and mapping
functions may be implemented in terms of a fold and yet
return an entirely new list! The new list is the summary value
of the old list after being reduced, or transformed, by function
application.
The folding function is always dependent on some Monoid
instance. The folds we wrote previously mostly relied on
implicit monoidal operations. As we‚Äôll see in this chapter,
generalizing catamorphisms to other datatypes depends on
understanding the monoids for those structures and, in some
cases, making them explicit.
This chapter will cover:
‚Ä¢theFoldable class and its core operations;
‚Ä¢the monoidal nature of folding;</p>
<p>CHAPTER 20. FOLDABLE 1261
‚Ä¢standard operations derived from folding.
20.2 The Foldable class
The Hackage documentation for the Foldable typeclass de-
scribes it as being a, ‚Äúclass of data structures that can be folded
to a summary value.‚Äù The folding operations that we‚Äôve seen
previously fit neatly into that definition, but this typeclass in-
cludes many operations. We‚Äôre going to go through the full
definition a little at a time. The definition in the library begins:
classFoldable twhere
{-# MINIMAL foldMap | foldr #-}
TheMINIMAL annotation on the typeclass tells you that a
minimally complete definition of the typeclass will define
foldMap orfoldrfor a datatype. As it happens, foldMap andfoldr
can each be implemented in terms of the other, and the other
operations included in the typeclass can be implemented in
terms of either of them. As long as at least one is defined,
you have a working instance of Foldable . Some methods in the
typeclass have default implementations that can be overridden
when needed. This is in case there‚Äôs a more efficient way to
do something that‚Äôs specific to your datatype.
If you query the info about the typeclass in GHCi, the first
line of the definition includes the kind signature for ùë°:</p>
<p>CHAPTER 20. FOLDABLE 1262
class Foldable (t :: * -&gt; *) where
Thatùë°should be a higher-kinded type is not surprising: lists
are higher-kinded types. We need ùë°to be a type constructor
for the same reasons we did with Functor , and we will see that
the eÔ¨Äects are very similar. Types that take more than one
type argument, such as tuples and Either , will necessarily have
their first type argument included as part of their structure.
Please note that you will need to use GHC 7.10 or later ver-
sions for all the examples in this chapter to work. Also, while
thePrelude as of GHCi 7.10 includes many changes related to
theFoldable typeclass, not all of Foldable is in the Prelude . To
follow along with the examples in the chapter, you may need
to import Data.Foldable andData.Monoid (for some of the Monoid
newtypes).
20.3 Revenge of the monoids
One thing we did not talk about when we covered folds pre-
viously is the importance of monoids. Folding necessarily
implies a binary associative operation that has an identity
value. The first two operations defined in Foldable make this
explicit:</p>
<p>CHAPTER 20. FOLDABLE 1263
classFoldable (t:: * -&gt; * )where
fold::Monoidm=&gt;t m-&gt;m
foldMap ::Monoidm
=&gt;(a-&gt;m)-&gt;t a-&gt;m
Whilefoldallows you to combine elements inside a Foldable
structure using the Monoid defined for those elements, foldMap
first maps each element of the structure to a Monoid and then
combines the results using that instance of Monoid .
Thesemightseemalittleweirduntilyourealizethat Foldable
is requiring that you make the implicit Monoid visible in folding
operations. Let‚Äôs take a look at a very basic foldroperation
and see how it compares to foldandfoldMap :
Prelude&gt; foldr (+) 0 [1..5]
15
The binary associative operation for that fold is (+), so we‚Äôve
specified it without thinking of it as a monoid. The fact that
the numbers in our list have other possible monoids is not
relevant once we‚Äôve specified which operation to use.
We can already see from the type of foldthat it‚Äôs not going to
work the same as foldr, because it doesn‚Äôt take a function for its
first argument. But we also can‚Äôt just fold up a list of numbers,
because the foldfunction doesn‚Äôt have a Monoid specified:
Prelude&gt; fold (+) [1, 2, 3, 4, 5]</p>
<p>CHAPTER 20. FOLDABLE 1264
-- error message resulting from incorrect
-- number of arguments
Prelude&gt; fold [1, 2, 3, 4, 5]
-- error message resulting from not having
-- an instance of Monoid
So, what we need to do to make foldwork is specify a Monoid
instance:
Prelude&gt; let xs = map Sum [1..5]
Prelude&gt; fold xs
Sum {getSum = 15}
Or, less tediously:
Prelude&gt; :{
*Main| let xs :: Sum Integer
*Main| xs = [1, 2, 3, 4, 5]
*Main| :}
Prelude&gt; fold xs
Sum {getSum = 15}
Prelude&gt; :{
*Main| let xs :: Product Integer
*Main| xs = [1, 2, 3, 4, 5]
*Main| :}
Prelude&gt; fold xs</p>
<p>CHAPTER 20. FOLDABLE 1265
Product {getProduct = 120}
In some cases, the compiler can identify and use the stan-
dardMonoid for a type, without us being explicit:
Prelude&gt; foldr (++) &quot;&quot; [&quot;hello&quot;, &quot; julie&quot;]
&quot;hello julie&quot;
Prelude&gt; fold [&quot;hello&quot;, &quot; julie&quot;]
&quot;hello julie&quot;
The default Monoid instance for lists gives us what we need
without having to specify it.
And now for something diÔ¨Äerent
Let‚Äôs turn our attention now to foldMap . Unlike fold,foldMap has
a function as its first argument. Unlike foldr, the first (function)
argument of foldMap must explicitly map each element of the
structure to a Monoid :
Prelude&gt; foldMap Sum [1, 2, 3, 4]
Sum {getSum = 10}
Prelude&gt; foldMap Product [1, 2, 3, 4]
Product {getProduct = 24}
Prelude&gt; foldMap All [True, False, True]
All {getAll = False}</p>
<p>CHAPTER 20. FOLDABLE 1266
Prelude&gt; foldMap Any [(3 == 4), (9 &gt; 5)]
Any {getAny = True}
Prelude&gt; let xs = [Just 1, Nothing, Just 5]
Prelude&gt; foldMap First xs
First {getFirst = Just 1}
Prelude&gt; foldMap Last xs
Last {getLast = Just 5}
In the above examples, the function being applied is a data
constructor. The data constructor identifies the Monoid instance
‚Äî themappend ‚Äî for those types. It already contains enough
information to allow foldMap to reduce the collection of values
to one summary value.
However, foldMap can also have a function to map that is
diÔ¨Äerent from the Monoid it‚Äôs using:
Prelude&gt; let xs = map Product [1..3]
Prelude&gt; foldMap (*5) xs
Product {getProduct = 750}
-- 5 * 10 * 15
750
Prelude&gt; let xs = map Sum [1..3]
Prelude&gt; foldMap (*5) xs
Sum {getSum = 30}</p>
<p>CHAPTER 20. FOLDABLE 1267
-- 5 + 10 + 15
30
It can map the function to each value first and then use the
Monoid instance to reduce them to one value. Compare this to
foldrin which the function has the Monoid instance baked in:
Prelude&gt; foldr (<em>) 5 [1, 2, 3]
-- (1 * (2 * (3 * 5)))
30
In fact, due to the way foldrworks, declaring a Monoid in-
stance that is diÔ¨Äerent from what is implied in the folding
function doesn‚Äôt change the final result:
Prelude&gt; let sumXs = map Sum [2..4]
Prelude&gt; foldr (</em>) 3 sumXs
Sum {getSum = 72}
Prelude&gt; let productXs = map Product [2..4]
Prelude&gt; foldr (*) 3 productXs
Product {getProduct = 72}
However, it is worth pointing out that if what you‚Äôre trying
to fold only contains one value, declaring a Monoid instance
won‚Äôt change the behavior of foldMap either:
Prelude&gt; let fm = foldMap (*5)
Prelude&gt; fm (Just 100) :: Product Integer</p>
<p>CHAPTER 20. FOLDABLE 1268
Product {getProduct = 500}
Prelude&gt; fm (Just 5) :: Sum Integer
Sum {getSum = 25}
With only one value, it doesn‚Äôt need the Monoid instance.
Specifying the Monoid instance is necessary to satisfy the type-
checker, but with only one value, there is nothing to mappend .
It just applies the function. It will use the mempty value from
the declared Monoid instance, though, in cases where what you
are trying to fold is empty:
Prelude&gt; fm Nothing :: Sum Integer
Sum {getSum = 0}
Prelude&gt; fm Nothing :: Product Integer
Product {getProduct = 1}
So, what we‚Äôve seen so far is that Foldable is a way of general-
izing catamorphisms ‚Äî folding ‚Äî to diÔ¨Äerent datatypes, and
at least in some cases, it forces you to think about the monoid
you‚Äôre using to combine values.
20.4 Demonstrating Foldable instances
As we said above, a minimal Foldable instance must have either
foldrorfoldMap . Any of the other functions in this typeclass
can be derived from one or the other of those. With that said,</p>
<p>CHAPTER 20. FOLDABLE 1269
let‚Äôs turn our attention to implementing Foldable instances for
diÔ¨Äerent types.
Identity
We‚Äôll kick things oÔ¨Ä by writing a Foldable instance for Identity :
dataIdentity a=
Identity a
We‚Äôre only obligated to write foldrorfoldMap , but we‚Äôll write
both plus foldlso you have the gist of it.
instance Foldable Identity where
foldr f z ( Identity x)=f x z
foldl f z ( Identity x)=f z x
foldMap f ( Identity x)=f x
Withfoldrandfoldl, we‚Äôre doing basically the same thing,
but with the arguments swapped. We didn‚Äôt need to do any-
thing special for foldMap .
It may seem strange to think of folding one value. When
we‚Äôve talked about catamorphisms previously, we‚Äôve focused
on how they can reduce a bunch of values down to one sum-
mary value. In the case of this Identity catamorphism, though,</p>
<p>CHAPTER 20. FOLDABLE 1270
the point is less to reduce the values inside the structure to
one value and more to consume, or use, the value:
Prelude&gt; foldr (<em>) 1 (Identity 5)
5
Prelude&gt; foldl (</em>) 5 (Identity 5)
25
Prelude&gt; let fm = foldMap (*5)
Prelude&gt; type PI = Product Integer
Prelude&gt; fm (Identity 100) :: PI
Product {getProduct = 500}
Maybe
Thisoneisalittlemoreinterestingbecause, unlikewith Identity ,
we have to account for the Nothing cases. When the Maybevalue
that we‚Äôre folding is Nothing , we need to be able to return some
‚Äúzero‚Äù value, while doing nothing with the folding function
but also disposing of the Maybestructure. For foldrandfoldl,
that zero value is the start value provided:
Prelude&gt; foldr (+) 1 Nothing
1
On the other hand, for foldMap we use the Monoid‚Äôs identity
value as our zero:</p>
<p>CHAPTER 20. FOLDABLE 1271
Prelude&gt; let fm = foldMap (+1)
Prelude&gt; fm Nothing :: Sum Integer
Sum {getSum = 0}
When the value is a Justvalue, though, we need to apply
the folding function to the value and, again, dispose of the
structure:
Prelude&gt; foldr (+) 1 (Just 3)
4
Prelude&gt; fm $ Just 3 :: Sum Integer
Sum {getSum = 4}
So, let‚Äôs look at the instance. We‚Äôll use a fake Maybetype
again, to avoid conflict with the Maybe instance that already
exists:
instance Foldable Optional where
foldr_zNada=z
foldr f z ( Yepx)=f x z
foldl_zNada=z
foldl f z ( Yepx)=f z x
foldMap _Nada=mempty
foldMap f ( Yepa)=f a</p>
<p>CHAPTER 20. FOLDABLE 1272
Note that if you don‚Äôt tell it what Monoid you mean, it will
complain about the type being ambiguous:
Prelude&gt; foldMap (+1) Nada
No instance for (Num a0) arising
from a use of ‚Äòit‚Äô
The type variable ‚Äòa0‚Äô is ambiguous
(... blah blah who cares ...)
So, we need to assert a type that has a Monoid for this to work:
Prelude&gt; import Data.Monoid
Prelude&gt; foldMap (+1) Nada :: Sum Int
Sum {getSum = 0}
Prelude&gt; foldMap (+1) Nada :: Product Int
Product {getProduct = 1}
Prelude&gt; foldMap (+1) (Just 1) :: Sum Int
Sum {getSum = 2}
With aNadavalue and a declared type of Sum Int (giving us
ourMonoid ),foldMap gave us Sum 0because that was the mempty or
identity for Sum. Similarly with NadaandProduct , we got Product
1because that was the identity for Product .</p>
<p>CHAPTER 20. FOLDABLE 1273
20.5 Some basic derived operations
TheFoldable typeclass includes some other operations that
we haven‚Äôt covered in this context yet. Some of these, such
aslength, were previously defined for use with lists, but their
types have been generalized now to make them useful with
other types of data structures. Below are descriptions, type
signatures, and examples for several of these:
-- | List of elements of a structure,
-- from left to right.
toList::t a-&gt;[a]
Prelude&gt; toList (Just 1)
[1]
Prelude&gt; let xs = [Just 1, Just 2, Just 3]
Prelude&gt; map toList xs
[[1],[2],[3]]
Prelude&gt; concatMap toList xs
[1,2,3]
Prelude&gt; let xs = [Just 1, Just 2, Nothing]
Prelude&gt; concatMap toList xs
[1,2]
Prelude&gt; toList (1, 2)
[2]</p>
<p>CHAPTER 20. FOLDABLE 1274
Why doesn‚Äôt it put the 1 in the list? For the same reason that
fmapdoesn‚Äôt apply a function to the 1.
-- | Test whether the structure is empty.
null::t a-&gt;Bool
Notice that nullreturns TrueonLeftandNothing values, just
as it does on empty lists and so forth:
Prelude&gt; null (Left 3)
True
Prelude&gt; null []
True
Prelude&gt; null Nothing
True
Prelude&gt; null (1, 2)
False
Prelude&gt; let xs = [Just 1, Just 2, Nothing]
Prelude&gt; fmap null xs
[False,False,True]
The next one, length , returns a count of how many ùëévalues
inhabit the t a. In a list, that could be multiple ùëévalues due to
the definition of that datatype. It‚Äôs important to note, though,
that for tuples, the first argument (as well as the leftmost, or
outermost, type arguments of datatypes such as Maybeand
Either ) is part of the ùë°here, not part of the ùëé.</p>
<p>CHAPTER 20. FOLDABLE 1275
-- | Returns the size/length of a finite
-- structure as an 'Int'.
length::t a-&gt;Int
Prelude&gt; length (1, 2)
1
Prelude&gt; let xs = [(1, 2), (3, 4), (5, 6)]
Prelude&gt; length xs
3
Prelude&gt; fmap length xs
[1,1,1]
Prelude&gt; fmap length Just [1, 2, 3]
1
The last example looks strange, we know. But if you run
it in your REPL, you‚Äôll see it returns the result we promised.
Why? And why does this
Prelude&gt; length $ Just [1, 2, 3]
1
return the same result?
TheùëéofJust a in the last case above is a list. There is only
one list.</p>
<p>CHAPTER 20. FOLDABLE 1276
Prelude&gt; let xs = [Just 1, Just 2, Just 3]
Prelude&gt; fmap length xs
[1,1,1]
Prelude&gt; let xs = [Just 1, Just 2, Nothing]
Prelude&gt; fmap length xs
[1,1,0]
-- | Does the element occur
-- in the structure?
elem::Eqa=&gt;a-&gt;t a-&gt;Bool
We‚Äôve used Either in the following example set to demon-
strate the behavior of Foldable functions with Leftvalues. As
we saw with Functor , you can‚Äôt map over the left data construc-
tor, because the left type argument is part of the structure. In
the following example set, that means that elemcan‚Äôt see inside
theLeftconstructor to whatever the value is, so the result will
beFalse, even if the value matches:
Prelude&gt; elem 2 (Just 3)
False
Prelude&gt; elem True (Left False)
False
Prelude&gt; elem True (Left True)
False
Prelude&gt; elem True (Right False)
False</p>
<p>CHAPTER 20. FOLDABLE 1277
Prelude&gt; elem True (Right True)
True
Prelude&gt; let xs = [Right 1,Right 2,Right 3]
Prelude&gt; fmap (elem 3) xs
[False,False,True]
-- | The largest element
-- of a non-empty structure.
maximum ::Orda=&gt;t a-&gt;a
-- | The least element
-- of a non-empty structure.
minimum ::Orda=&gt;t a-&gt;a
Here, notice that LeftandNothing (and similar) values are
empty for the purposes of these functions:
Prelude&gt; maximum [10, 12, 33, 5]
33
Prelude&gt; let xs = [Just 2, Just 10, Just 4]
Prelude&gt; fmap maximum xs
[2,10,4]
Prelude&gt; fmap maximum (Just [3, 7, 10, 2])
Just 10</p>
<p>CHAPTER 20. FOLDABLE 1278
Prelude&gt; minimum &quot;julie&quot;
'e'
Prelude&gt; fmap minimum (Just &quot;julie&quot;)
Just 'e'
Prelude&gt; let xs = map Just &quot;jul&quot;
Prelude&gt; xs
[Just 'j',Just 'u',Just 'l']
Prelude&gt; fmap minimum xs
&quot;jul&quot;
Prelude&gt; let xs = [Just 4, Just 3, Nothing]
Prelude&gt; fmap minimum xs
[4,3,*** Exception:
minimum: empty structure
Prelude&gt; minimum (Left 3)
*** Exception: minimum: empty structure
We‚Äôve seen sumandproduct before, and they do what their
names suggest: return the sum and product of the members
of a structure:
sum::(Foldable t,Numa)=&gt;t a-&gt;a
product ::(Foldable t,Numa)=&gt;t a-&gt;a
And now for some examples:</p>
<p>CHAPTER 20. FOLDABLE 1279
Prelude&gt; sum (7, 5)
5
Prelude&gt; fmap sum [(7, 5), (3, 4)]
[5,4]
Prelude&gt; fmap sum (Just [1, 2, 3, 4, 5])
Just 15
Prelude&gt; product Nothing
1
Prelude&gt; fmap product (Just [])
Just 1
Prelude&gt; fmap product (Right [1, 2, 3])
Right 6
Exercises: Library Functions
Implement the functions in terms of foldMap orfoldrfrom
Foldable , then try them out with multiple types that have
Foldable instances.
1.This and the next one are nicer with foldMap , butfoldris
fine too.
sum::(Foldable t,Numa)=&gt;t a-&gt;a
2.product ::(Foldable t,Numa)=&gt;t a-&gt;a
3.elem::(Foldable t,Eqa)
=&gt;a-&gt;t a-&gt;Bool</p>
<p>CHAPTER 20. FOLDABLE 1280
4.minimum ::(Foldable t,Orda)
=&gt;t a-&gt;Maybea
5.maximum ::(Foldable t,Orda)
=&gt;t a-&gt;Maybea
6.null::(Foldable t)=&gt;t a-&gt;Bool
7.length::(Foldable t)=&gt;t a-&gt;Int
8.Some say this is all Foldable amounts to.
toList::(Foldable t)=&gt;t a-&gt;[a]
9.Hint: use foldMap .
-- | Combine the elements
-- of a structure using a monoid.
fold::(Foldable t,Monoidm)=&gt;t m-&gt;m
10.DefinefoldMap in terms of foldr.
foldMap ::(Foldable t,Monoidm)
=&gt;(a-&gt;m)-&gt;t a-&gt;m
20.6 Chapter Exercises
WriteFoldable instances for the following datatypes.</p>
<p>CHAPTER 20. FOLDABLE 1281
1.dataConstant a b=
Constant b
2.dataTwoa b=
Twoa b
3.dataThreea b c=
Threea b c
4.dataThree'a b=
Three'a b b
5.dataFour'a b=
Four'a b b b
Thinking cap time. Write a filter function for Foldable types
usingfoldMap .
filterF ::(Applicative f
,Foldable t
,Monoid(f a))
=&gt;(a-&gt;Bool)-&gt;t a-&gt;f a
filterF =undefined
20.7 Follow-up resources
1.Jakub Arnold; Foldable and Traversable.</p>
<p>Chapter 21
Traversable
O, Thou hast damnable
iteration; and art, indeed,
able to corrupt a saint.
Shakespeare
1282</p>
<p>CHAPTER 21. TRAVERSABLE 1283
21.1 Traversable
Functor gives us a way to transform any values embedded in
structure. Applicative gives us a way to transform any val-
ues contained within a structure using a function that is also
embedded in structure. This means that each application pro-
duces the eÔ¨Äect of adding structure which is then applicatively
combined. Foldable gives us a way to process values embedded
in a structure as if they existed in a sequential order, as we‚Äôve
seen ever since we learned about list folding.
Traversable was introduced in the same paper as Applicative
and its introduction to Prelude didn‚Äôt come until the release
of GHC 7.10. However, it was available as part of the base
library before that. Traversable depends on Applicative , and
thusFunctor , and is also superclassed by Foldable .
Traversable allows you to transform elements inside the
structure like a functor, producing applicative eÔ¨Äects along the
way, and lift those potentially multiple instances of applicative
structure outside of the traversable structure. It is commonly
described as a way to traverse a data structure, mapping a
function inside a structure while accumulating the applicative
contexts along the way. This is easiest to see, perhaps, through
liberal demonstration of examples, so let‚Äôs get to it.
In this chapter, we will:
‚Ä¢explain the Traversable typeclass and its canonical func-</p>
<p>CHAPTER 21. TRAVERSABLE 1284
tions;
‚Ä¢explore examples of Traversable in practical use;
‚Ä¢tidy up some code using this typeclass;
‚Ä¢and, of course, write some Traversable instances.
21.2 The Traversable typeclass definition
This is the typeclass definition as it appears in the library
Data.Traversable :
class(Functor t,Foldable t)
=&gt;Traversable twhere
traverse ::Applicative f=&gt;
(a-&gt;f b)
-&gt;t a
-&gt;f (t b)
traverse f =sequenceA .fmap f
traverse maps each element of a structure to an action, eval-
uates the actions from left to right, and collects the results. So,
for example, if you have a list (structure) of IOactions, at the
end you‚Äôd have</p>
<p>CHAPTER 21. TRAVERSABLE 1285
-- | Evaluate each action in the
-- structure from left to right,
-- and collect the results.
sequenceA ::Applicative f
=&gt;t (f a) -&gt;f (t a)
sequenceA =traverse id
{-# MINIMAL traverse | sequenceA #-}
A minimal instance for this typeclass provides an imple-
mentation of either traverse orsequenceA , because as you can
see they can be defined in terms of each other. As with Foldable ,
we can define more than the bare minimum if we can leverage
information specific to our datatype to make the behavior
more efficient. We‚Äôre going to focus on these two functions in
this chapter, though, as those are the most typically useful.
21.3sequenceA
We will start with some examples of sequenceA in action, as it is
the simpler of the two. You can see from the type signature
above that the eÔ¨Äect of sequenceA is flipping two contexts or
structures. It doesn‚Äôt by itself allow you to apply any function
to theùëévalue inside the structure; it only flips the layers of
structure around. Compare these:
Prelude&gt; sum [1, 2, 3]</p>
<p>CHAPTER 21. TRAVERSABLE 1286
6
Prelude&gt; fmap sum [Just 1, Just 2, Just 3]
[1,2,3]
Prelude&gt; (fmap . fmap) sum Just [1, 2, 3]
Just 6
Prelude&gt; fmap product [Just 1, Just 2, Nothing]
[1,2,1]
To these:
Prelude&gt; fmap Just [1, 2, 3]
[Just 1,Just 2,Just 3]
Prelude&gt; sequenceA $ fmap Just [1, 2, 3]
Just [1,2,3]
Prelude&gt; sequenceA [Just 1, Just 2, Just 3]
Just [1,2,3]
Prelude&gt; sequenceA [Just 1, Just 2, Nothing]
Nothing
Prelude&gt; fmap sum $ sequenceA [Just 1, Just 2, Just 3]
Just 6
Prelude&gt; let xs = [Just 3, Just 4, Nothing]
Prelude&gt; fmap product (sequenceA xs)
Nothing
In the first example, using sequenceA flips the structures
around ‚Äî instead of a list of Maybevalues, you get a Maybeof a
list value. In the next two examples, we can lift a function over</p>
<p>CHAPTER 21. TRAVERSABLE 1287
theMaybestructure and apply it to the list that is inside, if we
have aJust a value after applying the sequenceA .
It‚Äôs worth mentioning here that the Data.Maybe module has a
function called catMaybes that oÔ¨Äers a diÔ¨Äerent way of handling
a list of Maybevalues:
Prelude&gt; import Data.Maybe
Prelude&gt; catMaybes [Just 1, Just 2, Just 3]
[1,2,3]
Prelude&gt; catMaybes [Just 1, Just 2, Nothing]
[1,2]
Prelude&gt; let xs = [Just 1, Just 2, Just 3, Nothing]
Prelude&gt; sum $ catMaybes xs
6
Prelude&gt; fmap sum $ sequenceA xs
Nothing
UsingcatMaybes allows you to sum (or otherwise process) the
list ofMaybevalues even if there‚Äôs potentially a Nothing value
lurking within.
21.4traverse
Let‚Äôs look next at the type of traverse :</p>
<p>CHAPTER 21. TRAVERSABLE 1288
traverse
::(Applicative f,Traversable t)
=&gt;(a-&gt;f b)-&gt;t a-&gt;f (t b)
You might notice a similarity between that and the types of
fmapand(=&lt;&lt;)(flip bind):
fmap ::(a-&gt;b)-&gt;f a-&gt;f b
(=&lt;&lt;)::(a-&gt;m b)-&gt;m a-&gt;m b
traverse ::(a-&gt;f b)-&gt;t a-&gt;f (t b)
We‚Äôre still mapping a function over some embedded value(s), like
fmap, but similar to flip bind, that function is itself generating
more structure. However, unlike flip bind, that structure can
be of a diÔ¨Äerent type than the structure we lifted over to apply
the function. And at the end, it will flip the two structures
around, as sequenceA did.
In fact, as we saw in the typeclass definition, traverse isfmap
composed with sequenceA :
traverse f=sequenceA .fmap f
Let‚Äôs look at how that works in practice:
Prelude&gt; fmap Just [1, 2, 3]
[Just 1,Just 2,Just 3]
Prelude&gt; sequenceA $ fmap Just [1, 2, 3]</p>
<p>CHAPTER 21. TRAVERSABLE 1289
Just [1,2,3]
Prelude&gt; sequenceA . fmap Just $ [1, 2, 3]
Just [1,2,3]
Prelude&gt; traverse Just [1, 2, 3]
Just [1,2,3]
We‚Äôll run through some longer examples in a moment, but
the general idea is that anytime you‚Äôre using sequenceA . fmap
f, you can use traverse to achieve the same result in one step.
mapMistraverse
YoumayhaveseenaslightlydiÔ¨Äerentwayofexpressing traverse
before, in the form of mapM.
In versions of GHC prior to 7.10, the type of mapMwas the
following:
mapM::Monadm
=&gt;(a-&gt;m b)-&gt;[a]-&gt;m [b]
-- contrast with
traverse ::Applicative f
=&gt;(a-&gt;f b)-&gt;t a-&gt;f (t b)
We can think of traverse inTraversable as abstracting the []
inmapMto being any traversable data structure and generalizing</p>
<p>CHAPTER 21. TRAVERSABLE 1290
theMonadrequirement to only need an Applicative . This is
valuable as it means we can use this pattern more widely and
with more code. For example, the list datatype is fine for
small pluralities of values but in more performance-sensitive
code, you may want to use a Vector from the vector1library.
Withtraverse , you won‚Äôt have to change your code because
the primary Vector datatype has a Traversable instance and so
should work.
Similarly, the type for sequence in GHC versions prior to
7.10 is a less useful sequenceA :
sequence ::Monadm
=&gt;[m a]
-&gt;m [a]
-- contrast with
sequenceA ::(Applicative f,Traversable t)
=&gt;t (f a)
-&gt;f (t a)
Again we‚Äôre generalizing the list to any Traversable and weak-
ening the Monadrequirement to Applicative .
1http://hackage.haskell.org/package/vector</p>
<p>CHAPTER 21. TRAVERSABLE 1291
21.5 So, what‚Äôs Traversable for?
In a literal sense, anytime you need to flip two type construc-
tors around, or map something and then flip them around,
that‚Äôs probably Traversable :
sequenceA ::Applicative f
=&gt;t (f a) -&gt;f (t a)
traverse ::Applicative f
=&gt;(a-&gt;f b)-&gt;t a-&gt;f (t b)
We‚Äôll kick around some hypothetical functions and values
without bothering to implement them in the REPL to see when
we may want traverse orsequenceA :
Prelude&gt; let f = undefined :: a -&gt; Maybe b
Prelude&gt; let xs = undefined :: [a]
Prelude&gt; :t map f xs
map f xs :: [Maybe b]
But what if we want a value of type Maybe [b] ? The following
will work, but we can do better:
Prelude&gt; :t sequenceA $ map f xs
sequenceA $ map f xs :: Maybe [a]</p>
<p>CHAPTER 21. TRAVERSABLE 1292
It‚Äôs usually better to use traverse whenever we see a sequence
orsequenceA combined with a maporfmap:
Prelude&gt; :t traverse f xs
traverse f xs :: Maybe [b]
Next we‚Äôll start looking at real examples of when you‚Äôd want
to do this.
21.6 Morse code revisited
We‚Äôre going to call back to what we did in the Testing chapter
with the Morse code to look at a nice example of how to use
traverse . Let‚Äôs recall what we had done there:
stringToMorse ::String-&gt;Maybe[Morse]
stringToMorse s=
sequence $fmap charToMorse s
-- what we want to do:
stringToMorse ::String-&gt;Maybe[Morse]
stringToMorse =traverse charToMorse
Normally, you might expect that if you mapped an (a -&gt;
f b)over at a, you‚Äôd end up with t (f b) buttraverse flips
that around. Remember, we had each character conversion
wrapped in a Maybedue to the possibility of getting characters in</p>
<p>CHAPTER 21. TRAVERSABLE 1293
a string that aren‚Äôt translatable into Morse (or, in the opposite
conversion, aren‚Äôt Morse characters):
Prelude&gt; morseToChar &quot;gobbledegook&quot;
Nothing
Prelude&gt; morseToChar &quot;-.-.&quot;
Just 'c'
We can use fromMaybe to remove the Maybelayer:
Prelude&gt; import Data.Maybe
Prelude Data.Maybe&gt; fromMaybe ' ' (morseToChar &quot;-.-.&quot;)
'c'
Prelude&gt; stringToMorse &quot;chris&quot;
Just [&quot;-.-.&quot;,&quot;....&quot;,&quot;.-.&quot;,&quot;..&quot;,&quot;...&quot;]
Prelude&gt; import Data.Maybe
Prelude&gt; fromMaybe [] (stringToMorse &quot;chris&quot;)
[&quot;-.-.&quot;,&quot;....&quot;,&quot;.-.&quot;,&quot;..&quot;,&quot;...&quot;]
We‚Äôll define a little helper for use in the following examples:
Prelude&gt; let morse s = fromMaybe [] (stringToMorse s)
Prelude&gt; :t morse
morse :: String -&gt; [Morse]
Now, if we fmap morseToChar , we get a list of Maybevalues:</p>
<p>CHAPTER 21. TRAVERSABLE 1294
Prelude&gt; fmap morseToChar (morse &quot;chris&quot;)
[Just 'c',Just 'h',Just 'r',Just 'i',Just 's']
We don‚Äôt want catMaybes here because it drops the Nothing
values. What we want here is for any Nothing values to make the
final result Nothing . The function that gives us what we want for
this issequence . We did use sequence in the original version of
thestringToMorse function. sequence is useful for flipping your
types around as well (note the positions of the ùë°andùëö). There
is asequence inPrelude and another, more generic, version in
Data.Traversable :
Prelude&gt; :t sequence
sequence :: (Monad m, Traversable t) =&gt;
t (m a) -&gt; m (t a)
-- more general, can be used with types
-- other than List
Prelude&gt; import Data.Traversable as T
Prelude T&gt; :t T.sequence
T.sequence :: (Traversable t, Monad m)
=&gt; t (m a) -&gt; m (t a)
To use this over a list of Maybe(or other monadic) values, we
need to compose it with fmap:
Prelude&gt; :t (sequence .) . fmap</p>
<p>CHAPTER 21. TRAVERSABLE 1295
(sequence .) . fmap
:: (Monad m, Traversable t) =&gt;
(a1 -&gt; m a) -&gt; t a1 -&gt; m (t a)
Prelude&gt; sequence $ fmap morseToChar (morse &quot;chris&quot;)
Just &quot;chris&quot;
Prelude&gt; sequence $ fmap morseToChar (morse &quot;julie&quot;)
Just &quot;julie&quot;
The weird looking composition, which you‚Äôve possibly also
seen in the form of (join .) . fmap is because fmaptakes two
(not one) arguments, so the expressions aren‚Äôt proper unless
we compose twice to await a second argument for fmapto get
applied to.
-- we want this
(sequence .).fmap=
\f xs-&gt;sequence (fmap f xs)
-- not this
sequence .fmap=
\f-&gt;sequence (fmap f)
This composition of sequence andfmapis so common that
traverse is now a standard Prelude function. Compare the
above to the following:</p>
<p>CHAPTER 21. TRAVERSABLE 1296
*Morse T&gt; traverse morseToChar (morse &quot;chris&quot;)
Just &quot;chris&quot;
*Morse T&gt; traverse morseToChar (morse &quot;julie&quot;)
Just &quot;julie&quot;
So,traverse isjustfmapandthe Traversable versionof sequence
bolted together into one convenient function. sequence is the
unique bit, but you need to do the fmapfirst most of the time,
so you end up using traverse . This is very similar to the way
&gt;&gt;=is justjoincomposed with fmapwherejoinis the bit that is
unique to Monad.
21.7 Axing tedious code
Try to bear with us for a moment and realize that the following
is real but also intentionally fake code. That is, one of the
authors helped somebody with refactoring their code, and
this simplified version is what your author was given. One of
the strengths of Haskell is that we can work in terms of types
without worry about code that actually runs sometimes. This
code is from Alex Petrov:</p>
<p>CHAPTER 21. TRAVERSABLE 1297
-- Thanks for the great example, Alex
dataQuery =Query
dataSomeObj =SomeObj
dataIoOnlyObj =IoOnlyObj
dataErr =Err
-- There's a decoder function that makes
-- some object from String
decodeFn ::String-&gt;EitherErrSomeObj
decodeFn =undefined
-- There's a query, that runs against the
-- DB and returns array of strings
fetchFn ::Query-&gt;IO[String]
fetchFn =undefined
-- an additional &quot;context initializer&quot;,
-- that also has IO
makeIoOnlyObj ::[SomeObj]
-&gt;IO[(SomeObj,IoOnlyObj )]
makeIoOnlyObj =undefined</p>
<p>CHAPTER 21. TRAVERSABLE 1298
-- before
pipelineFn
::Query
-&gt;IO(EitherErr[(SomeObj,IoOnlyObj )])
pipelineFn query= do
a&lt;-fetchFn query
casesequence (map decodeFn a) of
(Lefterr)-&gt;return$Left$err
(Rightres)-&gt; do
a&lt;-makeIoOnlyObj res
return$Righta
The objective was to clean up this code. A few things made
them suspicious:
1.The use of sequence andmap.
2.Manually casing on the result of the sequence and the map.
3.Binding monadically over the Either only to perform an-
other monadic ( IO) action inside of that.
We pared the pipeline function down to this:</p>
<p>CHAPTER 21. TRAVERSABLE 1299
pipelineFn
::Query
-&gt;IO(EitherErr[(SomeObj,IoOnlyObj )])
pipelineFn query= do
a&lt;-fetchFn query
traverse makeIoOnlyObj (mapM decodeFn a)
Thanks to merijn on the IRC channel for helping with this.
We can make it pointfree if we want to:
pipelineFn
::Query
-&gt;IO(EitherErr[(SomeObj,IoOnlyObj )])
pipelineFn =
(traverse makeIoOnlyObj
.mapM decodeFn =&lt;&lt;).fetchFn
And since mapMis justtraverse with a slightly diÔ¨Äerent type:
pipelineFn
::Query
-&gt;IO(EitherErr[(SomeObj,IoOnlyObj )])
pipelineFn =
(traverse makeIoOnlyObj
.traverse decodeFn =&lt;&lt;).fetchFn</p>
<p>CHAPTER 21. TRAVERSABLE 1300
This is the terse, clean style many Haskellers prefer. As we
said back when we first introduced it, pointfree style can help
focus the attention on the functions, rather than the specifics
of the data that are being passed around as arguments. Using
functions like traverse cleans up code by drawing attention to
the ways the types are changing and signaling the program-
mer‚Äôs intent.
21.8 Do all the things
We‚Äôre going to use an HTTP client library named wreq2for
this demonstration so we can make calls to a handy-dandy
website for testing HTTP clients at http://httpbin.org/ . Feel
free to experiment and substitute your own ideas for HTTP
services or websites you could poke and prod.
2http://hackage.haskell.org/package/wreq</p>
<p>CHAPTER 21. TRAVERSABLE 1301
moduleHttpStuff where
importData.ByteString.Lazy hiding(map)
importNetwork.Wreq
-- replace with other websites
-- if desired or needed
urls::[String]
urls=[&quot;http://httpbin.org/ip&quot;
,&quot;http://httpbin.org/bytes/5&quot;
]
mappingGet ::[IO(Response ByteString )]
mappingGet =map get urls
But what if we don‚Äôt want a list of IOactions we can perform
to get a response, but rather one big IOaction that produces a
list of responses? This is where Traversable can be helpful:
traversedUrls ::IO[Response ByteString ]
traversedUrls =traverse get urls
We hope that these examples have helped demonstrate that
Traversable is a useful typeclass. While Foldable seems trivial,
it is a necessary superclass of Traversable , andTraversable , like</p>
<p>CHAPTER 21. TRAVERSABLE 1302
Functor andMonad, is now widely used in everyday Haskell code,
due to its practicality.
Strength for understanding
Traversable is stronger than Functor andFoldable . Because of
this, we can recover the Functor andFoldable instance for a
type from the Traversable , just as we can recover the Functor
andApplicative from the Monad. Here we can use the Identity
type to get something that is essentially just fmapall over again:
Prelude&gt; import Data.Functor.Identity
Prelude&gt; traverse (Identity . (+1)) [1, 2]
Identity [2,3]
Prelude&gt; runIdentity $ traverse (Identity . (+1)) [1, 2]
[2,3]
Prelude&gt; :{
Prelude| let edgeMap f t =
Prelude| runIdentity $ traverse (Identity . f) t
Prelude| :}
Prelude&gt; :t edgeMap
edgeMap :: Traversable t =&gt; (a -&gt; b) -&gt; t a -&gt; t b
Prelude&gt; edgeMap (+1) [1..5]
[2,3,4,5,6]</p>
<p>CHAPTER 21. TRAVERSABLE 1303
UsingConstorConstant , wecanrecoverafoldMappy-looking
Foldable as well:
Prelude&gt; import Data.Monoid
-- from <code>transformers</code>
Prelude&gt; import Data.Functor.Constant
Prelude&gt; let xs = [1, 2, 3, 4, 5] :: [Sum Integer]
Prelude&gt; traverse (Constant . (+1)) xs
Constant (Sum {getSum = 20})
Prelude&gt; :{
Prelude| let foldMap' f t =
Prelude| getConstant $ traverse (Constant . f) t
Prelude| :}
Prelude&gt; :t foldMap'
foldMap' :: (Traversable t, Monoid a)
=&gt; (a1 -&gt; a) -&gt; t a1 -&gt; a
Prelude&gt; :t foldMap
foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m
Doing exercises like this can help strengthen your intuitions
for the relationships of these typeclasses and their canonical
functions. We know it sometimes feels like these things are
pure intellectual exercise, but getting comfortable with ma-
nipulating functions like these is ultimately the key to getting</p>
<p>CHAPTER 21. TRAVERSABLE 1304
comfortable with Haskell. This is how you learn to play type
Tetris with the pros.
21.9 Traversable instances
You knew this was coming.
Either
TheTraversable instance that follows here is identical to the
one in the Data.Traversable module in base, but we‚Äôve added
aFunctor ,Foldable , andApplicative so that you might see a
progression:</p>
<p>CHAPTER 21. TRAVERSABLE 1305
dataEithera b=
Lefta
|Rightb
deriving (Eq,Ord,Show)
instance Functor (Eithera)where
fmap_(Leftx)=Leftx
fmap f ( Righty)=Right(f y)
instance Applicative (Eithere)where
pure =Right
Lefte&lt;<em>&gt; _ = Lefte
Rightf&lt;</em>&gt;r=fmap f r
instance Foldable (Eithera)where
foldMap <em>(Left</em>)=mempty
foldMap f ( Righty)=f y
foldr_z (Left_)=z
foldr f z ( Righty)=f y z
instance Traversable (Eithera)where
traverse _(Leftx)=pure (Leftx)
traverse f ( Righty)=Right&lt;$&gt;f y</p>
<p>CHAPTER 21. TRAVERSABLE 1306
Given what you‚Äôve seen above, this hopefully isn‚Äôt too sur-
prising. We have function application and type-flipping, in an
Either context.
Tuple
As above, we‚Äôve provided a progression of instances, but for
the two-tuple or anonymous product:
instance Functor ((,) a) where
fmap f (x,y) =(x, f y)
instance Monoida
=&gt;Applicative ((,) a) where
pure x=(mempty, x)
(u, f)&lt;*&gt;(v, x)=
(u <code>mappend</code> v, f x)
instance Foldable ((,) a) where
foldMap f ( _, y)=f y
foldr f z ( _, y)=f y z
instance Traversable ((,) a) where
traverse f (x, y) =(,) x&lt;$&gt;f y
Here, we have much the same, but for a tuple context.</p>
<p>CHAPTER 21. TRAVERSABLE 1307
21.10Traversable Laws
Thetraverse function must satisfy the following laws:
1.Naturality
t.traverse f =traverse (t .f)
This law tells us that function composition behaves in
unsurprising ways with respect to a traversed function.
Since a traversed function ùëìis generating the structure
that appears on the ‚Äúoutside‚Äù of the traverse operation,
there‚Äôs no reason we shouldn‚Äôt be able to float a function
over the structure into the traversal itself.
2.Identity
traverse Identity =Identity
This law says that traversing the data constructor of the
Identity type over a value will produce the same result
as just putting the value in Identity . This tells us Identity
represents a structural identity for traversing data. This is
another way of saying that a Traversable instance cannot
add or inject any structure or eÔ¨Äects.
3.Composition
traverse (Compose .fmap g.f)=
Compose .fmap (traverse g) .traverse f</p>
<p>CHAPTER 21. TRAVERSABLE 1308
This law demonstrates how we can collapse sequential
traversals into a single traversal, by taking advantage of
theCompose datatype, which combines structure.
ThesequenceA function must satisfy the following laws:
1.Naturality
t.sequenceA =sequenceA .fmap t
2.Identity
sequenceA .fmapIdentity =Identity
3.Composition
sequenceA .fmapCompose =
Compose .fmap sequenceA .sequenceA
Noneofthisshould‚Äôvebeentoosurprisinggivenwhatyou‚Äôve
seen with traverse .
21.11 Quality Control
Great news! You can QuickCheck your Traversable instances as
well, since they have laws. Conveniently, the checkers library
we‚Äôve been using already has the laws for us. You can add the
following to a module and change the type alias to change
what instances are being tested:</p>
<p>CHAPTER 21. TRAVERSABLE 1309
typeTI=[]
main= do
lettrigger ::TI(Int,Int, [Int])
trigger =undefined
quickBatch (traversable trigger)
21.12 Chapter Exercises
Traversable instances
Write a Traversable instance for the datatype provided, filling
in any required superclasses. Use QuickCheck to validate your
instances.
Identity
Write a Traversable instance for Identity .
newtype Identity a=Identity a
deriving (Eq,Ord,Show)
instance Traversable Identity where
traverse =undefined</p>
<p>CHAPTER 21. TRAVERSABLE 1310
Constant
newtype Constant a b=
Constant { getConstant ::a }
Maybe
dataOptional a=
Nada
|Yepa
List
dataLista=
Nil
|Consa (Lista)
Three
dataThreea b c=
Threea b c
Pair
dataPaira b=
Paira b</p>
<p>CHAPTER 21. TRAVERSABLE 1311
Big
When you have more than one value of type ùëè, you‚Äôll want
to useMonoid andApplicative for the Foldable andTraversable
instances respectively.
dataBiga b=
Biga b b
Bigger
Same as for Big.
dataBiggera b=
Biggera b b b
S
This may be difficult. To make it easier, we‚Äôll give you the
constraints and QuickCheck instances:
{-# LANGUAGE FlexibleContexts #-}
moduleSkiFree where
importTest.QuickCheck
importTest.QuickCheck.Checkers</p>
<p>CHAPTER 21. TRAVERSABLE 1312
dataSn a=S(n a) a deriving (Eq,Show)
instance (Functor n
,Arbitrary (n a)
,Arbitrary a )
=&gt;Arbitrary (Sn a)where
arbitrary =
S&lt;$&gt;arbitrary &lt;<em>&gt;arbitrary
instance (Applicative n
,Testable (nProperty )
,EqPropa )
=&gt;EqProp(Sn a)where
(Sx y)=-=(Sp q)=
(property $(=-=)&lt;$&gt;x&lt;</em>&gt;p)
.&amp;.(y=-=q)
instance Traversable n
=&gt;Traversable (Sn)where
traverse =undefined
main=
sample' (arbitrary ::Gen(S[]Int))</p>
<p>CHAPTER 21. TRAVERSABLE 1313
Instances for Tree
This might be hard. Write the following instances for Tree.
dataTreea=
Empty
|Leafa
|Node(Treea) a (Treea)
deriving (Eq,Show)
instance Functor Treewhere
fmap=undefined
-- foldMap is a bit easier
-- and looks more natural,
-- but you can do foldr too
-- for extra credit.
instance Foldable Treewhere
foldMap =undefined
instance Traversable Treewhere
traverse =undefined
Hints:
1.ForfoldMap , thinkFunctor but with some Monoid thrown in.</p>
<p>CHAPTER 21. TRAVERSABLE 1314
2.Fortraverse , thinkFunctor but with some Functor3thrown
in.
21.13 Follow-up resources
1.Foldable and Traversable; Jakub Arnold.
2.The Essence of the Iterator Pattern; Jeremy Gibbons and
Bruno Oliveira.
3.Applicative Programming with EÔ¨Äects; Conor McBride
and Ross Paterson.
3Not a typo.</p>
<p>Chapter 22
Reader
The tears of the world are
a constant quantity. For
each one who begins to
weep somewhere else
another stops. The same
is true of the laugh.
Samuel Beckett
1315</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1316
22.1 Reader
The last two chapters were focused on some typeclasses that
might still seem strange and difficult to you. The next three
chapters are going to focus on some patterns that might still
seem strange and difficult. Foldable ,Traversable ,Reader,State,
and parser combinators are not strictly necessary to under-
standing and using Haskell. We do have reasons for introduc-
ing them now, but those reasons might not seem clear to you
for a while. If you don‚Äôt quite grasp all of it on the first pass,
that‚Äôs completely fine. Read it through, do your best with the
exercises, come back when you feel like you‚Äôre ready.
Whenwritingapplications, programmersoftenneedtopass
around some information that may be needed intermittently
or universally throughout an entire application. We don‚Äôt want
to simply pass this information as arguments because it would
be present in the type of almost every function. This can make
the code harder to read and harder to maintain. To address
this, we use Reader .
In this chapter, we will:
‚Ä¢examine the Functor ,Applicative , andMonadinstances for
functions;
‚Ä¢learn about the Reader newtype;
‚Ä¢see some examples of using Reader .</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1317
22.2 A new beginning
We‚Äôre going to set this chapter up a bit diÔ¨Äerently from previ-
ous chapters, because we‚Äôre hoping that this will help demon-
strate that what we‚Äôre doing here is not that diÔ¨Äerent from
things you‚Äôve done before. So, we‚Äôre going to start with some
examples. Start a file like this:
importControl.Applicative
boop=(*2)
doop=(+10)
bip::Integer -&gt;Integer
bip=boop.doop
We know that the bipfunction will take one argument be-
cause of the types of boop,doop, and(.). Note that if you do not
specify the types and load it from a file, it will be monomor-
phic by default; if you wish to make bippolymorphic, you
may change its signature but you also need to specify a poly-
morphic type for the two functions it‚Äôs built from. The rest of
the chapter will wait while you verify these things.
When we apply bipto an argument, doopwill be applied to
that argument first, and then the result of that will be passed
as input to boop. So far, nothing new.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1318
We can also write that function composition this way:
bloop::Integer -&gt;Integer
bloop=fmap boop doop
We aren‚Äôt accustomed to fmapping a function over another
function, and you may be wondering what the functorial con-
text here is. By ‚Äúfunctorial context‚Äù we mean the structure
(datatype) that the function is being lifted over in order to
apply to the value inside. For example, a list is a functorial
context we can lift functions over. We say that the function gets
lifted over the structure of the list and applied to or mapped
over the values that are inside the list.
Inbloop, the context is a partially applied function. As in
function composition, fmapcomposes the two functions before
applying them to the argument. The result of the one can then
get passed to the next as input. Using fmaphere lifts the one
partially applied function over the next, in a sense setting up
something like this:
fmapboop doop x ==(*2) ((+10) x)
-- when this x comes along, it's the
-- first necessary argument to (+10)
-- then the result for that is the
-- first necessary argument to (*2)</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1319
This is the Functor of functions. We‚Äôre going to go into more
detail about this soon.
For now, let‚Äôs turn to another set of examples. Put these in
the same file so boopanddoopare still in scope:
bbop::Integer -&gt;Integer
bbop=(+)&lt;$&gt;boop&lt;*&gt;doop
duwop::Integer -&gt;Integer
duwop=liftA2 ( +) boop doop
Now we‚Äôre in an Applicative context. We‚Äôve added another
function to lift over the contexts of our partially applied func-
tions. This time, we still have partially applied functions that
are awaiting application to an argument, but this will work
diÔ¨Äerently than fmapping did. This time, the argument will
get passed to both boopanddoopin parallel, and the results will
be added together.
boopanddoopare each waiting for an input. We can apply
them both at once like this:
Prelude&gt; bbop 3
19
That does something like this:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1320
((+)&lt;$&gt;(<em>2)&lt;</em>&gt;(+10))3
-- First the fmap
(*2)::Numa=&gt;a-&gt;a
(+)::Numa=&gt;a-&gt;a-&gt;a
(+)&lt;$&gt;(*2)::Numa=&gt;a-&gt;a-&gt;a
Mapping a function awaiting two arguments over a function
awaiting one produces a two argument function.
Remember, this is identical to function composition:
(+).(*2)::Numa=&gt;a-&gt;a-&gt;a
With the same result:
Prelude&gt; ((+) . (*2)) 5 3
13
Prelude&gt; ((+) &lt;$&gt; (*2)) 5 3
13
So what‚Äôs happening?</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1321
((+)&lt;$&gt;(*2))53
-- Keeping in mind that this
-- is (.) under the hood
((+).(*2))53
-- f . g = \ x -&gt; f (g x)
((+).(<em>2))==\x-&gt;(+) (2</em>x)
The tricky part here is that even after we apply ùë•, we‚Äôve got
(+)partially applied to the first argument which was doubled
by(*2). There‚Äôs a second argument, and that‚Äôs what will get
added to the first argument that got doubled:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1322
-- The first function to get
-- applied is (<em>2), and the
-- first argument is 5. (<em>2)
-- takes one argument, so we get:
((+).(<em>2))53
(\x-&gt;(+) (2</em>x))53
(\5-&gt;(+) (2</em>5))3
((+)10)3
-- Then it adds 10 and 3
13
Okay, but what about the second bit?
((+)&lt;$&gt;(<em>2)&lt;</em>&gt;(+10))3
-- Wait, what? What happened to the
-- first argument?
((+)&lt;$&gt;(<em>2)&lt;</em>&gt;(+10))::Numb=&gt;b-&gt;b
One of the nice things about Haskell is we can assert a more
concrete type for functions like (&lt;</em>&gt;)and see if the compiler
agrees we‚Äôre putting forth something hypothetically possible.
Let‚Äôs remind ourselves of the type of (&lt;<em>&gt;):
Prelude&gt; :t (&lt;</em>&gt;)</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1323
(&lt;<em>&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
-- in this case, we know f is ((-&gt;) a)
-- so we concretize it thusly
Prelude&gt; :t (&lt;</em>&gt;) :: (a -&gt; a -&gt; b) -&gt; (a -&gt; a) -&gt; (a -&gt; b)
(&lt;<em>&gt;) :: (a -&gt; a -&gt; b) -&gt; (a -&gt; a) -&gt; (a -&gt; b)
The compiler agrees that this is a possible type for (&lt;</em>&gt;).
So how does that work? What‚Äôs happening is we‚Äôre feeding
a single argument to the (<em>2)and(+10)and the two results
form the two arguments to (+):
((+)&lt;$&gt;(<em>2)&lt;</em>&gt;(+10))3
(3</em>2)+(3+10)
6+13
19
We‚Äôd use this when two functions would share the same
input and we want to apply some other function to the result
of those to reach a final result. This happens more than you
might think, and we saw an example of it back in the Abstract
Structure Applied chapter:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1324
moduleWeb.Shipping.Utils ((&lt;||&gt;))where
importControl.Applicative (liftA2)
(&lt;||&gt;)::(a-&gt;Bool)
-&gt;(a-&gt;Bool)
-&gt;a
-&gt;Bool
(&lt;||&gt;)=liftA2 ( ||)
That is the same idea as duwopabove.
Finally, another example:
boopDoop ::Integer -&gt;Integer
boopDoop = do
a&lt;-boop
b&lt;-doop
return (a +b)
This will do precisely the same thing as the Applicative ex-
ample, but this time the context is monadic. This distinction
doesn‚Äôt much matter with this particular function. We assign
the variable ùëéto the partially applied function boop, andùëèto
doop. As soon as we receive an input, it will fill the empty slots
inboopanddoop. The results will be bound to the variables ùëé
andùëèand passed into return .</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1325
So, we‚Äôve seen here that we can have a Functor ,Applicative ,
andMonadfor partially applied functions. In all cases, these
are awaiting application to one argument that will allow both
functions to be evaluated. The Functor of functions is function
composition. The Applicative andMonadchain the argument
forward in addition to the composition (applicatives and mon-
ads are both varieties of functors, so they retain that core
functorial behavior).
This is the idea of Reader. It is a way of stringing functions
together when all those functions are awaiting one input from
a shared environment. We‚Äôre going to get into the details of
how it works, but the important intuition here is that it‚Äôs an-
other way of abstracting out function application and gives us
a way to do computation in terms of an argument that hasn‚Äôt
been supplied yet. We use this most often when we have a con-
stant value that we will obtain from somewhere outside our
program that will be an argument to a whole bunch of func-
tions. Using Reader allows us to avoid passing that argument
around explicitly.
Short Exercise: Warming Up
We‚Äôll be doing something here very similar to what you saw
above, to give you practice and try to develop a feel or intuition
for what is to come. These are similar enough to what you just
saw that you can almost copy and paste, so try not to overthink</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1326
them too much.
First, start a file oÔ¨Ä like this:
importData.Char
cap::[Char]-&gt;[Char]
capxs=map toUpper xs
rev::[Char]-&gt;[Char]
revxs=reverse xs
Two simple functions with the same type, taking the same
type of input. We could compose them, using (.)orfmap:
composed ::[Char]-&gt;[Char]
composed =undefined
fmapped ::[Char]-&gt;[Char]
fmapped =undefined
The output of those two should be identical: one string that
is made all uppercase and reversed, like this:
Prelude&gt; composed &quot;Julie&quot;
&quot;EILUJ&quot;
Prelude&gt; fmapped &quot;Chris&quot;
&quot;SIRHC&quot;</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1327
Now we want to return the results of capandrevboth, as a
tuple, like this:
Prelude&gt; tupled &quot;Julie&quot;
(&quot;JULIE&quot;,&quot;eiluJ&quot;)
-- or
Prelude&gt; tupled' &quot;Julie&quot;
(&quot;eiluJ&quot;,&quot;JULIE&quot;)
We will want to use an Applicative here. The type will look
like this:
tupled::[Char]-&gt;([Char], [Char])
There is no special reason such a function needs to be
monadic, but let‚Äôs do that, too, to get some practice. Do it
one time using dosyntax; then try writing a new version using
(&gt;&gt;=). The types will be the same as the type for tupled .
22.3 This is Reader
As we saw above, functions have Functor ,Applicative , andMonad
instances. Usually when you see or hear the term Reader, it‚Äôll
be referring to the Monadinstance.
We use function composition because it lets us compose two
functions without explicitly having to recognize the argument
that will eventually arrive; the Functor of functions is function</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1328
composition. With the Functor of functions, we are able to map
an ordinary function over another to create a new function
awaiting a final argument. The Applicative andMonadinstances
for the function type give us a way to map a function that is
awaiting an ùëéover another function that is also awaiting an ùëé.
Giving it a name helps us know the what and why of what
we‚Äôre doing: reading an argument from the environment into
functions. It‚Äôll be especially nice for clarity‚Äôs sake later when
we make the ReaderT monad transformer.
Exciting, right? Let‚Äôs back up here and go into more detail
about how Reader works.
22.4 Breaking down the Functor of
functions
If you type :info Functor in your REPL, one of the instances
you might notice is the one for the partially applied type
constructor of functions ((-&gt;) r) :
instance Functor ((-&gt;) r)
This can be a little confusing, so we‚Äôre going to unwind it
until hopefully it‚Äôs a bit more comfortable. First, let‚Äôs see what
we can accomplish with this:
Prelude&gt; fmap (+1) (*2) 3</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1329
7
-- Rearranging a little bit
Prelude&gt; fmap (+1) (*2) $ 3
7
Prelude&gt; (fmap (+1) (*2)) 3
7
This should look familiar:
Prelude&gt; (+1) . (*2) $ 3
7
Prelude&gt; (+2) . (*1) $ 2
4
Prelude&gt; fmap (+2) (*1) $ 2
4
Prelude&gt; (+2) <code>fmap</code> (*1) $ 2
4
Fortunately, there‚Äôs nothing weird going on here. If you
check the implementation of the instance in base, you‚Äôll find
the following:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1330
instance Functor ((-&gt;) r)where
fmap=(.)
Let‚Äôs unravel the types. Remember that (-&gt;)takes two argu-
ments and therefore has kind * -&gt; * -&gt; * . So, we know upfront
that we have to apply one of the type arguments before we
can have a Functor . With the Either Functor , we know that we
will lift over the Either a and if our function will be applied, it
will be applied to the ùëèvalue. With the function type:
data(-&gt;) a b
the same rule applies: you have to lift over the (-&gt;) a and
only transform the ùëèvalue. The ùëéis conventionally called ùëü
forReader in these instances, but a type variable of any other
name smells as sweet. Here, ùëüis the first argument of (a -&gt; b) :</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1331
-- Type constructor of functions
(-&gt;)
-- Fully applied
a-&gt;b
((-&gt;) r)
-- is
r-&gt;
-- so r is the type of the
-- argument to the function
From this, we can determine that ùëü, the argument type for
functions, is part of the structure being lifted over when we lift
over a function, not the value being transformed or mapped
over.
This leaves the result of the function as the value being
transformed. This happens to line up neatly with what func-
tion composition is about:
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
-- or perhaps
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
Now how does this line up with Functor ?</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1332
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
fmap::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
We‚Äôll remove the names of the functions and the typeclass
constraint as we can take them for granted from here on out:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1333
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
::(a-&gt;b)-&gt;f a-&gt;f b
-- Changing up the letters
-- without changing the meaning
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
::(b-&gt;c)-&gt;f b-&gt;f c
-- f is ((-&gt;) a)
::(b-&gt;c)
-&gt; (a-&gt;b)
-&gt; (a-&gt;c)
::(b-&gt;c)
-&gt;((-&gt;) a) b
-&gt;((-&gt;) a) c
-- Unroll the prefix notation into infix
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
Bada bing. Functorial lifting for functions.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1334
22.5 But uh, Reader?
Ah yes, right. Reader is a newtype wrapper for the function
type:
newtype Readerr a=
Reader{ runReader ::r-&gt;a }
Theùëüis the type we‚Äôre reading in and ùëéis the result type of
our function.
TheReader newtype has a handy runReader accessor to get
the function out of Reader. Let us prove for ourselves that
this is the same thing, but with a touch of data constructor
jiggery-pokery mixed in. What does the Functor for this look
like compared to function composition?</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1335
instance Functor (Readerr)where
fmap::(a-&gt;b)
-&gt;Readerr a
-&gt;Readerr b
fmap f ( Readerra)=
Reader$\r-&gt;f (ra r)
-- same as (.)
compose ::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
compose f g=\x-&gt;f (g x)
-- see it?
\r-&gt;f (ra r)
\x-&gt;f (g x)
Basically the same thing right? In the Reader functor, rahas
the type r -&gt; a, andfhas the type a -&gt; b. Applying rato the
valueryields a value of type a, which fis then applied to,
yielding a value of type b. Function composition!
We can use the fact that we recognize this as function com-
position to make a slightly diÔ¨Äerent instance for Reader :</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1336
instance Functor (Readerr)where
fmap::(a-&gt;b)
-&gt;Readerr a
-&gt;Readerr b
fmap f ( Readerra)=
Reader$(f.ra)
So what we‚Äôre doing here is basically:
1.Unpack r -&gt; a out ofReader
2.Compose ùëìwith the function we unpacked out of Reader .
3.Put the new function made from the composition back
intoReader .
Without the Reader newtype, we drop steps 1 and 3 and have
function composition.
Exercise: Ask
Implement the following function. If you get stuck, remem-
ber it‚Äôs less complicated than it looks. Write down what you
know. What do you know about the type ùëé? What does the
type simplify to? How many inhabitants does that type have?
You‚Äôve seen the type before.
ask::Readera a
ask=Reader???</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1337
22.6 Functions have an Applicative too
We‚Äôve seen a couple of examples already of the Applicative of
functions and how it works. Now we‚Äôll get into the details.
The first thing we want to do is notice how the types spe-
cialize:
-- Applicative f =&gt;
-- f ~ (-&gt;) r
pure::a-&gt;f a
pure::a-&gt;(r-&gt;a)
(&lt;<em>&gt;)::f (a-&gt;b)
-&gt;f a
-&gt;f b
(&lt;</em>&gt;)::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
As we saw in the Functor instance, the ùëüofReader is part of
theùëìstructure. We have two arguments in this function, and
both of them are functions waiting for the ùëüinput. When that
comes, both functions will be applied to return a final result
ofùëè.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1338
Demonstrating the function Applicative
This example is similar to other demonstrations we‚Äôve done
previously in the book, but this time we‚Äôll be aiming to show
you what specific use the Applicative of functions typically has.
We start with some newtypes for tracking our diÔ¨Äerent String
values:
newtype HumanName =
HumanName String
deriving (Eq,Show)
newtype DogName =
DogName String
deriving (Eq,Show)
newtype Address =
Address String
deriving (Eq,Show)
We do this so that our types are more self-explanatory, to
express intent, and so we don‚Äôt accidentally mix up our inputs.
A type like this:
String-&gt;String-&gt;String
is difficult when:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1339
1.They aren‚Äôt strictly any string value.
2.They aren‚Äôt processed in an identical fashion. You don‚Äôt
handle addresses the same as names.
So make the diÔ¨Äerence explicit.
We‚Äôll make two record types:
dataPerson=
Person{
humanName ::HumanName
, dogName ::DogName
, address ::Address
}deriving (Eq,Show)
dataDog=
Dog{
dogsName ::DogName
, dogsAddress ::Address
}deriving (Eq,Show)
The following are sample data to use. You can modify them
as you‚Äôd like:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1340
pers::Person
pers=
Person(HumanName &quot;Big Bird&quot; )
(DogName &quot;Barkley&quot; )
(Address &quot;Sesame Street&quot; )
chris::Person
chris=Person(HumanName &quot;Chris Allen&quot; )
(DogName &quot;Papu&quot;)
(Address &quot;Austin&quot; )
And here is how we‚Äôd write it with and without Reader :
-- without Reader
getDog::Person-&gt;Dog
getDogp=
Dog(dogName p) (address p)
-- with Reader
getDogR ::Person-&gt;Dog
getDogR =
Dog&lt;$&gt;dogName &lt;*&gt;address
Can‚Äôt see the Reader ? What if we concrete the types a bit?</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1341
(&lt;$-&gt;&gt;)::(a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
(&lt;$-&gt;&gt;)=(&lt;$&gt;)
(&lt;<em>-&gt;&gt;)::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
(&lt;</em>-&gt;&gt;)=(&lt;<em>&gt;)
-- with Reader
getDogR' ::Person-&gt;Dog
getDogR' =
Dog&lt;$-&gt;&gt;dogName &lt;</em>-&gt;&gt;address
What we‚Äôre trying to highlight here is that Reader is not
alwaysReader , sometimes it‚Äôs the ambient Applicative orMonad
associated with the partially applied function type, here that
isr -&gt;.
The pattern of using Applicative in this manner is common,
so there‚Äôs an alternate way to do this using liftA2 :</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1342
importControl.Applicative (liftA2)
-- with Reader, alternate
getDogR' ::Person-&gt;Dog
getDogR' =
liftA2DogdogName address
Here‚Äôs the type of liftA2.
liftA2::Applicative f=&gt;
(a-&gt;b-&gt;c)
-&gt;f a-&gt;f b-&gt;f c
Again, we‚Äôre waiting for an input from elsewhere. Rather
than having to thread the argument through our functions,
we elide it and let the types manage it for us.
Exercise: Reading Comprehension
1.WriteliftA2 yourself. Think about it in terms of abstract-
ing out the diÔ¨Äerence between getDogR andgetDogR' if that
helps.
myLiftA2 ::Applicative f=&gt;
(a-&gt;b-&gt;c)
-&gt;f a-&gt;f b-&gt;f c
myLiftA2 =undefined</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1343
2.Write the following function. Again, it is simpler than it
looks.
asks::(r-&gt;a)-&gt;Readerr a
asksf=Reader???
3.Implement the Applicative forReader .
To write the Applicative instance for Reader, we‚Äôll use an
extension called InstanceSigs . It‚Äôs an extension we need
in order to assert a type for the typeclass methods. You
ordinarily cannot assert type signatures in instances. The
compiler already knows the type of the functions, so it‚Äôs
not usually necessary to assert the types in instances any-
way. We did this for the sake of clarity, to make the Reader
type explicit in our signatures.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1344
-- you'll need this pragma
{-# LANGUAGE InstanceSigs #-}
instance Applicative (Readerr)where
pure::a-&gt;Readerr a
pure a=Reader$ ???
(&lt;<em>&gt;)::Readerr (a-&gt;b)
-&gt;Readerr a
-&gt;Readerr b
(Readerrab)&lt;</em>&gt;(Readerra)=
Reader$\r-&gt; ???
Some instructions and hints.
a)When writing the purefunction for Reader , remember
that what you‚Äôre trying to construct is a function that
takes a value of type ùëü, which you know nothing about,
and return a value of type ùëé. Given that you‚Äôre not
really doing anything with ùëü, there‚Äôs really only one
thing you can do.
b)We got the definition of the apply function started for
you, we‚Äôll describe what you need to do and you write
the code. If you unpack the type of Reader‚Äôs apply
above, you get the following:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1345
&lt;*&gt; ::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
-- contrast this with the type of fmap
fmap::(a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
So what‚Äôs the diÔ¨Äerence? The diÔ¨Äerence is that apply,
unlikefmap, also takes an argument of type ùëü.
Make it so.
22.7 The Monadof functions
Functions also have a Monadinstance. You saw this in the be-
ginning of this chapter, and you perhaps have some intuition
now for how this must work. We‚Äôre going to walk through a
simplified demonstration of how it works before we get to the
types and instance. Feel free to work through this section as
quickly or slowly as you think appropriate to your own grasp
of what we‚Äôve presented so far.
Let‚Äôs start by supposing that we could write a couple of
functions like so:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1346
foo::(Functor f,Numa)=&gt;f a-&gt;f a
foor=fmap (+1) r
bar::Foldable f=&gt;t-&gt;f a-&gt;(t,Int)
barr t=(r, length t)
Now, as it happens in our program, we want to make one
function that will do both ‚Äî increment the values inside our
structure and also tell us the length of the value. We could
write that like this:
froot::Numa=&gt;[a]-&gt;([a],Int)
frootr=(map (+1) r, length r)
Or we could write the same function by combining the
two functions we already had. As it is written above, bartakes
two arguments. We could write a version that takes only one
argument, so that both parts of the tuple apply to the same
argument. That is easy enough to do (notice the change in the
type signature as well):
barOne::Foldable t=&gt;t a-&gt;(t a,Int)
barOner=(r, length r)
That gave us the reduction to one argument that we wanted
but didn‚Äôt increment the values in the list as our foofunction
does. We can add that this way:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1347
barPlus r=(foo r, length r)
But we can also do that more compactly by making (foo r)
the first argument to bar:
frooty::Numa=&gt;[a]-&gt;([a],Int)
frootyr=bar (foo r) r
Now we have an environment in which two functions are
waiting for the same argument to come in. They‚Äôll both apply
to that argument in order to produce a final result.
Let‚Äôs make a small change to make it look a little more
Reader -y:
frooty' ::Numa=&gt;[a]-&gt;([a],Int)
frooty' =\r-&gt;bar (foo r) r
Then we abstract this out so that it‚Äôs not specific to these
functions:
fooBind m k=\r-&gt;k (m r) r
In this very polymorphic version, the type signature will
look like this:
fooBind ::(t2-&gt;t1)
-&gt;(t1-&gt;t2-&gt;t)
-&gt;t2
-&gt;t</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1348
So many ùë°types! That‚Äôs because we can‚Äôt know very much
about those types once our function is that abstract. We can
make it a little more clear by making some substitutions. We‚Äôll
use the ùëüto represent the argument that both of our functions
are waiting on ‚Äî the Reader -y part:
fooBind ::(r-&gt;a)
-&gt;(a-&gt;r-&gt;b)
-&gt;(r-&gt;b)
If we could take the ùëüparts out, we might notice that fooBind
itself looks like a very abstract and simplified version of some-
thing we‚Äôve seen before (overparenthesizing a bit, for clarity):
(&gt;&gt;=) :: Monad m =&gt;
m a -&gt; (a -&gt; (m b)) -&gt; m b
(r -&gt; a) -&gt; (a -&gt; (r -&gt; b)) -&gt; (r -&gt; b)
This is how we get to the Monadof functions. Just as with the
Functor andApplicative instances, the ((-&gt;) r) is our structure
‚Äî theùëöin the type of (&gt;&gt;=). In the next section, we‚Äôll work
forward from the types.
TheMonadinstance
As we noted, the ùëüargument remains part of our (monadic)
structure:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1349
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b) -&gt; m b
(&gt;&gt;=)::
(-&gt;) r a-&gt;(a-&gt;(-&gt;) r b)-&gt;(-&gt;) r b
(&gt;&gt;=)::
(r-&gt;a)-&gt;(a-&gt;r-&gt;b)-&gt;r-&gt;b
return::Monadm=&gt;a-&gt; m a
return:: a-&gt;(-&gt;) r a
return:: a-&gt;r-&gt;a
You may notice that return looks like a function we‚Äôve seen
a lot of in this book.
Let‚Äôs look at it side by side with the Applicative :
(&lt;*&gt;)::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
(&gt;&gt;=)::(r-&gt;a)
-&gt;(a-&gt;r-&gt;b)
-&gt;(r-&gt;b)
Or with the flipped bind:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1350
(&lt;*&gt;)::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
(=&lt;&lt;)::(a-&gt;r-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
So you‚Äôve got this ever-present type ùëüfollowing your func-
tions around like a lonely puppy.
Example uses of the Reader type
Remember the earlier example with Person andDog? Here‚Äôs the
same but with the Reader Monad anddosyntax:
-- with Reader Monad
getDogRM ::Person-&gt;Dog
getDogRM = do
name&lt;-dogName
addy&lt;-address
return$Dogname addy
Exercise: Reader Monad
1.Implement the Reader Monad .</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1351
-- Don't forget instancesigs.
instance Monad(Readerr)where
return=pure
(&gt;&gt;=)::Readerr a
-&gt;(a-&gt;Readerr b)
-&gt;Readerr b
(Readerra)&gt;&gt;=aRb=
Reader$\r-&gt; ???
Hint: constrast the type with the Applicative instance and
perform the most obvious change you can imagine to
make it work.
2.Rewrite the monadic getDogRM to use your Reader datatype.
22.8Reader Monad by itself is boring
It can‚Äôt do anything the Applicative cannot.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1352
{-# LANGUAGE NoImplicitPrelude #-}
modulePrettyReader where
flip::(a-&gt;b-&gt;c)-&gt;(b-&gt;a-&gt;c)
flipf a b=f b a
const::a-&gt;b-&gt;a
consta b=a
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
f.g=\a-&gt;f (g a)
classFunctor fwhere
fmap::(a-&gt;b)-&gt;f a-&gt;f b
classFunctor f=&gt;Applicative fwhere
pure::a-&gt;f a
(&lt;*&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
classApplicative f=&gt;Monadfwhere
return::a-&gt;f a
(&gt;&gt;=)::f a-&gt;(a-&gt;f b)-&gt;f b</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1353
instance Functor ((-&gt;) r)where
fmap=(.)
instance Applicative ((-&gt;) r)where
pure=const
f&lt;<em>&gt;a=\r-&gt;f r (a r)
instance Monad((-&gt;) r)where
return=pure
m&gt;&gt;=k=flip k&lt;</em>&gt;m
Speaking generally in terms of the algebras alone, you can-
not get a Monadinstance from the Applicative . You can get
anApplicative from the Monad. However, our instances above
aren‚Äôt in terms of an abstract datatype; we know it‚Äôs the type
of functions. Because it‚Äôs not hiding behind a Reader newtype,
we can use flipandapplyto make the Monadinstance. We need
specific type information to augment what the Applicative is
capable of before we can get our Monadinstance.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1354
22.9 You can change what comes below,
but not above
The ‚Äúread-only‚Äù nature of the type argument ùëümeans that you
can swap in a diÔ¨Äerent type or value of ùëüfor functions that
you call, but not for functions that call you. The best way to
demonstrate this is with the withReaderT function which lets
us start a new Reader context with a diÔ¨Äerent argument being
provided:
withReaderT
::(r'-&gt;r)
-- ^ The function to modify
-- the environment.
-&gt;ReaderT r m a
-- ^ Computation to run in the
-- modified environment.
-&gt;ReaderT r' m a
withReaderT f m=
ReaderT $runReaderT m .f
In the next chapter, we‚Äôll see the Statemonad where we can
not only read in a value, but provide a new one which will
change the value carried by the functions that called us, not
only those we called.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1355
22.10 You tend to see ReaderT , notReader
Reader rarely stands alone. Usually it‚Äôs one Monadin a stack of
multiple types providing a Monadinstance such as with a web
application that uses Reader to give you access to context about
the HTTP request. When used in that fashion, it‚Äôs a monad
transformer and we put a letter T after the type to indicate
when we‚Äôre using it as such, so you‚Äôll usually see ReaderT in
production Haskell code rather than Reader .
Further, a Reader ofIntisn‚Äôt all that useful or compelling.
Usually if you have a Reader , it‚Äôs of a record of several (possibly
many) values that you‚Äôre getting out of the Reader .
22.11 Chapter Exercises
A warm-up stretch
These exercises are designed to be a warm-up and get you
using some of the stuÔ¨Ä we‚Äôve learned in the last few chap-
ters. While these exercises comprise code fragments from
real code, they are simplified in order to be discrete exercises.
That will allow us to highlight and practice some of the type
manipulation from Traversable andReader, both of which are
tricky.
The first simplified part is that we‚Äôre going to set up some
toy data; in the real programs these are taken from, the data</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1356
is coming from somewhere else ‚Äî a database, for example.
We just need some lists of numbers. We‚Äôre going to use some
functions from Control.Applicative andData.Maybe , so we‚Äôll im-
port those at the top of our practice file. We‚Äôll call our lists of
toy data by common variable names for simplicity.
moduleReaderPractice where
importControl.Applicative
importData.Maybe
x=[1,2,3]
y=[4,5,6]
z=[7,8,9]
The next thing we want to do is write some functions that
zip those lists together and use lookup to find the value associ-
ated with a specified key in our zipped lists. For demonstration
purposes, it‚Äôs nice to have the outputs be predictable, so we
recommend writing some that are concrete values, as well as
one that can be applied to a variable:
lookup::Eqa=&gt;a-&gt;[(a, b)] -&gt;Maybeb
-- zip x and y using 3 as the lookup key
xs::MaybeInteger
xs=undefined</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1357
-- zip y and z using 6 as the lookup key
ys::MaybeInteger
ys=undefined
-- it's also nice to have one that
-- will return Nothing, like this one
-- zip x and y using 4 as the lookup key
zs::MaybeInteger
zs=lookup4$zip x y
-- now zip x and z using a
-- variable lookup key
z'::Integer -&gt;MaybeInteger
z'n=undefined
Now we want to add the ability to make a Maybe (,) of values
usingApplicative . Have x1make a tuple of xsandys, andx2
make a tuple of of ysandzs. Also, write x3which takes one
input and makes a tuple of the results of two applications of
z'from above.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1358
x1::Maybe(Integer,Integer)
x1=undefined
x2::Maybe(Integer,Integer)
x2=undefined
x3::Integer
-&gt;(MaybeInteger,MaybeInteger)
x3=undefined
Your outputs from those should look like this:
*ReaderPractice&gt; x1
Just (6,9)
*ReaderPractice&gt; x2
Nothing
*ReaderPractice&gt; x3 3
(Just 9,Just 9)
Next, we‚Äôre going to make some helper functions. Let‚Äôs use
uncurry to allow us to add the two values that are inside a tuple:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1359
uncurry ::(a-&gt;b-&gt;c)-&gt;(a, b)-&gt;c
-- that first argument is a function
-- in this case, we want it to be addition
-- summed is uncurry with addition as
-- the first argument
summed::Numc=&gt;(c, c)-&gt;c
summed=undefined
And now we‚Äôll make a function similar to some we‚Äôve seen
before that lifts a boolean function over two partially applied
functions:
bolt::Integer -&gt;Bool
-- use &amp;&amp;, &gt;3, &lt;8
bolt=undefined
Finally, we‚Äôll be using fromMaybe in themainexercise, so let‚Äôs
look at that:
fromMaybe ::a-&gt;Maybea-&gt;a
You give it a default value and a Maybevalue. If the Maybe
value is a Just a, it will return the ùëévalue. If the value is a
Nothing , it returns the default value instead:
*ReaderPractice&gt; fromMaybe 0 xs</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1360
6
<em>ReaderPractice&gt; fromMaybe 0 zs
0
Now we‚Äôll cobble together a main, so that in one call we can
execute several things at once.
main::IO()
main= do
print$
sequenceA [ Just3,Just2,Just1]
print$sequenceA [x, y]
print$sequenceA [xs, ys]
print$summed&lt;$&gt;((,)&lt;$&gt;xs&lt;</em>&gt;ys)
print$fmap summed ((,) &lt;$&gt;xs&lt;*&gt;zs)
print$bolt7
print$fmap bolt z
When you run this in GHCi, your results should look like
this:
*ReaderPractice&gt; main
Just [3,2,1]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
Just [6,9]
Just 15
Nothing</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1361
True
[True,False,False]
Next, we‚Äôre going to add one that combines sequenceA and
Reader in a somewhat surprising way (add this to main):
print$sequenceA [( &gt;3), (&lt;8), even] 7
The type of sequenceA is
sequenceA ::(Applicative f,Traversable t)
=&gt;t (f a) -&gt;f (t a)
-- so in this:
sequenceA [(&gt;3), (&lt;8), even] 7
-- f ~ (-&gt;) a and t ~ []
Wehavea Reader fortheApplicative (functions)andatraversable
for the list. Pretty handy. We‚Äôre going to call that function
sequAfor the purposes of the following exercises:
sequA::Integral a=&gt;a-&gt;[Bool]
sequAm=sequenceA [( &gt;3), (&lt;8), even] m
And henceforth let
summed&lt;$&gt;((,)&lt;$&gt;xs&lt;*&gt;ys)</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1362
be known as s'.
OK, your turn. Within the mainabove, write the following
(you can delete everything after donow if you prefer ‚Äî just
remember to use printto be able to print the results of what
you‚Äôre adding):
1.fold the boolean conjunction operator over the list of
results of sequA(applied to some value).
2.applysequAtos'; you‚Äôll need fromMaybe .
3.applybolttoys; you‚Äôll need fromMaybe .
Rewriting Shawty
Remember the URL shortener? Instead of manually passing
the database connection rConnfrommainto the app function
that generates a Scotty app, use ReaderT to make the database
connection available. We know you haven‚Äôt seen the trans-
former variant yet and we‚Äôll explain them soon, but you should
try to do the transformation mechanically. Research as neces-
sary using a search engine. Use this version of the app: https:
//github.com/bitemyapp/shawty-prime/blob/master/app/Main.hs
22.12 Definition
A monad transformer is a special type that takes a monad as
an argument and returns a monad as a result. It allows us to</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1363
combine two monads into one that shares the behaviors of
both, such as allowing us to add exception handling to a State
monad. It is somewhat common to create a stack of transform-
ers to create one large monad that has features from several
monads, for example, rolling Reader,Either, andIOtogether
to get a monad that captures the behavior of waiting for an
argument that will get passed around to multiple functions
but is likely to come in via some kind of I/O action and has the
possibility of failure we might like to catch. Often this stack
will be given a type alias for convenience.
22.13 Follow-up resources
1.Reader Monad; All About Monads
https://wiki.haskell.org/All_About_Monads
2.Reader Monad; Programming with Monads; Real World
Haskell</p>
<p>Chapter 23
State
Four centuries ago,
Descartes pondered the
mind-body problem:
how can incorporeal
minds interact with
physical bodies? Today,
computing scientists face
their own version of the
mind-body problem:
how can virtual software
interact with the real
world?
Philip Wadler
1364</p>
<p>CHAPTER 23. STATE 1365
23.1 State
What if I need state? In Haskell we have many means of repre-
senting, accessing, and modifying state. We can think of state
as data that exists in addition to the inputs and outputs of our
functions, data that can potentially change after each function
is evaluated.
In this chapter, we will:
‚Ä¢talk about what state means;
‚Ä¢explore some ways of handling state in Haskell;
‚Ä¢generate some more random numbers;
‚Ä¢and examine the Statenewtype and Monadinstance.
23.2 What is state?
The concept of state originates in the circuit and automata
theory that much of computer science and programming be-
gan with. The simplest form of state could be understood as a
light switch. A light switch has two possible states, on or oÔ¨Ä.
That disposition of the light switch, being on or oÔ¨Ä, could be
understood as its state. Similarly, transistors in computers
have binary states of being on or oÔ¨Ä. This is a very low-level
way of seeing it, but this maps onto the state that exists in
computer memory.</p>
<p>CHAPTER 23. STATE 1366
In most imperative programming languages, this stateful-
ness is pervasive, implicit, and not referenced in the types
of your functions. In Haskell, we‚Äôre not allowed to secretly
change some value; all we can do is accept arguments and
return a result. The Statetype in Haskell is a means of express-
ing state that may change in the course of evaluating code
without resort to mutation. The monadic interface for State
is, much as you‚Äôve seen already, more of a convenience than a
strict necessity for working with State.
We have the option to capture the idea and convenience
of a value which potentially changes with each computation
without resorting to mutability. Statecaptures this idea and
cleans up the bookkeeping required. If you need in-place
mutation, then the STtype is what you want, and we address
that briefly in later chapters.
In Haskell, if we use the Statetype and its associated Monad
(for convenience, not strictly necessary), we can have state
which:
1.doesn‚Äôt require IO;
2.is limited only to the data in our Statecontainer;
3.maintains referential transparency;
4.is explicit in the types of our functions.</p>
<p>CHAPTER 23. STATE 1367
There are other means of sharing data within a program
that are designed for diÔ¨Äerent needs than the Statedatatype
itself.Stateis appropriate when you want to express your
program in terms of values that potentially vary with each
evaluation step, which can be read and modified, but don‚Äôt
otherwise have specific operational constraints.
23.3 Random numbers
As we did in the previous chapter, we‚Äôll start with an extended
example. This will help you get an idea of the problem we‚Äôre
trying to solve with the Statedatatype.
We‚Äôll be using the random1library, version 1.1, in this ex-
ample.
First, let‚Äôs give an overview of some of the functions we‚Äôll
be using here. We used the System.Random library back in the
chapter where we built the hangman game, but we‚Äôll be using
some diÔ¨Äerent functions for this example. This is in broad
strokes; it isn‚Äôt meant to go into great detail about how these
generators work.
System.Random is designed to generate pseudorandom values.
You can generate those values through providing a seed value
or by using the system-initialised generator. We‚Äôll be using
the following from that library:
1https://hackage.haskell.org/package/random</p>
<p>CHAPTER 23. STATE 1368
1.One of the types we‚Äôll be seeing here, StdGen , is a datatype
that is a product of two Int32values. So a value of type
StdGen always comprises two Int32values. They are the
seed values used to generate the next random number.
2.mkStdGen has the type:
mkStdGen ::Int-&gt;StdGen
We‚Äôll ignore the implementation at this point because
those details aren‚Äôt important here. The idea is that it takes
anIntargument and maps it into a generator to return a
value of type StdGen , which is a pair of Int32values.
3.nexthas the type:
next::g-&gt;(Int, g)
whereùëîis a value of type StdGen . TheIntthat is first in the
tuple is the pseudorandom number generated from the
StdGen value; the second value is a new StdGen value.
4.random has the type:
random::(RandomGen g,Randoma)
=&gt;g-&gt;(a, g)
This is similar to nextbut allows us to generate random
values that aren‚Äôt numbers. The range generated will be
determined by the type.</p>
<p>CHAPTER 23. STATE 1369
Now, let‚Äôs have a little demonstration of these:
Prelude&gt; import System.Random
Prelude&gt; mkStdGen 0
1 1
Prelude&gt; :t mkStdGen 0
mkStdGen 0 :: StdGen
Prelude&gt; let sg = mkStdGen 0
Prelude&gt; :t next sg
next sg :: (Int, StdGen)
Prelude&gt; next sg
(2147482884,40014 40692)
Prelude&gt; next sg
(2147482884,40014 40692)
We get the same answer twice because the underlying func-
tionthat‚Äôsdecidingthevaluesreturnedispure; thetypedoesn‚Äôt
permit the performance of any eÔ¨Äects to get spooky action.
Define a new version of sgthat provides a diÔ¨Äerent input value
tomkStdGen and see what happens.
So, we have a value called next sg . Now, if we want to use
that to generate the next random number, we need to feed the
StdGen value from that tuple to nextagain. We can use sndto
extract that StdGen value and pass it as an input to next:
Prelude&gt; snd (next sg)
40014 40692</p>
<p>CHAPTER 23. STATE 1370
Prelude&gt; let newSg = snd (next sg)
Prelude&gt; :t newSg
newSg :: StdGen
Prelude&gt; next newSg
(2092764894,1601120196 1655838864)
You‚Äôll keep getting the same results of nextthere, but you
can extract that StdGen value and pass it to nextagain to get a
new tuple:
Prelude&gt; next (snd (next newSg))
(1679949200,1635875901 2103410263)
Now we‚Äôll look at a few examples using random. Because
random can generate values of diÔ¨Äerent types, we need to specify
the type to use:
Prelude&gt; :t random newSg
random newSg :: Random a =&gt; (a, StdGen)
Prelude&gt; random newSg :: (Int, StdGen)
(138890298504988632,439883729 1872071452)
Prelude&gt; random newSg :: (Double, StdGen)
(0.41992072972993366,439883729 1872071452)
Simple enough, but what if we want a number within a
range?</p>
<p>CHAPTER 23. STATE 1371
Prelude&gt; :t randomR
randomR :: (RandomGen g, Random a) =&gt; (a, a) -&gt; g -&gt; (a, g)
Prelude&gt; randomR (0, 3) newSg :: (Int, StdGen)
(1,1601120196 1655838864)
Prelude&gt; randomR (0, 3) newSg :: (Double, StdGen)
(1.259762189189801,439883729 1872071452)
We have to pass the new state of the random number gen-
erator to the nextfunction to get a new value:
Prelude&gt; let rx :: (Int, StdGen); rx = random (snd sg3)
Prelude&gt; rx
(2387576047905147892,1038587761 535353314)
Prelude&gt; snd rx
1038587761 535353314
This chaining of state can get tedious. Addressing this te-
dium is our aim in this chapter.
23.4 The Statenewtype
Stateis defined in a newtype, like Reader in the previous chap-
ter, and that type looks like this:
newtype States a=
State{ runState ::s-&gt;(a, s) }</p>
<p>CHAPTER 23. STATE 1372
It‚Äôs initially a bit strange looking, but you might notice some
similarity to the Reader newtype:
newtype Readerr a=
Reader{ runReader ::r-&gt;a }
We‚Äôve seen several newtypes whose contents are a function,
particularly with our Monoid newtypes ( Sum,Product , etc.). New-
types must have the same underlying representation as the
type they wrap, as the newtype wrapper disappears at compile
time. So the function contained in the newtype must be iso-
morphic to the type it wraps. That is, there must be a way to go
from the newtype to the thing it wraps and back again without
losing information. For example, the following demonstrates
an isomorphism:
typeIsoa b=(a-&gt;b, b-&gt;a)
newtype Suma=Sum{ getSum ::a }
sumIsIsomorphicWithItsContents
::Isoa (Suma)
sumIsIsomorphicWithItsContents =
(Sum, getSum)
Whereas the following do not:</p>
<p>CHAPTER 23. STATE 1373
-- Not an isomorphism, because
-- it might not work.
(a-&gt;Maybeb, b-&gt;Maybea)
-- Not an isomorphism for two reasons.
-- You lose information whenever there
-- was more than one element in [a]. Also,
-- [a] -&gt; a is partial because there
-- might not be any elements.
[a]-&gt;a, a-&gt;[a]
With that in mind, let us look at the Statedata constructor
andrunState record accessor as our means of putting a value
in and taking a value out of the Statetype:
State::(s-&gt;(a, s)) -&gt;States a
runState ::States a-&gt;s-&gt;(a, s)
Stateis a function that takes input state and returns an out-
put value, ùëé, tupled with the new state value. The key is that
the previous state value from each application is chained to
the next one, and this is not an uncommon pattern. Stateis
often used for things like random number generators, solvers,
games, and carrying working memory while traversing a data
structure. The polymorphism means you don‚Äôt have to make
a new state for each possible instantiation of ùë†andùëé.</p>
<p>CHAPTER 23. STATE 1374
Let‚Äôs get back to our random numbers:
Note that random looks an awful lot like Statehere:
random::(Randoma)
=&gt;StdGen-&gt;(a,StdGen)
State{ runState
::s-&gt;(a, s) }
If we look at the type of randomR , once partially applied, it
should also remind you of State:
randomR ::(...)=&gt;(a, a)-&gt;g-&gt;(a, g)
State{ runState :: s-&gt;(a, s) }
23.5 Throw down
Now let us use this kit to generate die such as for a game:</p>
<p>CHAPTER 23. STATE 1375
moduleRandomExample where
importSystem.Random
-- Six-sided die
dataDie=
DieOne
|DieTwo
|DieThree
|DieFour
|DieFive
|DieSix
deriving (Eq,Show)
As you might expect, we‚Äôll be using the random library, and a
simpleDiedatatype to represent a six-sided die.</p>
<p>CHAPTER 23. STATE 1376
intToDie ::Int-&gt;Die
intToDie n=
casenof
1-&gt;DieOne
2-&gt;DieTwo
3-&gt;DieThree
4-&gt;DieFour
5-&gt;DieFive
6-&gt;DieSix
-- Use 'error'
-- <em>extremely</em> sparingly.
x-&gt;
error$
&quot;intToDie got non 1-6 integer: &quot;
++show x
Don‚Äôt use erroroutside of experiments like this, or in cases
where the branch you‚Äôre ignoring is provably impossible. We
do not use the word provably here lightly.2
Now we need to roll the dice:
2Because partial functions are a pain, you should only use an error like this when
the branch that would spawn the error can literally never happen. Unexpected software
failures are often due to things like this. It is also completely unnecessary in Haskell; we
have good alternatives, like using MaybeorEither. The only reason we didn‚Äôt here is to
keep it simple and focus attention on the State Monad .</p>
<p>CHAPTER 23. STATE 1377
rollDieThreeTimes ::(Die,Die,Die)
rollDieThreeTimes = do
lets=mkStdGen 0
(d1, s1) =randomR ( 1,6) s
(d2, s2) =randomR ( 1,6) s1
(d3,_)=randomR ( 1,6) s2
(intToDie d1, intToDie d2, intToDie d3)
This code isn‚Äôt optimal, but it does work. It will produce
the same results every time, because it is free of eÔ¨Äects, but
you can make it produce a new result on a new dice roll if you
modify the start value. Try it a couple of times to see what we
mean. It seems unlikely that this will develop into a gambling
addiction, but in the event it does, the authors disclaim liability
for such.
So, how can we improve our suboptimal code there. With
State, of course!
moduleRandomExample2 where
importControl.Applicative (liftA3)
importControl.Monad (replicateM )
importControl.Monad.Trans.State
importSystem.Random
importRandomExample</p>
<p>CHAPTER 23. STATE 1378
First, we‚Äôll add some new imports. You‚Äôll need transformers
to be installed for the Stateimport to work, but that should
have come with your GHC install, so you should be good to
go.
UsingStatewill allow us to factor out the generation of a
singleDie:
rollDie ::StateStdGenDie
rollDie =state$ do
(n, s)&lt;-randomR ( 1,6)
return (intToDie n, s)
For our purposes, the statefunction is a constructor that
takes aState-like function and embeds it in the Statemonad
transformer. Ignore the transformer part for now ‚Äî we‚Äôll get
there. The state function has the following type:
state::Monadm
=&gt;(s-&gt;(a, s))
-&gt;StateTs m a
Note that we‚Äôre binding the result of randomR out of the State
monad the doblock is in rather than using let. This is still more
verbose than is necessary. We can lift our intToDie function
over the State:</p>
<p>CHAPTER 23. STATE 1379
rollDie' ::StateStdGenDie
rollDie' =
intToDie &lt;$&gt;state (randomR ( 1,6))
State StdGen had a final type argument of Int. We lifted Int
-&gt; Die over it and transformed that final type argument to Die.
We‚Äôll exercise more brevity upfront in the next function:
rollDieThreeTimes'
::StateStdGen(Die,Die,Die)
rollDieThreeTimes' =
liftA3 (,,) rollDie rollDie rollDie
Lifting the three-tuple constructor over three Stateactions
that produce Dievalues when given an initial state to work
with. How does this look in practice?
Prelude&gt; evalState rollDieThreeTimes' (mkStdGen 0)
(DieSix,DieSix,DieFour)
Prelude&gt; evalState rollDieThreeTimes' (mkStdGen 1)
(DieSix,DieFive,DieTwo)
Seems to work fine. Again, the same inputs give us the same
result. What if we want a list of Dieinstead of a tuple?</p>
<p>CHAPTER 23. STATE 1380
-- Seems appropriate?
repeat::a-&gt;[a]
infiniteDie ::StateStdGen[Die]
infiniteDie =repeat&lt;$&gt;rollDie
Does this infiniteDie function do what we want or expect?
What is it repeating?
Prelude&gt; take 6 $ evalState infiniteDie (mkStdGen 0)
[DieSix,DieSix,DieSix,DieSix,DieSix,DieSix]
We already know based on previous inputs that the first 3
values shouldn‚Äôt be identical for a seed value of 0. So what
happened? What happened is we repeated a single die value
‚Äî we didn‚Äôt repeat the state action that produces a die. This is
what we need:
replicateM ::Monadm
=&gt;Int-&gt;m a-&gt;m [a]
nDie::Int-&gt;StateStdGen[Die]
nDien=replicateM n rollDie
And when we use it?
Prelude&gt; evalState (nDie 5) (mkStdGen 0)</p>
<p>CHAPTER 23. STATE 1381
[DieSix,DieSix,DieFour,DieOne,DieFive]
Prelude&gt; evalState (nDie 5) (mkStdGen 1)
[DieSix,DieFive,DieTwo,DieSix,DieFive]
We get precisely what we wanted.
Keep on rolling
In the following example, we keep rolling a single die until we
reach or exceed a sum of 20.
rollsToGetTwenty ::StdGen-&gt;Int
rollsToGetTwenty g=go00g
where
go::Int-&gt;Int-&gt;StdGen-&gt;Int
go sum count gen
|sum&gt;=20=count
|otherwise =
let(die, nextGen) =
randomR ( 1,6) gen
ingo (sum +die)
(count+1) nextGen
Then seeing it in action:
Prelude&gt; rollsToGetTwenty (mkStdGen 0)
5</p>
<p>CHAPTER 23. STATE 1382
Prelude&gt; rollsToGetTwenty (mkStdGen 0)
5
We can also use randomIO , which uses IOto get a new value
each time without needing to create a unique value for the
StdGen :
Prelude&gt; :t randomIO
randomIO :: Random a =&gt; IO a
Prelude&gt; (rollsToGetTwenty . mkStdGen) &lt;$&gt; randomIO
6
Prelude&gt; (rollsToGetTwenty . mkStdGen) &lt;$&gt; randomIO
7
Under the hood, it‚Äôs the same interface and State Monad
driven mechanism, but it‚Äôs mutating a single globally used
StdGen to walk the generator forward on each use. See the
random library source code to see how this works.
Exercises: Roll Your Own
1.Refactor rollsToGetTwenty into having the limit be a func-
tion argument.
rollsToGetN ::Int-&gt;StdGen-&gt;Int
rollsToGetN =undefined
2.Change rollsToGetN to recording the series of die that oc-
curred in addition to the count.</p>
<p>CHAPTER 23. STATE 1383
rollsCountLogged ::Int
-&gt;StdGen
-&gt;(Int, [Die])
rollsCountLogged =undefined
23.6 Write Statefor yourself
Use the datatype definition from the beginning of this chapter,
with the name changed to avoid conflicts in case you have
Stateimported from the libraries transformers ormtl. We‚Äôre
calling it Moi, because we enjoy allusions to famous quotations3;
feel free to change the name if you wish to protest absolute
monarchy, but change them consistently throughout.
newtype Mois a=
Moi{ runMoi ::s-&gt;(a, s) }
State Functor
Implement the Functor instance for State.
instance Functor (Mois)where
fmap::(a-&gt;b)-&gt;Mois a-&gt;Mois b
fmap f ( Moig)= ???
3We are referring to the (possibly apocryphal) quotation attributed to the French
King Louis XIV, ‚ÄúL‚ÄôEtat, c‚Äôest moi.‚Äù For those of you who do not speak French, it means,
‚ÄúI am the State.‚Äù Cheers.</p>
<p>CHAPTER 23. STATE 1384
Prelude&gt; runMoi ((+1) &lt;$&gt; (Moi $ \s -&gt; (0, s))) 0
(1,0)
State Applicative
Write the Applicative instance for State.
instance Applicative (Mois)where
pure::a-&gt;Mois a
pure a= ???
(&lt;<em>&gt;)::Mois (a-&gt;b)
-&gt;Mois a
-&gt;Mois b
(Moif)&lt;</em>&gt;(Moig)=
???
State Monad
Write the Monadinstance for State.</p>
<p>CHAPTER 23. STATE 1385
instance Monad(Mois)where
return=pure
(&gt;&gt;=)::Mois a
-&gt;(a-&gt;Mois b)
-&gt;Mois b
(Moif)&gt;&gt;=g=
???
23.7 Get a coding job with one weird
trick
Some companies will use FizzBuzz4to screen (not so much
test) candidates applying to software positions. The problem
statement goes:
Write a program that prints the numbers from 1 to
100. But for multiples of three print ‚ÄúFizz‚Äù instead of
the number and for the multiples of five print ‚ÄúBuzz‚Äù.
For numbers which are multiples of both three and
five print ‚ÄúFizzBuzz‚Äù.
A typical fizzbuzz solution in Haskell looks something like:
4http://c2.com/cgi/wiki?FizzBuzzTest</p>
<p>CHAPTER 23. STATE 1386
fizzBuzz ::Integer -&gt;String
fizzBuzz n|n <code>mod</code> 15==0=&quot;FizzBuzz&quot;
|n <code>mod</code> 5==0=&quot;Buzz&quot;
|n <code>mod</code> 3==0=&quot;Fizz&quot;
|otherwise =show n
main::IO()
main=
mapM_ (putStrLn .fizzBuzz) [ 1..100]
A fizzbuzz using Stateis a suitable punishment for asking
a software candidate to write this in person after presumably
getting through a couple phone screens. Let‚Äôs look at what a
version with Statemight look like:
importControl.Monad
importControl.Monad.Trans.State
fizzBuzz ::Integer -&gt;String
fizzBuzz n|n <code>mod</code> 15==0=&quot;FizzBuzz&quot;
|n <code>mod</code> 5==0=&quot;Buzz&quot;
|n <code>mod</code> 3==0=&quot;Fizz&quot;
|otherwise =show n</p>
<p>CHAPTER 23. STATE 1387
fizzbuzzList ::[Integer]-&gt;[String]
fizzbuzzList list=
execState (mapM_ addResult list) []
addResult ::Integer -&gt;State<a href="">String</a>
addResult n= do
xs&lt;-get
letresult=fizzBuzz n
put (result :xs)
Note that Stateis a type alias of StateT you imported.
main::IO()
main=
mapM_ putStrLn $
reverse $fizzbuzzList [ 1..100]
The good part here is that we‚Äôre collecting data initially
before dumping the results to standard output via putStrLn .
The bad is that we‚Äôre reversing a list. Reversing singly-linked
lists is not great, even in Haskell, and won‚Äôt terminate on an
infinite list. One of the issues is that we‚Äôre accepting an input
that defines the numbers we‚Äôll use fizzbuzz on linearly from
beginning to end.
There are a couple ways we could handle this. One is to
use a data structure with cheaper appending to the end. Using
(++)recursively can be very slow, so let‚Äôs use something that</p>
<p>CHAPTER 23. STATE 1388
can append in constant time. The counterpart to []which has
this property is the diÔ¨Äerence list5which has O(1) append.
importControl.Monad
importControl.Monad.Trans.State
-- http://hackage.haskell.org/package/dlist
import qualified Data.DList asDL
fizzBuzz ::Integer -&gt;String
fizzBuzz n|n <code>mod</code> 15==0=&quot;FizzBuzz&quot;
|n <code>mod</code> 5==0=&quot;Buzz&quot;
|n <code>mod</code> 3==0=&quot;Fizz&quot;
|otherwise =show n
5https://github.com/spl/dlist</p>
<p>CHAPTER 23. STATE 1389
fizzbuzzList ::[Integer]-&gt;[String]
fizzbuzzList list=
letdlist=
execState (mapM_ addResult list)
DL.empty
-- convert back to normal list
inDL.apply dlist []
addResult ::Integer
-&gt;State(DL.DListString)()
addResult n= do
xs&lt;-get
letresult=fizzBuzz n
-- snoc appends to the end, unlike
-- cons which adds to the front
put (DL.snoc xs result)
main::IO()
main=
mapM_ putStrLn $fizzbuzzList [ 1..100]
We can clean this up further. If you have GHC 7.10 or newer,
mapM_will specify a Foldable type, not only a list:
Prelude&gt; :t mapM_
mapM_ :: (Monad m, Foldable t) =&gt; (a -&gt; m b) -&gt; t a -&gt; m ()</p>
<p>CHAPTER 23. STATE 1390
By letting DList‚ÄôsFoldable instance do the conversion to a
list for us, we can eliminate some code:
fizzbuzzList ::[Integer]
-&gt;DL.DListString
fizzbuzzList list=
execState (mapM_ addResult list) DL.empty
addResult ::Integer
-&gt;State(DL.DListString)()
addResult n= do
xs&lt;-get
letresult=fizzBuzz n
put (DL.snoc xs result)
main::IO()
main=
mapM_ putStrLn $fizzbuzzList [ 1..100]
DList‚ÄôsFoldable instance converts to a list before folding
because of limitations specific to the datatype. You get cheap
appending, but you give up the ability to ‚Äúsee‚Äù what you‚Äôve
built unless you‚Äôre willing to do all the work of building the
structure. We‚Äôll discuss this in more detail in a forthcoming
chapter.</p>
<p>CHAPTER 23. STATE 1391
One thing that may strike you here is that the use of State
was superfluous. That‚Äôs good! It‚Äôs not common you need State
as such in Haskell. You might use a diÔ¨Äerent form of State
calledSTas a selective optimization, but Stateitself is a stylistic
choice that falls out of what the code is telling you. Don‚Äôt
feel compelled to use or not use State. Please frighten some
interviewers with a spooky fizzbuzz. Make something even
weirder than what we‚Äôve shown you here!
Fizzbuzz DiÔ¨Äerently
It‚Äôs an exercise! Rather than changing the underlying data
structure, fix our reversing fizzbuzz by changing the code in
the following way:
fizzbuzzFromTo ::Integer
-&gt;Integer
-&gt;[String]
fizzbuzzFromTo =undefined
Continue to use consing in the construction of the result
list, but have it come out in the right order to begin with by
enumerating the sequence backwards. This sort of tactic is
more commonly how you‚Äôll want to fix your code when you‚Äôre
quashing unnecessary reversals.</p>
<p>CHAPTER 23. STATE 1392
23.8 Chapter exercises
Write the following functions. You‚Äôll want to use your own
Statetype for which you‚Äôve defined the Functor ,Applicative ,
andMonad.
1.Construct a Statewhere the state is also the value you
return.
get::States s
get= ???
Expected output
Prelude&gt; runState get &quot;curryIsAmaze&quot;
(&quot;curryIsAmaze&quot;,&quot;curryIsAmaze&quot;)
2.Construct a Statewhere the resulting state is the argument
provided and the value is defaulted to unit.
put::s-&gt;States()
puts= ???
Prelude&gt; runState (put &quot;blah&quot;) &quot;woot&quot;
((),&quot;blah&quot;)
3.Run the Statewithùë†and get the state that results.</p>
<p>CHAPTER 23. STATE 1393
exec::States a-&gt;s-&gt;s
exec(Statesa) s= ???
Prelude&gt; exec (put &quot;wilma&quot;) &quot;daphne&quot;
&quot;wilma&quot;
Prelude&gt; exec get &quot;scooby papu&quot;
&quot;scooby papu&quot;
4.Run the Statewithùë†and get the value that results.
eval::States a-&gt;s-&gt;a
eval(Statesa)= ???
Prelude&gt; eval get &quot;bunnicula&quot;
&quot;bunnicula&quot;
Prelude&gt; eval get &quot;stake a bunny&quot;
&quot;stake a bunny&quot;
5.Write a function which applies a function to create a new
State.
modify::(s-&gt;s)-&gt;States()
modify=undefined
Should behave like the following:</p>
<p>CHAPTER 23. STATE 1394
Prelude&gt; runState (modify (+1)) 0
((),1)
Prelude&gt; runState (modify (+1) &gt;&gt; modify (+1)) 0
((),2)
You don‚Äôt need to compose them, you can throw away the
result because it returns unit for ùëéanyway.
23.9 Follow-up resources
1.State Monad; All About Monads; Haskell Wiki
https://wiki.haskell.org/All_About_Monads
2.State Monad; Haskell Wiki
https://wiki.haskell.org/State_Monad
3.Understanding Monads; Haskell Wikibook</p>
<p>Chapter 24
Parser combinators
Within a computer,
natural language is
unnatural.
Alan Perlis
1395</p>
<p>CHAPTER 24. PARSER COMBINATORS 1396
24.1 Parser combinators
The word parse comes from the Latin word for parts, and
means to analyze a sentence and label the syntactic role, or part
of speech, of each component. Language teachers once em-
phasized this ability because it forced students to think about
the structure of sentences, the relationships among the parts,
and the connection between the structure and the meaning of
the whole. Diagramming sentences was common because it
made parsing visual and somewhat concrete.
It is now common to represent grammatical structures of
natural languages as trees, so that a sentence such as
Boy plays with dog.
might be thought to have an underlying representation
such as
S(entence)
/ <br />
Boy plays (verb)
(subject) <br />
with (preposition)
<br />
dog (object)
We are not here to become linguists, but parsing in com-
puter science is related to the parsing of natural language</p>
<p>CHAPTER 24. PARSER COMBINATORS 1397
sentences. The core idea of parsing in programming is to
accept serialized input in the form of a sequence of characters
(textual data) or bytes (raw binary data) and turn that into a
value of a structured datatype. Serialized data is data that has
been translated into a format, such as JSON or XML1, that can
be stored or transmitted across a network connection. Parsing
breaks up that chunk of data and allows you to find and process
the parts you care about.
If we wrote a computer program to parse a sentence into
a very simplified model of English grammar, it could look
something like the tree above. Often when we are parsing
things, the structured datatype that results will look something
like a tree. In Haskell, we can sometimes end up having a tree
because recursive types are so easy to express in Haskell.
In this chapter, we will
‚Ä¢use a parsing library to cover the basics of parsing;
‚Ä¢demonstrate the awesome power of parser combinators;
‚Ä¢marshall and unmarshall some JSON data;
‚Ä¢talk about tokenization.
1If you do not know what JSON and XML are yet, try not to get too hung up on that.
All that matters at this point is that they are standard data formats. We‚Äôll look at JSON in
more detail later in the chapter.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1398
24.2 A few more words of introduction
In this chapter, we will not look too deeply into the types of
the parsing libraries we‚Äôre using, learn every sort of parser
there is, or artisanally handcraft all of our parsing functions
ourselves.
These are thoroughly considered decisions. Parsing is a
huge field of research in its own right with connections that
span natural language processing, linguistics, and program-
ming language theory. This topic could easily fill a book in
itself (in fact, it has). The underlying types and typeclasses of
the libraries we‚Äôll be using are complicated. To be sure, if you
enjoy parsing and expect to do it a lot, those are things you‚Äôd
want to learn; they are simply out of the scope of this book.
This chapter takes a diÔ¨Äerent approach than previous chap-
ters. The focus is on enabling you to use Haskell‚Äôs parsing
libraries ‚Äî not to be a master of parsing and writing parsers
in general. This is not the bottom-up approach you may be
accustomed to; by necessity, we‚Äôre working outside-in and
trying to cover what you‚Äôre likely to need. Depending on your
specific interests, you may find this chapter too long or not
nearly long enough.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1399
24.3 Understanding the parsing process
A parser is a function that takes some textual input (it could
be aString , or another datatype such as ByteString orText) and
returns some structure as an output. That structure might
be a tree, for example, or an indexed map of locations in the
parsed data. Parsers analyze structure in conformance with
rules specified in a grammar, whether it‚Äôs a grammar of a
human language, a programming language, or a format such
as JSON.
A parser combinator is a higher-order function that takes
parsers as input and returns a new parser as output. You may
remember our brief discussion of combinators way back in
the lambda calculus chapter. Combinators are expressions
with no free variables.
The standard for what constitutes a combinator with respect
to parser combinators is a little looser. Parsers are functions,
so parser combinators are higher-order functions that can take
parsers as arguments. Usually the argument passing is elided
because the interface of parsers will often be like the State
monad which permits Reader -style implicit argument passing.
Among other things, combinators allow for recursion and for
gluing together parsers in a modular fashion to parse data
according to complex rules.
For computers, parsing is something like reading when
you‚Äôre really young. Perhaps you were taught to trace the</p>
<p>CHAPTER 24. PARSER COMBINATORS 1400
letters with your finger for phonetic pronunciation. Later, you
were able to follow word by word, then you started scanning
with your eyes. Eventually, you learned how to read with
subvocalization.
Since we didn‚Äôt use an analogy for Monad
We‚Äôre going to run through some code now that will demon-
strate the idea of parsing. Let‚Äôs begin by installing the parsing
librarytrifecta ,2then work through a short demonstration of
what it does. We‚Äôll talk more about the design of trifecta in
a while. For now, we‚Äôre going to use it in a state of somewhat
ignorant bliss.
Let‚Äôs put up some code:
moduleLearnParsers where
importText.Trifecta
stop::Parsera
stop=unexpected &quot;stop&quot;
unexpected is a means of throwing errors in parsers like
trifecta which are an instance of the Parsing typeclass. Here
2We‚Äôll be using this version of trifecta
http://hackage.haskell.org/package/trifecta-1.5.2</p>
<p>CHAPTER 24. PARSER COMBINATORS 1401
we‚Äôre using it to make the parser fail for demonstration pur-
poses.
What demonstration purposes?
We‚Äôre glad you asked! The basic idea behind a parser is that
you‚Äôre moving a sort of cursor around a linear stream of text.
It‚Äôssimplesttothinkoftheindividualunitswithinthestreamas
characters or ideographs, though you‚Äôll want to start thinking
of your parsing problems in chunkier terms as you progress.
The idea is that this cursor is a bit like you‚Äôre reading the text
with your finger:
Julie bit Papuchon
^
Then let us say we parsed the word ‚ÄúJulie‚Äù ‚Äî we‚Äôve now
consumed that input, so the cursor will be at ‚Äúbit‚Äù:
Julie bit Papuchon
^
If we weren‚Äôt expecting the word ‚Äúbit,‚Äù our parser could fail
here, and we‚Äôd get an error at the word ‚Äúbit‚Äù like that. However,
if we did parse the word ‚Äúbit‚Äù successfully and thus consumed
that input, it might look something like this:
Julie bit Papuchon
^</p>
<p>CHAPTER 24. PARSER COMBINATORS 1402
The analogy we‚Äôre using here isn‚Äôt perfect. One of the hard-
est problems in writing parsers, especially the parser libraries
themselves, is making it easy to express things the way the
programmer would like, but still have the resulting parser be
fast.
Back to the code
With the cursor analogy in mind, let‚Äôs return to the module
we started.
We‚Äôll first make a little function that only parses one charac-
ter, and then sequence that with stopto make it read that one
character and then die:
-- read a single character '1'
one=char'1'
-- read a single character '1', then die
one'=one&gt;&gt;stop
-- equivalent to char '1' &gt;&gt; stop
Forone', we‚Äôre using the sequencing operator from Monadto
combine two parsers, stopandchar '1' . Given the type of &gt;&gt;:
(&gt;&gt;)::Monadm=&gt;m a-&gt;m b-&gt;m b
it‚Äôs safe to assume that whatever char '1' returns in the
expression</p>
<p>CHAPTER 24. PARSER COMBINATORS 1403
char'1'&gt;&gt;stop
gets thrown away. Critically, any eÔ¨Äect the m aaction had
upon the monadic context remains. The result value of the
parse function gets thrown away, but the eÔ¨Äect of ‚Äúmoving the
cursor‚Äù remains. Another possible eÔ¨Äect is causing the parse
to fail.
A bit like‚Ä¶
State. Plus failure. No seriously, take a look at this definition
of theParser type:
typeParsera=String-&gt;Maybe(a,String)
You can read this as:
1.Await a string value
2.Produce a result which may or may not succeed. (A
Nothing value means the parse failed.)
3.Return a tuple of the value you wanted and whatever‚Äôs
left of the string that you didn‚Äôt consume to produce the
value of type ùëé.
Then remind yourself of what Reader andStatelook like:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1404
newtype Readerr a=
Reader{ runReader ::r-&gt;a }
newtype States a=
State{ runState ::s-&gt;(a, s) }
If you have convinced yourself that Stateis an elaboration
ofReader and that you can see how the Parser type looks sorta
likeState, we can move on.
The idea here with the Parser type is that the Stateis han-
dling the fact that you need to await an eventual text input and
that having parsed something out of that text input results in
a new state of the input stream. It also lets you return a value
independent of the state, while Maybehandles the possibility
of the parser failure.
If we were to look at the underlying pattern of a parsing
function such as char, you can see the State-ish pattern. Please
understand that while this should work as a character-parsing
function, we are simplifying here and this is not what the
source code of any modern parsing library will look like:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1405
-- rudimentary char
-- demo only, this won't work as is.
char::Char-&gt;ParserChar
charc=
Parser$\s-&gt;
casesof
(x:xs)-&gt; ifc==x
then[(c, xs)]
else[]
_ -&gt;[]
We could encode the possibility of failure in that by adding
Maybebut at this point, that isn‚Äôt important because we‚Äôre using
a library that has encoded the possibility of failure for us. It has
also optimized the heck out of charfor us. But we wanted to
show you how the underlying function is the s -&gt;embedded
in theParser data constructor.
Consider the type of a Hutton-Meijer parser:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1406
-- from Text.ParserCombinators.HuttonMeijer
-- polyparse-1.11
typeToken=Char
newtype Parsera=
P([Token]-&gt;[(a, [Token])])
-- Same thing, differently formatted:
typeParser' a=String-&gt;[(a,String)]
This changes things from the previous, less common but
simpler variant, by allowing you to express a range of possibly
valid parses starting from the input provided. This is more
powerful than the Maybevariant, but this design isn‚Äôt used in
popular Haskell parser combinator libraries any longer. Al-
though the underlying implementation has changed dramati-
cally with new discoveries and designs, most parsing libraries
in Haskell are going to have an interface that behaves a bit like
Statein that the act of parsing things has an observable eÔ¨Äect
on one or more bits of state.
If we were talking about State, this means any putto the
Statevalue would be observable to the next action in the same
Monad(you can verify what follows in your REPL by import-
ingControl.Monad.Trans.State ). These examples use the trans-
former variant of State, but if you ignore the T, you should be
able to get the basic idea:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1407
get::Monadm=&gt;StateTs m s
put::Monadm=&gt;s-&gt;StateTs m()
runStateT ::StateTs m a-&gt;s-&gt;m (a, s)
Prelude&gt; runStateT (put 8) 7
((),8)
Prelude&gt; runStateT get 8
(8,8)
Prelude&gt; runStateT (put 1 &gt;&gt; get) 8
(1,1)
Prelude&gt; (runStateT $ put 1 &gt;&gt; get) 0
(1,1)
Prelude&gt; (runStateT $ put 2 &gt;&gt; get) 10021490234890
(2,2)
Prelude&gt; (runStateT $ put 2 &gt;&gt; return 9001) 0
(9001,2)
Nowputreturns a unit value, a throwaway value, so we‚Äôre
only evaluating it for eÔ¨Äect anyway. It modifies the state but
doesn‚Äôt have any value of its own. So when we throw away its
value, we‚Äôre left with its eÔ¨Äect on the state, although getputs
that value into both the ùëéandùë†slots in the tuple.
This is an awful lot like what happens when we sequence a
parsing function such as charwithstop, as above. There is no
real result of char, but it does change the state. The state here
is the location of the cursor in the input stream. In reality, a</p>
<p>CHAPTER 24. PARSER COMBINATORS 1408
modern and mature parser design in Haskell will often look
about as familiar to you as the alien hellscape underneath the
frozen crust of one of the moons of Jupiter. Don‚Äôt take the
idea of there being an actual cursor too literally, but there may
be some utility in imagining it this way.
Back to our regularly scheduled coding
Onward with the code:
-- read two characters, '1', and '2'
oneTwo=char'1'&gt;&gt;char'2'
-- read two characters,
-- '1' and '2', then die
oneTwo' =oneTwo&gt;&gt;stop
testParse ::ParserChar-&gt;IO()
testParse p=
print$parseString p mempty &quot;123&quot;
Theùëùargument is a parser. Specifically, it‚Äôs a character
parser. The functions oneandoneTwo have the type Parser Char .
You can check the types of one'andoneTwo' yourself.
We needed to declare the type of testParse in order to Show
what we parsed because of ambiguity.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1409
The key thing to realize here is that we‚Äôre using parsers like
values and combining them using the same stuÔ¨Ä we use with
ordinary functions or operators from the Applicative andMonad
typeclasses. The structure that makes up the Applicative or
Monadin this case is the Parser itself.
Next we‚Äôll write a function to print a string to standard
output (stdout) with a newline prefixed, and then use that
function as part of a mainthat will show us what we‚Äôve got so
far:
pNLs=
putStrLn ( '\n':s)
main= do
pNL&quot;stop:&quot;
testParse stop
pNL&quot;one:&quot;
testParse one
pNL&quot;one':&quot;
testParse one'
pNL&quot;oneTwo:&quot;
testParse oneTwo
pNL&quot;oneTwo':&quot;
testParse oneTwo'
Let‚Äôs run it and interpret the results. Since it‚Äôs text on a</p>
<p>CHAPTER 24. PARSER COMBINATORS 1410
computer screen instead of tea leaves, we‚Äôll call it science. If
you remain unconvinced, you have our permission to don a
white labcoat and print the output using a dot-matrix printer.
Some of you kids probably don‚Äôt even know what a dot-matrix
printer is.3
Runmainand see what happens:
Prelude&gt; main
stop:
Failure (interactive):1:1: error: unexpected
stop
123<EOF>
^
We failed immediately before consuming any input in the
above, so the caret in the error is at the beginning of our string
value.
Next result:
one:
Success '1'
We parsed a single character, the digit 1. The result is know-
ing we succeeded. But what about the rest of the input stream?
Well, the thing we used to run the parser dropped the rest of
3shakes fist at sky</p>
<p>CHAPTER 24. PARSER COMBINATORS 1411
the input on the floor. There are ways to change this behavior
which we‚Äôll explain in the exercises.
Next up:
one':
Failure (interactive):1:2: error: unexpected
stop
123<EOF>
^
We parsed a single character successfully, then dropped it
because we used &gt;&gt;to sequence it with stop. This means the
cursor was one character forward due to the previous parser
succeeding. Helpfully, trifecta tells us where our parser failed.
And for our last result:
oneTwo:
Success '2'
oneTwo':
Failure (interactive):1:3: error: unexpected
stop
123<EOF>
^
It‚Äôs the same as before, but we parsed two characters indi-
vidually. What if we we don‚Äôt want to discard the first character
we parsed and instead parse ‚Äú12?‚Äù See the exercises below!</p>
<p>CHAPTER 24. PARSER COMBINATORS 1412
Exercises: Parsing Practice
1.There‚Äôs a combinator that‚Äôll let us mark that we expect
an input stream to be finished at a particular point in our
parser. In the parsers library this is simply called eof(end-
of-file) and is in the Text.Parser.Combinators module. See
if you can make the oneandoneTwo parsers fail because
they didn‚Äôt exhaust the input stream!
2.Usestring to make a Parser that parses ‚Äú1‚Äù, ‚Äú12‚Äù, and ‚Äú123‚Äù
out of the example input respectively. Try combining it
withstoptoo. That is, a single parser should be able to
parse all three of those strings.
3.Try writing a Parser that does what string does, but using
char.
Intermission: parsing free jazz
Let us play with these parsers! We typically use the parseString
function to run parsers, but if you figure some other way that
works for you, so be it! Here‚Äôs some parsing free jazz, if you
will, meant only to help develop your intuition about what‚Äôs
going on:
Prelude&gt; import Text.Trifecta
Prelude&gt; :t char
char :: CharParsing m =&gt; Char -&gt; m Char</p>
<p>CHAPTER 24. PARSER COMBINATORS 1413
Prelude&gt; :t parseString
parseString
:: Parser a
-&gt; Text.Trifecta.Delta.Delta
-&gt; String
-&gt; Result a
Prelude&gt; let gimmeA = char 'a'
Prelude&gt; :t parseString gimmeA mempty
parseString gimmeA mempty :: String -&gt; Result Char
Prelude&gt; parseString gimmeA mempty &quot;a&quot;
Success 'a'
Prelude&gt; parseString gimmeA mempty &quot;b&quot;
Failure (interactive):1:1: error: expected: &quot;a&quot;
b<EOF>
^
Prelude&gt; parseString (char 'b') mempty &quot;b&quot;
Success 'b'
Prelude&gt; parseString (char 'b' &gt;&gt; char 'c') mempty &quot;b&quot;
Failure (interactive):1:2: error: unexpected
EOF, expected: &quot;c&quot;
b<EOF>
^
Prelude&gt; parseString (char 'b' &gt;&gt; char 'c') mempty &quot;bc&quot;
Success 'c'</p>
<p>CHAPTER 24. PARSER COMBINATORS 1414
Prelude&gt; parseString (char 'b' &gt;&gt; char 'c') mempty &quot;abc&quot;
Failure (interactive):1:1: error: expected: &quot;b&quot;
abc<EOF>
^
Seems like we ought to have a way to say, ‚Äúparse this string‚Äù
rather than having to sequence the parsers of individual char-
acters bit by bit, right? Turns out, we do:
Prelude&gt; parseString (string &quot;abc&quot;) mempty &quot;abc&quot;
Success &quot;abc&quot;
Prelude&gt; parseString (string &quot;abc&quot;) mempty &quot;bc&quot;
Failure (interactive):1:1: error: expected: &quot;abc&quot;
bc<EOF>
^
Prelude&gt; parseString (string &quot;abc&quot;) mempty &quot;ab&quot;
Failure (interactive):1:1: error: expected: &quot;abc&quot;
ab<EOF>
^
Importantly, it‚Äôs not a given that a single parser exhausts all
of its input ‚Äî they only consume as much text as they need
to produce the value of the type requested.
Prelude&gt; parseString (char 'a') mempty &quot;abcdef&quot;
Success 'a'
Prelude&gt; let stop = unexpected &quot;stop pls&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1415
Prelude&gt; parseString (char 'a' &gt;&gt; stop) mempty &quot;abcdef&quot;
Failure (interactive):1:2: error: unexpected
stop pls
abcdef<EOF>
^
Prelude&gt; parseString (string &quot;abc&quot;) mempty &quot;abcdef&quot;
Success &quot;abc&quot;
Prelude&gt; parseString (string &quot;abc&quot; &gt;&gt; stop) mempty &quot;abcdef&quot;
Failure (interactive):1:4: error: unexpected
stop pls
abcdef<EOF>
^
Note that we can also parse UTF-8 encoded ByteString s with
trifecta :
Prelude&gt; import Text.Trifecta
Prelude&gt; :t parseByteString
parseByteString
:: Parser a
-&gt; Text.Trifecta.Delta.Delta
-&gt; Data.ByteString.Internal.ByteString
-&gt; Result a
Prelude&gt; parseByteString (char 'a') mempty &quot;a&quot;
Success 'a'</p>
<p>CHAPTER 24. PARSER COMBINATORS 1416
This ends the free jazz session. We now return to serious
matters.
24.4 Parsing fractions
Now that we have some idea of what parsing is, what parser
combinators are, and what the monadic underpinnings of
parsing look like, let‚Äôs move on to parsing fractions. The top
of this module should look like this:
{-# LANGUAGE OverloadedStrings #-}
moduleText.Fractions where
importControl.Applicative
importData.Ratio ((%))
importText.Trifecta
We named the module Text.Fractions because we‚Äôre pars-
ing fractions out of text input, and there‚Äôs no need to be more
clever about it than that. We‚Äôre going to be using String in-
puts with trifecta at first, but you‚Äôll see why we threw an
OverloadedStrings extension in there later.
Now, on to parsing fractions! We‚Äôll start with some test
inputs:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1417
badFraction =&quot;1/0&quot;
alsoBad =&quot;10&quot;
shouldWork =&quot;1/2&quot;
shouldAlsoWork =&quot;2/1&quot;
Then we‚Äôll write our actual parser:
parseFraction ::ParserRational
parseFraction = do
numerator &lt;-decimal
-- [2] [1]
char'/'
-- [3]
denominator &lt;-decimal
-- [ 4 ]
return (numerator %denominator)
-- [5] [6]
1.decimal ::Integral a=&gt;Parsera
This is the type of decimal within the context of those
functions. If you use GHCi to query the type of decimal ,
you will see a more polymorphic type signature.
2.Herenumerator has the type Integral a =&gt; a .
3.char::Char-&gt;ParserChar</p>
<p>CHAPTER 24. PARSER COMBINATORS 1418
As with decimal , if you query the type of charin GHCi,
you‚Äôll see a more polymorphic type, but this is the type
ofcharin context.
4.Same deal as numerator , but when we match an integral
number we‚Äôre binding the result to the name denominator .
5.The final result has to be a parser, so we embed our inte-
gral value in the Parser type by using return.
6.We construct ratios using the %infix operator:
(%)::Integral a
=&gt;a-&gt;a-&gt;GHC.Real.Ratioa
Then the fact that our final result is a Rational makes the
Integral a =&gt; a values into concrete Integer values.
typeRational =GHC.Real.RatioInteger
We‚Äôll put together a quick shim main function to run the
parser against the test inputs and see the results:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1419
main::IO()
main= do
letparseFraction' =
parseString parseFraction mempty
print$parseFraction' shouldWork
print$parseFraction' shouldAlsoWork
print$parseFraction' alsoBad
print$parseFraction' badFraction
Try not to worry about the mempty values; it might give you
a clue about what‚Äôs going on in trifecta under the hood, but
it‚Äôs not something we‚Äôre going to explore in this chapter.
We will briefly note the type of parseString , which is how
we‚Äôre running the parser we created:
parseString ::Parsera
-&gt;Text.Trifecta .Delta.Delta
-&gt;String
-&gt;Resulta
The first argument is the parser we‚Äôre going to run against
the input, the second is a Delta, the third is the String we‚Äôre
parsing, and then the final result is either the thing we wanted
of type ùëéor an error string to let us know something went
wrong. You can ignore the Deltathing ‚Äî use mempty to provide
the do-nothing input. We won‚Äôt be covering deltas in this book
so consider it extra credit if you get curious.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1420
Anyway, when we run the code, the results look like this:
Prelude&gt; main
Success (1 % 2)
Success (2 % 1)
Failure (interactive):1:3: error: unexpected
EOF, expected: &quot;/&quot;, digit
10<EOF>
^
Success *** Exception: Ratio has zero denominator
The first two succeeded properly. The third failed because it
couldn‚Äôt parse a fraction out of the text ‚Äú10‚Äù. The error is telling
us that it ran out of text in the input stream while still waiting
for the character '/'. The final error did not result from the
process of parsing; we know that because it is a Success data
constructor. The final error resulted from trying to construct
a ratio with a denominator that is zero ‚Äî which makes no
sense. We can reproduce the issue in GHCi:
Prelude&gt; 1 % 0
*** Exception: Ratio has zero denominator
-- So the parser result is which is tantamount to
Prelude&gt; Success (1 % 0)
Success *** Exception: Ratio has zero denominator
This is sort of a problem because exceptions end our pro-
grams. Observe:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1421
main::IO()
main= do
letparseFraction' =
parseString parseFraction mempty
print$parseFraction' badFraction
print$parseFraction' shouldWork
print$parseFraction' shouldAlsoWork
print$parseFraction' alsoBad
We‚Äôve put the expression that throws an exception in the
first line this time, when we run it we get:
Prelude&gt; main
Success *** Exception: Ratio has zero denominator
So, our program halted on the error. This is not great. You
may be tempted to ‚Äúhandle‚Äù the error. Catching exceptions
is okay, but this is a particular class of exceptions that means
something is quite wrong with your program. You should elim-
inate the possibility of exceptions occurring in your programs
where possible.
We‚Äôll talk more about error handling in a later chapter, but
the idea here is that a Parser type already explicitly encodes
the possibility of failure. It‚Äôs better for a value of type Parser
ato have only one vector for errors and that vector is the
parser‚Äôs ability to encode failure. There may be an edge case</p>
<p>CHAPTER 24. PARSER COMBINATORS 1422
that doesn‚Äôt suit this design preference, but it‚Äôs a very good
idea to not have exceptions or bottoms that aren‚Äôt explicitly
called out as a possibility in the types whenever possible.
We could modify our program to handle the 0 denominator
case and change it into a parse error:
virtuousFraction ::ParserRational
virtuousFraction = do
numerator &lt;-decimal
char'/'
denominator &lt;-decimal
casedenominator of
0-&gt;fail&quot;Denominator cannot be zero&quot;
_ -&gt;return (numerator %denominator)
Here is our first explicit use of fail, which by historical ac-
cident is part of the Monadtypeclass. Realistically, not all Monads
have a proper implementation of fail, so it will be moved out
into aMonadFail class eventually. For now, it suffices to know
that it is our means of returning an error for the Parser type
here.
Now for another run of our test inputs, but with our more
cautious parser:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1423
testVirtuous ::IO()
testVirtuous = do
letvirtuousFraction' =
parseString virtuousFraction mempty
print$virtuousFraction' badFraction
print$virtuousFraction' alsoBad
print$virtuousFraction' shouldWork
print$virtuousFraction' shouldAlsoWork
When we run this, we‚Äôre going to get a slightly diÔ¨Äerent
result at the end:
Prelude&gt; testVirtuous
Failure (interactive):1:4: error: Denominator
cannot be zero, expected: digit
1/0<EOF>
^
Failure (interactive):1:3: error: unexpected
EOF, expected: &quot;/&quot;, digit
10<EOF>
^
Success (1 % 2)
Success (2 % 1)
Now we have no bottom causing the program to halt and
we get a Failure value which explains the cause for the failure.
Much better!</p>
<p>CHAPTER 24. PARSER COMBINATORS 1424
Exercise: Unit of Success
This should not be unfamiliar at this point, even if you do not
understand all the details:
Prelude&gt; parseString integer mempty &quot;123abc&quot;
Success 123
Prelude&gt; parseString (integer &gt;&gt; eof) mempty &quot;123abc&quot;
Failure (interactive):1:4: error: expected: digit,
end of input
123abc<EOF>
^
Prelude&gt; parseString (integer &gt;&gt; eof) mempty &quot;123&quot;
Success ()
You may have already deduced why it returns ()as aSuccess
result here; it‚Äôs consumed all the input but there is no result
to return from having done so. The result Success () tells you
the parse was successful and consumed the entire input, so
there‚Äôs nothing to return.
What we want you to try now is rewriting the final example
so it returns the integer that it parsed instead of Success () .
It should return the integer successfully when it receives an
input with an integer followed by an EOF and fail in all other
cases:
Prelude&gt; parseString (yourFuncHere) mempty &quot;123&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1425
Success 123
Prelude&gt; parseString (yourFuncHere) mempty &quot;123abc&quot;
Failure (interactive):1:4: error: expected: digit,
end of input
123abc<EOF>
^
24.5 Haskell‚Äôs parsing ecosystem
Haskell has several excellent parsing libraries available. parsec
andattoparsec are perhaps the two most well known parser
combinator libraries in Haskell, but there is also megaparsec
and others. aesonandcassava are among the libraries designed
for parsing specific types of data (JSON data and CSV data,
respectively).
For this chapter, we opted to use trifecta , as you‚Äôve seen.
One reason for that decision is that trifecta has error messages
that are very easy to read and interpret, unlike some other
libraries. Also, trifecta does not seem likely to undergo major
changes in its fundamental design. Its design is somewhat
unusual and complex, but most of the things that make it
unusual will be irrelevant to you in this chapter. If you intend
to do a lot of parsing in production, you may need to get
comfortable using attoparsec , as it is particularly known for
very speedy parsing; you will see some attoparsec (andaeson)
later in the chapter.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1426
The design of trifecta has evolved such that the API4is split
across two libraries, parsers5andtrifecta . The reason for this
is that the trifecta package itself provides the concrete im-
plementation of the trifecta parser as well as trifecta -specific
functionality, but the parsers API is a collection of typeclasses
that abstract over diÔ¨Äerent kinds of things parsers can do. The
Text.Trifecta module handles exporting what you need to get
started from each package, so this information is mostly so
you know where to look if you need to start spelunking.
Typeclasses of parsers
As we noted above, trifecta relies on the parsers library for
certain typeclasses. These typeclasses abstract over common
kinds of things parsers do. We‚Äôre only going to note a few
things here that we‚Äôll be seeing in the chapter so that you have
a sense of their provenance.
Note that the following is a discussion of code provided for
you by the parsers library, you do not need to type this in!
1.The typeclass Parsing hasAlternative as a superclass. We‚Äôll
talk more about Alternative in a bit. The Parsing typeclass
4API stands for application programming interface. When we write software that
relies on libraries or makes requests to a service such as Twitter ‚Äî basically, software
that relies on other software ‚Äî we rely on a set of defined functions. The API is that set
of functions that we use to interface with that software without having to write those
functions or worry too much about their source code. When you look at a library on
Hackage, (unless you click to view the source code), you‚Äôre looking at the API of that
library.
5http://hackage.haskell.org/package/parsers</p>
<p>CHAPTER 24. PARSER COMBINATORS 1427
provides for functionality needed to describe parsers in-
dependent of input type. A minimal complete instance of
this typeclass defines the following functions: try,(&lt;?&gt;),
andnotFollowedBy . Let‚Äôs start with try:
-- Text.Parser.Combinators
classAlternative m=&gt;Parsing mwhere
try::m a-&gt;m a
Thistakesaparserthatmayconsumeinputand, onfailure,
goes back to where it started and fails if we didn‚Äôt consume
input.
It also gives us the function notFollowedBy which does not
consume input but allows us to match on keywords by
matching on a string of characters that is not followed by
some thing we do not want to match:
notFollowedBy ::Showa=&gt;m a-&gt;m()
-- &gt; noAlpha = notFollowedBy alphaNum
-- &gt; keywordLet =
-- try $ string &quot;let&quot; &lt;* noAlpha
2.TheParsing typeclass also includes unexpected which is
used to emit an error on an unexpected token, as we saw
earlier, and eof. Theeoffunction only succeeds at the end
of input:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1428
eof::m()
-- &gt; eof =
-- notFollowedBy anyChar
-- &lt;?&gt; &quot;end of input&quot;
We‚Äôll be seeing more of this one in upcoming sections.
3.The library also defines the typeclass CharParsing , which
hasParsing as a superclass. This handles parsing individ-
ual characters.
-- Text.Parser.Char
classParsing m=&gt;CharParsing mwhere
We‚Äôve already seen charfrom this class, but it also includes
these:
-- Parses any single character other
-- than the one provided. Returns
-- the character parsed.
notChar ::Char-&gt;mChar
-- Parser succeeds for any character.
-- Returns the character parsed.
anyChar ::mChar</p>
<p>CHAPTER 24. PARSER COMBINATORS 1429
-- Parses a sequence of characters, returns
-- the string parsed.
string::String-&gt;mString
-- Parses a sequence of characters
-- represented by a Text value,
-- returns the parsed Text fragment.
text::Text-&gt;mText
Theparsers library has much more than this, but for our
immediate purposes these will suffice. The important point is
that it defines for us some typeclasses and basic combinators
for common parsing tasks. We encourage you to explore the
documentation more on your own.
24.6 Alternative
Let‚Äôs say we had a parser for numbers and one for alphanu-
meric strings:
Prelude&gt; import Text.Trifecta
Prelude&gt; parseString (some letter) mempty &quot;blah&quot;
Success &quot;blah&quot;
Prelude&gt; parseString integer mempty &quot;123&quot;
Success 123
What if we had a type that could be an Integer or aString ?</p>
<p>CHAPTER 24. PARSER COMBINATORS 1430
moduleAltParsing where
importControl.Applicative
importText.Trifecta
typeNumberOrString =
EitherInteger String
a=&quot;blah&quot;
b=&quot;123&quot;
c=&quot;123blah789&quot;
parseNos ::ParserNumberOrString
parseNos =
(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
main= do
letp f i=
parseString f mempty i
print$p (some letter) a
print$p integer b
print$p parseNos a
print$p parseNos b
print$p (many parseNos) c
print$p (some parseNos) c</p>
<p>CHAPTER 24. PARSER COMBINATORS 1431
We can read &lt;|&gt;as being an or, or disjunction, of our two
parsers; manyis zero or more and someis one or more.
Prelude&gt; parseString (some integer) mempty &quot;123&quot;
Success [123]
Prelude&gt; parseString (many integer) mempty &quot;123&quot;
Success [123]
Prelude&gt; parseString (many integer) mempty &quot;&quot;
Success []
Prelude&gt; parseString (some integer) mempty &quot;&quot;
Failure (interactive):1:1: error: unexpected
EOF, expected: integer
<EOF>
^
What we‚Äôre taking advantage of here with some,many, and
(&lt;|&gt;)is theAlternative typeclass:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1432
classApplicative f=&gt;Alternative fwhere
-- | The identity of '&lt;|&gt;'
empty::f a
-- | An associative binary operation
(&lt;|&gt;)::f a-&gt;f a-&gt;f a
-- | One or more.
some::f a-&gt;f [a]
some v=some_v
where
many_v=some_v&lt;|&gt;pure[]
some_v=(fmap (:) v)&lt;<em>&gt;many_v
-- | Zero or more.
many::f a-&gt;f [a]
many v=many_v
where
many_v=some_v&lt;|&gt;pure[]
some_v=(fmap (:) v)&lt;</em>&gt;many_v
If you use the :infocommand in the REPL after importing
Text.Trifecta or loading the above module, you‚Äôll find some
andmanyare defined in GHC.Base because they come from this
typeclass rather than being specific to a particular parser or to
theparsers library, or even to this particular problem domain.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1433
What if we wanted to require that each value be separated
by newline? QuasiQuotes lets us have a multiline string without
the newline separators and use it as a single argument:
{-# LANGUAGE QuasiQuotes #-}
moduleAltParsing where
importControl.Applicative
importText.RawString.QQ
importText.Trifecta
typeNumberOrString =
EitherInteger String
eitherOr ::String
eitherOr =[r|
123
abc
456
def
|]</p>
<p>CHAPTER 24. PARSER COMBINATORS 1434
QuasiQuotes
Above, the [r|is beginning a quasiquoted6section, using the
quasiquoter named r. Note we had to enable the QuasiQuotes
language extension to use this syntax. At time of writing ris
defined in raw-strings-qq version 1.1 as follows:
r::QuasiQuoter
r=QuasiQuoter {
-- Extracted from dead-simple-json.
quoteExp =
return.LitE.StringL
.normaliseNewlines,
-- error messages elided
quotePat =
_ -&gt;fail&quot;some error message&quot;
quoteType =
_ -&gt;fail&quot;some error message&quot;
quoteDec =
_ -&gt;fail&quot;some error message&quot;
The idea here is that this is a macro that lets us write ar-
bitrary text inside of the block that begins with [r|and ends
6There‚Äôs a rather nice wiki page and tutorial example at: https://wiki.haskell.org/
Quasiquotation</p>
<p>CHAPTER 24. PARSER COMBINATORS 1435
with|]. This specific quasiquoter exists to allow writing mul-
tiline strings without manual escaping. The quasiquoter is
generating the following for us:
&quot;\n<br />
\123\n<br />
\abc\n<br />
\456\n<br />
\def\n&quot;
Not as nice right? As it happens, if you want to see what
a quasiquoter or Template Haskell7is generating at compile-
time, you can enable the -ddump-splices flag to see what it does.
Here‚Äôs an example using a minimal stub file:
7https://wiki.haskell.org/Template_Haskell</p>
<p>CHAPTER 24. PARSER COMBINATORS 1436
{-# LANGUAGE QuasiQuotes #-}
moduleQuasimodo where
importText.RawString.QQ
eitherOr ::String
eitherOr =[r|
123
abc
456
def
|]
Then in GHCi we use the :setcommand to turn on the
splice dumping flag so we can see what the quasiquoter gener-
ated:
Prelude&gt; :set -ddump-splices
Prelude&gt; :l code/quasi.hs
[1 of 1] Compiling Quasimodo
code/quasi.hs:(8,12)-(12,2): Splicing expression
&quot;\n<br />
\123\n<br />
\abc\n<br />
\456\n&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1437
======&gt;
&quot;\n<br />
\123\n<br />
\abc\n<br />
\456\n&quot;
Right, so back to the parser we were going to write!
Return to Alternative
All right, we return now to our AltParsing module. We‚Äôre going
to use this fantastic function:
parseNos ::ParserNumberOrString
parseNos =
(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
and rewrite mainto apply that to the eitherOr value:
main= do
letp f i=parseString f mempty i
print$p parseNos eitherOr
Note that we lifted LeftandRightover their arguments.
This is because there is Parser structure between the (potential)
value obtained by running the parser and what the data con-
structor expects. A value of type Parser Char is a parser that</p>
<p>CHAPTER 24. PARSER COMBINATORS 1438
will possibly produce a Charvalue if it is given an input that
doesn‚Äôt cause it to fail. The type of some letter is the following:
Prelude&gt; import Text.Trifecta
Prelude&gt; :t some letter
some letter :: CharParsing f =&gt; f [Char]
However, for our purposes we can say that the type is specif-
icallytrifecta ‚ÄôsParser type:
Prelude&gt; let someLetter = some letter :: Parser [Char]
Prelude&gt; let someLetter = some letter :: Parser String
If we try to mash a data constructor expecting a String and
our parser-of-string together like a kid playing with action
figures, we get a type error:
Prelude&gt; data MyName = MyName String deriving Show
Prelude&gt; MyName someLetter
Couldn't match type ‚ÄòParser String‚Äô with ‚Äò[Char]‚Äô
Expected type: String
Actual type: Parser String
In the first argument of ‚ÄòMyName‚Äô, namely ‚ÄòsomeLetter‚Äô
In the expression: MyName someLetter
Unless we lift it over the Parser structure, since Parser is a
Functor !</p>
<p>CHAPTER 24. PARSER COMBINATORS 1439
Prelude&gt; :info Parser
{... content elided ...}
instance Monad Parser
instance Functor Parser
instance Applicative Parser
instance Monoid a =&gt; Monoid (Parser a)
instance Errable Parser
instance DeltaParsing Parser
instance TokenParsing Parser
instance Parsing Parser
instance CharParsing Parser
We should need an fmapright?
-- same deal
Prelude&gt; :t MyName &lt;$&gt; someLetter
MyName &lt;$&gt; someLetter :: Parser MyName
Prelude&gt; :t MyName <code>fmap</code> someLetter
MyName <code>fmap</code> someLetter :: Parser MyName
Then running either of them:
Prelude&gt; parseString someLetter mempty &quot;Chris&quot;
Success &quot;Chris&quot;
Prelude&gt; let mynameParser = MyName &lt;$&gt; someLetter
Prelude&gt; parseString mynameParser mempty &quot;Chris&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1440
Success (MyName &quot;Chris&quot;)
Cool.
Back to our original code, which will spit out an error:
Prelude&gt; main
Failure (interactive):1:1: error: expected: integer,
letter
It‚Äôs easier to see why if we look at the test string:
Prelude&gt; eitherOr
&quot;\n123\nabc\n456\ndef\n&quot;
One way to fix this is to amend the quasiquoted string:
eitherOr ::String
eitherOr =[r|123
abc
456
def
|]
What if we wanted to permit a newline before attempting
to parse strings or integers?</p>
<p>CHAPTER 24. PARSER COMBINATORS 1441
eitherOr ::String
eitherOr =[r|
123
abc
456
def
|]
parseNos ::ParserNumberOrString
parseNos =
skipMany (oneOf &quot;\n&quot;)
&gt;&gt;
(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
main= do
letp f i=parseString f mempty i
print$p parseNos eitherOr
Prelude&gt; main
Success (Left 123)
OK, but we‚Äôd like to keep parsing after each line. If we try
the obvious thing and use someto ask for one-or-more results,
we‚Äôll get a somewhat mysterious error:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1442
Prelude&gt; parseString (some parseNos) mempty eitherOr
Failure (interactive):6:1: error: unexpected
EOF, expected: integer, letter
<EOF>
^
The issue here is that while skipMany lets us skip zero or more
times, it means we started the next run of the parser before we
hit EOF. This means it expects us to match an integer or some
letters after having seen the newline character after ‚Äúdef‚Äù. We
can simply amend the input:
eitherOr ::String
eitherOr =[r|
123
abc
456
def|]
Our previous attempt will now work fine:
Prelude&gt; parseString (some parseNos) mempty eitherOr
Success [Left 123,Right &quot;abc&quot;,Left 456,Right &quot;def&quot;]
If we‚Äôre dissatisfied with simply changing the rules of the
game, there are a couple ways we can make our parser cope
withspuriousterminalnewlines. Oneistoaddanother skipMany
rule after we parse our value:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1443
parseNos ::ParserNumberOrString
parseNos = do
skipMany (oneOf &quot;\n&quot;)
v&lt;-(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
skipMany (oneOf &quot;\n&quot;)
return v
Another option is to keep the previous version of the parser
which skips a potential leading newline:
parseNos ::ParserNumberOrString
parseNos =
skipMany (oneOf &quot;\n&quot;)
&gt;&gt;
(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
But then tokenize it with the default tokenbehavior:
Prelude&gt; parseString (some (token parseNos)) mempty eitherOr
Success [Left 123,Right &quot;abc&quot;,Left 456,Right &quot;def&quot;]
We‚Äôll explain soon what this token stuÔ¨Ä is about, but we
want to be a bit careful here as token parsers and character
parsers are diÔ¨Äerent sorts of things. What applying tokento
parseNos did for us here is make it optionally consume trailing</p>
<p>CHAPTER 24. PARSER COMBINATORS 1444
whitespace we don‚Äôt care about, where whitespace includes
newline characters.
Exercise: Try Try
Make a parser, using the existing fraction parser plus a new dec-
imal parser, that can parse either decimals or fractions. You‚Äôll
want to use &lt;|&gt;fromAlternative to combine the‚Ä¶alternative
parsers. If you find this too difficult, write a parser that parses
straightforward integers or fractions. Make a datatype that
contains either an integer or a rational and use that datatype as
the result of the parser. Or use Either . Run free, grasshopper.
Hint: we‚Äôve not explained it yet, but you may want to try
try.
24.7 Parsing configuration files
For our next examples, we‚Äôll be using the INI8configuration
file format, partly because it‚Äôs an informal standard so we can
play fast and loose for learning and experimentation purposes.
We‚Äôre also using INI because it‚Äôs relatively uncomplicated.
Here‚Äôs a teensy example of an INI config file:
8INI is an informal standard for configuration files on some platforms. The name
comes from the file extension, .ini, short for ‚Äúinitialization.‚Äù</p>
<p>CHAPTER 24. PARSER COMBINATORS 1445
; comment
[section]
host=wikipedia .org
alias=claw
The above contains a comment, which contributes noth-
ing to the data parsed out of the configuration file but which
may provide context to the settings being configured. It‚Äôs fol-
lowed by a section header named &quot;section&quot; which contains
two settings: one named &quot;host&quot; with the value &quot;wikipedia.org&quot; ,
another named &quot;alias&quot; with the value &quot;claw&quot; .
We‚Äôll begin this example with our pragmas, module decla-
ration, and imports:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1446
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
moduleData.Ini where
importControl.Applicative
importData.ByteString (ByteString )
importData.Char (isAlpha)
importData.Map (Map)
import qualified Data.Map asM
importData.Text (Text)
import qualified Data.Text.IO asTIO
importTest.Hspec
importText.RawString.QQ
-- parsers 0.12.3, trifecta 1.5.2
importText.Trifecta
OverloadedStrings andQuasiQuotes should be familiar by now.
When writing parsers in Haskell, it‚Äôs often easiest to work in
terms of smaller parsers that deal with a sub-problem of the
overall parsing problem you‚Äôre solving, then combine them
into the final parser. This isn‚Äôt a perfect recipe for understand-
ing your parser, but being able to compose them straightfor-
wardly like functions is pretty nifty. Let‚Äôs start by creating a
test input for an INI header, a datatype, and then the parser</p>
<p>CHAPTER 24. PARSER COMBINATORS 1447
for it:
headerEx ::ByteString
headerEx =&quot;[blah]&quot;
-- &quot;[blah]&quot; -&gt; Section &quot;blah&quot;
newtype Header=
HeaderString
deriving (Eq,Ord,Show)
parseBracketPair ::Parsera-&gt;Parsera
parseBracketPair p=
char'['*&gt;p&lt;*char']'
-- these operators mean the brackets
-- will be parsed and then discarded
-- but the p will remain as our result
parseHeader ::ParserHeader
parseHeader =
parseBracketPair ( Header&lt;$&gt;some letter)
Here we‚Äôve combined two parsers in order to parse a Header .
We can experiment with each of them in the REPL. First
we‚Äôll examine the types of the some letter parser we passed to
parseBracketPair :</p>
<p>CHAPTER 24. PARSER COMBINATORS 1448
Prelude&gt; :t some letter
some letter :: CharParsing f =&gt; f [Char]
Prelude&gt; :t Header &lt;$&gt; some letter
Header &lt;$&gt; some letter :: CharParsing f =&gt; f Header
Prelude&gt; let slp = Header &lt;$&gt; some letter :: Parser Header
The first type is some parser that can understand characters
which will produce a String value if it succeeds. The second
type is the same, but produces a Header value instead of a String .
Parser types in Haskell almost always encode the possibility
of failure; we‚Äôll cover how later in this chapter. The third type
gives us concrete Parser type from trifecta where there had
been the polymorphic type ùëì.
Theletter function parses a single character, while some
letter parses one or more characters. We need to wrap the
Header constructor around that so that our result there ‚Äî what-
everlettersmightbeinsidethebrackets, the ùëùofparseBracketPair
‚Äî will be labeled as the Header of the file in the final parse.
Next,assignmentEx is just some test input so we can begin
kicking around our parser. The type synonyms are to make
the types more readable as well. Nothing too special here:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1449
assignmentEx ::ByteString
assignmentEx =&quot;woot=1&quot;
typeName=String
typeValue=String
typeAssignments =MapNameValue
parseAssignment ::Parser(Name,Value)
parseAssignment = do
name&lt;-some letter
_ &lt;-char'='
val&lt;-some (noneOf &quot;\n&quot;)
skipEOL -- important!
return (name, val)
-- | Skip end of line and
-- whitespace beyond.
skipEOL ::Parser()
skipEOL =skipMany (oneOf &quot;\n&quot;)
Let us explain parseAssignment step by step. For parsing the
initial key or name of an assignment, we parse one or more
letters:
name&lt;-some letter</p>
<p>CHAPTER 24. PARSER COMBINATORS 1450
Then we parse and throw away the ‚Äú=‚Äù used to separate keys
and values:
_ &lt;-char'='
Then we parse one or more characters as long as they aren‚Äôt
a newline. This is so letters, numbers, and whitespace are
permitted:
val&lt;-some (noneOf &quot;\n&quot;)
We skip ‚Äúend-of-line‚Äù until we stop getting newline charac-
ters:
skipEOL -- important!
This is so we can delineate the end of assignments and
parse more than one assignment in a straightforward manner.
Consider an alternative variant of this same parser that doesn‚Äôt
haveskipEOL :
parseAssignment' ::Parser(Name,Value)
parseAssignment' = do
name&lt;-some letter
_ &lt;-char'='
val&lt;-some (noneOf &quot;\n&quot;)
return (name, val)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1451
Then trying out this variant of the parser:
Prelude&gt; let spa' = some parseAssignment'
Prelude&gt; let s = &quot;key=value\nblah=123&quot;
Prelude&gt; parseString spa' mempty s
Success [(&quot;key&quot;,&quot;value&quot;)]
Pity. Can‚Äôt parse the second assignment. But the first ver-
sion that includes the skipEOL should work:
Prelude&gt; let spa = some parseAssignment
Prelude&gt; parseString spa mempty s
Success [(&quot;key&quot;,&quot;value&quot;),(&quot;blah&quot;,&quot;123&quot;)]
Prelude&gt; let d = &quot;key=value\n\n\ntest=data&quot;
Prelude&gt; parseString spa mempty d
Success [(&quot;key&quot;,&quot;value&quot;),(&quot;test&quot;,&quot;data&quot;)]
We have to skip the one-or-more newline characters sepa-
rating the first and second assignment in order for the rerun
of the assignment parser to begin successfully parsing the
letters that make up the key of the second assignment. Happy-
making, right?
We finish things oÔ¨Ä for parseAssignment by tupling name and
value together and re-embedding the result in the Parser type:
return(name, val)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1452
Then for dealing with INI comments, that is, skipping them
in the parser and discarding the data:
commentEx ::ByteString
commentEx =
&quot;; last modified 1 April <br />
\2001 by John Doe&quot;
commentEx' ::ByteString
commentEx' =
&quot;; blah\n; woot\n\n;hah&quot;
-- | Skip comments starting at the
-- beginning of the line.
skipComments ::Parser()
skipComments =
skipMany ( do _ &lt;- char';'&lt;|&gt;char'#'
skipMany (noneOf &quot;\n&quot;)
skipEOL)
We made a couple of comment examples for testing the
parser. Note that comments can begin with #or;.
Next, we need section parsing. We‚Äôll make some data for
testing that out, as we did with comments above. This is also
where we‚Äôll put that QuasiQuotes extension to use, allowing us
to make multiline strings nicer to write:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1453
sectionEx ::ByteString
sectionEx =
&quot;; ignore me \n[states] \nChris=Texas&quot;
sectionEx' ::ByteString
sectionEx' =[r|
; ignore me
[states]
Chris=Texas
|]
sectionEx'' ::ByteString
sectionEx'' =[r|
; comment
[section]
host=wikipedia .org
alias=claw
[whatisit]
red=intoothandclaw
|]
Then we get into the section parsing:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1454
dataSection =
Section HeaderAssignments
deriving (Eq,Show)
newtype Config=
Config(MapHeaderAssignments )
deriving (Eq,Show)
skipWhitespace ::Parser()
skipWhitespace =
skipMany (char ' '&lt;|&gt;char'\n')
parseSection ::ParserSection
parseSection = do
skipWhitespace
skipComments
h&lt;-parseHeader
skipEOL
assignments &lt;-some parseAssignment
return$
Section h (M.fromList assignments)
Above, we defined datatypes for a section and an entire INI
config. You‚Äôll notice that parseSection skips both whitespace
and comments now. And it returns the parsed section with</p>
<p>CHAPTER 24. PARSER COMBINATORS 1455
the header (that‚Äôs the ‚Ñé) and a map of assignments:
*Data.Ini&gt; parseByteString parseSection mempty sectionEx
Success (Section (Header &quot;states&quot;)
(fromList [(&quot;Chris&quot;,&quot;Texas&quot;)]))
So far, so good. Next, let‚Äôs roll the sections up into a Map
that keys section data by section name, with the values being
further more Maps of assignment names mapped to their
values. We use foldrto aggregate the list of sections into a
single Map value:
rollup::Section
-&gt;MapHeaderAssignments
-&gt;MapHeaderAssignments
rollup(Section h a) m=
M.insert h a m
parseIni ::ParserConfig
parseIni = do
sections &lt;-some parseSection
letmapOfSections =
foldr rollup M.empty sections
return ( ConfigmapOfSections)
After you load this code into your REPL, try running:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1456
parseByteString parseIni mempty sectionEx
and comparing it to the output of:
parseByteString parseSection mempty sectionEx
that you saw above.
Now we‚Äôll put these things together. We‚Äôre interested in
whether our parsers do what they should do rather than pars-
ing an actual INI file, so we‚Äôll have mainrun some hspectests.
We‚Äôll use a helper function, maybeSuccess , as part of the tests:
maybeSuccess ::Resulta-&gt;Maybea
maybeSuccess (Success a)=Justa
maybeSuccess _ =Nothing
main::IO()
main=hspec$ do
describe &quot;Assignment Parsing&quot; $
it&quot;can parse a simple assignment&quot; $ do
letm=parseByteString
parseAssignment
mempty assignmentEx
r'=maybeSuccess m
print m
r' <code>shouldBe</code> Just(&quot;woot&quot;,&quot;1&quot;)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1457
describe &quot;Header Parsing&quot; $
it&quot;can parse a simple header&quot; $ do
letm=
parseByteString parseHeader
mempty headerEx
r'=maybeSuccess m
print m
r' <code>shouldBe</code> Just(Header&quot;blah&quot;)
describe &quot;Comment parsing&quot; $
it&quot;Skips comment before header&quot; $ do
letp=skipComments &gt;&gt;parseHeader
i=&quot;; woot\n[blah]&quot;
m=parseByteString p mempty i
r'=maybeSuccess m
print m
r' <code>shouldBe</code> Just(Header&quot;blah&quot;)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1458
describe &quot;Section parsing&quot; $
it&quot;can parse a simple section&quot; $ do
letm=parseByteString parseSection
mempty sectionEx
r'=maybeSuccess m
states=
M.fromList [( &quot;Chris&quot;,&quot;Texas&quot;)]
expected' =
Just(Section (Header&quot;states&quot; )
states)
print m
r' <code>shouldBe</code> expected'</p>
<p>CHAPTER 24. PARSER COMBINATORS 1459
describe &quot;INI parsing&quot; $
it&quot;Can parse multiple sections&quot; $ do
letm=
parseByteString parseIni
mempty sectionEx''
r'=maybeSuccess m
sectionValues =
M.fromList
[ (&quot;alias&quot;,&quot;claw&quot;)
, (&quot;host&quot;,&quot;wikipedia.org&quot; )]
whatisitValues =
M.fromList
[(&quot;red&quot;,&quot;intoothandclaw&quot; )]
expected' =
Just(Config
(M.fromList
[ (Header&quot;section&quot;
, sectionValues)
, (Header&quot;whatisit&quot;
, whatisitValues)]))
print m
r' <code>shouldBe</code> expected'
We leave it to you to run this and experiment with it.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1460
24.8 Character and token parsers
All right, that was a lot of code. Let‚Äôs all step back and take a
deep breath.
You probably have some idea by now of what we mean by
tokenizing, but the time has come for more detail. Tokeniza-
tion is a handy parsing tactic, so it‚Äôs baked into some of the
library functions we‚Äôve been using. It‚Äôs worth diving in and
exploring what it means.
Traditionally, parsing has been done in two stages, lexing
and parsing. Characters from a stream will be fed into the
lexer, which will then emit tokens on demand to the parser
until it has no more to emit.9The parser then structures the
stream of tokens into a tree, commonly called an ‚Äúabstract
syntax tree‚Äù or AST:
-- hand-wavy types: Stream because
-- production-grade parsers in Haskell
-- won't use [] for performance reasons
lexer::StreamChar-&gt;StreamToken
parser::StreamToken-&gt;AST
Lexers are simpler, typically performing parses that don‚Äôt
require looking ahead into the input stream by more than
9Lexers and tokenizers are similar, separating a stream of text into tokens based on
indicators such as whitespace or newlines; lexers often attach some context to the tokens,
where tokenizers typically do not.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1461
one character or token at a time. Lexers are at times called
tokenizers. Lexing is sometimes done with regular expres-
sions, but a parsing library in Haskell will usually intend that
you do your lexing and parsing with the same API. Lexers (or
tokenizers) and parsers have a lot in common, being primarily
diÔ¨Äerentiated by their purpose and class of grammar.10
Insert tokens to play
Let‚Äôs play around with some things to see what tokenizing
does for us:
Prelude&gt; parseString (some digit) mempty &quot;123 456&quot;
Success &quot;123&quot;
Prelude&gt; parseString (some (some digit)) mempty &quot;123 456&quot;
Success [&quot;123&quot;]
Prelude&gt; parseString (some integer) mempty &quot;123&quot;
Success [123]
Prelude&gt; parseString (some integer) mempty &quot;123456&quot;
Success [123456]
The problem here is that if we wanted to recognize 123 and
456 as independent strings, we need some kind of separator.
Now we can go ahead and do that manually, but the tokenizers
10Formal grammars ‚Äî rules for generating strings in a formal language ‚Äî are placed
in a hierarchy, often called the Chomsky hierarchy after the linguist Noam Chomsky.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1462
inparsers can do it for you too, also handling a mixture of
whitespace and newlines:
Prelude&gt; parseString (some integer) mempty &quot;123 456&quot;
Success [123,456]
Prelude&gt; parseString (some integer) mempty &quot;123\n\n 456&quot;
Success [123,456]
Or even space and newlines interleaved:
Prelude&gt; parseString (some integer) mempty &quot;123 \n \n 456&quot;
Success [123,456]
But simply applying tokentodigitdoesn‚Äôt do what you
think:
Prelude&gt; let s = &quot;123 \n \n 456&quot;
Prelude&gt; parseString (token (some digit)) mempty s
Success &quot;123&quot;
Prelude&gt; parseString (token (some (token digit))) mempty s
Success &quot;123456&quot;
Prelude&gt; parseString (some decimal) mempty s
Success [123]
Prelude&gt; parseString (some (token decimal)) mempty s
Success [123,456]
Compare that to the integer function, which is already a
tokenizer:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1463
Prelude&gt; parseString (some integer) mempty &quot;1\n2\n 3\n&quot;
Success [1,2,3]
We can write a tokenizing parser like some integer like this:
p'::Parser[Integer]
p'=some$ do
i&lt;-token (some digit)
return (read i)
And we can compare the output of that to the output of
applying tokentodigit:
Prelude&gt; let s = &quot;1\n2\n3&quot;
Prelude&gt; parseString p' mempty s
Success [1,2,3]
Prelude&gt; parseString (token (some digit)) mempty s
Success &quot;1&quot;
Prelude&gt; parseString (some (token (some digit))) mempty s
Success [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
You‚Äôll want to think carefully about the scope at which
you‚Äôre tokenizing as well:
Prelude&gt; let tknWhole = token $ char 'a' &gt;&gt; char 'b'
Prelude&gt; parseString tknWhole mempty &quot;a b&quot;
Failure (interactive):1:2: error: expected: &quot;b&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1464
a b<EOF>
^
Prelude&gt; parseString tknWhole mempty &quot;ab ab&quot;
Success 'b'
Prelude&gt; parseString (some tknWhole) mempty &quot;ab ab&quot;
Success &quot;bb&quot;
If we wanted that first example to work, we need to tokenize
the parse of the first character, not the whole a-then-b parse:
Prelude&gt; let tknCharA = (token (char 'a')) &gt;&gt; char 'b'
Prelude&gt; parseString tknCharA mempty &quot;a b&quot;
Success 'b'
Prelude&gt; parseString (some tknCharA) mempty &quot;a ba b&quot;
Success &quot;bb&quot;
Prelude&gt; parseString (some tknCharA) mempty &quot;a b a b&quot;
Success &quot;b&quot;
The last example stops at the first ùëé ùëèparse because the
parser doesn‚Äôt say anything about a space after ùëèand the tok-
enization behavior only applies to what followed ùëé. We can
tokenize both character parsers though:
Prelude&gt; let tknBoth = token (char 'a') &gt;&gt; token (char 'b')
Prelude&gt; parseString (some tknBoth) mempty &quot;a b a b&quot;
Success &quot;bb&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1465
A mild warning: don‚Äôt get too tokenization happy. Try to
make it coarse-grained and selective. Overuse of tokenizing
parsersormixturewithcharacterparserscanmakeyourparser
slow or hard to understand. Use your judgment. Keep in mind
that tokenization isn‚Äôt exclusively about whitespace; it‚Äôs about
ignoring noise so you can focus on the structures you are
parsing.
24.9 Polymorphic parsers
If we take the time to assert polymorphic types for our parsers,
we can get parsers that can be run using attoparsec ,trifecta ,
parsec, or anything else that has implemented the necessary
typeclasses. Let‚Äôs give it a whirl, shall we?
{-# LANGUAGE OverloadedStrings #-}
moduleText.Fractions where
importControl.Applicative
importData.Attoparsec.Text (parseOnly )
importData.Ratio ((%))
importData.String (IsString )
importText.Trifecta</p>
<p>CHAPTER 24. PARSER COMBINATORS 1466
badFraction ::IsString s=&gt;s
badFraction =&quot;1/0&quot;
alsoBad ::IsString s=&gt;s
alsoBad =&quot;10&quot;
shouldWork ::IsString s=&gt;s
shouldWork =&quot;1/2&quot;
shouldAlsoWork ::IsString s=&gt;s
shouldAlsoWork =&quot;2/1&quot;
parseFraction ::(Monadm,TokenParsing m)
=&gt;mRational
parseFraction = do
numerator &lt;-decimal
_ &lt;-char'/'
denominator &lt;-decimal
casedenominator of
0-&gt;fail&quot;Denominator cannot be zero&quot;
_ -&gt;return (numerator %denominator)
We‚Äôve left some typeclass-constrained polymorphism in
our type signatures for flexibility. Our mainwill run both
attoparsec andtrifecta versions for us so we can compare the
outputs directly:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1467
main::IO()
main= do
-- parseOnly is Attoparsec
letattoP=parseOnly parseFraction
print$attoP badFraction
print$attoP shouldWork
print$attoP shouldAlsoWork
print$attoP alsoBad
-- parseString is Trifecta
letp f i=
parseString f mempty i
print$p parseFraction badFraction
print$p parseFraction shouldWork
print$p parseFraction shouldAlsoWork
print$p parseFraction alsoBad
Prelude&gt; main
Left &quot;Failed reading: Denominator cannot be zero&quot;
Right (1 % 2)
Right (2 % 1)
Left &quot;&quot;/&quot;: not enough input&quot;
Failure (interactive):1:4: error: Denominator
cannot be zero, expected: digit
1/0<EOF></p>
<p>CHAPTER 24. PARSER COMBINATORS 1468
^
Success (1 % 2)
Success (2 % 1)
Failure (interactive):1:3: error: unexpected
EOF, expected: &quot;/&quot;, digit
10<EOF>
^
See what we meant earlier about the error messages?
It‚Äôs not perfect and could bite you
While the polymorphic parser combinators in the parsers li-
brary enable you to write parsers which can then be run with
various parsing libraries, this doesn‚Äôt free you of understand-
ing the particularities of each. In general, trifecta tries to
matchparsec ‚Äôs behaviors in most respects, the latter of which
is more extensively documented.
Failure and backtracking
Returning to our cursor model of parsers, backtracking is
returning the cursor to where it was before a failing parser
consumed input. In some cases, it can be a little confusing
to debug the same error in two diÔ¨Äerent runs of the same
parser doing essentially the same things in trifecta ,parsec,</p>
<p>CHAPTER 24. PARSER COMBINATORS 1469
andattoparsec , but the errors themselves might be diÔ¨Äerent.
Let‚Äôs consider an example of this.
{-# LANGUAGE OverloadedStrings #-}
We use OverloadedStrings so that we can use string literals as
if they were ByteStrings when testing attoparsec :
moduleBTwhere
importControl.Applicative
import qualified Data.Attoparsec.ByteString
asA
importData.Attoparsec.ByteString
(parseOnly )
importData.ByteString (ByteString )
importText.Trifecta hiding(parseTest )
importText.Parsec (Parsec,parseTest )
trifP::Showa
=&gt;Parsera
-&gt;String-&gt;IO()
trifPp i=
print$parseString p mempty i
Helper function to run a trifecta parser and print the result:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1470
parsecP ::(Showa)
=&gt;ParsecString()a
-&gt;String-&gt;IO()
parsecP =parseTest
Helper function to run a parsec parser and print the result:
attoP::Showa
=&gt;A.Parsera
-&gt;ByteString -&gt;IO()
attoPp i=
print$parseOnly p i
Helper function for attoparsec ‚Äî same deal as before:
nobackParse ::(Monadf,CharParsing f)
=&gt;fChar
nobackParse =
(char'1'&gt;&gt;char'2')
&lt;|&gt;char'3'
Here‚Äôs our first parser. It attempts to parse '1'followed by
'2'or'3'. This parser does not backtrack:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1471
tryParse ::(Monadf,CharParsing f)
=&gt;fChar
tryParse =
try (char '1'&gt;&gt;char'2')
&lt;|&gt;char'3'
This parser has similar behavior to the previous one, except
it backtracks if the first parse fails. Backtracking means that the
input cursor returns to where it was before the failed parser
consumed input.
main::IO()
main= do
-- trifecta
trifP nobackParse &quot;13&quot;
trifP tryParse &quot;13&quot;
-- parsec
parsecP nobackParse &quot;13&quot;
parsecP tryParse &quot;13&quot;
-- attoparsec
attoP nobackParse &quot;13&quot;
attoP tryParse &quot;13&quot;
The error messages you get from each parser are going
to vary a bit. This isn‚Äôt because they‚Äôre wildly diÔ¨Äerent, but</p>
<p>CHAPTER 24. PARSER COMBINATORS 1472
is mostly due to how they attribute errors. You should see
something like:
Prelude&gt; main
Failure (interactive):1:2:
error: expected: &quot;2&quot;
13<EOF>
^
Failure (interactive):1:1: error:
expected: &quot;3&quot;
13<EOF>
^
parse error at (line 1, column 2):
unexpected &quot;3&quot;
expecting &quot;2&quot;
parse error at (line 1, column 2):
unexpected &quot;3&quot;
expecting &quot;2&quot;
Left &quot;&quot;3&quot;: satisfyElem&quot;
Left &quot;&quot;3&quot;: satisfyElem&quot;
Conversely, if you try the valid inputs &quot;12&quot;and&quot;3&quot;with
nobackParse and each of the three parsers, you should see all of
them succeed.
This can be confusing. When you add backtracking to a
parser, error attribution can become more complicated at</p>
<p>CHAPTER 24. PARSER COMBINATORS 1473
times. To avoid this, consider using the &lt;?&gt;operator to anno-
tate parse rules any time you use try.11
tryAnnot ::(Monadf,CharParsing f)
=&gt;fChar
tryAnnot =
(try (char '1'&gt;&gt;char'2')</p>
<?>"Tried 12" )
<p>&lt;|&gt;(char'3'&lt;?&gt;&quot;Tried 3&quot; )
Then running this in the REPL:
Prelude&gt; trifP tryAnnot &quot;13&quot;
Failure (interactive):1:1: error: expected: Tried 12,
Tried 3
13<EOF>
^
Now the error will list the parses it attempted before it failed.
You‚Äôll want to make the annotations more informative than
what we demonstrated in your own parsers.
11Parsec ‚Äútry a &lt;|&gt; b‚Äù considered harmful; Edward Z. Yang</p>
<p>CHAPTER 24. PARSER COMBINATORS 1474
24.10 Marshalling from an AST to a
datatype
Fair warning: This section relies on a little more background
knowledge from you than previous sections have. If you are
not a person who already has some programming experience,
the following may not seem terribly useful to you, and there
may be some unfamiliar terminology and concepts.
The act of parsing, in a sense, is a means of necking down
the cardinality of our inputs to the set of things our programs
have a sensible answer for. It‚Äôs unlikely you can do some-
thing meaningful and domain-specific when your input type
isString ,Text, orByteString . However, if you can parse one of
those types into something structured, rejecting bad inputs,
then you might be able to write a proper program. One of the
mistakes programmers make in writing programs handling
text is in allowing their data to stay in the textual format, doing
mind-bending backflips to cope with the unstructured nature
of textual inputs.
In some cases, the act of parsing isn‚Äôt enough. You might
have a sort of AST or structured representation of what was
parsed, but from there, you might expect that AST or repre-
sentation to take a particular form. This means we want to
narrow the cardinality and get even more specific about how
our data looks. Often this second step is called unmarshalling</p>
<p>CHAPTER 24. PARSER COMBINATORS 1475
our data. Similarly, marshalling is the act of preparing data
for serialization, whether via memory alone (foreign function
interface boundary) or over a network interface.
The whole idea here is that you have two pipelines for your
data:
Text-&gt;Structure -&gt;Meaning
-- parse -&gt; unmarshall
Meaning -&gt;Structure -&gt;Text
-- marshall -&gt; serialize
There isn‚Äôt only one way to accomplish this, but we‚Äôll show
you a commonly used library and how it has this two-stage
pipeline in the API.
Marshalling and unmarshalling JSON data
aesonis presently the most popular JSON12library in Haskell.
One of the things that‚Äôll confuse programmers coming to
Haskell from Python, Ruby, Clojure, JavaScript, or similar
languages, is that there‚Äôs usually no unmarshall/marshall step.
Instead, the raw JSON AST will be represented directly as an
untyped blob of data. Users of typed languages are more likely
12JSON stands for JavaScript Object Notation. JSON is, for better or worse, a very
common open-standard data format used to transmit data, especially between browsers
and servers. As such, dealing with JSON is a common programming task, so you might
as well get used to it now.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1476
to have encountered something like this. We‚Äôll be using aeson
0.10.0.0 for the following examples.
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
moduleMarshalling where
importData.Aeson
importData.ByteString.Lazy (ByteString )
importText.RawString.QQ
sectionJson ::ByteString
sectionJson =[r|
{&quot;section&quot; :{&quot;host&quot;:&quot;wikipedia.org&quot; },
&quot;whatisit&quot; :{&quot;red&quot;:&quot;intoothandclaw&quot; }
}
|]
Notethatwe‚Äôresayingthetypeof sectionJson isalazy ByteString .
If you get strict and lazy ByteString types mixed up you‚Äôll get
errors.
Provided a strict ByteString when a lazy one was expected:
<interactive>:10:8:
Couldn't match expected type</p>
<p>CHAPTER 24. PARSER COMBINATORS 1477
Data.ByteString.Lazy.Internal.ByteString
with actual type ByteString
NB:
Data.ByteString.Lazy.Internal.ByteString
is defined in
Data.ByteString.Lazy.Internal
ByteString
is defined in
Data.ByteString.Internal
The actual type is what we provided; the expected type is
what the types wanted. The NB:in the type error stands for
nota bene. Either we used the wrong code (so expected type
needs to change), or we provided the wrong values (actual
type, our types/values, need to change). You can reproduce
this error by making the following mistake in the marshalling
module:
-- Change the import of the ByteString
-- type constructor from:
importData.ByteString.Lazy (ByteString )
-- Into:
importData.ByteString (ByteString )</p>
<p>CHAPTER 24. PARSER COMBINATORS 1478
Provided a lazy ByteString when a strict one was expected:
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
moduleWantedStrict where
importData.Aeson
importData.ByteString.Lazy (ByteString )
importText.RawString.QQ
sectionJson ::ByteString
sectionJson =[r|
{&quot;section&quot; :{&quot;host&quot;:&quot;wikipedia.org&quot; },
&quot;whatisit&quot; :{&quot;red&quot;:&quot;intoothandclaw&quot; }
}
|]
main= do
letblah::MaybeValue
blah=decodeStrict sectionJson
print blah
You‚Äôll get the following type error if you load that up:
code/wantedStrictGotLazy.hs:19:27:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1479
Couldn't match expected type
‚ÄòData.ByteString.Internal.ByteString‚Äô
with actual type ‚ÄòByteString‚Äô
NB:
‚ÄòData.ByteString.Internal.ByteString‚Äô
is defined in ‚ÄòData.ByteString.Internal‚Äô
‚ÄòByteString‚Äô is defined in ‚ÄòData.ByteString.Lazy.Internal‚Äô
In the first argument of ‚ÄòdecodeStrict‚Äô,
namely ‚ÄòsectionJson‚Äô
In the expression: decodeStrict sectionJson
The more useful information is in the NB:or nota bene,
where the internal modules are mentioned. The key is to re-
member actual type means ‚Äúyour code‚Äù, expected type means
‚Äúwhat they expected,‚Äù and that the ByteString module that
doesn‚Äôt have Lazyin the name is the strict version. We can
modify our code a bit to get nicer type errors:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1480
-- replace the (ByteString)
-- import with these
import qualified Data.ByteString asBS
import qualified Data.ByteString.Lazy
asLBS
-- edit the type sig for this one
sectionJson ::LBS.ByteString
Then we‚Äôll get the following type error instead:
Couldn't match expected type ‚ÄòBS.ByteString‚Äô
with actual type ‚ÄòLBS.ByteString‚Äô
NB: ‚ÄòBS.ByteString‚Äô is defined in
‚ÄòData.ByteString.Internal‚Äô
‚ÄòLBS.ByteString‚Äô is defined in
‚ÄòData.ByteString.Lazy.Internal‚Äô
In the first argument of ‚ÄòdecodeStrict‚Äô,
namely ‚ÄòsectionJson‚Äô
In the expression: decodeStrict sectionJson
This is helpful because we have both versions available as
qualified modules. You may not always be so fortunate and
will need to remember which is which.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1481
Back to the JSON
Let‚Äôs get back to handling JSON. The most common functions
for using aesonare the following:
Prelude&gt; import Data.Aeson
Prelude&gt; :t encode
encode :: ToJSON a =&gt; a -&gt; LBS.ByteString
Prelude&gt; :t decode
decode :: FromJSON a =&gt; LBS.ByteString -&gt; Maybe a
These functions are sort of eliding the intermediate step
that passes through the Value type in aeson, which is a datatype
JSON AST ‚Äî ‚Äúsort of,‚Äù because you can decode the raw JSON
data into a Valueanyway:
Prelude&gt; decode sectionJson :: Maybe Value
Just (Object (fromList [
(&quot;whatisit&quot;,
Object (fromList [(&quot;red&quot;,
String &quot;intoothandclaw&quot;)])),
(&quot;section&quot;,
Object (fromList [(&quot;host&quot;,
String &quot;wikipedia.org&quot;)]))]))
Not, uh, super pretty. We‚Äôll figure out something nicer in
a moment. Also do not forget to assert a type, or the type-
defaulting in GHCi will do silly things:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1482
Prelude&gt; decode sectionJson
Nothing
Now what if we do want a nicer representation for this JSON
noise? Well, let‚Äôs define our datatypes and see if we can decode
the JSON into our type:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1483
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
moduleMarshalling where
importControl.Applicative
importData.Aeson
importData.ByteString.Lazy (ByteString )
import qualified Data.Text asT
importData.Text (Text)
importText.RawString.QQ
sectionJson ::ByteString
sectionJson =[r|
{&quot;section&quot; :{&quot;host&quot;:&quot;wikipedia.org&quot; },
&quot;whatisit&quot; :{&quot;red&quot;:&quot;intoothandclaw&quot; }
}
|]
dataTestData =
TestData {
section ::Host
, what::Color
}deriving (Eq,Show)
newtype Host=
HostString
deriving (Eq,Show)
typeAnnotation =String
dataColor=
RedAnnotation
|BlueAnnotation
|YellowAnnotation
deriving (Eq,Show)
main= do
letd::MaybeTestData
d=decode sectionJson
print d</p>
<p>CHAPTER 24. PARSER COMBINATORS 1484
This will in fact net you a type error complaining about
there not being an instance of FromJSON forTestData . Which is
true! GHC has no idea how to unmarshall JSON data (in the
form of a Value) into a TestData value. Let‚Äôs add an instance so
it knows how:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1485
instance FromJSON TestData where
parseJSON ( Objectv)=
TestData &lt;$&gt;v.:&quot;section&quot;
&lt;*&gt;v.:&quot;whatisit&quot;
parseJSON _ =
fail&quot;Expected an object for TestData&quot;
instance FromJSON Hostwhere
parseJSON ( Objectv)=
Host&lt;$&gt;v.:&quot;host&quot;
parseJSON _ =
fail&quot;Expected an object for Host&quot;
instance FromJSON Colorwhere
parseJSON ( Objectv)=
(Red&lt;$&gt;v.:&quot;red&quot;)
&lt;|&gt;(Blue&lt;$&gt;v.:&quot;blue&quot;)
&lt;|&gt;(Yellow&lt;$&gt;v.:&quot;yellow&quot; )
parseJSON _ =
fail&quot;Expected an object for Color&quot;
Also note that you can use quasiquotes to avoid having to
escape quotation marks in the REPL as well:
Prelude&gt; :set -XOverloadedStrings
Prelude&gt; decode &quot;{&quot;blue&quot;: &quot;123&quot;}&quot; :: Maybe Color</p>
<p>CHAPTER 24. PARSER COMBINATORS 1486
Just (Blue &quot;123&quot;)
Prelude&gt; :set -XQuasiQuotes
Prelude&gt; decode [r|{&quot;red&quot;: &quot;123&quot;}|] :: Maybe Color
Just (Red &quot;123&quot;)
To relate what we just did back to the relationship between
parsing and marshalling, the idea is that our FromJSON instance
is accepting the Valuetype and ToJSON instances generate the
Valuetype, closing the following loop:
-- FromJSON
ByteString -&gt;Value-&gt;yourType
-- parse -&gt; unmarshall
-- ToJSON
yourType -&gt;Value-&gt;ByteString
-- marshall -&gt; serialize
The definition of Valueat time of writing is the following:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1487
-- | A JSON value represented
-- as a Haskell value.
dataValue=Object!Object
|Array!Array
|String!Text
|Number!Scientific
|Bool!Bool
|Null
deriving (Eq,Read,Show,
Typeable ,Data)
What if we want to unmarshall something that could be a
Number or aString ?
dataNumberOrString =
NumbaInteger
|Stringy Text
deriving (Eq,Show)
instance FromJSON NumberOrString where
parseJSON ( Numberi)=return$Numbai
parseJSON ( Strings)=return$Stringy s
parseJSON _ =
fail&quot;NumberOrString must <br />
\be number or string&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1488
This won‚Äôt quite work at first. The trouble is that JSON (and
JavaScript, as it happens) only has one numeric type and that
type is a IEEE-754 float. JSON (and JavaScript, terrifyingly)
have no integral types or integers, so aesonhas to pick one
representation that works for all possible JSON numbers. The
most precise way to do that is the Scientific type which is an
arbitrarily precise numerical type (you may remember this
from way back in Chapter 4, Basic Datatypes). So we need to
convert from a Scientific to anInteger :
importControl.Applicative
importData.Aeson
importData.ByteString.Lazy (ByteString )
import qualified Data.Text asT
importData.Text (Text)
importText.RawString.QQ
importData.Scientific (floatingOrInteger )
dataNumberOrString =
NumbaInteger
|Stringy Text
deriving (Eq,Show)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1489
instance FromJSON NumberOrString where
parseJSON ( Numberi)=
casefloatingOrInteger i of
(Left_)-&gt;
fail&quot;Must be integral number&quot;
(Rightinteger) -&gt;
return$Numbainteger
parseJSON ( Strings)=return$Stringy s
parseJSON _ =
fail&quot;NumberOrString must <br />
\be number or string&quot;
-- so it knows what we want to parse
dec::ByteString
-&gt;MaybeNumberOrString
dec=decode
eitherDec ::ByteString
-&gt;EitherStringNumberOrString
eitherDec =eitherDecode
main= do
print$dec&quot;blah&quot;
Now let‚Äôs give it a whirl:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1490
Prelude&gt; main
Nothing
Butwhathappened? Wecanrewritethecodetouse eitherDec
to get a slightly more helpful type error:
main= do
print$dec&quot;blah&quot;
print$eitherDec &quot;blah&quot;
Then reloading the code and trying again in the REPL:
Prelude&gt; main
Nothing
Left &quot;Error in $: Failed reading:
not a valid json value&quot;
By that means, we are able to get more informative errors
fromaeson. If we wanted some examples that worked, we
could try things like the following:
Prelude&gt; dec &quot;123&quot;
Just (Numba 123)
Prelude&gt; dec &quot;&quot;blah&quot;&quot;
Just (Stringy &quot;blah&quot;)
It‚Äôs worth getting comfortable with aesoneven if you don‚Äôt
plan to work with much JSON because many serialization</p>
<p>CHAPTER 24. PARSER COMBINATORS 1491
libraries in Haskell follow a similar API pattern. Play with the
example and see how you need to change the type of decto
be able to parse a list of numbers or strings.
24.11 Chapter Exercises
1.Write a parser for semantic versions as defined by http:
//semver.org/ . After making a working parser, write an Ord
instance for the SemVer type that obeys the specification
outlined on the SemVer website.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1492
-- Relevant to precedence/ordering,
-- cannot sort numbers like strings.
dataNumberOrString =
NOSSString
|NOSIInteger
typeMajor=Integer
typeMinor=Integer
typePatch=Integer
typeRelease =[NumberOrString ]
typeMetadata =[NumberOrString ]
dataSemVer=
SemVerMajorMinorPatchRelease Metadata
parseSemVer ::ParserSemVer
parseSemVer =undefined
Expected results:
Prelude&gt; parseString parseSemVer mempty &quot;2.1.1&quot;
Success (SemVer 2 1 1 [] [])
Prelude&gt; parseString parseSemVer mempty &quot;1.0.0-x.7.z.92&quot;
Success (SemVer 1 0 0
[NOSS &quot;x&quot;, NOSI 7, NOSS &quot;z&quot;, NOSI 92] [])</p>
<p>CHAPTER 24. PARSER COMBINATORS 1493
Prelude&gt; SemVer 2 1 1 [] [] &gt; SemVer 2 1 0 [] []
True
2.Write a parser for positive integer values. Don‚Äôt reuse the
pre-existing digitorinteger functions, but you can use
the rest of the libraries we‚Äôve shown you so far. You are
not expected to write a parsing library from scratch.
parseDigit ::ParserChar
parseDigit =undefined
base10Integer ::ParserInteger
base10Integer =undefined
Expected results:
Prelude&gt; parseString parseDigit mempty &quot;123&quot;
Success '1'
Prelude&gt; parseString parseDigit mempty &quot;abc&quot;
Failure (interactive):1:1: error: expected: parseDigit
abc<EOF>
^
Prelude&gt; parseString base10Integer mempty &quot;123abc&quot;
Success 123
Prelude&gt; parseString base10Integer mempty &quot;abc&quot;
Failure (interactive):1:1: error: expected: integer</p>
<p>CHAPTER 24. PARSER COMBINATORS 1494
abc<EOF>
^
Hint: Assume you‚Äôre parsing base-10 numbers. Use arith-
metic as a cheap ‚Äúaccumulator‚Äù for your final number as
you parse each digit left-to-right.
3.Extend the parser you wrote to handle negative and pos-
itive integers. Try writing a new parser in terms of the
one you already have to do this.
Prelude&gt; parseString base10Integer' mempty &quot;-123abc&quot;
Success (-123)
4.Write a parser for US/Canada phone numbers with vary-
ing formats.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1495
-- aka area code
typeNumberingPlanArea =Int
typeExchange =Int
typeLineNumber =Int
dataPhoneNumber =
PhoneNumber NumberingPlanArea
Exchange LineNumber
deriving (Eq,Show)
parsePhone ::ParserPhoneNumber
parsePhone =undefined
With the following behavior:
Prelude&gt; parseString parsePhone mempty &quot;123-456-7890&quot;
Success (PhoneNumber 123 456 7890)
Prelude&gt; parseString parsePhone mempty &quot;1234567890&quot;
Success (PhoneNumber 123 456 7890)
Prelude&gt; parseString parsePhone mempty &quot;(123) 456-7890&quot;
Success (PhoneNumber 123 456 7890)
Prelude&gt; parseString parsePhone mempty &quot;1-123-456-7890&quot;
Success (PhoneNumber 123 456 7890)
Cf. Wikipedia‚Äôs article on ‚ÄúNational conventions for writ-
ing telephone numbers‚Äù. You are encouraged to adapt the</p>
<p>CHAPTER 24. PARSER COMBINATORS 1496
exercise to your locality‚Äôs conventions if they are not part
of the NNAP scheme.
5.Write a parser for a log file format and sum the time
spent in each activity. Additionally, provide an alterna-
tive aggregation of the data that provides average time
spent per activity per day. The format supports the use
of comments which your parser will have to ignore. The
#characters followed by a date mark the beginning of a
particular day.
Log format example:
-- wheee a comment</p>
<h1 id="2025-02-05"><a class="header" href="#2025-02-05">2025-02-05</a></h1>
<p>08:00 Breakfast
09:00 Sanitizing moisture collector
11:00 Exercising in high-grav gym
12:00 Lunch
13:00 Programming
17:00 Commuting home in rover
17:30 R&amp;R
19:00 Dinner
21:00 Shower
21:15 Read
22:00 Sleep</p>
<p>CHAPTER 24. PARSER COMBINATORS 1497</p>
<h1 id="2025-02-07----dates-not-nececessarily-sequential"><a class="header" href="#2025-02-07----dates-not-nececessarily-sequential">2025-02-07 -- dates not nececessarily sequential</a></h1>
<p>08:00 Breakfast -- should I try skippin bfast?
09:00 Bumped head, passed out
13:36 Wake up, headache
13:37 Go to medbay
13:40 Patch self up
13:45 Commute home for rest
14:15 Read
21:00 Dinner
21:15 Read
22:00 Sleep
You are to derive a reasonable datatype for represent-
ing this data yourself. For bonus points, make this bi-
directionalbymakingaShowrepresentationforthedatatype
which matches the format you are parsing. Then write a
generator for this data using QuickCheck‚Äôs Gen and see if
you can break your parser with QuickCheck.
6.Write a parser for IPv4 addresses.
importData.Word
dataIPAddress =
IPAddress Word32
deriving (Eq,Ord,Show)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1498
A 32-bit word is a 32-bit unsigned int. Lowest value is 0
rather than being capable of representing negative num-
bers, but the highest possible value in the same number
of bits is twice as high. Note:
Prelude&gt; import Data.Int
Prelude&gt; import Data.Word
Prelude&gt; maxBound :: Int32
2147483647
Prelude&gt; maxBound :: Word32
4294967295
Prelude&gt; div 4294967295 2147483647
2
Word32 is an appropriate and compact way to represent
IPv4 addresses. You are expected to figure out not only
how to parse the typical IP address format, but how IP
addresses work numerically insofar as is required to write
a working parser. This will require using a search engine
unless you have an appropriate book on internet network-
ing handy.
Example IPv4 addresses and their decimal representa-
tions:
172.16.254.1 -&gt; 2886794753
204.120.0.15 -&gt; 3430416399</p>
<p>CHAPTER 24. PARSER COMBINATORS 1499
7.Same as before, but IPv6.
importData.Word
dataIPAddress6 =
IPAddress6 Word64Word64
deriving (Eq,Ord,Show)
Example IPv6 addresses and their decimal representa-
tions:
0:0:0:0:0:ffff:ac10:fe01 -&gt; 281473568538113
0:0:0:0:0:ffff:cc78:f -&gt; 281474112159759
FE80:0000:0000:0000:0202:B3FF:FE1E:8329 -&gt;
338288524927261089654163772891438416681
2001:DB8::8:800:200C:417A -&gt;
42540766411282592856906245548098208122
One of the trickier parts about IPv6 will be full vs. col-
lapsed addresses and the abbrevations. See this Q&amp;A
thread13about IPv6 abbreviations for more.
Ensure you can parse abbreviated variations of the earlier
examples like:
13http://answers.google.com/answers/threadview/id/770645.html</p>
<p>CHAPTER 24. PARSER COMBINATORS 1500
FE80::0202:B3FF:FE1E:8329
2001:DB8::8:800:200C:417A
8.Removethederived ShowinstancesfromtheIPAddress/IPAd-
dress6 types, and write your own Showinstance for each
type that renders in the typical textual format appropriate
to each.
9.Write a function that converts between IPAddress and
IPAddress6.
10.Write a parser for the DOT language14that Graphviz uses
to express graphs in plain-text.
We suggest you look at the AST datatype in Haphviz15for
ideas on how to represent the graph in a Haskell datatype.
If you‚Äôre feeling especially robust, you can try using fgl16.
24.12 Definitions
1.A parser parses.
You read the chapter right?
2.A parser combinator combines two or more parsers to
produce a new parser. Good examples of this are things
14http://www.graphviz.org/doc/info/lang.html
15http://hackage.haskell.org/package/haphviz
16http://hackage.haskell.org/package/fgl</p>
<p>CHAPTER 24. PARSER COMBINATORS 1501
like using &lt;|&gt;fromAlternative to produce a new parser
from the disjunction of two parser arguments to &lt;|&gt;. Or
some. Ormany. Ormappend . Or(&gt;&gt;).
3.Marshalling is transforming a potentially nonlinear rep-
resentation of data in memory into a format that can be
stored on disk or transmitted over a network socket. Go-
ing in the opposite direction is called unmarshalling. Cf.
serialization and deserialization.
4.A token(izer) converts text, usually a stream of characters,
into more meaningful or ‚Äúchunkier‚Äù structures such as
words, sentences, or symbols. The linesandwordsfunc-
tions you‚Äôve used earlier in this book are like very unso-
phisticated tokenizers.
5.Lexer ‚Äî see tokenizer.
24.13 Follow-up resources
1.Parsec try a-or-b considered harmful; Edward Z. Yang
2.Code case study: parsing a binary data format; Real World
Haskell
3.The Parsec parsing library; Real World Haskell</p>
<p>CHAPTER 24. PARSER COMBINATORS 1502
4.An introduction to parsing text in Haskell with Parsec;
James Wilson;
http://unbui.lt/#!/post/haskell-parsec-basics
5.Parsing CSS with Parsec; Jakub Arnold
6.Parsec: A practical parser library; Daan Leijen, Erik Mei-
jer;
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.
5200
7.How to Replace Failure by a List of Successes; Philip
Wadler;
http://dl.acm.org/citation.cfm?id=5288
8.How to Replace Failure by a Heap of Successes; Edward
Kmett
9.Two kinds of backtracking; Samuel G√©lineau (gelisam);
http://gelisam.blogspot.ca/2015/09/two-kinds-of-backtracking.
html
10.LL and LR in Context: Why Parsing Tools Are Hard; Josh
Haberman
http://blog.reverberate.org/2013/09/ll-and-lr-in-context-why-parsing-tools.
html
11.Parsing Techniques, a practical guide; second edition;
Grune &amp; Jacobs</p>
<p>CHAPTER 24. PARSER COMBINATORS 1503
12.Parsing JSON with Aeson; School of Haskell
13.aeson; 24 days of Hackage; Oliver Charles</p>
<p>Chapter 25
Composing types
The last thing one
discovers in composing a
work is what to put first.
T. S. Eliot
1504</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1505
25.1 Composing types
This chapter and the next are about monad transformers, both
the principles behind them and the practicalities of using them.
For many programmers, monad transformers are indistin-
guishable from magick, so we want to approach them from
both angles and demonstrate that they are both comprehen-
sible via their types and practical in normal programming.
Functors and applicatives are both closed under composi-
tion: this means that you can compose two functors (or two
applicatives) and return another functor (or applicative, as the
case may be). This is not true of monads, however; when you
compose two monads, the result is not necessarily another
monad. We will see this soon.
However, there are times when composing monads is desir-
able. DiÔ¨Äerent monads allow us to work with diÔ¨Äerent eÔ¨Äects.
Composing monads allows you to build up computations with
multiple eÔ¨Äects. By stacking, for example, a Maybemonad with
anIO, you can be performing IOactions while also building up
computations that have a possibility of failure, handled by the
Maybemonad.
A monad transformer is a variant of an ordinary type that
takes an additional type argument which is assumed to have a
Monadinstance. For example, MaybeT is the transformer variant
of theMaybetype. The transformer variant of a type gives us</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1506
aMonadinstance that binds over both bits of structure. This
allows us to compose monads and combine their eÔ¨Äects. Get-
ting comfortable with monad transformers is important to
becoming proficient in Haskell, so we‚Äôre going to take it pretty
slowly and go step by step. You won‚Äôt necessarily want to start
out early on defining a bunch of transformer stacks yourself,
but familiarity with them will help a great deal in using other
people‚Äôs libraries.
In this chapter, we will
‚Ä¢demonstrate why composing two monads does not give
you another monad;
‚Ä¢examine the Identity andCompose types;
‚Ä¢manipulate types until we can make monads compose;
‚Ä¢meet some common monad transformers;
‚Ä¢work through an Identity crisis.
25.2 Common functions as types
We‚Äôll start in a place that may seem a little strange and point-
less at first, with newtypes that correspond to some very basic
functions. We can construct types that are like those func-
tions because we have types that can take arguments ‚Äî that</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1507
is, type constructors. In particular, we‚Äôll be using types that
correspond to idand(.).
You‚Äôve seen some of the types we‚Äôre going to use in the
following sections before, but we‚Äôll be putting them to some
novel uses. The idea here is to use these datatypes as helpers in
order to demonstrate the problems with composing monads,
and we‚Äôll see how these type constructors can also serve as
monad transformers, because a monad transformer is a type
constructor that takes a monad as an argument.
Identity is boring
You‚Äôve seen this type in previous chapters, sometimes as a
datatype and sometimes as a newtype. We‚Äôll construct the
type diÔ¨Äerently this time, as a newtype with a helper function
of the sort we saw in Reader andState:
newtype Identity a=
Identity { runIdentity ::a }
We‚Äôll be using the newtype in this chapter because the
monad transformer version, IdentityT , is usually written as
a newtype. The use of the prefixes runorgetindicates that
these accessor functions are means of extracting the underly-
ing value from the type. There is no real diÔ¨Äerence in meaning
between runandget. You‚Äôll see these accessor functions often,</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1508
particularly with utility types like Identity or transformer vari-
ants reusing an original type.
Anoteaboutnewtypes Whilemonadtransformertypescould
be written using the datakeyword, they are most commonly
written as newtypes, and we‚Äôll be sticking with that pattern
here. They are only newtyped to avoid unnecessary overhead,
as newtypes, as we recall, have an underlying representation
identical to the type they contain. The important thing is that
monad transformers are never sum or product types; they are
always a means of wrapping one extra layer of (monadic) struc-
ture around a type, so there is never a reason they couldn‚Äôt
be newtypes. Haskellers have a general tendency to avoid
adding additional runtime overhead if they can, so if they can
newtype it, they most often will.
Another thing we want to notice about Identity is the sim-
ilarity of the kind of our Identity type to the type of the id
function, although the fidelity of the comparison isn‚Äôt perfect
given the limitations of type-level computation in Haskell:
Prelude&gt; :t id
id :: a -&gt; a
Prelude&gt; :k Identity
Identity :: * -&gt; *
The kind signature of the type resembles the type signature</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1509
of the function, which we hope isn‚Äôt too much of a surprise.
Fine, so far ‚Äî not much new here. Yet.
Compose
We mentioned above that we can also construct a datatype
that corresponds to function composition.
Here is the Compose type. It should look to you much like
function composition, but in this case, the ùëìandùëîrepresent
type constructors, not term-level functions:
newtype Compose f g a=
Compose { getCompose ::f (g a) }
deriving (Eq,Show)
So, we have a type constructor that takes three type argu-
ments: ùëìandùëîmust be type constructors themselves, while ùëé
will be a concrete type (consider the relationship between type
constructors and term-level functions on the one hand, and
values and type constants on the other). As we did above, let‚Äôs
look at the kind of Compose ‚Äî note the kinds of the arguments
to the type constructor:
Compose :: (* -&gt; <em>) -&gt; (</em> -&gt; *) -&gt; * -&gt; *
Does that remind you of anything?
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1510
So, what does that look like in practice? Something like this:
Prelude&gt; Compose [Just 1, Nothing]
Compose {getCompose = [Just 1,Nothing]}
Prelude&gt; let xs = [Just (1::Int), Nothing]
Prelude&gt; :t Compose xs
Compose [Just (1 :: Int), Nothing]
:: Compose [] Maybe Int
Given the above value, the type variables get bound accord-
ingly:
Compose [Just(1::Int),Nothing]
Compose { getCompose ::f (g a) }
Compose []MaybeInt
f~[]
g~Maybe
a~Int
We have one bit of structure wrapped around another, then
a value type (the ùëé) because the whole thing still has to be kind
*in the end.
We‚Äôve made the point in previous chapters that type con-
structors are functions. Type constructors can take other type</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1511
constructors as arguments, too, just as functions can take other
functions as arguments. This is what allows us to compose
types.
25.3 Two little functors sittin‚Äô in a tree,
L-I-F-T-I-N-G
Let‚Äôs start with composing functors, using the types we saw
above. We know we can lift over Identity ; you‚Äôve seen this
Functor before:
instance Functor Identity where
fmap f ( Identity a)=Identity (f a)
Identity here gives us a sort of vanilla Functor that doesn‚Äôt do
anything interesting but captures the essence of what Functor is
about. The function gets lifted into the context of the Identity
type and then mapped over the ùëévalue.
It turns out we can get a Functor instance for Compose , too, if
we ask that the ùëìandùëîboth have Functor instances:
instance (Functor f,Functor g)=&gt;
Functor (Compose f g)where
fmap f ( Compose fga)=
Compose $(fmap.fmap) f fga</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1512
Now the ùëìand the ùëîboth have to be part of the structure
that we‚Äôre lifting over, so they both have to be Functor s them-
selves. We need to be able to jump over both those layers in
order to apply to the value that‚Äôs ultimately inside. We have
tofmaptwice to get to that value inside because of the layered
structures.
To return to the example we used above, we have this type:
newtype Compose f g a=
Compose { getCompose ::f (g a) }
deriving (Eq,Show)
Compose { getCompose ::f (g a) }
Compose []MaybeInt
And if we use our Functor instance, we can apply a function
to theIntvalue wrapped up in all that structure:
Prelude&gt; let xs = [Just 1, Nothing]
Prelude&gt; Compose xs
Compose {getCompose = [Just 1,Nothing]}
Prelude&gt; fmap (+1) (Compose xs)
Compose {getCompose = [Just 2,Nothing]}</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1513
We can generalize this to diÔ¨Äerent amounts of structure,
such as with one less bit of structure. You may remember this
from a previous chapter:
newtype Onef a=
One(f a)
deriving (Eq,Show)
instance Functor f=&gt;
Functor (Onef)where
fmap f ( Onefa)=One$fmap f fa
Or one more layer of structure than Compose :
newtype Threef g h a =
Three(f (g (h a)))
deriving (Eq,Show)
instance (Functor f,Functor g,Functor h)
=&gt;Functor (Threef g h)where
fmap f ( Threefgha)=
Three$(fmap.fmap.fmap) f fgha
As with the anonymous product (,)and the anonymous
sumEither, theCompose type allows us to express arbitrarily
nested types:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1514
v::Compose []
Maybe
(Compose Maybe[]Integer)
v=Compose [Just(Compose $Just[1])]
The way to think about this is that the composition of two
datatypes that have a Functor instance gives rise to a new Functor
instance. You‚Äôll sometimes see people refer to this as functors
being closed under composition which means that when you
compose two Functor s, you get another Functor .
25.4 Twinplicative
You probably guessed this was our next step in Compose -landia.
Applicatives, it turns out, are also closed under composition.
We can compose two types that have Applicative instances and
get a new Applicative instance. But you‚Äôre going to write it.</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1515
GOTCHA! Exercise time
-- instance types provided as
-- they may help.
{-# LANGUAGE InstanceSigs #-}
instance (Applicative f,Applicative g)
=&gt;Applicative (Compose f g)where
pure::a-&gt;Compose f g a
pure=undefined
(&lt;<em>&gt;)::Compose f g (a-&gt;b)
-&gt;Compose f g a
-&gt;Compose f g b
(Compose f)&lt;</em>&gt;(Compose a)=undefined
We mentioned in an earlier chapter that Applicative is a
weaker algebra than Monad, and that sometimes there are bene-
fits to preferring an Applicative when you don‚Äôt need the full
power of the Monad. This is one of those benefits. To compose
Applicative s, you don‚Äôt need to do the legwork that Monads re-
quire in order to compose and still have a Monad. Oh, yes, right
‚Äî we still haven‚Äôt quite made it to monads composing, but
we‚Äôre about to.</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1516
25.5 Twonad?
What about Monad? There‚Äôs no problem composing two arbi-
trary datatypes that have Monadinstances. We saw this already
when we used Compose withMaybeand list, which both have Monad
instances defined. However, the result of having done so does
not give you a Monad.
The issue comes down to a lack of information. Both types
Compose is working with are polymorphic, so when you try to
write bind for the Monad, you‚Äôre trying to combine two poly-
morphic binds into a single combined bind. This, it turns out,
is not possible:
{-# LANGUAGE InstanceSigs #-}
-- impossible.
instance (Monadf,Monadg)
=&gt;Monad(Compose f g)where
return=pure
(&gt;&gt;=)::Compose f g a
-&gt;(a-&gt;Compose f g b)
-&gt;Compose f g b
(&gt;&gt;=)= ???</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1517
These are the types we‚Äôre trying to combine, because ùëìand
ùëîare necessarily both monads with their own Monadinstances:
Monadf=&gt;f a-&gt;(a-&gt;f b)-&gt;f b
Monadg=&gt;g a-&gt;(a-&gt;g b)-&gt;g b
From those, we are trying to write this bind:
(Monadf,Monadg)
=&gt;f (g a) -&gt;(a-&gt;f (g b)) -&gt;f (g b)
Or formulated diÔ¨Äerently:
(Monadf,Monadg)
=&gt;f (g (f (g a))) -&gt;f (g a)
And this is not possible. There‚Äôs not a good way to jointhat
finalùëìandùëî. It‚Äôs a great exercise to try to make it work, because
the barriers you‚Äôll run into are instructive in their own right.
You can also read Composing monads1by Mark P. Jones and
Luc Duponcheel to see why it‚Äôs not possible.
No free burrito lunches
Since getting another Monadgiven the composition of two arbi-
trary types that have a Monadinstance is impossible, what can
we do to get a Monadinstance for combinations of types? The
1http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1518
answer is, monad transformers. We‚Äôll get to that after a little
break for some exercises.
25.6 Exercises: Compose Instances
1.Write the Compose Foldable instance.
ThefoldMap = undefined bit is a hint to make it easier and
look more like what you‚Äôve seen already.
instance (Foldable f,Foldable g)=&gt;
Foldable (Compose f g)where
foldMap =undefined
2.Write the Compose Traversable instance.
instance (Traversable f,Traversable g)=&gt;
Traversable (Compose f g)where
traverse =undefined
And now for something completely diÔ¨Äerent
This has nothing to do with anything else in this chapter, but
it makes for a fun exercise.</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1519
classBifunctor pwhere
{-# MINIMAL bimap | first, second #-}
bimap::(a-&gt;b)
-&gt;(c-&gt;d)
-&gt;p a c
-&gt;p b d
bimap f g =first f .second g
first::(a-&gt;b)-&gt;p a c-&gt;p b c
first f =bimap f id
second::(b-&gt;c)-&gt;p a b-&gt;p a c
second=bimap id
It‚Äôs a functor that can map over two type arguments instead
of one. Write Bifunctor instances for the following types:
1.The less you think, the easier it‚Äôll be.
dataDeuxa b=Deuxa b
2.dataConsta b=Consta
3.dataDreia b c=Dreia b c
4.dataSuperDrei a b c=SuperDrei a b</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1520
5.dataSemiDrei a b c=SemiDrei a
6.dataQuadriceps a b c d =
Quadzzz a b c d
7.dataEithera b=
Lefta
|Rightb
25.7 Monad transformers
We‚Äôve now seen what the problem with Monadis: you can put
two together but you don‚Äôt get a new Monadinstance out of it.
When we need to get a new Monadinstance, we need a monad
transformer. It‚Äôs not magic; the answer is in the types.
We said above that a monad transformer is a type construc-
tor that takes a Monadas an argument and returns a Monadas
a result. We also noted that the fundamental problem with
composing two monads lies in the impossibility of joining two
unknown monads. In order to make that joinhappen, we need
to reduce the polymorphism and get concrete information
about one of the monads that we‚Äôre working with. The other
monad remains polymorphic as a variable type argument to
our type constructor. Transformers help you make a monad
out of multiple (2, 3, 4...) types that each have a Monadinstance</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1521
by wrapping around existing monads that provide each bit of
wanted functionality.
The types are tricky here, so we‚Äôre going to be walking
through writing monad transformers very slowly. Parts of
what follows may seem tedious, so work through it as slowly
or quickly as you need to.
Monadic stacking
Applicative allows us to apply functions of more than one ar-
gument in the presence of functorial structure, enabling us to
cope with this transition:
-- from this:
fmap(+1) (Just1)
-- to this:
(,,)
&lt;$&gt;Just1
&lt;<em>&gt;Just&quot;lol&quot;
&lt;</em>&gt;Just[1,2]
Sometimes we want a (&gt;&gt;=)which can address more than
oneMonadat once. You‚Äôll often see this in applications that have
multiple things going on, such as a web app where combining
Reader andIOis common. You want IOso you can perform ef-
fectful actions like talking to a database and also Reader for the</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1522
database connection(s) and/or HTTP request context. Some-
times you may even want multiple Readers (app-specific data
vs. what the framework provides by default), although usually
there‚Äôs a way to add only the data you want to a product type
of a single Reader .
So the question becomes, how do we get one big bind over
a type like the following?
IO(ReaderString[a])
-- where the Monad instances involved
-- are that of IO, Reader, and []
Doing it badly
We could make one-oÔ¨Ä types for each combination, but this
will get tiresome quickly. For example:
newtype MaybeIO a=
MaybeIO { runMaybeIO ::IO(Maybea) }
newtype MaybeList a=
MaybeList { runMaybeList ::[Maybea] }
We don‚Äôt need to resort to this; we can get a Monadfor two
types, as long as we know what one of the types is. Transform-</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1523
ers are a means of avoiding making a one-oÔ¨Ä Monadfor every
possible combination of types.
25.8 IdentityT
Much as Identity helps show oÔ¨Ä the most basic essence of
Functor ,Applicative , andMonad,IdentityT is going to help you
begin to understand monad transformers. Using this type that
doesn‚Äôt have a lot of interesting stuÔ¨Ä going on with it will help
keep us focused on the types and the important fundamentals
of transformers. What we see here will be applicable to other
transformers as well, but types like Maybeand list introduce
other possibilities (failure cases, empty lists) that complicate
things a bit.
First, let‚Äôs compare the Identity type you‚Äôve seen up to this
point and our new IdentityT datatype:
-- Plain old Identity. 'a' can be
-- something with more structure,
-- but it's not required and Identity
-- won't know anything about it.
newtype Identity a=
Identity { runIdentity ::a }
deriving (Eq,Show)</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1524
-- The identity monad transformer, serving
-- only to to specify that additional
-- structure should exist.
newtype IdentityT f a=
IdentityT { runIdentityT ::f a }
deriving (Eq,Show)
What changed here is that we added an extra type argument.
Thenwewant Functor instancesforboth Identity andIdentityT :
instance Functor Identity where
fmap f ( Identity a)=Identity (f a)
instance (Functor m)
=&gt;Functor (IdentityT m)where
fmap f ( IdentityT fa)=
IdentityT (fmap f fa)
TheIdentityT instancehereshouldlooksimilartothe Functor
instance for the Onedatatype above ‚Äî the ùëìùëéargument is the
value inside the IdentityT with the (untouchable) structure
wrapped around it. All we know about that additional layer of
structure wrapped around the ùëévalue is that it is a Functor .
We also want Applicative instances for each:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1525
instance Applicative Identity where
pure=Identity
(Identity f)&lt;<em>&gt;(Identity a)=
Identity (f a)
instance (Applicative m)
=&gt;Applicative (IdentityT m)where
pure x=IdentityT (pure x)
(IdentityT fab)&lt;</em>&gt;(IdentityT fa)=
IdentityT (fab&lt;<em>&gt;fa)
TheIdentity instance should be familiar. In the IdentityT
instance, the ùëìùëéùëèvariable represents the f (a -&gt; b) that is the
first argument of (&lt;</em>&gt;). Since this can rely on the Applicative
instance for ùëöto handle that bit, this instance defines how
to applicatively apply in the presence of that outer IdentityT
layer.
Finally, we want some Monadinstances:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1526
instance MonadIdentity where
return=pure
(Identity a)&gt;&gt;=f=f a
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(IdentityT ma)&gt;&gt;=f=
IdentityT $ma&gt;&gt;=runIdentityT .f
TheMonadinstance is tricky, so we‚Äôre going to do a few things
to break it down. Keep in mind that Monadis where we have to
really use concrete type information from IdentityT in order
to make the types fit.
The bind breakdown
We‚Äôll start with a closer look at the instance as written above:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1527
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(IdentityT ma)&gt;&gt;=f=
-- [ 1 ] [2] [3]
IdentityT $ma
-- [8] [4]
&gt;&gt;=runIdentityT .f
-- [5] [7] [6]
1.First we pattern match or unpack the m avalue of IdentityT
m avia the data constructor. Doing this has the type
IdentityT m a -&gt; m a and the type of maism a. This nomen-
clature doesn‚Äôt mean anything beyond mnemonic signal-
ing, but it is intended to be helpful.
2.The type of the bind we are implementing is the follow-
ing:
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
This is the instance we are defining.
3.The function we‚Äôre binding over is IdentityT m a . It has
the following type:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1528
(a-&gt;IdentityT m b)
4.Heremais the same one we unpacked out of the IdentityT
data constructor and has the type m a. Removed from its
IdentityT context, this is now the m athat this bind takes
as its first argument.
5.This is a diÔ¨Äerent bind! The first bind is the bind we‚Äôre
trying to implement; this bind is its definition or imple-
mentation. We‚Äôre now using the Monadwe asked for in the
instance declaration with the constraint Monad m =&gt; . This
will have the type:
(&gt;&gt;=)::m a-&gt;(a-&gt;m b)-&gt;m b
This is with respect to the ùëöin the type IdentityT m a , not
the class of Monadinstances in general. In other words,
since we have already unpacked the IdentityT bit and, in
a sense, gotten it out of the way, this bind will be the bind
for the type ùëöin the type IdentityT m . We don‚Äôt know
whatMonadthat is yet, and we don‚Äôt need to; since it has
theMonadtypeclass constraint on that variable, we know it
already has a Monadinstance defined for it, and this second
bind will be the bind defined for that type. All we‚Äôre doing
here is defining how to use that bind in the presence of
the additional IdentityT structure.</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1529
6.This is the same ùëìwhich was an argument to the Monad
instance we are defining, of type:
(a-&gt;IdentityT m b)
7.We need runIdentityT because ùëìreturns IdentityT m b , but
the&gt;&gt;=for the Monad m =&gt; has the type m a -&gt; (a -&gt; m b)
-&gt; m b. It‚Äôll end up trying to join m (IdentityT m b) , which
won‚Äôt work because mandIdentityT m are not the same
type. We use runIdentityT to unpack the value. Doing
this has the type IdentityT m b -&gt; m b and the composition
runIdentityT . f in this context has the type a -&gt; m b . You
can use undefined in GHCi to demonstrate this for yourself:
Prelude&gt; :{
*Main| let f :: (a -&gt; IdentityT m b)
*Main| f = undefined
*Main| :}
Prelude&gt; :t f
f :: a -&gt; IdentityT m b
Prelude&gt; :t runIdentityT
runIdentityT :: IdentityT f a -&gt; f a
Prelude&gt; :t (runIdentityT . f)
(runIdentityT . f) :: a1 -&gt; f a</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1530
OK, the type variables don‚Äôt have the same name, but you
can see how a1 -&gt; f a anda -&gt; m b are the same type.
8.To satisfy the type of the outer bind we are implementing
for the MonadofIdentityT m , which expects a final result
of the type IdentityT m b , we must take the m bwhich the
expression ma &gt;&gt;= runIdentityT . f returns and repack it
inIdentityT . Note:
Prelude&gt; :t IdentityT
IdentityT :: f a -&gt; IdentityT f a
Prelude&gt; :t runIdentityT
runIdentityT :: IdentityT f a -&gt; f a
Now we have a bind we can use with IdentityT and some
otherMonad‚Äî in this example, a list:
Prelude&gt; let sumR = return . (+1)
Prelude&gt; IdentityT [1, 2, 3] &gt;&gt;= sumR
IdentityT {runIdentityT = [2,3,4]}
Implementing the bind, step by step
Now we‚Äôre going to backtrack and go through implementing
that bind step by step. The goal here is to demystify what
we‚Äôve done and enable you to write your own instances for
whatever monad transformer you might need to implement</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1531
yourself. We‚Äôll go ahead and start back at the beginning, but
withInstanceSigs turned on so we can see the type:
{-# LANGUAGE InstanceSigs #-}
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
undefined
Let‚Äôs leave the undefined as our final return expression, then
useletbindings and contradiction to see the types of our
attempts at making a Monadinstance. We‚Äôre going to use the
bottom value ( undefined ) to defer the parts of the proof we‚Äôre
obligated to produce until we‚Äôre ready. First, let‚Äôs get a let
binding in place and see it load, even if the code doesn‚Äôt work:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1532
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb=ma&gt;&gt;=f
inundefined
We‚Äôre using ùëéùëñùëöùëèas a mnemonic for the parts of the whole
thing that we‚Äôre trying to implement.
Here we get an error:
Couldn't match type ‚Äòm‚Äô with ‚ÄòIdentityT m‚Äô
That type error isn‚Äôt the most helpful thing in the world.
It‚Äôs hard to know what‚Äôs wrong from that. So, we‚Äôll poke at this
a bit in order to get a more helpful type error.
First, we‚Äôll do something we know should work. We‚Äôll use
fmapinstead. Because that will typecheck (but not give us the
same result as (&gt;&gt;=)), we need to do something to give the
compiler a chance to contradict us and tell us the real type.
We force that type error by asserting a fully polymorphic type
forùëéùëñùëöùëè:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1533
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb::a
aimb=fmap f ma
inundefined
The type we asserted for ùëéùëñùëöùëèis impossible; we‚Äôve said it
could be every type, and it can‚Äôt. The only thing that can have
that type is bottom, as bottom inhabits all types.
Conveniently, GHC will let us know what ùëéùëñùëöùëèis:
Couldn't match expected type ‚Äòa1‚Äô
with actual type ‚Äòm (IdentityT m b)‚Äô
Withthecurrentimplementation, ùëéùëñùëöùëèhasthetype m (IdentityT
m b). Now we can see the real problem: there is an IdentityT
layer in between the two bits of ùëöthat we need to join in order
to have a monad.
Here‚Äôs a breakdown:
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
The pattern match on IdentityT comes from having lifted
over it:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1534
(a-&gt;IdentityT m b)
The problem is, we used &gt;&gt;=over
ma
-- and got
m(IdentityT m b)
It doesn‚Äôt typecheck because (&gt;&gt;=)merges structure of the
same type after lifting (remember: it‚Äôs fmapcomposed with
joinunder the hood). Had our type been m (m b) after binding
fovermait would‚Äôve worked fine. As it is, we need to find a
way to get the two bits of ùëötogether without an intervening
IdentityT layer.
We‚Äôre going to continue with having separate fmapandjoin
instead of using (&gt;&gt;=)because it makes the step-wise manip-
ulation of structure easier to see. How do we get rid of the
IdentityT in the middle of the two ùëöstructures? Well, we know
ùëöis aMonad, which means it‚Äôs also a Functor . So, we can use
runIdentityT to get rid of the IdentityT structure in the middle
of the stack of types:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1535
-- Change m (IdentityT m b)
-- into m (m b)
-- Note:
runIdentityT ::IdentityT f a-&gt;f a
fmaprunIdentityT ::Functor f
=&gt;f (IdentityT f1 a)-&gt;f (f1 a)
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb::a
aimb=fmap runIdentityT (fmap f ma)
inundefined
And when we load this code, we get an encouraging type
error:
Couldn't match expected type ‚Äòa1‚Äô
with actual type ‚Äòm (m b)‚Äô
It‚Äôs telling us we have achieved the type m (m b) , so now we
know how to get where we want. The ùëé1here is the ùëéwe had
assigned to ùëéùëñùëöùëè, but it‚Äôs telling us that our actual type is not
what we asserted but this other type. Thus we have discovered</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1536
what our actual type is, which gives us a clue about how to fix
it.
We‚Äôll use joinfromControl.Monad to merge the nested ùëö
structure:
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb::a
aimb=
join (fmap runIdentityT (fmap f ma))
inundefined
And when we load it, the compiler tells us we finally have
anm bthat we can return:
Couldn't match expected type ‚Äòa1‚Äô
with actual type ‚Äòm b‚Äô
In fact, before we begin cleaning up our code, we can verify
this is the case real quick:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1537
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb=
join (fmap runIdentityT (fmap f ma))
inaimb
We removed the type declaration for aimband also changed
thein undefined . But we know that ùëéùëñùëöùëèhas the actual type m
b, so this won‚Äôt work. Why? If we take a look at the type error:
Couldn't match type ‚Äòm‚Äô with ‚ÄòIdentityT m‚Äô
The(&gt;&gt;=)we are implementing has a final result of type
IdentityT m b , so the type of ùëéùëñùëöùëèdoesn‚Äôt match it yet. We need
to wrap m binIdentityT to make it typecheck:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1538
-- Remember:
IdentityT ::f a-&gt;IdentityT f a
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb=
join (fmap runIdentityT
(fmap f ma))
inIdentityT aimb
This should compile. We rewrap m bback in the IdentityT
type and we should be good to go.
Refactoring
Now that we have something that works, let‚Äôs refactor. We‚Äôd
like to improve our implementation of (&gt;&gt;=). Taking things
one step at a time is usually more successful than trying to
rewrite all at once, especially once you have a baseline version
that you know should work. How should we improve this line?</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1539
IdentityT $
join(fmap runIdentityT (fmap f ma))
Well, oneofthe Functor lawstellsussomethingabout fmapping
twice:
-- Functor law:
fmap(f.g)==fmap f.fmap g
Indeed! So we can change that line to the following and it
should be identical:
IdentityT $
join(fmap (runIdentityT .f) ma)
Now it seems suspicious that we‚Äôre fmapping and also us-
ingjoinon the result of having fmapped the two functions we
composed. Isn‚Äôt joincomposed with fmapjust(&gt;&gt;=)?
x&gt;&gt;=f=join (fmap f x)
Accordingly, we can change our Monadinstance to the fol-
lowing:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1540
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
IdentityT $ma&gt;&gt;=runIdentityT .f
And that should work still! We have a type constructor now
(IdentityT ) that takes a monad as an argument and returns a
monad as a result.
This implementation can be written other ways. In the
transformers library, for example, it‚Äôs written like this:
m&gt;&gt;=k=
IdentityT $runIdentityT .k
=&lt;&lt;runIdentityT m
Take a moment and work out for yourself how that is func-
tionally equivalent to our implementation.
The essential extra of monad transformers
It may not seem like it, but the IdentityT monad transformer
captures the essence of transformers generally. We only em-</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1541
barked on this quest because we couldn‚Äôt be guaranteed a Monad
instance given the composition of two types. Given that, we
know having Functor ,Applicative , andMonadat our disposal isn‚Äôt
enough to make that new Monadinstance. So what was novel in
the following code?
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
IdentityT $ma&gt;&gt;=runIdentityT .f
It wasn‚Äôt the pattern match on IdentityT ; we get that from
theFunctor anyway:
-- Not this
(IdentityT ma)...
It wasn‚Äôt the ability to (&gt;&gt;=)functions over the mavalue of
typeùëöùëé, we get that from the Monadconstraint on ùëöanyway.
-- Not this
...ma&gt;&gt;= ...
We needed to know one of the types concretely so that
we could use runIdentityT (essentially fmapping a fold of the
IdentityT structure) and then repack the value in IdentityT :</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1542
-- We need to know IdentityT
-- concretely to do this
IdentityT ..runIdentityT ...
As you‚Äôll recall, until we used runIdentityT we couldn‚Äôt get
the types to fit because IdentityT was wedged in the middle of
two bits of ùëö. It turns out to be impossible to fix that using
onlyFunctor ,Applicative , andMonad. This is an example of why
we can‚Äôt make a Monadinstance for the Compose type, but we
can make a transformer type like IdentityT where we leverage
information specific to the type and combine it with any other
type that has a Monadinstance. In general, in order to make the
types fit, we‚Äôll need some way to fold and reconstruct the type
we have concrete information for.
25.9 Finding a pattern
Transformers are bearers of single-type concrete information
that let you create ever-bigger monads in a sense. Nesting
such as
(Monadm)=&gt;m (m a)
is addressed by joinalready. We use transformers when
we want a &gt;&gt;=operation over ùëìandùëîof diÔ¨Äerent types (but
both have Monadinstances). You have to create new types called</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1543
monad transformers and write Monadinstances for those types
to have a way of dealing with the extra structure generated.
The general pattern is this: You want to compose two poly-
morphic types, ùëìandùëî, that each have a Monadinstance. But
you‚Äôll end up with this pattern:
f(g (f b))
Monad‚Äôs bind can‚Äôt join those types, not with that intervening
ùëî. So you need to get to this:
f(f b)
You won‚Äôt be able to unless you have some way of folding
theùëîin the middle. You can‚Äôt do that with Monad. The essence
ofMonadisjoin, but here you have only one bit of ùëîstructure,
notg (g ...) , so that‚Äôs not enough. The straightforward thing
to do is to make ùëîconcrete. With concrete type information
for the inner bit of structure, we can fold out the ùëîand get on
with it. The good news is that transformers don‚Äôt require ùëìbe
concrete; ùëìcan remain polymorphic so long as it has a Monad
instance, so we only write a transformer once for each type.
We can see this pattern with IdentityT as well. You may
recall this step in our process of writing IdentityT ‚ÄôsMonad:
(IdentityT ma)&gt;&gt;=f=
letaimb::m (IdentityT m b)
aimb=fmap f ma</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1544
We have something that‚Äôll typecheck, but it‚Äôs not quite in
the shape we would like. Of course, the underlying type once
we throw away the IdentityT data constructor is m (m b) which‚Äôll
suit us just fine, but we have to fold out the IdentityT before we
can use the joinfromMonad m =&gt; m . That leads us to the next
step:
letaimb::m (m b)
aimb=fmap runIdentityT (fmap f ma)
Now we finally have something we can join because we lifted
the record accessor for IdentityT over the ùëö! Since IdentityT
is so simple, the record accessor is sufficient to fold up the
structure. From there the following transitions become easy:
m(m b)-&gt;m b-&gt;IdentityT m b
The final type is what our definition of (&gt;&gt;=)forIdentityT
must result in.
The basic pattern that many monad transformers are en-
abling us to cope with is the following type transitions, where
ùëöis the polymorphic, outer structure and ùëáis some concrete
type the transformer is for. For example, in the above, ùëáwould
beIdentityT .</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1545
m (Tm b)
-&gt;m (m b)
-&gt;m b
-&gt;Tm b
Don‚Äôt consider this a hard and fast rule for what types you‚Äôll
encounter in implementing transformers, but rather some
intuition for why transformers are necessary to begin with.</p>
<p>Chapter 26
Monad transformers
I do not say such things
except insofar as I
consider this to permit
some transformation of
things. Everything I do, I
do in order that it may be
of use.
Michel Foucault
1546</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1547
26.1 Monad transformers
The last chapter demonstrated why we need monad transform-
ers and the basic type manipulation that‚Äôs going on to make
that bit of magick happen. Monad transformers are important
in a lot of everyday Haskell code, though, so we want to dive
deeper and make sure we have a good understanding of how
to use them in practice. Even after you know how to write all
the transformer instances, managing stacks of transformers
in an application can be tricky. The goal of this chapter is to
get comfortable with it.
In this chapter, we will
‚Ä¢work through more monad transformer types and in-
stances;
‚Ä¢look at the ordering and wrapping of monad transformer
stacks;
‚Ä¢lift, lift, lift, and lift some more.
26.2 MaybeT
In the last chapter, we worked through an extended break-
down of the IdentityT transformer. IdentityT is, as you might
imagine, not the most useful of the monad transformers, al-
though it is not without practical applications (more on this</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1548
later). As we‚Äôve seen, though, the Maybe Monad can be useful, and
so it is that the tranformer variant, MaybeT, finds its way into
the pantheon of important transformers.
TheMaybeT transformer is a bit more complex than IdentityT .
If you worked through all the exercises of the previous chapter,
then this section will not be too surprising, because this will
rely on things you‚Äôve seen with IdentityT and the Compose type
already. However, to ensure that transformers are thoroughly
demystified for you, it‚Äôs worth working through them carefully.
We begin with the newtype for our transformer:
newtype MaybeTm a=
MaybeT{ runMaybeT ::m (Maybea) }
The structure of our MaybeT type and the Compose type are
similar so we can reuse the basic patterns of the Compose type
for theFunctor andApplicative instances:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1549
-- Remember the Functor for Compose?
instance (Functor f,Functor g)
=&gt;Functor (Compose f g)where
fmap f ( Compose fga)=
Compose $(fmap.fmap) f fga
-- compare to the instance for MaybeT
instance (Functor m)
=&gt;Functor (MaybeTm)where
fmap f ( MaybeTma)=
MaybeT$(fmap.fmap) f ma
We don‚Äôt need to do anything diÔ¨Äerent for the Functor in-
stance, because transformers are needed for the Monad, not the
Functor .
Spoiler alert!
If you haven‚Äôt yet written the Applicative instance for Compose
from the previous chapter, you may want to stop right here.
We‚Äôll start with what might seem like an obvious way to
write the MaybeT Applicative and find out why it doesn‚Äôt work.
This does not compile:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1550
instance (Applicative m)
=&gt;Applicative (MaybeTm)where
pure x=MaybeT(pure (pure x))
(MaybeTfab)&lt;<em>&gt;(MaybeTmma)=
MaybeT$fab&lt;</em>&gt;mma
Theùëìùëéùëèrepresents the function m (Maybe (a -&gt; b)) and the
ùëöùëöùëérepresents the m (Maybe a) .
You‚Äôll get this error if you try it:
Couldn't match type ‚ÄòMaybe (a -&gt; b)‚Äô
with ‚ÄòMaybe a -&gt; Maybe b‚Äô
Here is the Applicative instance for Compose as a comparison
with the MaybeT instance we‚Äôre trying to write:
instance (Applicative f,Applicative g)
=&gt;Applicative (Compose f g)where
pure x=Compose (pure (pure x))
Compose f&lt;<em>&gt;Compose x=
Compose ((&lt;</em>&gt;)&lt;$&gt;f&lt;*&gt;x)
Let‚Äôs break this down a bit in case you felt confused when
you wrote this for the last chapter‚Äôs exercise. Because you did
that exercise‚Ä¶right?</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1551
The idea here is that we have to lift an Applicative apply
over the outer structure ùëìto get the g (a -&gt; b) intog a -&gt; g b
so that the Applicative instance for ùëìcan be leveraged. We can
stretch this idea a bit and use concrete types:
innerMost
::[Maybe(Identity (a-&gt;b))]
-&gt;[Maybe(Identity a-&gt;Identity b)]
innerMost =(fmap.fmap) (&lt;<em>&gt;)
second'
::[Maybe(Identity a-&gt;Identity b)]
-&gt;[Maybe(Identity a)
-&gt;Maybe(Identity b) ]
second' =fmap (&lt;</em>&gt;)
final'
::[Maybe(Identity a)
-&gt;Maybe(Identity b) ]
-&gt;[Maybe(Identity a)]
-&gt;[Maybe(Identity b)]
final'=(&lt;*&gt;)
The function that could be the Applicative instance for such
a hypothetical type would look like:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1552
lmiApply ::[Maybe(Identity (a-&gt;b))]
-&gt;[Maybe(Identity a)]
-&gt;[Maybe(Identity b)]
lmiApply f x=
final' (second' (innerMost f)) x
TheApplicative instance for our MaybeT type will employ this
same idea, because applicatives are closed under composition,
as we noted in the last chapter. We only need to do something
diÔ¨Äerent from the Compose instances once we get to Monad.
So, we took the long way around to this:
instance (Applicative m)
=&gt;Applicative (MaybeTm)where
pure x=MaybeT(pure (pure x))
(MaybeTfab)&lt;<em>&gt;(MaybeTmma)=
MaybeT$(&lt;</em>&gt;)&lt;$&gt;fab&lt;*&gt;mma
MaybeT Monad instance
At last, on to the Monadinstance! Note that we‚Äôve given some of
the intermediate types:
instance (Monadm)
=&gt;Monad(MaybeTm)where
return=pure</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1553
(&gt;&gt;=)::MaybeTm a
-&gt;(a-&gt;MaybeTm b)
-&gt;MaybeTm b
(MaybeTma)&gt;&gt;=f=
-- [2] [3]
MaybeT$ do
-- [ 1 ]
-- ma :: m (Maybe a)
-- v :: Maybe a
v&lt;-ma
-- [4]
casevof
-- [5]
Nothing -&gt;returnNothing
-- [ 6 ]
Justy-&gt;runMaybeT (f y)
-- [7] [8]
-- y :: a
-- f :: a -&gt; MaybeT m b
-- f y :: MaybeT m b
-- runMaybeT (f y) :: m (Maybe b)
Explaining it step by step:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1554
1.We have to return a MaybeT value at the end, so the doblock
has the MaybeT data constructor in front of it. This means
the final value of our doblock expression must be of type
m (Maybe b) in order to typecheck because our goal is to
go from MaybeT m a toMaybeT m b .
2.The first argument to bind here is MaybeT m a . We unbun-
dled that from MaybeT by pattern matching on the MaybeT
newtype data constructor.
3.The second argument to bind is (a -&gt; MaybeT m b) .
4.In the definition of MaybeT , notice something:
newtype MaybeTm a=
MaybeT{ runMaybeT ::m (Maybea) }
-- ^---------^
It‚Äôs aMaybevalue wrapped in some other type for which
all we know is that it has a Monadinstance. Accordingly, we
begin in our doblock by using the left arrow bind syntax.
This gives us a reference to the hypothetical Maybevalue
out of the ùëöstructure which is unknown.
5.Since using &lt;-to bind Maybe a out ofm (Maybe a) left us
with aMaybevalue, we use a case expression on the Maybe
value.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1555
6.If we get Nothing , we kick Nothing back out, but we have to
embed it in the ùëöstructure. We don‚Äôt know what ùëöis, but
being a Monad(and thus also an Applicative ) means we can
usereturn (pure) to perform that embedding.
7.If we get Just, we now have a value of type ùëéthat we can
pass to our function fof type a -&gt; MaybeT m b .
8.We have to fold the m (Maybe b) value out of the MaybeT
since the MaybeT constructor is already wrapped around
the whole doblock, then we‚Äôre done.
Don‚Äôt be afraid to get a pen and paper and work all that out
until you understand how things are happening before you
move on.
26.3 EitherT
Just asMaybehas a transformer variant in the form of MaybeT , we
can make a transformer variant of Either . We‚Äôll call it EitherT .
Your task is to implement the instances for the transformer
variant:
newtype EitherT e m a=
EitherT { runEitherT ::m (Eithere a) }</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1556
Exercises: EitherT
1.Write the Functor instance for EitherT :
instance Functor m
=&gt;Functor (EitherT e m)where
fmap=undefined
2.Write the Applicative instance for EitherT :
instance Applicative m
=&gt;Applicative (EitherT e m)where
pure=undefined
f&lt;*&gt;a=undefined
3.Write the Monadinstance for EitherT :
instance Monadm
=&gt;Monad(EitherT e m)where
return=pure
v&gt;&gt;=f=undefined
4.Write the swapEitherT helper function for EitherT .</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1557
-- transformer version of swapEither.
swapEitherT ::(Functor m)
=&gt;EitherT e m a
-&gt;EitherT a m e
swapEitherT =undefined
Hint: write swapEither first, then swapEitherT in terms of
the former.
5.Write the transformer variant of the either catamorphism.
eitherT ::Monadm=&gt;
(a-&gt;m c)
-&gt;(b-&gt;m c)
-&gt;EitherT a m b
-&gt;m c
eitherT =undefined
26.4 ReaderT
ReaderT is one of the most commonly used transformers in
conventional Haskell applications. It is like Reader, except in
the transformer variant we‚Äôre generating additional structure
in the return type of the function:
newtype ReaderT r m a=
ReaderT { runReaderT ::r-&gt;m a }</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1558
The value inside the ReaderT is a function. Type constructors
such as Maybeare also functions in some senses, but we have
to handle this case a bit diÔ¨Äerently. The first argument to the
function inside ReaderT is part of the structure we‚Äôll have to
bind over.
This time we‚Äôre going to give you the instances. If you want
to try writing them yourself, do not read on!</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1559
instance (Functor m)
=&gt;Functor (ReaderT r m)where
fmap f ( ReaderT rma)=
ReaderT $(fmap.fmap) f rma
instance (Applicative m)
=&gt;Applicative (ReaderT r m)where
pure a=ReaderT (pure (pure a))
(ReaderT fmab)&lt;<em>&gt;(ReaderT rma)=
ReaderT $(&lt;</em>&gt;)&lt;$&gt;fmab&lt;*&gt;rma
instance (Monadm)
=&gt;Monad(ReaderT r m)where
return=pure
(&gt;&gt;=)::ReaderT r m a
-&gt;(a-&gt;ReaderT r m b)
-&gt;ReaderT r m b
(ReaderT rma)&gt;&gt;=f=
ReaderT $\r-&gt; do
-- [1]
a&lt;-rma r
-- [3] [ 2 ]
runReaderT (f a) r
-- [5] [ 4 ] [6]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1560
1.Again, the type of the value in a ReaderT must be a function,
so the act of binding a function over a ReaderT must itself
be a function awaiting the argument of type ùëü, which we‚Äôve
chosen to name ùëüas a convenience in our terms. Also note
that we‚Äôre repacking our lambda inside the ReaderT data
constructor.
2.Wepattern-matchedthe r -&gt; m a (representedinourterms
byùëüùëöùëé) out of the ReaderT data constructor. Now we‚Äôre ap-
plying it to the ùëüthat we‚Äôre expecting in the body of the
anonymous lambda.
3.The result of applying r -&gt; m a to a value of type ùëüism
a. We need a value of type ùëéin order to apply our a -&gt;
ReaderT r m b function. To be able to write code in terms
of that hypothetical ùëé, we bind ( &lt;-) theùëéout of the ùëö
structure. We‚Äôve bound that value to the name ùëéas a
mnemonic to remember the type.
4.Applying ùëì, which has type a -&gt; ReaderT r m b , to the value
ùëéresults in a value of type ReaderT r m b .
5.We unpack the r -&gt; m b out of the ReaderT structure.
6.Finally, we apply the resulting r -&gt; m b to theùëüwe had at
the beginning of our lambda, that eventual argument that
Reader abstracts for us. We have to return m bas the final
expression in this anonymous lambda or the function is</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1561
not valid. To be valid, it must be of type r -&gt; m b which
expresses the constraint that if it is applied to an argument
of type ùëü, it must produce a value of type m b.
No exercises this time. You deserve a break.
26.5 StateT
Similar to Reader andReaderT ,StateT isStatebut with additional
monadic structure wrapped around the result. StateT is some-
what more useful and common than the State Monad you saw
earlier. Like ReaderT , its value is a function:
newtype StateTs m a=
StateT{ runStateT ::s-&gt;m (a,s) }
Exercises: StateT
If you‚Äôre familiar with the distinction, you‚Äôll be implementing
the strict variant of StateT here. To make the strict variant,
you don‚Äôt have to do anything special. Write the most obvious
thing that could work. The lazy (lazier, anyway) variant is
the one that involves adding a bit extra. We‚Äôll explain the
diÔ¨Äerence in the chapter on nonstrictness.
1.You‚Äôll have to do the Functor andApplicative instances
first, because there aren‚Äôt Functor andApplicative instances
ready to go for the type Monad m =&gt; s -&gt; m (a, s) .</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1562
instance (Functor m)
=&gt;Functor (StateTs m)where
fmap f m =undefined
2.As with Functor , you can‚Äôt cheat and reuse an underlying
Applicative instance, so you‚Äôll have to do the work with
thes -&gt; m (a, s) type yourself.
instance (Monadm)
=&gt;Applicative (StateTs m)where
pure=undefined
(&lt;*&gt;)=undefined
Also note that the constraint on ùëöis notApplicative as you
expect, but rather Monad. This is because you can‚Äôt express
the order-dependent computation you‚Äôd expect the StateT
Applicative to have without having a Monad for ùëö. To
learn more, see this Stack Overflow question1about this
issue. Also see this Github issue2on the NICTA Course
Github repository. Beware ! The NICTA course issue
gives away the answer. In essence, the issue is that without
Monad, you‚Äôre feeding the initial state to each computation
inStateT rather than threading it through as you go. This
1Is it possible to implement ‚Äò(Applicative m) =&gt; Applica-
tive (StateT s m)‚Äò? http://stackoverflow.com/questions/18673525/
is-it-possible-to-implement-applicative-m-applicative-statet-s-m
2https://github.com/NICTA/course/issues/134</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1563
is a general pattern contrasting Applicative andMonadand
is worth contemplating.
3.TheMonadinstance should look fairly similar to the Monad
instance you wrote for ReaderT .
instance (Monadm)
=&gt;Monad(StateTs m)where
return=pure
sma&gt;&gt;=f=undefined
ReaderT, WriterT, StateT
We‚Äôd like to point something out about these three types:
newtype Readerr a=
Reader{ runReader ::r-&gt;a }
newtype Writerw a=
Writer{ runWriter ::(a, w) }
newtype States a=
State{ runState ::s-&gt;(a, s) }
and their transformer variants:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1564
newtype ReaderT r m a=
ReaderT { runReaderT ::r-&gt;m a }
newtype WriterT w m a=
WriterT { runWriterT ::m (a, w) }
newtype StateTs m a=
StateT{ runStateT ::s-&gt;m (a, s) }
You‚Äôre already familiar with Reader andState. We haven‚Äôt
shown you Writer orWriterT up to this point because, quite
frankly, you shouldn‚Äôt use it. We‚Äôll explain why not in a section
later in this chapter.
For the purposes of the progression we‚Äôre trying to demon-
strate here, it suffices to know that the Writer Applicative and
Monadwork by combining the ùë§values monoidally. With that
in mind, what we can see is that Reader lets us talk about val-
ues we need, Writer lets us deal with values we can emit and
combine (but not read), and Statelets us both read and write
values in any manner we desire ‚Äî including monoidally, like
Writer . This is one reason you needn‚Äôt bother with Writer since
Statecan replace it anyway. That‚Äôs why you don‚Äôt need Writer ;
we‚Äôll talk more about why you don‚Äôt want Writer later.
In fact, there is a type in the transformers library that com-
binesReader ,Writer , andStateinto one big type:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1565
newtype RWSTr w s m a =
RWST{ runRWST ::r-&gt;s-&gt;m (a, s, w) }
Because of the Writer component, you probably wouldn‚Äôt
want to use that in most applications either, but it‚Äôs good to
know it exists.
Correspondence between StateT and Parser
You may recall what a simple parser type looks like:
typeParsera=String-&gt;Maybe(a,String)
You may remember our discussion about the similarities
between parsers and Statein the Parsers chapter. Now, we
could choose to define a Parser type in the following manner:
newtype StateTs m a=
StateT{ runStateT ::s-&gt;m (a,s) }
typeParser=StateTStringMaybe
Nobody does this in practice, but it‚Äôs useful to consider the
similarity to get a feel for what StateT is all about.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1566
26.6 Types you probably don‚Äôt want to
use
Not every type will necessarily be performant or make sense.
ListTandWriter /WriterT are examples of this.
Why not use Writer or WriterT?
It‚Äôs a bit too easy to get into a situation where Writer is either
too lazy or too strict for the problem you‚Äôre solving, and then
it‚Äôll use more memory than you‚Äôd like. Writer can accumulate
unevaluated thunks, causing memory leaks. It‚Äôs also inappro-
priate for logging long-running or ongoing programs due to
the fact that you can‚Äôt retrieve any of the logged values until
the computation is complete.3
Usually when Writer is used in an application, it‚Äôs not called
Writer . Instead a one-oÔ¨Ä is created for a specific type ùë§. Given
that, it‚Äôs still useful to know when you‚Äôre looking at something
that‚Äôs a Reader,Writer, orState, even if the author didn‚Äôt use
the types by those names from the transformers library. Some-
times this is because they wanted a stricter Writer than the one
already available.
Determining and measuring when more strictness (more
eagerly evaluating your thunks) is needed in your programs is
3If you‚Äôd like to understand this better, Gabriel Gonzalez has a helpful blog post on
the subject. http://www.haskellforall.com/2014/02/streaming-logging.html</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1567
the topic of the upcoming chapter on nonstrictness.
The ListT you want isn‚Äôt made from the List type
The most obvious way to implement ListTis generally not
recommended for a variety of reasons, including:
1.Most people‚Äôs first attempt won‚Äôt pass the associativity law.
We‚Äôre not going to show you a way to write it that does
pass that law because it‚Äôs not worth it for the reasons listed
below.
2.It‚Äôs not very fast.
3.Streaming libraries like pipes4andconduit5do it better for
most use cases.
Prior art for ‚Äú ListTdone right‚Äù also includes AmbT6by Conal</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../HaskellProgramming/part3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../HaskellProgramming/part5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../HaskellProgramming/part3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../HaskellProgramming/part5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
