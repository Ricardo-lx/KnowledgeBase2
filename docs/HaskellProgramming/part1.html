<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Part1 - KnowledgeBase</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../HaskellProgramming/HaskellProgramming.html"><strong aria-hidden="true">1.</strong> Haskell Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../HaskellProgramming/part1.html" class="active"><strong aria-hidden="true">1.1.</strong> Part1</a></li><li class="chapter-item expanded "><a href="../HaskellProgramming/part2.html"><strong aria-hidden="true">1.2.</strong> Part2</a></li><li class="chapter-item expanded "><a href="../HaskellProgramming/part3.html"><strong aria-hidden="true">1.3.</strong> Part3</a></li><li class="chapter-item expanded "><a href="../HaskellProgramming/part4.html"><strong aria-hidden="true">1.4.</strong> Part4</a></li><li class="chapter-item expanded "><a href="../HaskellProgramming/part5.html"><strong aria-hidden="true">1.5.</strong> Part5</a></li></ol></li><li class="chapter-item expanded "><a href="../csapp/csapp.html"><strong aria-hidden="true">2.</strong> csapp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../csapp/part1.html"><strong aria-hidden="true">2.1.</strong> Part1</a></li><li class="chapter-item expanded "><a href="../csapp/part2.html"><strong aria-hidden="true">2.2.</strong> Part2</a></li><li class="chapter-item expanded "><a href="../csapp/part3.html"><strong aria-hidden="true">2.3.</strong> Part3</a></li><li class="chapter-item expanded "><a href="../csapp/part4.html"><strong aria-hidden="true">2.4.</strong> Part4</a></li><li class="chapter-item expanded "><a href="../csapp/part5.html"><strong aria-hidden="true">2.5.</strong> Part5</a></li><li class="chapter-item expanded "><a href="../csapp/part6.html"><strong aria-hidden="true">2.6.</strong> Part6</a></li><li class="chapter-item expanded "><a href="../csapp/part7.html"><strong aria-hidden="true">2.7.</strong> Part7</a></li><li class="chapter-item expanded "><a href="../csapp/part8.html"><strong aria-hidden="true">2.8.</strong> Part8</a></li><li class="chapter-item expanded "><a href="../csapp/part9.html"><strong aria-hidden="true">2.9.</strong> Part9</a></li><li class="chapter-item expanded "><a href="../csapp/part10.html"><strong aria-hidden="true">2.10.</strong> Part10</a></li></ol></li><li class="chapter-item expanded "><a href="../midjourney/combined_html_page.html"><strong aria-hidden="true">3.</strong> midjourney</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../midjourney/mjprompt.html"><strong aria-hidden="true">3.1.</strong> MjPrompt</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">KnowledgeBase</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>i
Reader feedback
“Astonishingly insightful examples. This book is a lot like
having a good teacher — it never fails to provide the low-end
information even though I have already moved on. So just
like a good teacher isn’t presumptuous in what I’m supposed
to know (which might force me to try and save face in case I
do not, yet), information conveniently resurfaces.” – David
Deutsch
“When @haskellbook is done, it will be an unexpected mile-
stone for #haskell. There will forever be Haskell before, and
Haskell after.” – Jason Kuhrt
“I feel safe recommending Haskell to beginners now that
@haskellbook is available, which is very beginner friendly” –
Gabriel Gonzalez
“”Structure and Interpretation of Computer Programs” has
its credit, but @haskellbook is now my #1 recommendation
for FP beginners.” – Irio Musskopf
“The book is long, but not slow — a large fraction of it is
made up of examples and exercises. You can tell it’s written
by someone who’s taught Haskell to programmers before.” –
Christopher Jones</p>
<p>ii
“I already have a lot of experience with Haskell, but I’ve
never felt confident in it the way this book has made me feel.”
– Alain O’Dea
“Real deal with @haskellbook is that you don’t just learn
Haskell; you get a hands on experience as to why functional
programming works.” – George Makrydakis
“One of my goals this year is to evangelize @haskellbook
and @HaskellForMac. I think these tools will make anyone
who uses them better. I want to get comfortable with it so that
I can shift how I think about Swift.” – Janie Clayton</p>
<p>Contents
Reader feedback . . . . . . . . . . . . . . . . . . . . . . . . . . i
Contents iii
Authors’ preface . . . . . . . . . . . . . . . . . . . . . . . . . . . xx
Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . xxv
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxix
Why This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . xxix
A few words to new programmers . . . . . . . . . . . . . . . xxxiv
Haskevangelism . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxv
What’s in this book? . . . . . . . . . . . . . . . . . . . . . . . . xxxix
Best practices for examples and exercises . . . . . . . . . . xliii
1 All You Need is Lambda 1
1.1 All You Need is Lambda . . . . . . . . . . . . . . . 2
1.2 What is functional programming? . . . . . . . . 2
1.3 What is a function? . . . . . . . . . . . . . . . . . . 4
1.4 The structure of lambda terms . . . . . . . . . . 7
1.5 Beta reduction . . . . . . . . . . . . . . . . . . . . . 10
1.6 Multiple arguments . . . . . . . . . . . . . . . . . . 15
1.7 Evaluation is simplification . . . . . . . . . . . . . 20
1.8 Combinators . . . . . . . . . . . . . . . . . . . . . . 21
iii</p>
<p>CONTENTS iv
1.9 Divergence . . . . . . . . . . . . . . . . . . . . . . . 23
1.10 Summary . . . . . . . . . . . . . . . . . . . . . . . . 24
1.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 25
1.12 Answers . . . . . . . . . . . . . . . . . . . . . . . . . 27
1.13 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 31
1.14 Follow-up resources . . . . . . . . . . . . . . . . . 33
2 Hello, Haskell! 34
2.1 Hello, Haskell . . . . . . . . . . . . . . . . . . . . . . 35
2.2 Interacting with Haskell code . . . . . . . . . . . 36
2.3 Understanding expressions . . . . . . . . . . . . . 40
2.4 Functions . . . . . . . . . . . . . . . . . . . . . . . . 43
2.5 Evaluation . . . . . . . . . . . . . . . . . . . . . . . . 47
2.6 Infix operators . . . . . . . . . . . . . . . . . . . . . 50
2.7 Declaring values . . . . . . . . . . . . . . . . . . . . 57
2.8 Arithmetic functions in Haskell . . . . . . . . . . 67
2.9 Parenthesization . . . . . . . . . . . . . . . . . . . . 78
2.10 Let and where . . . . . . . . . . . . . . . . . . . . . 85
2.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 90
2.12 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 94
2.13 Follow-up resources . . . . . . . . . . . . . . . . . 96
3 Strings 97
3.1 Printing strings . . . . . . . . . . . . . . . . . . . . . 98
3.2 A first look at types . . . . . . . . . . . . . . . . . . 98
3.3 Printing simple strings . . . . . . . . . . . . . . . . 100</p>
<p>CONTENTS v
3.4 Top-level versus local definitions . . . . . . . . . 107
3.5 Types of concatenation functions . . . . . . . . . 110
3.6 Concatenation and scoping . . . . . . . . . . . . . 115
3.7 More list functions . . . . . . . . . . . . . . . . . . 119
3.8 Chapter Exercises . . . . . . . . . . . . . . . . . . . 122
3.9 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 128
4 Basic datatypes 131
4.1 Basic Datatypes . . . . . . . . . . . . . . . . . . . . 132
4.2 What are types? . . . . . . . . . . . . . . . . . . . . 133
4.3 Anatomy of a data declaration . . . . . . . . . . . 133
4.4 Numeric types . . . . . . . . . . . . . . . . . . . . . 137
4.5 Comparing values . . . . . . . . . . . . . . . . . . . 147
4.6 Go on and Bool me . . . . . . . . . . . . . . . . . . 152
4.7 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . 160
4.8 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
4.9 Chapter Exercises . . . . . . . . . . . . . . . . . . . 167
4.10 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 172
4.11 Names and variables . . . . . . . . . . . . . . . . . 175
5 Types 178
5.1 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
5.2 What are types for? . . . . . . . . . . . . . . . . . . 180
5.3 How to read type signatures . . . . . . . . . . . . 182
5.4 Currying . . . . . . . . . . . . . . . . . . . . . . . . . 192
5.5 Polymorphism . . . . . . . . . . . . . . . . . . . . . 208</p>
<p>CONTENTS vi
5.6 Type inference . . . . . . . . . . . . . . . . . . . . . 217
5.7 Asserting types for declarations . . . . . . . . . . 222
5.8 Chapter Exercises . . . . . . . . . . . . . . . . . . . 225
5.9 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 239
5.10 Follow-up resources . . . . . . . . . . . . . . . . . 246
6 Typeclasses 247
6.1 Typeclasses . . . . . . . . . . . . . . . . . . . . . . . 248
6.2 What are typeclasses? . . . . . . . . . . . . . . . . . 248
6.3 Back to Bool . . . . . . . . . . . . . . . . . . . . . . 250
6.4 Eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
6.5 Writing typeclass instances . . . . . . . . . . . . . 257
6.6 Num . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
6.7 Type-defaulting typeclasses . . . . . . . . . . . . 278
6.8 Ord . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
6.9 Enum . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
6.10 Show . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
6.11 Read . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
6.12 Instances are dispatched by type . . . . . . . . . 304
6.13 Gimme more operations . . . . . . . . . . . . . . 309
6.14 Chapter Exercises . . . . . . . . . . . . . . . . . . . 314
6.15 Chapter Definitions . . . . . . . . . . . . . . . . . . 323
6.16 Typeclass inheritance, partial . . . . . . . . . . . 326
6.17 Follow-up resources . . . . . . . . . . . . . . . . . 326
7 More functional patterns 328</p>
<p>CONTENTS vii
7.1 Make it func-y . . . . . . . . . . . . . . . . . . . . . 329
7.2 Arguments and parameters . . . . . . . . . . . . . 329
7.3 Anonymous functions . . . . . . . . . . . . . . . . 339
7.4 Pattern matching . . . . . . . . . . . . . . . . . . . 344
7.5 Case expressions . . . . . . . . . . . . . . . . . . . . 360
7.6 Higher-order functions . . . . . . . . . . . . . . . 365
7.7 Guards . . . . . . . . . . . . . . . . . . . . . . . . . . 377
7.8 Function composition . . . . . . . . . . . . . . . . 387
7.9 Pointfree style . . . . . . . . . . . . . . . . . . . . . 392
7.10 Demonstrating composition . . . . . . . . . . . . 396
7.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 400
7.12 Chapter Definitions . . . . . . . . . . . . . . . . . . 406
7.13 Follow-up resources . . . . . . . . . . . . . . . . . 417
8 Recursion 419
8.1 Recursion . . . . . . . . . . . . . . . . . . . . . . . . 420
8.2 Factorial! . . . . . . . . . . . . . . . . . . . . . . . . . 421
8.3 Bottom . . . . . . . . . . . . . . . . . . . . . . . . . . 431
8.4 Fibonacci numbers . . . . . . . . . . . . . . . . . . 435
8.5 Integral division from scratch . . . . . . . . . . . 441
8.6 Chapter Exercises . . . . . . . . . . . . . . . . . . . 448
8.7 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 455
9 Lists 457
9.1 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 458
9.2 The list datatype . . . . . . . . . . . . . . . . . . . . 458</p>
<p>CONTENTS viii
9.3 Pattern matching on lists . . . . . . . . . . . . . . 460
9.4 List’s syntactic sugar . . . . . . . . . . . . . . . . . 464
9.5 Using ranges to construct lists . . . . . . . . . . . 465
9.6 Extracting portions of lists . . . . . . . . . . . . . 469
9.7 List comprehensions . . . . . . . . . . . . . . . . . 477
9.8 Spines and nonstrict evaluation . . . . . . . . . . 485
9.9 Transforming lists of values . . . . . . . . . . . . 500
9.10 Filtering lists of values . . . . . . . . . . . . . . . . 511
9.11 Zipping lists . . . . . . . . . . . . . . . . . . . . . . . 513
9.12 Chapter Exercises . . . . . . . . . . . . . . . . . . . 517
9.13 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 526
9.14 Follow-up resources . . . . . . . . . . . . . . . . . 529
10 Folding lists 530
10.1 Folds . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
10.2 Bringing you into the fold . . . . . . . . . . . . . . 531
10.3 Recursive patterns . . . . . . . . . . . . . . . . . . . 534
10.4 Fold right . . . . . . . . . . . . . . . . . . . . . . . . 535
10.5 Fold left . . . . . . . . . . . . . . . . . . . . . . . . . 548
10.6 How to write fold functions . . . . . . . . . . . . . 561
10.7 Folding and evaluation . . . . . . . . . . . . . . . . 568
10.8 Summary . . . . . . . . . . . . . . . . . . . . . . . . 571
10.9 Scans . . . . . . . . . . . . . . . . . . . . . . . . . . . 573
10.10 Chapter Exercises . . . . . . . . . . . . . . . . . . . 578
10.11 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 585
10.12 Follow-up resources . . . . . . . . . . . . . . . . . 589</p>
<p>CONTENTS ix
11 Algebraic datatypes 590
11.1 Algebraic datatypes . . . . . . . . . . . . . . . . . . 591
11.2 Data declarations review . . . . . . . . . . . . . . . 592
11.3 Data and type constructors . . . . . . . . . . . . . 594
11.4 Type constructors and kinds . . . . . . . . . . . . 597
11.5 Data constructors and values . . . . . . . . . . . . 599
11.6 What’s a type and what’s data? . . . . . . . . . . . 605
11.7 Data constructor arities . . . . . . . . . . . . . . . 611
11.8 What makes these datatypes algebraic? . . . . . 614
11.9 newtype . . . . . . . . . . . . . . . . . . . . . . . . . 620
11.10 Sum types . . . . . . . . . . . . . . . . . . . . . . . . 627
11.11 Product types . . . . . . . . . . . . . . . . . . . . . . 631
11.12 Normal form . . . . . . . . . . . . . . . . . . . . . . 636
11.13 Constructing and deconstructing values . . . . 642
11.14 Function type is exponential . . . . . . . . . . . . 667
11.15 Higher-kinded datatypes . . . . . . . . . . . . . . 674
11.16 Lists are polymorphic . . . . . . . . . . . . . . . . 677
11.17 Binary Tree . . . . . . . . . . . . . . . . . . . . . . . 681
11.18 Chapter Exercises . . . . . . . . . . . . . . . . . . . 690
11.19 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 703
12 Signaling adversity 704
12.1 Signaling adversity . . . . . . . . . . . . . . . . . . 705
12.2 How I learned to stop worrying and love Nothing 705
12.3 Bleating either . . . . . . . . . . . . . . . . . . . . . 709
12.4 Kinds, a thousand stars in your types . . . . . . 720</p>
<p>CONTENTS x
12.5 Chapter Exercises . . . . . . . . . . . . . . . . . . . 732
12.6 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 748
13 Building projects 750
13.1 Modules . . . . . . . . . . . . . . . . . . . . . . . . . 751
13.2 Making packages with Stack . . . . . . . . . . . . 753
13.3 Working with a basic project . . . . . . . . . . . . 754
13.4 Making our project a library . . . . . . . . . . . . 759
13.5 Module exports . . . . . . . . . . . . . . . . . . . . 762
13.6 More on importing modules . . . . . . . . . . . . 765
13.7 Making our program interactive . . . . . . . . . 773
13.8 do syntax and IO . . . . . . . . . . . . . . . . . . . . 779
13.9 Hangman game . . . . . . . . . . . . . . . . . . . . 784
13.10 Step One: Importing modules . . . . . . . . . . . 787
13.11 Step Two: Generating a word list . . . . . . . . . 793
13.12 Step Three: Making a puzzle . . . . . . . . . . . . 798
13.13 Adding a newtype . . . . . . . . . . . . . . . . . . . 810
13.14 Chapter exercises . . . . . . . . . . . . . . . . . . . 811
13.15 Follow-up resources . . . . . . . . . . . . . . . . . 815
14 Testing 817
14.1 Testing . . . . . . . . . . . . . . . . . . . . . . . . . . 818
14.2 A quick tour of testing for the uninitiated . . . 819
14.3 Conventional testing . . . . . . . . . . . . . . . . . 821
14.4 Enter QuickCheck . . . . . . . . . . . . . . . . . . . 833
14.5 Morse code . . . . . . . . . . . . . . . . . . . . . . . 846</p>
<p>CONTENTS xi
14.6 Arbitrary instances . . . . . . . . . . . . . . . . . . 863
14.7 Chapter Exercises . . . . . . . . . . . . . . . . . . . 875
14.8 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 885
14.9 Follow-up resources . . . . . . . . . . . . . . . . . 886
15 Monoid, Semigroup 887
15.1 Monoids and semigroups . . . . . . . . . . . . . . 888
15.2 What we talk about when we talk about algebras 889
15.3 Monoid . . . . . . . . . . . . . . . . . . . . . . . . . . 890
15.4 How Monoid is defined in Haskell . . . . . . . . 892
15.5 Examples of using Monoid . . . . . . . . . . . . . 893
15.6 Why Integer doesn’t have a Monoid . . . . . . . 895
15.7 Why bother? . . . . . . . . . . . . . . . . . . . . . . 901
15.8 Laws . . . . . . . . . . . . . . . . . . . . . . . . . . . . 903
15.9 Diﬀerent instance, same representation . . . . . 908
15.10 Reusing algebras by asking for algebras . . . . . 911
15.11 Madness . . . . . . . . . . . . . . . . . . . . . . . . . 923
15.12 Better living through QuickCheck . . . . . . . . 925
15.13 Semigroup . . . . . . . . . . . . . . . . . . . . . . . . 936
15.14 Strength can be weakness . . . . . . . . . . . . . . 941
15.15 Chapter exercises . . . . . . . . . . . . . . . . . . . 944
15.16 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 955
15.17 Follow-up resources . . . . . . . . . . . . . . . . . 956
16 Functor 957
16.1 Functor . . . . . . . . . . . . . . . . . . . . . . . . . . 958</p>
<p>CONTENTS xii
16.2 What’s a functor? . . . . . . . . . . . . . . . . . . . 959
16.3 There’s a whole lot of fmapgoin’ round . . . . . 962
16.4 Let’s talk about 𝑓, baby . . . . . . . . . . . . . . . . 965
16.5 Functor Laws . . . . . . . . . . . . . . . . . . . . . . 979
16.6 The Good, the Bad, and the Ugly . . . . . . . . . 981
16.7 Commonly used functors . . . . . . . . . . . . . . 987
16.8 Transforming the unapplied type argument . . 1005
16.9 QuickChecking Functor instances . . . . . . . . 1010
16.10 Exercises: Instances of Func . . . . . . . . . . . . 1014
16.11 Ignoring possibilities . . . . . . . . . . . . . . . . . 1015
16.12 A somewhat surprising functor . . . . . . . . . . 1024
16.13 More structure, more functors . . . . . . . . . . . 1028
16.14 IO Functor . . . . . . . . . . . . . . . . . . . . . . . . 1030
16.15 What if we want to do something diﬀerent? . . 1034
16.16 Functors are unique to a datatype . . . . . . . . . 1039
16.17 Chapter exercises . . . . . . . . . . . . . . . . . . . 1041
16.18 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 1046
16.19 Follow-up resources . . . . . . . . . . . . . . . . . 1050
17 Applicative 1052
17.1 Applicative . . . . . . . . . . . . . . . . . . . . . . . 1053
17.2 Defining Applicative . . . . . . . . . . . . . . . . . 1054
17.3 Functor vs. Applicative . . . . . . . . . . . . . . . . 1057
17.4 Applicative functors are monoidal functors . . 1059
17.5 Applicative in use . . . . . . . . . . . . . . . . . . . 1067
17.6 Applicative laws . . . . . . . . . . . . . . . . . . . . 1106</p>
<p>CONTENTS xiii
17.7 You knew this was coming . . . . . . . . . . . . . 1115
17.8 ZipList Monoid . . . . . . . . . . . . . . . . . . . . 1120
17.9 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1135
17.10 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 1138
17.11 Follow-up resources . . . . . . . . . . . . . . . . . 1138
18 Monad 1140
18.1 Monad . . . . . . . . . . . . . . . . . . . . . . . . . . 1141
18.2 Sorry — a monad is not a burrito . . . . . . . . . 1141
18.3 Do syntax and monads . . . . . . . . . . . . . . . . 1154
18.4 Examples of Monaduse . . . . . . . . . . . . . . . . 1163
18.5 Monad laws . . . . . . . . . . . . . . . . . . . . . . . 1188
18.6 Application and composition . . . . . . . . . . . 1199
18.7 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1206
18.8 Definition . . . . . . . . . . . . . . . . . . . . . . . . 1209
18.9 Follow-up resources . . . . . . . . . . . . . . . . . 1211
19 Applying structure 1212
19.1 Applied structure . . . . . . . . . . . . . . . . . . . 1213
19.2 Monoid . . . . . . . . . . . . . . . . . . . . . . . . . . . 1213
19.3 Functor . . . . . . . . . . . . . . . . . . . . . . . . . . 1221
19.4 Applicative . . . . . . . . . . . . . . . . . . . . . . . . 1226
19.5 Monad. . . . . . . . . . . . . . . . . . . . . . . . . . . . 1233
19.6 An end-to-end example: URL shortener . . . . 1237
19.7 That’s a wrap! . . . . . . . . . . . . . . . . . . . . . . 1257
19.8 Follow-up resources . . . . . . . . . . . . . . . . . 1258</p>
<p>CONTENTS xiv
20 Foldable 1259
20.1 Foldable . . . . . . . . . . . . . . . . . . . . . . . . . 1260
20.2 The Foldable class . . . . . . . . . . . . . . . . . . . 1261
20.3 Revenge of the monoids . . . . . . . . . . . . . . . 1262
20.4 Demonstrating Foldable instances . . . . . . . . . 1268
20.5 Some basic derived operations . . . . . . . . . . 1273
20.6 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1280
20.7 Follow-up resources . . . . . . . . . . . . . . . . . 1281
21 Traversable 1282
21.1 Traversable . . . . . . . . . . . . . . . . . . . . . . . 1283
21.2 The Traversable typeclass definition . . . . . . . 1284
21.3 sequenceA . . . . . . . . . . . . . . . . . . . . . . . . . 1285
21.4 traverse . . . . . . . . . . . . . . . . . . . . . . . . . . 1287
21.5 So, what’s Traversable for? . . . . . . . . . . . . . . 1291
21.6 Morse code revisited . . . . . . . . . . . . . . . . . 1292
21.7 Axing tedious code . . . . . . . . . . . . . . . . . . 1296
21.8 Do all the things . . . . . . . . . . . . . . . . . . . . 1300
21.9 Traversable instances . . . . . . . . . . . . . . . . . 1304
21.10 Traversable Laws . . . . . . . . . . . . . . . . . . . . 1307
21.11 Quality Control . . . . . . . . . . . . . . . . . . . . 1308
21.12 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1309
21.13 Follow-up resources . . . . . . . . . . . . . . . . . 1314
22 Reader 1315
22.1 Reader . . . . . . . . . . . . . . . . . . . . . . . . . . 1316</p>
<p>CONTENTS xv
22.2 A new beginning . . . . . . . . . . . . . . . . . . . . 1317
22.3 This is Reader . . . . . . . . . . . . . . . . . . . . . 1327
22.4 Breaking down the Functor of functions . . . . . 1328
22.5 But uh, Reader ? . . . . . . . . . . . . . . . . . . . . . 1334
22.6 Functions have an Applicative too . . . . . . . . . 1337
22.7 The Monadof functions . . . . . . . . . . . . . . . . 1345
22.8 Reader Monad by itself is boring . . . . . . . . . . . 1351
22.9 You can change what comes below, but not above 1354
22.10 You tend to see ReaderT , notReader . . . . . . . . . 1355
22.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1355
22.12 Definition . . . . . . . . . . . . . . . . . . . . . . . . 1362
22.13 Follow-up resources . . . . . . . . . . . . . . . . . 1363
23 State 1364
23.1 State . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1365
23.2 What is state? . . . . . . . . . . . . . . . . . . . . . . 1365
23.3 Random numbers . . . . . . . . . . . . . . . . . . . 1367
23.4 The Statenewtype . . . . . . . . . . . . . . . . . . . 1371
23.5 Throw down . . . . . . . . . . . . . . . . . . . . . . 1374
23.6 Write Statefor yourself . . . . . . . . . . . . . . . 1383
23.7 Get a coding job with one weird trick . . . . . . 1385
23.8 Chapter exercises . . . . . . . . . . . . . . . . . . . 1392
23.9 Follow-up resources . . . . . . . . . . . . . . . . . 1394
24 Parser combinators 1395
24.1 Parser combinators . . . . . . . . . . . . . . . . . . 1396</p>
<p>CONTENTS xvi
24.2 A few more words of introduction . . . . . . . . 1398
24.3 Understanding the parsing process . . . . . . . . 1399
24.4 Parsing fractions . . . . . . . . . . . . . . . . . . . . 1416
24.5 Haskell’s parsing ecosystem . . . . . . . . . . . . . 1425
24.6 Alternative . . . . . . . . . . . . . . . . . . . . . . . . 1429
24.7 Parsing configuration files . . . . . . . . . . . . . . 1444
24.8 Character and token parsers . . . . . . . . . . . . 1460
24.9 Polymorphic parsers . . . . . . . . . . . . . . . . . 1465
24.10 Marshalling from an AST to a datatype . . . . . 1474
24.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1491
24.12 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 1500
24.13 Follow-up resources . . . . . . . . . . . . . . . . . 1501
25 Composing types 1504
25.1 Composing types . . . . . . . . . . . . . . . . . . . 1505
25.2 Common functions as types . . . . . . . . . . . . 1506
25.3 Two little functors sittin’ in a tree,
L-I-F-T-I-N-G . . . . . . . . . . . . . . . . . . . . . 1511
25.4 Twinplicative . . . . . . . . . . . . . . . . . . . . . . 1514
25.5 Twonad? . . . . . . . . . . . . . . . . . . . . . . . . . 1516
25.6 Exercises: Compose Instances . . . . . . . . . . . 1518
25.7 Monad transformers . . . . . . . . . . . . . . . . . 1520
25.8 IdentityT . . . . . . . . . . . . . . . . . . . . . . . . . 1523
25.9 Finding a pattern . . . . . . . . . . . . . . . . . . . 1542
26 Monad transformers 1546</p>
<p>CONTENTS xvii
26.1 Monad transformers . . . . . . . . . . . . . . . . . 1547
26.2 MaybeT . . . . . . . . . . . . . . . . . . . . . . . . . . 1547
26.3 EitherT . . . . . . . . . . . . . . . . . . . . . . . . . . 1555
26.4 ReaderT . . . . . . . . . . . . . . . . . . . . . . . . . 1557
26.5 StateT . . . . . . . . . . . . . . . . . . . . . . . . . . . 1561
26.6 Types you probably don’t want to use . . . . . . 1566
26.7 Recovering an ordinary type from a transformer 1568
26.8 Lexically inner is structurally outer . . . . . . . 1570
26.9 MonadTrans . . . . . . . . . . . . . . . . . . . . . . 1574
26.10 MonadIO aka zoom-zoom . . . . . . . . . . . . . 1597
26.11 Monad transformers in use . . . . . . . . . . . . . 1601
26.12 Monads do not commute . . . . . . . . . . . . . . 1617
26.13 Transform if you want to . . . . . . . . . . . . . . 1617
26.14 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1618
26.15 Defintion . . . . . . . . . . . . . . . . . . . . . . . . . 1627
26.16 Follow-up resources . . . . . . . . . . . . . . . . . 1628
27 Nonstrictness 1629
27.1 Laziness . . . . . . . . . . . . . . . . . . . . . . . . . 1630
27.2 Observational Bottom Theory . . . . . . . . . . . 1631
27.3 Outside in, inside out . . . . . . . . . . . . . . . . . 1633
27.4 What does the other way look like? . . . . . . . . 1637
27.5 Can we make Haskell strict? . . . . . . . . . . . . . 1638
27.6 Call by name, call by need . . . . . . . . . . . . . 1657
27.7 Nonstrict evaluation changes what we can do . 1658
27.8 Thunk Life . . . . . . . . . . . . . . . . . . . . . . . 1660</p>
<p>CONTENTS xviii
27.9 Sharing is caring . . . . . . . . . . . . . . . . . . . . 1664
27.10 Refutable and irrefutable patterns . . . . . . . . 1686
27.11 Bang patterns . . . . . . . . . . . . . . . . . . . . . . 1689
27.12 Strict and StrictData . . . . . . . . . . . . . . . . . 1693
27.13 Adding strictness . . . . . . . . . . . . . . . . . . . . 1695
27.14 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1702
27.15 Follow-up resources . . . . . . . . . . . . . . . . . 1705
28 Basic libraries 1707
28.1 Basic libraries and data structures . . . . . . . . . 1708
28.2 Benchmarking with Criterion . . . . . . . . . . . 1709
28.3 Profiling your programs . . . . . . . . . . . . . . . 1727
28.4 Constant applicative forms . . . . . . . . . . . . . 1732
28.5 Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1737
28.6 Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1741
28.7 Sequence . . . . . . . . . . . . . . . . . . . . . . . . . 1744
28.8 Vector . . . . . . . . . . . . . . . . . . . . . . . . . . . 1748
28.9 String types . . . . . . . . . . . . . . . . . . . . . . . 1762
28.10 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1775
28.11 Follow-up resources . . . . . . . . . . . . . . . . . 1779
29 IO 1781
29.1 IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1782
29.2 Where IO explanations go astray . . . . . . . . . 1783
29.3 The reason we need this type . . . . . . . . . . . 1786
29.4 Sharing . . . . . . . . . . . . . . . . . . . . . . . . . . 1788</p>
<p>CONTENTS xix
29.5 IO doesn’t disable sharing for everything . . . . 1795
29.6 Purity is losing meaning . . . . . . . . . . . . . . . 1797
29.7 IO’s Functor, Applicative, and Monad . . . . . . 1800
29.8 Well, then, how do we MVar? . . . . . . . . . . . . 1806
29.9 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1809
29.10 Follow-up resources . . . . . . . . . . . . . . . . . 1810
30 When things go wrong 1812
30.1 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . 1813
30.2 The Exception class and methods . . . . . . . . . 1814
30.3 This machine kills programs . . . . . . . . . . . . 1825
30.4 Want either? Try! . . . . . . . . . . . . . . . . . . . 1832
30.5 The unbearable imprecision of trying . . . . . . 1837
30.6 Why throwIO? . . . . . . . . . . . . . . . . . . . . . 1840
30.7 Making our own exception types . . . . . . . . . 1844
30.8 Surprising interaction with bottom . . . . . . . . 1851
30.9 Asynchronous Exceptions . . . . . . . . . . . . . . 1853
30.10 Follow-up Reading . . . . . . . . . . . . . . . . . . 1857
31 Final project 1859
31.1 Final project . . . . . . . . . . . . . . . . . . . . . . . 1860
31.2 fingerd . . . . . . . . . . . . . . . . . . . . . . . . . . 1860
31.3 Exploring finger . . . . . . . . . . . . . . . . . . . . 1862
31.4 Slightly modernized fingerd . . . . . . . . . . . . 1872
31.5 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1887</p>
<p>CONTENTS xx
Authors’ preface
Chris’s story
I’ve been programming for over 15 years, 8 of them profes-
sionally. I’ve worked primarily in Common Lisp, Clojure, and
Python. I became interested in Haskell about 6 years ago.
Haskell was the language that made me aware that progress
is being made in programming language research and that
there are benefits to using a language with a design informed
by knowledge of those advancements.
I’ve had type errors in Clojure that multiple professional
Clojure devs (including myself) couldn’t resolve in less than
2 hours because of the source-to-sink distance caused by dy-
namic typing. We had copious tests. We added println s ev-
erywhere. We tested individual functions from the REPL. It
still took ages. It was only 250 lines of Clojure. I did finally
fix it and found it was due to vectors in Clojure implementing
IFn. The crazy values that propagated from the IFnusage of
the vector allowed malformed data to propagate downward
far away from the origin of the problem. I’ve had similar hap-
pen in Python and Common Lisp as well. The same issue
in Haskell would be trivially resolved in a minute or less be-
cause the typechecker will identify precisely where you were
inconsistent.
I use Haskell because I want to be able to refactor without</p>
<p>CONTENTS xxi
fear, because I want maintenance to be something I don’t re-
sent, so I can reuse code freely. This doesn’t come without
learning new things. The diﬀerence between people that are
“good at math” who “do it in their head” and professional math-
ematicians is that the latter show their work and use tools that
help them get the job done. When you’re using a dynamically
typed language, you’re forcing yourself unnecessarily to do it
“in your head.” As a human with limited working memory, I
want all the help I can get to reason about and write correct
code. Haskell provides that help.
Haskell is not a difficult language to use — quite the opposite.
I’m now able to tackle problems that I couldn’t have tackled
when I was primarily a Clojure, Common Lisp, or Python
user. Haskell is difficult to teach eﬀectively, and the ineﬀective
pedagogy has made it hard for many people to learn.
It doesn’t have to be that way.
I’ve spent the last two years actively teaching Haskell on-
line and in person. Along the way, I started keeping notes
on exercises and methods of teaching specific concepts and
techniques that worked. Those notes eventually turned into
my guide for learning Haskell. I’m still learning how to teach
Haskell better by working with people locally in Austin, Texas,
as well as online in the IRC channel I made for beginners to
get help with learning Haskell.
I wrote this book because I had a hard time learning Haskell,
and I don’t want others to struggle the way I did.</p>
<p>CONTENTS xxii
Julie’s story
I met Chris Allen in spring 2014. We met on Twitter and
quickly became friends. As anyone who has encountered
Chris — probably in any medium, but certainly on Twitter —
knows, it doesn’t take long before he starts urging you to learn
Haskell.
I told him I had no interest in programming. I told him
nothing and nobody had ever been able to interest me in pro-
gramming before. When Chris learned of my background
in linguistics, he thought I might be interested in natural lan-
guage processing and exhorted me to learn Haskell for that
purpose. I remained unconvinced.
Then he tried a diﬀerent approach. He was spending a lot of
time gathering and evaluating resources for teaching Haskell
and refining his pedagogical techniques, and he convinced me
to try to learn Haskell so that he could gain the experience
of teaching a code-neophyte. Finally, with an “anything for
science” attitude, I gave in.
Chris had already known that the available Haskell learning
materials each had problems, but I don’t think even he realized
just how frustrating they would be to me. All of the materials
I ran across relied on a background with other programming
languages and left many terms undefined or explained fea-
tures of Haskell by analogy (often faulty) to features of other
languages — features I had no experience with.</p>
<p>CONTENTS xxiii
When I say I had no programming experience, I really, truly
mean it. I had to start from learning what a compiler does,
what version control means, what constitutes side eﬀects, what
is a library, what is a module, what on earth is a stack overflow.
At the time of this writing, that is where I was less than a year
ago; by the time we finish writing this book and it is published,
it will be a little over two years.
Eventually, as he realized that a new type of book for learn-
ing Haskell was necessary, he decided to write one. I agreed at
the time to be his guinea pig. He would send me chapters and
I would learn Haskell from them and send feedback. Through
the fall, we worked like this, on and oﬀ, in short bursts. Even-
tually we found it more efficient for me to take on authorship
duties. We developed a writing process where Chris made
the first pass at a chapter, scaﬀolding the material it needed to
cover. Then I filled in the parts that I understood and came
up with questions that would elaborate and clarify the parts I
didn’t already know. He answered my questions until I under-
stood, and I continued adding to and refining what was there.
We each wrote exercises — I write much easier ones than he
does, but the variety is beneficial.
I have tried, throughout the process, to keep thinking from
the perspective of the absolute beginner. For one thing, I
wanted my own understanding of Haskell to deepen as I wrote
soIkeptquestioningthethingsIthoughtIknew. Also, Iwanted
this book to be accessible to everyone.</p>
<p>CONTENTS xxiv
In interacting with other Haskell learners I often hear that
other materials leave them feeling like Haskell is difficult and
mysterious, a programming language best left to wizards.
It doesn’t have to be that way.</p>
<p>CONTENTS xxv
Acknowledgements
This book developed out of many eﬀorts to teach and learn
Haskell, online and oﬀ. We could not have done this without
the help of the growing community of friendly Haskellers as
well as the Haskell learners who have graciously oﬀered time
to help us make the book better.
First and foremost, we owe a huge debt of gratitude to our
first-round reviewers, Angela May O’Connor and Martin Vlk,
for their tremendous patience. We have sent them each some
very rough material, and they have been willing to work with
it and send detailed feedback about what worked and what
didn’t. Their reviews helped ensure the book is suitable for
both beginners and comprehensive. Also, they’re both just
wonderful people all around.
Martin DeMello, Daniel Gee, and Simon Yang have each
sent us (many) smart criticisms and helpful suggestions. The
book would have been shorter without their help, we think,
but it’s much more thorough and clear now.
A number of people have contributed feedback and tech-
nical review for limited parts of the book. Thanks to Sean
Chalmers, Erik de Castro Lopo, Alp Mestanogullari, Juan Al-
berto Sanchez, Jonathan Ferguson, Deborah Newton, Matt
Parsons, Peter Harpending, Josh Cartwright, Eric Mertens,
and George Makrydakis, who have all oﬀered critiques of our
writing and our technical coverage of diﬀerent topics.</p>
<p>CONTENTS xxvi
We have some very active early access readers who send us
a stream of feedback, everything from minor typographical
errors they find to questions about exercises, and we’re pleased
and grateful to have their input. The book would be messier
and the exercises less useful if not for their help. Julien Baley
and Jason Kuhrt have been particularly outstanding on this
front, not only representing a nontrivial portion of our reader
feedback over the course of several releases of the book, but
also catching things nobody else noticed.
The book cover was designed by David Deutsch (skore_de
on Twitter). He took pity on the state of our previous, original,
super special early access cover, and took it upon himself to
redesign it. We liked it so much we asked him to redo the book
web site as well. He’s a talented designer, and we’re grateful
for all the work he’s done for us.
A special thank-you is owed to Soryu Moronuki, Julie’s son,
who agreed to try to use the book to teach himself Haskell and
allowed us to use his feedback and occasionally blog about his
progress.
A warm hello to all the reading groups, both online and
in meatspace, that have formed to work through the book
together. We’ve had some great feedback from these groups
and hope to visit with you all someday. We’re delighted to see
the Haskell community growing.
We would also like to thank Michael Neale for being funny
and letting us use something he said on Twitter as an epigraph.</p>
<p>CONTENTS xxvii
Some day we hope to buy the gentleman a beer.
Thank you as well to Steven Proctor for having hosted us on
his Functional Geekery podcast, and to Adam Stacoviak and
Jerod Santo for inviting us onto their podcast, The Changelog
— and to Zaki Manian for bringing us to Adam and Jerod’s
attention.
Chris I would like to thank the participants in the #haskell-
beginners IRC channel, the teachers and the students, who have
helped me practice and refine my teaching techniques. Many
of the exercises and approaches in the book would’ve never
happened without the wonderful Haskell IRC community to
learn from.
I owe Alex Kurilin, Carter Schonwald, Aidan Coyne, and
Mark Wotton thanks for being there when I was reallybad at
teaching, being kind and patient friends, and for giving me
advice when I needed it. I wouldn’t have scratched this itch
without y’all.
Julie I would like to send a special shout-out to the Austin
Haskell meetup group, especially Sukant Hajra and Austin
Seipp for giving me the opportunity to teach the meetup.
The list of Haskellers who have responded to the kvetches
and confusions of a Haskell beginner with assistance, humor,
and advice would be very long indeed, but I owe special grati-
tude to Sooraj Bhat, Reid McKenzie, Dan Lien, Zaki Manian,</p>
<p>CONTENTS xxviii
and Alex Feldman-Crough for their help and encouragement.
I wouldn’t have made it through the last few months of fin-
ishing this thing without the patient advice and friendship of
Chris Martin.
My husband and children have tolerated me spending un-
countable hours immersed in the dark arts of thunkery. I am
grateful for their love, patience, and support and hope that
my kids will remember this: that it’s never too late to learn
something new. Besos, mijos.
Finally, a warm thank you to George Makrydakis for the
ongoing discussion on matters to do with math, programming,
and the weirding way.
Any errors in the book, of course, remain the sole responsi-
bility of the authors.</p>
<p>CONTENTS xxix
Introduction
Welcome to a new way to learn Haskell. Perhaps you are
coming to this book frustrated by previous attempts to learn
Haskell. Perhaps you have only the faintest notion of what
Haskell is. Perhaps you are coming here because you are not
convinced that anything will ever be better than Common
Lisp/Scala/Ruby/whatever language you love, and you want
to argue with us. Perhaps you were just looking for the 18
billionth (n.b.: this number may be inaccurate) monad tutorial,
certain that this time around you will understand monads
once and for all. Whatever your situation, welcome and read
on! It is our goal here to make Haskell as clear, painless, and
practical as we can, no matter what prior experiences you’re
bringing to the table.
Why This Book
If you are new to programming entirely, Haskell is a great
first language. Haskell is a general purpose, functional pro-
gramming1language. It’s applicable virtually anywhere one
would use a program to solve a problem, save for some specific
embedded applications. If you could write software to solve a
1Functional programming is a style of programming in which function calls, rather
than a series of instructions for the computer to execute, are the primary constructs of
your program. What it is doesn’t matter much right now; Haskell completely embodies
the functional style, so it will become clear over the course of the book.</p>
<p>CONTENTS xxx
problem, you could probably use Haskell.
If you are already a programmer, you may be looking to
enrich your skills by learning Haskell for a variety of reasons
— from love of pure functional programming itself to wanting
to write functional Scala code to finding a bridge to PureScript
or Idris. Languages such as Java are gradually adopting func-
tional concepts, but most were not designed to be functional
languages. Because Haskell is a pure functional language, it is
a fertile environment for mastering functional programming.
That way of thinking and problem solving is useful, no matter
what other languages you might know or learn. We’ve heard
from readers who are finding this book useful to their work in
diverse languages such as Scala, F#, Frege, Swift, PureScript,
Idris, and Elm.
Haskell has a bit of a reputation for being difficult. Writing
Haskellmayseemtobemoredifficultupfront, notjustbecause
of the hassle of learning a language that is syntactically and
conceptually diﬀerent from a language you already know, but
also because of features such as strong typing that enforce
some discipline in how you write your code. But what seems
like a bug is a feature. Humans, unfortunately, have relatively
limited abilities of short-term memory and concentration,
even if we don’t like to admit it. We cannot track all relevant
metadata about our programs in our heads. Using up working
memory for anything a computer can do for us is counter-
productive, and computers are very good at keeping track of</p>
<p>CONTENTS xxxi
data for us, including metadata such as types.
We don’t write Haskell because we’re geniuses — we use
tools like Haskell because they help us. Good tools like Haskell
enable us to work faster, make fewer mistakes, and have more
information about what our code is supposed to do as we read
it.
We use Haskell because it is easier (over the long run) and enables
us to do a better job. That’s it. There’s a ramp-up required in
order to get started, but that can be ameliorated with patience
and a willingness to work through exercises.
OK, but I was just looking for a monad tutorial...
The bad news is looking for an easy route into Haskell and
functional programming is how a lot of people end up think-
ing it’s “too hard” for them. The good news is we have a lot
of experience teaching and we don’t want that to happen to
anyone, but especially not you, gentle reader.
We encourage you to forget what you might already know
about programming and come at this course in Haskell with a
beginner’s mindset. Make yourself an empty vessel, ready to
let the types flow through you.
If you are an experienced programmer, learning Haskell is
more like learning to program all over again. Learning Haskell
imposes new ways of thinking about and structuring programs
on most people already comfortable with an imperative or</p>
<p>CONTENTS xxxii
untyped programming language. This makes it harder to
learn not because it is intrinsically harder, but because most
people who have learned at least a couple of programming
languages are accustomed to the process being trivial, and
their expectations have been set in a way that lends itself to
burnout and failure.
If Haskell is your first language, or even if it is not, you may
have noticed a specific problem with many Haskell learning
resources: they assume a certain level of background with
programming, so they frequently explain Haskell concepts in
terms, by analogy or by contrast, of programming concepts
from other languages. This is confusing for the student who
doesn’t know those other languages, but we posit that it is just
as unhelpful for experienced programmers. Most attempts to
compare Haskell with other languages only lead to a superficial
understanding of Haskell, and making analogies to loops and
other such constructs can lead to bad intuitions about how
Haskell code works. For all of these reasons, we have tried to
avoid relying on knowledge of other programming languages.
Just as you can’t achieve fluency in a human language so long
as you are still attempting direct translations of concepts and
structures from your native language to the target language,
it’s best to learn to understand Haskell on its own terms.</p>
<p>CONTENTS xxxiii
But I’ve heard Haskell is hard...
There’s a wild rumor that goes around the internet from time
to time about needing a Ph.D. in mathematics and an under-
standing of monads just to write “hello, world”2in Haskell.
We will write “hello, world” in Chapter 3. We’re going to do
some arithmetic before that to get you used to function syntax
and application in Haskell, but you will not need a Ph.D. in
monadology to write it.
Intruth, therewill be a monad underlyingour “hello, world,”
and by the end of the book, you willunderstand monads,
but you’ll be interacting with monadic code long before you
understand how it all works. You’ll find, at times, this book
goes into more detail than you strictly need to be able to write
Haskell successfully. There is no problem with that. You do
not need to understand everything in here perfectly on the
first try.
You are not a Spartan warrior who must come back with
your shield or on it. Returning later to investigate things more
deeply is an efficient technique, not a failure.
2Writing “hello, world” in a new programming language is a standard sort of “baby’s
first program,” so the idea here is that if it’s difficult to write a “hello, world” program,
then the language must be impossible. There are languages that have purposely made it
inhumanly difficult to write such programs, but Haskell is not one of them.</p>
<p>CONTENTS xxxiv
A few words to new programmers
We’ve tried very hard to make this book as accessible as possi-
ble, no matter your level of previous experience. We have kept
comparisons and mentions of other languages to a minimum,
and we promise that if we compare something in Haskell to
something in another language, that comparison is not itself
crucial to understanding the Haskell — it’s just a little extra for
those who do know the other language.
However, especially as the book progresses and the exercises
and projects get more “real,” there are going to be terms and
concepts that we do not have the space to explain fully but
that are relatively well known among programmers. You may
have to do internet searches for terms like JSON. The next
section of this introduction references things that you may not
know about but programmers will — don’t panic. We think
you’ll still get something out of reading it, but if not, it’s not
something to worry about. The fact that you don’t know every
term in this book before you come to it is not a sign that you
can’t learn Haskell or aren’t ready for this: it’s only a sign that
you don’t know everything yet , and since no one does, you’re in
fine company.
Along those same lines, this book does not oﬀer much in-
struction on using the terminal and text editor. The instruc-
tions provided assume you know how to find your way around
your terminal and understand how to do simple tasks like</p>
<p>CONTENTS xxxv
make a directory or open a file. Due to the number of text
editors available, we do not provide specific instructions for
any of them.3
If you need help or would like to start getting to know the
communities of functional programmers, there are several
options. The Freenode IRC channel #haskell-beginners has
teachers who will be glad to help you, and they especially
welcome questions regarding specific problems that you are
trying to solve.4There are also Slack channels and subreddits
where Haskellers congregate, along with a plethora of Haskell-
oriented blogs, many of which are mentioned in footnotes
and recommended readings throughout the book. Many of
our readers also program in languages like Swift and Scala, so
you may want to investigate those communities as well.
Haskevangelism
The rest of this introduction will give some background of
Haskell and will make reference to other programming lan-
3If you’re quite new and unsure what to do about text editors, you might consider
Atom. It’s free, open-source, and configurable. Sublime Text has served Julie well through-
out the writing of the book, but is not free. Chris uses Emacs most of the time; Emacs
is very popular among programmers, but has its own learning curve. Vim is another
popular text editor with itsown learning curve. If you have no experience with Emacs or
Vim, we’d really recommend sticking with something like Sublime or Atom for now.
4Freenode IRC (Internet Relay Chat) is a network of channels for textual chat. There
are other IRC networks around, as well as other group chat platforms, but the Freenode
IRC channels for Haskell are popular meeting places for the Haskell community. There
are several ways to access Freenode IRC, including Irssi and HexChat, if you’re interested
in getting to know the community in their natural habitat.</p>
<p>CONTENTS xxxvi
guages and styles. If you’re a new programmer, it is possible
not all of this will make sense, and that’s okay. The rest of the
book is written with beginners in mind, and the features we’re
outlining will make more sense as you work through the book.
We’re going to compare Haskell a bit with other languages
to demonstrate why we think using Haskell is valuable. Haskell
is a language in a progression of languages dating back to 1973,
when ML was invented by Robin Milner and others at the
University of Edinburgh. ML was itself influenced by ISWIM,
which was in turn influenced by ALGOL 60 and Lisp. We
mention this lineage because Haskell isn’tnew. The most pop-
ular implementation of Haskell, the Glasgow Haskell Compiler
(GHC), is mature and well-made. Haskell brings together some
nice design choices that make for a language that oﬀers more
expressiveness than Ruby, but more type safety than any lan-
guage presently in wide use commercially.
In 1968, the ALGOL68 dialect had the following features
built into the language:
1.User-defined record types.
2.User-defined sum types (unions not limited to simple
enumerations).
3.Switch/case expressions supporting the sum types.
4.Compile-time enforced constant values, declared with =
rather than :=.</p>
<p>CONTENTS xxxvii
5.Unified syntax for using value and reference types — no
manual pointer dereferencing.
6.Closures with lexical scoping (without this, many func-
tional patterns fall apart).
7.Implementation-agnostic parallelized execution of pro-
cedures.
8.Multi-pass compilation — you can declare stuﬀ after you
use it.
As of the early 21st century, many popular languages used
commercially don’t have anything equivalent to or better than
what ALGOL68 had. We mention this because we believe
technological progress in computer science, programming,
and programming languages is possible, desirable, and critical
to software becoming a true engineering discipline. By that,
we mean that while the phrase “software engineering” is in
common use, engineering disciplines involve the application
of both scientific and practical knowledge to the creation and
maintenance of better systems. As the available materials
change and as knowledge grows, so must engineers.
Haskell leverages more of the developments in program-
ming languages invented since ALGOL68 than most languages
in popular use, but with the added benefit of a mature imple-
mentation and sound design. Sometimes we hear Haskell be-
ing dismissed as “academic” because it is relatively up-to-date</p>
<p>CONTENTS xxxviii
with the current state of mathematics and computer science
research. In our view, that progress is good and helps us solve
practical problems in modern computing and software design.
Progress is possible and desirable, but it is not monotonic or
inevitable. The history of the world is riddled with examples
of uneven progress. For example, it is estimated that scurvy
killed two million sailors between the years 1500 and 1800.
Western culture has forgotten the cure for scurvy multiple
times. As early as 1614, the Surgeon General of the East In-
dia Company recommended bringing citrus on voyages for
scurvy. It saved lives, but the understanding of whycitrus
cured scurvy was incorrect. This led to the use of limes, which
have a lower vitamin C content than lemons, and scurvy re-
turned until ascorbic acid was discovered in 1932. Indiscipline
and stubbornness (the British Navy stuck with limes despite
sailors continuing to die from scurvy) can hold back progress.
We’d rather have a doctor who is willing to understand that
he makes mistakes, will be responsive to new information,
and even actively seek to expand his understanding rather
than one that hunkers down with a pet theory informed by
anecdote.
There are other ways to prevent scurvy, just as there are
other programming languages you can use to write software.
Or perhaps you are an explorer who doesn’t believe scurvy
can happen to you. But packing lemons provides some in-
surance on those long voyages. Similarly, having Haskell in</p>
<p>CONTENTS xxxix
your toolkit, even when it’s not your only tool, provides type
safety and predictability that can improve your software devel-
opment. Buggy software might not literally make your teeth
fall out, but software problems are far from trivial, and when
there are better ways to solve those problems — not perfect,
but better — it’s worth your time to investigate them.
Set your limes aside for now, and join us at the lemonade
stand.
What’s in this book?
This book is more of a course than a book, something to
be worked through. There are exercises sprinkled liberally
throughout the book; we encourage you to do them, even
when they seem simple. Those exercises are where the major-
ity of your epiphanies will come from. No amount of chatter-
ing, no matter how well structured and suited to your temper-
ament, will be as eﬀective as doing the work . If you do get to
a later chapter and find you did not understand a concept or
structure well enough, you may want to return to an earlier
chapter and do more exercises until you understand it.
We believe that spaced repetition and iterative deepening
are eﬀective strategies for learning, and the structure of the
book reflects this. You may notice we mention something
only briefly at first, then return to it over and over. As your
experience with Haskell deepens, you have a base from which</p>
<p>CONTENTS xl
to move to a deeper level of understanding. Try not to worry
that you don’t understand something completely the first time
we mention it. By moving through the exercises and returning
to concepts, you can develop a solid intuition for functional
programming.
Theexercisesinthefirstfewchaptersaredesignedtorapidly
familiarize you with basic Haskell syntax and type signatures,
but you should expect exercises to grow more challenging
in each successive chapter. Where possible, reason through
the code samples and exercises in your head first, then type
them out — either into the REPL5or into a source file — and
check to see if you were right. This will maximize your ability
to understand and reason about programs and about Haskell.
Later exercises may be difficult. If you get stuck on an exercise
for an extended period of time, proceed and return to it at a
later date.
We cover a mix of practical and abstract matters required
to use Haskell for a wide variety of projects. Chris’s experience
is principally with production backend systems and frontend
web applications. Julie is a linguist and teacher by training
and education, and learning Haskell was her first experience
with computer programming. The educational priorities of
this book are biased by those experiences. Our goal is to help
5This is short for read-eval-print loop, an interactive programming shell that evaluates
expressions and returns results in the same environment. The REPL we’ll be using is
called GHCi — ‘i’ for “interactive.”</p>
<p>CONTENTS xli
you not just write typesafe functional code but to understand
it on a deep enough level that you can go from here to more
advanced Haskell projects in a variety of ways, depending on
your own interests and priorities.
Each chapter focuses on diﬀerent aspects of a particular
topic. We start with a short introduction to the lambda calcu-
lus. What does this have to do with programming? All modern
functional languages are based on the lambda calculus, and a
passing familiarity with it will help you down the road with
Haskell. If you’ve understood the lambda calculus, under-
standing the feature known as currying will be a breeze, for
example.
The next few chapters cover basic expressions and functions
in Haskell, some simple operations with strings (text), and a few
essential types. You may feel a strong temptation, especially if
you have programmed previously, to skim or skip those first
chapters. Please do not do this. Even if those first chapters are
covering concepts you’re familiar with, it’s important to spend
time getting comfortable with Haskell’s terse syntax, making
sure you understand the diﬀerence between working in the
REPL and working in source files, and becoming familiar with
the compiler’s sometimes quirky error messages. Certainly
you may work quickly through those chapters — just don’t
skip them.
From there, we build both outward and upward so that your
understanding of Haskell both broadens and deepens. When</p>
<p>CONTENTS xlii
you finish this book, you will not just know what monads
are, you will know how to use them eﬀectively in your own
programs and understand the underlying algebra involved.
We promise — you will. We only ask that you do not go on to
write a monad tutorial on your blog that explains how monads
are really just like jalapeno poppers.
In each chapter you can expect:
•additions to your vocabulary of standard functions;
•syntactic patterns that build on each other;
•theoretical foundations so you understand how Haskell
works;
•illustrative examples of how to read Haskell code;
•step-by-step demonstrations of how to write your own
functions;
•explanations of how to read common error messages and
how to avoid those errors;
•exercises of varying difficulty sprinkled throughout;
•definitions of important terms.
We have put definitions at the end of most chapters. Each
term is, of course, defined within the body of the chapter, but</p>
<p>CONTENTS xliii
we added separate definitions at the end as a point of review.
If you’ve taken some time oﬀ between one chapter and the
next, the definitions can remind you of what you have already
learned, and, of course, they may be referred to any time you
need a refresher.
There are also recommendations at the end of most chap-
ters for followup reading. They are certainly not required but
are resources we personally found accessible and helpful that
may help you learn more about topics covered in the chapter.
Best practices for examples and exercises
We have tried to include a variety of examples and exercises in
each chapter. While we have made every eﬀort to include only
exercises that serve a clear pedagogical purpose, we recognize
that not all individuals enjoy or learn as much from every
type of demonstration or exercise. Also, since our readers
will necessarily come to the book with diﬀerent backgrounds,
some exercises may seem too easy or difficult to you but be
just right for someone else. Do your best to work through
as many exercises as seems practical for you. But if you skip
all the types and typeclasses exercises and then find yourself
confused when we get to Monoid, by all means, come back
and do more exercises until you understand.
Here are a few things to keep in mind to get the most out
of them:</p>
<p>CONTENTS xliv
•Examples are usually designed to demonstrate, with real
code, what we’ve just talked or are about to talk about in
further detail.
•You are intended to typeall of the examples into the REPL
or a file and load them. We strongly encourage you to
attempt to modify the example and play with the code af-
ter you’ve made it work. Forming hypotheses about what
eﬀect changes will have and verifying them is critical! It
is better to type the code examples and exercises yourself
rather than copy and paste because typing makes you pay
more attention to it.
•Sometimes the examples are designed intentionally to be
broken. Check surrounding prose if you’re confused by
an unexpected error as we will not show you code that
doesn’t work without commenting on the breakage. If it’s
still broken and it’s not supposed to be, you should start
checking your syntax and formatting for errors.
•Not every example is designed to be entered into the
REPL; not every example is designed to be entered into
a file. Once we have explained the syntactic diﬀerences
between files and REPL expressions, you are expected to
perform the translation between the two yourself. You
should be accustomed to working with code in an interac-
tive manner by the time you finish the book. You’ll want</p>
<p>CONTENTS xlv
to gradually move away from typing code examples and
exercises, except in limited cases, directly into GHCi and
develop the habit of working in source files. Editing and
modifying code, as you will be doing a lot as you rework
exercises, is easier and more practical in a source file. You
will still load your code into GHCi to run it.
•You may want to keep exercises, especially longer ones, as
named modules. There are several exercises, especially
later in the book, that we return to several times and being
able to reload the work you’ve already done and add only
the new parts will save you a lot of time and grief. We
have tried to note some of the exercises where this will
be especially helpful.
•Exercises at the end of the chapter may include some re-
view questions covering material from previous chapters
and are more or less ordered from least to most challeng-
ing. Your mileage may vary.
•Even exercises that seem easy can increase your fluency
in a topic. We do not fetishize difficulty for difficulty’s
sake. We just want you to understand the topics as well
as possible. That can mean coming at the same problem
from diﬀerent angles.
•We ask you to write and then rewrite (using diﬀerent
syntax) a lot of functions. Few problems have only one</p>
<p>CONTENTS xlvi
possible solution, and solving the same problem in dif-
ferent ways increases your fluency and comfort with the
way Haskell works (its syntax, its semantics, and in some
cases, its evaluation order).
•Do not feel obligated to do all the exercises in a single
sitting or even in a first pass through the chapter. In fact,
spaced repetition is generally a more eﬀective strategy.
•Some exercises, particularly in the earlier chapters, may
seem very contrived. Well, they are. But they are con-
trived to pinpoint certain lessons. As the book goes on
and you have more Haskell under your belt, the exercises
become less contrived and more like “real Haskell.”
•Another benefit to writing code in a source file and then
loading it into the REPL is that you can write comments
about the process you went through in solving a problem.
Writing out your own thought process can clarify your
thoughts and make the solving of similar problems easier.
At the very least, you can refer back to your comments
and learn from yourself.
•Sometimes we intentionally underspecify function def-
initions. You’ll commonly see things like:
f=undefined</p>
<p>CONTENTS xlvii
Even when 𝑓will probably take named arguments in your
implementation, we’re not going to name them for you.
Nobody will scaﬀold your code for you in your future
projects, so don’t expect this book to either.</p>
<p>Chapter 1
All You Need is Lambda
Even the greatest
mathematicians, the ones
that we would put into
our mythology of great
mathematicians, had to
do a great deal of leg
work in order to get to
the solution in the end.
Daniel Tammett
1</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 2
1.1 All You Need is Lambda
This chapter provides a very brief introduction to the lambda
calculus, a model of computation devised in the 1930s by
Alonzo Church. A calculus is a method of calculation or rea-
soning; the lambda calculus is one process for formalizing a
method. Like Turing machines, the lambda calculus formal-
izes the concept of eﬀective computability, thus determining
which problems, or classes of problems, can be solved.
You may be wondering where the Haskell is. You may be
contemplating skipping this chapter. You may feel tempted
to skip ahead to the fun stuﬀ when we build a project.
DON’T.
We’re starting from first principles here so that when we
get around to building projects you know what you’re doing.
You don’t start building a house from the attic down; you start
from the foundation. Lambda calculus is your foundation,
because Haskell is a lambda calculus.
1.2 What is functional programming?
Functionalprogrammingisacomputerprogrammingparadigm
that relies on functions modeled on mathematical functions.
The essence of functional programming is that programs are
a combination of expressions . Expressions include concrete
values, variables, and also functions. Functions have a more</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 3
specific definition: they are expressions that are applied to
an argument or input, and once applied, can be reduced or
evaluated . In Haskell, and in functional programming more
generally, functions are first-class : they can be used as values
or passed as arguments, or inputs, to yet more functions. We’ll
define these terms more carefully as we progress through the
chapter.
Functional programming languages are all based on the
lambda calculus. Some languages in this general category
incorporate features into the language that aren’t translatable
into lambda expressions. Haskell is a purefunctional language,
because it does not. We’ll address this notion of purity more
later in the book, but it isn’t a judgment of the moral worth of
other languages.
The word purity in functional programming is sometimes
also used to mean what is more properly called referential
transparency . Referential transparency means that the same
function, given the same values to evaluate, will always return
the same result in pure functional programming, as they do
in math.
Haskell’s pure functional basis also lends it a high degree
of abstraction and composability. Abstraction allows you to
write shorter, more concise programs by factoring common,
repeated structures into more generic code that can be reused.
Haskell programs are built from separate, independent func-
tions, kind of like LEGO®: the functions are bricks that can be</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 4
assembled and reassembled.
These features also make Haskell’s syntax rather minimalist,
as you’ll soon see.
1.3 What is a function?
If we step back from using the word “lambda,” you most likely
already know what a function is. A function is a relation be-
tween a set of possible inputs and a set of possible outputs. The
function itself defines and represents the relationship. When
you apply a function such as addition to two inputs, it maps
those two inputs to an output — the sum of those numbers.
For example, let’s imagine a function named 𝑓that defines
the following relations where the first value is the input and
the second is the output:
𝑓(1) = 𝐴
𝑓(2) = 𝐵
𝑓(3) = 𝐶
The input set is {1,2,3} and the output set is {𝐴,𝐵,𝐶} .1A
crucial point about how these relations are defined: our hypo-
thetical function will always return the value 𝐴given the input
1— no exceptions!
1For those who would like precise terminology, the input set is known as the domain.
The set of possible outputs for the function is called the codomain. All domains and</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 5
In contrast, the following is nota valid function:
𝑓(1) = 𝑋
𝑓(1) = 𝑌
𝑓(2) = 𝑍
This gets back to the referential transparency we mentioned
earlier: given the same input, the output should be predictable.
Is the following function valid?
𝑓(1) = 𝐴
𝑓(2) = 𝐴
𝑓(3) = 𝐴
Yes, having the same output for more than one input is valid.
Imagine, for example, that you need a function that tests a
positive integer for being less than 10. You’d want it to return
Truewhen the input was less than 10 and Falsefor all other
cases. In that case, several diﬀerent inputs will result in the
output True; many more will give a result of False. Diﬀerent
inputs can lead to the same output.
codomains are sets of unique values. The subset of the codomain that contains possible
outputs related to diﬀerent inputs is known as the image. The mapping between the
domain and the image or codomain need not be one-to-one; in some cases, multiple
input values will map to the same value in the image, as when a function returns either
‘true’ or ‘false’ so that many diﬀerent inputs map to each of those output values. However,
a given input should not map to multiple outputs.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 6
What matters here is that the relationship of inputs and
outputs is defined by the function, and that the output is pre-
dictable when you know the input and the function definition.
In the above examples, we didn’t demonstrate a relationship
between the inputs and outputs. Let’s look at an example that
does define the relationship. This function is again named 𝑓:
𝑓(𝑥) = 𝑥+1
This function takes one argument, which we have named
𝑥. The relationship between the input, 𝑥, and the output is
described in the function body. It will add 1 to whatever value
𝑥is and return that result. When we apply this function to a
value, such as 1, we substitute the value in for 𝑥:
𝑓(1) = 1+1
𝑓applied to 1 equals 1 + 1. That tells us how to map the input
to an output: 1 added to 1 becomes 2:
𝑓(1) = 2
Understanding functions in this way — as a mapping of a
set of inputs to a set of outputs — is crucial to understanding
functional programming.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 7
1.4 The structure of lambda terms
The lambda calculus has three basic components, or lambda
terms: expressions, variables, and abstractions. The word ex-
pression refers to a superset of all those things: an expression
can be a variable name, an abstraction, or a combination of
those things. The simplest expression is a single variable. Vari-
ables here have no meaning or value; they are only names for
potential inputs to functions.
Anabstraction is afunction . It is a lambda term that has a
head (a lambda) and a body and is applied to an argument. An
argument is an input value.
Abstractions consist of two parts: the headand the body.
The head of the function is a 𝜆(lambda) followed by a variable
name. The body of the function is another expression. So, a
simple function might look like this:
𝜆𝑥.𝑥
The variable named in the head is the parameter andbinds
all instances of that same variable in the body of the function.
That means, when we apply this function to an argument,
each𝑥in the body of the function will have the value of that
argument. We’ll demonstrate this in the next section.
In the previous section, we were talking about functions
called𝑓, but the lambda abstraction 𝜆𝑥.𝑥has no name. It is an</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 8
anonymous function . A named function can be called by name
by another function; an anonymous function cannot.
Let’s break down the basic structure:
λ x . x
^─┬─^
└────── extent of the head of the lambda.
λ x . x
^────── the single parameter of the
function. This binds any
variables with the same name
in the body of the function.
λ x . x
^── body, the expression the lambda
returns when applied. This is a
bound variable.
The dot ( .) separates the parameters of the lambda from
the function body.
The abstraction as a whole has no name, but the reason
we call it an abstraction is that it is a generalization, or abstrac-
tion, from a concrete instance of a problem, and it abstracts
through the introduction of names. The names stand for con-
crete values, but by using named variables, we allow for the</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 9
possibility of applying the general function to diﬀerent values
(or, perhaps even values of diﬀerent types, as we’ll see later).
When we apply the abstraction to arguments, we replace the
names with values, making it concrete.
Alpha equivalence
Often when people express this function in lambda calculus
you’ll see something like
𝜆𝑥.𝑥
The variable 𝑥here is not semantically meaningful except in
its role in that single expression. Because of this, there’s a form
of equivalence between lambda terms called alpha equivalence .
This is a way of saying that:
𝜆𝑥.𝑥
𝜆𝑑.𝑑
𝜆𝑧.𝑧
all mean the same thing. They’re all the same function.
Let’s look next at what happens when we apply this abstrac-
tion to a value.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 10
1.5 Beta reduction
When we apply a function to an argument, we substitute the
input expression for all instances of bound variables within
the body of the abstraction. You also eliminate the head of the
abstraction, since its only purpose was to bind a variable. This
process is called beta reduction .
Let’s use the function we had above:
𝜆𝑥.𝑥
We’ll do our first beta reduction using a number.2We apply
the function above to 2, substitute 2 for each bound variable
in the body of the function, and eliminate the head:
(𝜆𝑥.𝑥) 2
2
The only bound variable is the single 𝑥, so applying this
function to 2 returns 2. This function is the identity function.3
All it does is accept a single argument 𝑥and return that same
argument. The 𝑥has no inherent meaning, but, because it
is bound in the head of this function, when the function is
2The lambda calculus can derive numbers from lambda abstractions, rather than using
the numerals we are familiar with, but the applications can become quite cumbersome
and difficult to read.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 11
applied to an argument, all instances of 𝑥within the function
body must have the same value.
Let’s use an example that mixes some arithmetic into our
lambda calculus. We use the parentheses here to clarify that
thebodyexpressionis 𝑥+1. In otherwords, wearenotapplying
the function to the 1:
(𝜆𝑥.𝑥+1)
What is the result if we apply this abstraction to 2? How
about to 10?
Beta reduction is this process of applying a lambda term
to an argument, replacing the bound variables with the value
of the argument, and eliminating the head. Eliminating the
head tells you the function has been applied.
We can also apply our identity function to another lambda
abstraction:
(𝜆𝑥.𝑥)(𝜆𝑦.𝑦)
In this case, we’d substitute the entire abstraction in for 𝑥.
We’ll use a new syntax here, [𝑥 ∶= 𝑧] , to indicate that 𝑧will be
substituted for all occurrences of 𝑥(here𝑧is the function 𝜆𝑦.𝑦).
We reduce this application like this:
3Note that this is the same as the identity function in mathematical notation: u?(u?) = u? .
One diﬀerence is that u?(u?) = u? is a declaration involving a function named u?while the
above lambda abstraction isa function.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 12
(𝜆𝑥.𝑥)(𝜆𝑦.𝑦)
[𝑥 ∶= (𝜆𝑦.𝑦)]
𝜆𝑦.𝑦
Our final result is another identity function. There is no
argument to apply it to, so we have nothing to reduce.
Once more, but this time we’ll add another argument:
(𝜆𝑥.𝑥)(𝜆𝑦.𝑦)𝑧
Applications in the lambda calculus are left associative . That
is, unless specific parentheses suggest otherwise, they associate,
or group, to the left. So, this:
(𝜆𝑥.𝑥)(𝜆𝑦.𝑦)𝑧
can be rewritten as:
((𝜆𝑥.𝑥)(𝜆𝑦.𝑦))𝑧
Onward with the reduction:
((𝜆𝑥.𝑥)(𝜆𝑦.𝑦))𝑧
[𝑥 ∶= (𝜆𝑦.𝑦)]
(𝜆𝑦.𝑦)𝑧
[𝑦 ∶= 𝑧]
𝑧</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 13
We can’t reduce this any further as there is nothing left to
apply, and we know nothing about 𝑧.
We’ll look at functions below that have multiple heads and
alsofree variables (that is, variables in the body that are not
bound by the head), but the basic process will remain the same.
The process of beta reduction stops when there are either no
more heads, or lambdas, left to apply or no more arguments
to apply functions to. A computation therefore consists of an
initial lambda expression (or two, if you want to separate the
function and its input) plus a finite sequence of lambda terms,
each deduced from the preceding term by one application of
beta reduction. We keep following the rules of application,
substituting arguments in for bound variables until there are
no more heads left to evaluate or no more arguments to apply
them to.
Free variables
The purpose of the head of the function is to tell us which
variables to replace when we apply our function, that is, to
bind the variables. A bound variable must have the same value
throughout the expression.
But sometimes the body expression has variables that are
not named in the head. We call those variables free variables .
In the following expression:</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 14
𝜆𝑥.𝑥𝑦
The𝑥in the body is a bound variable because it is named in
the head of the function, while the 𝑦is a free variable because
it is not. When we apply this function to an argument, nothing
can be done with the 𝑦. It remains irreducible.
That whole abstraction can be applied to an argument, 𝑧,
like this: (𝜆𝑥.𝑥𝑦)𝑧 . We’ll show an intermediate step, using the
:=syntax we introduced above, that most lambda calculus
literature does not show:
1.(𝜆𝑥.𝑥𝑦)𝑧
We apply the lambda to the argument 𝑧.
2.(𝜆[𝑥 ∶= 𝑧].𝑥𝑦)
Since𝑥is the bound variable, all instances of 𝑥in the body
of the function will be replaced with 𝑧. The head will be
eliminated, and we replace any 𝑥in the body with a 𝑧.
3.𝑧𝑦
The head has been applied away, and there are no more
heads or bound variables. Since we know nothing about
𝑧or𝑦, we can reduce this no further.
Note that alpha equivalence does not apply to free vari-
ables. That is, 𝜆𝑥.𝑥𝑧and𝜆𝑥.𝑥𝑦are not equivalent because 𝑧
and𝑦might be diﬀerent things. However, 𝜆𝑥𝑦.𝑦𝑥 and𝜆𝑎𝑏.𝑏𝑎</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 15
are equivalent due to alpha equivalence, as are 𝜆𝑥.𝑥𝑧and𝜆𝑦.𝑦𝑧
because the free variable is left alone.
1.6 Multiple arguments
Each lambda can only bind one parameter and can only accept
one argument. Functions that require multiple arguments
have multiple, nested heads. When you apply it once and
eliminate the first (leftmost) head, the next one is applied and
so on. This formulation was originally discovered by Moses
Schönfinkel in the 1920s but was later rediscovered and named
after Haskell Curry and is commonly called currying .
What we mean by this description is that the following:
𝜆𝑥𝑦.𝑥𝑦
is a convenient shorthand for two nested lambdas (one for
each argument, 𝑥and𝑦):
𝜆𝑥.(𝜆𝑦.𝑥𝑦)
When you apply the first argument, you’re binding 𝑥, elimi-
nating the outer lambda, and have 𝜆𝑦.𝑥𝑦with x being whatever
the outer lambda was bound to.
To try to make this a little more concrete, let’s suppose
that we apply these lambdas to specific values. First, a simple
example with the identity function:</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 16
1.𝜆𝑥.𝑥
2.(𝜆𝑥.𝑥) 1
3.[𝑥 ∶= 1]
4.1
Now let’s look at a “multiple” argument lambda:
1.𝜆𝑥𝑦.𝑥𝑦
2.(𝜆𝑥𝑦.𝑥𝑦) 1 2
3.(𝜆𝑥.(𝜆𝑦.𝑥𝑦)) 1 2
4.[𝑥 ∶= 1]
5.(𝜆𝑦.1𝑦) 2
6.[𝑦 ∶= 2]
7.1 2
That wasn’t too interesting because it’s like nested identity
functions! We can’t meaningfully apply a 1 to a 2. Let’s try
something diﬀerent:
1.𝜆𝑥𝑦.𝑥𝑦
2.(𝜆𝑥𝑦.𝑥𝑦)(𝜆𝑧.𝑎) 1</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 17
3.(𝜆𝑥.(𝜆𝑦.𝑥𝑦))(𝜆𝑧.𝑎) 1
4.[𝑥 ∶= (𝜆𝑧.𝑎)]
5.(𝜆𝑦.(𝜆𝑧.𝑎)𝑦) 1
6.[𝑦 ∶= 1]
7.(𝜆𝑧.𝑎) 1 We still can apply this one more time.
8.[𝑧 ∶= 1] But there is no 𝑧in the body of the function, so
there is nowhere to put a 1. We eliminate the head, and
the final result is
9.𝑎
It’s more common in academic lambda calculus materi-
als to refer to abstract variables rather than concrete values.
The process of beta reduction is the same, regardless. The
lambda calculus is a process or method, like a game with a few
simple rules for transforming lambdas, but no specific mean-
ing. We’ve introduced concrete values to make the reduction
somewhat easier to see.
The next example uses only abstract variables. Due to al-
pha equivalence, you sometimes see expressions in lambda
calculus literature such as:
(𝜆𝑥𝑦.𝑥𝑥𝑦)(𝜆𝑥.𝑥𝑦)(𝜆𝑥.𝑥𝑧)</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 18
The substitution process can become a tangle of 𝑥s that are
not the same 𝑥because each was bound by a diﬀerent head. To
help make the reduction easier to read we’re going to use dif-
ferent variables in each abstraction, but it’s worth emphasizing
that the name of the variable (the letter) has no meaning or
significance:
1.(𝜆𝑥𝑦𝑧.𝑥𝑧(𝑦𝑧))(𝜆𝑚𝑛.𝑚)(𝜆𝑝.𝑝)
2.(𝜆𝑥.𝜆𝑦.𝜆𝑧.𝑥𝑧(𝑦𝑧))(𝜆𝑚.𝜆𝑛.𝑚)(𝜆𝑝.𝑝)
We’ve not reduced or applied anything here, but made
the currying explicit.
3.(𝜆𝑦.𝜆𝑧.(𝜆𝑚.𝜆𝑛.𝑚)𝑧(𝑦𝑧))(𝜆𝑝.𝑝)
Ourfirstreductionstepwastoapplytheoutermostlambda,
which was binding the 𝑥, to the first argument, (𝜆𝑚.𝜆𝑛.𝑚) .
4.𝜆𝑧.(𝜆𝑚.𝜆𝑛.𝑚)(𝑧)((𝜆𝑝.𝑝)𝑧)
We applied the 𝑦and replaced the single occurrence of
𝑦with the next argument, the term 𝜆𝑝.𝑝. The outermost
lambda binding 𝑧is, at this point, irreducible because it
has no argument to apply to. What remains is to go inside
the terms one layer at a time until we find something
reducible.
5.𝜆𝑧.(𝜆𝑛.𝑧)((𝜆𝑝.𝑝)𝑧)
We can apply the lambda binding 𝑚to the argument 𝑧.
We keep searching for terms we can apply. The next thing</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 19
we can apply is the lambda binding 𝑛to the lambda term
((𝜆𝑝.𝑝)𝑧) .
6.𝜆𝑧.𝑧
In the final step, the reduction takes a turn that might look
slightly odd. Here the outermost, leftmost reducible term
is𝜆𝑛.𝑧applied to the entirety of ((𝜆𝑝.𝑝)𝑧) . As we saw in
an example above, it doesn’t matter what 𝑛got bound to,
𝜆𝑛.𝑧unconditionally tosses the argument and returns 𝑧.
So, we are left with an irreducible lambda expression.
Intermission: Equivalence Exercises
We’ll give you a lambda expression. Keeping in mind both
alpha equivalence and how multiple heads are nested, choose
an answer that is equivalent to the listed lambda term.
1.𝜆𝑥𝑦.𝑥𝑧
a)𝜆𝑥𝑧.𝑥𝑧
b)𝜆𝑚𝑛.𝑚𝑧
c)𝜆𝑧.(𝜆𝑥.𝑥𝑧)
2.𝜆𝑥𝑦.𝑥𝑥𝑦
a)𝜆𝑚𝑛.𝑚𝑛𝑝
b)𝜆𝑥.(𝜆𝑦.𝑥𝑦)</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 20
c)𝜆𝑎.(𝜆𝑏.𝑎𝑎𝑏)
3.𝜆𝑥𝑦𝑧.𝑧𝑥
a)𝜆𝑥.(𝜆𝑦.(𝜆𝑧.𝑧))
b)𝜆𝑡𝑜𝑠.𝑠𝑡
c)𝜆𝑚𝑛𝑝.𝑚𝑛
1.7 Evaluation is simplification
There are multiple normal forms in lambda calculus, but here
when we refer to normal form we mean beta normal form . Beta
normalformiswhenyoucannotbetareduce(applylambdasto
arguments) the terms any further. This corresponds to a fully
evaluated expression, or, in programming, a fully executed
program. This is important to know so that you know when
you’re done evaluating an expression. It’s also valuable to have
an appreciation for evaluation as a form of simplification when
you get to the Haskell code as well.
Don’t be intimidated by calling the reduced form of an
expression its normal form. When you want to say “2,” do
you say 2000/1000 each time or do you say 2? The expression
2000/1000 is not fully evaluated because the division function
has been fully applied (two arguments), so it could be reduced,
or evaluated. In other words, there’s a simpler form it can be</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 21
reduced to — the number two. The normal form, therefore,
is 2.
The point is that if you have a function, such as (/), satu-
rated (all arguments applied) but you haven’t yet simplified it
to the final result then it is not fully evaluated, only applied.
Application is what makes evaluation/simplification possible.
Similarly, the normal form of the following is 600:
(10+2)∗100/2
We cannot reduce the number 600 any further. There are
no more functions that we can beta reduce. Normal form
means there is nothing left that can be reduced.
The identity function, 𝜆𝑥.𝑥, is fully reduced (that is, in nor-
mal form) because it hasn’t yet been applied to anything. How-
ever,(𝜆𝑥.𝑥)𝑧 isnotin beta normal form because the identity
function hasn’t been applied to a free variable 𝑧and hasn’t
been reduced. If we did reduce it, the final result, in beta
normal form, would be 𝑧.
1.8 Combinators
A combinator is a lambda term with no free variables. Combi-
nators, as the name suggests, serve only to combine the argu-
ments they are given.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 22
So the following are combinators because every term in the
body occurs in the head:
1.𝜆𝑥.𝑥
𝑥is the only variable and is bound because it is bound by
the enclosing lambda.
2.𝜆𝑥𝑦.𝑥
3.𝜆𝑥𝑦𝑧.𝑥𝑧(𝑦𝑧)
And the following are not because there’s one or more free
variables:
1.𝜆𝑦.𝑥
Here𝑦is bound (it occurs in the head of the lambda) but
𝑥is free.
2.𝜆𝑥.𝑥𝑧
𝑥is bound and is used in the body, but 𝑧is free.
We won’t have a lot to say about combinators per se. The
point is to call out a special class of lambda expressions that
canonlycombine the arguments it is given, without injecting
any new values or random data.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 23
1.9 Divergence
Not all reducible lambda terms reduce neatly to a beta normal
form. This isn’t because they’re already fully reduced, but
rather because they diverge . Divergence here means that the
reduction process never terminates or ends. Reducing terms
should ordinarily converge to beta normal form, and diver-
gence is the opposite of convergence, or normal form. Here’s
an example of a lambda term called omega that diverges:
1.(𝜆𝑥.𝑥𝑥)(𝜆𝑥.𝑥𝑥)
𝑥in the first lambda’s head becomes the second lambda
2.([𝑥 ∶= (𝜆𝑥.𝑥𝑥)]𝑥𝑥)
Using[𝑣𝑎𝑟 ∶= 𝑒𝑥𝑝𝑟] to denote what 𝑥has been bound to.
3.(𝜆𝑥.𝑥𝑥)(𝜆𝑥.𝑥𝑥)
Substituting (𝜆𝑥.𝑥𝑥) for each occurence of 𝑥. We’re back
to where we started and this reduction process never ends
— we can say omega diverges.
This matters in programming because terms that diverge
are terms that don’t produce an answer or meaningful result.
Understanding what will terminate means understanding what
programs will do useful work and return the answer we want.
We’ll cover this idea more later.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 24
1.10 Summary
The main points you should take away from this chapter are:
•Functional programming is based on expressions that in-
clude variables or constant values, expressions combined
with other expressions, and functions.
•Functions have a head and a body and are those expres-
sions that can be applied to arguments and reduced, or
evaluated, to a result.
•Variables may be bound in the function declaration, and
every time a bound variable shows up in a function, it has
the same value.
•All functions take one argument and return one result.
•Functions are a mapping of a set of inputs to a set of
outputs. Given the same input, they always return the
same result.
These things all apply to Haskell, as they do to any pure
functional languages, because semantically Haskell is a lambda
calculus. Haskell is a typedlambda calculus — more on types
later — with a lot of surface-level decoration sprinkled on top,
to make it easier for humans to write, but the semantics of the
core language are the same as the lambda calculus. That is,</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 25
the meaning of Haskell programs is centered around evaluat-
ing expressions rather than executing instructions, although
Haskell has a way to execute instructions, too. We will still
be making reference to the lambda calculus when we write
about all the later, apparently very complex topics: function
composition, monads, parser combinators. Don’t worry if you
don’t know those words yet. If you understood this chapter,
you have the foundation you need to understand them all.
1.11 Chapter Exercises
We’re going to do the following exercises a bit diﬀerently than
what you’ll see in the rest of the book, as we will be providing
some answers and explanations for the questions below.
Combinators Determine if each of the following are combi-
nators or not.
1.𝜆𝑥.𝑥𝑥𝑥
2.𝜆𝑥𝑦.𝑧𝑥
3.𝜆𝑥𝑦𝑧.𝑥𝑦(𝑧𝑥)
4.𝜆𝑥𝑦𝑧.𝑥𝑦(𝑧𝑥𝑦)
5.𝜆𝑥𝑦.𝑥𝑦(𝑧𝑥𝑦)</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 26
Normal form or diverge? Determine if each of the following
can be reduced to a normal form or if they diverge.
1.𝜆𝑥.𝑥𝑥𝑥
2.(𝜆𝑧.𝑧𝑧)(𝜆𝑦.𝑦𝑦)
3.(𝜆𝑥.𝑥𝑥𝑥)𝑧
Beta reduce Evaluate (that is, beta reduce) each of the fol-
lowing expressions to normal form. We strongly recommend
writing out the steps on paper with a pencil or pen.
1.(𝜆𝑎𝑏𝑐.𝑐𝑏𝑎)𝑧𝑧(𝜆𝑤𝑣.𝑤)
2.(𝜆𝑥.𝜆𝑦.𝑥𝑦𝑦)(𝜆𝑎.𝑎)𝑏
3.(𝜆𝑦.𝑦)(𝜆𝑥.𝑥𝑥)(𝜆𝑧.𝑧𝑞)
4.(𝜆𝑧.𝑧)(𝜆𝑧.𝑧𝑧)(𝜆𝑧.𝑧𝑦)
Hint: alpha equivalence.
5.(𝜆𝑥.𝜆𝑦.𝑥𝑦𝑦)(𝜆𝑦.𝑦)𝑦
6.(𝜆𝑎.𝑎𝑎)(𝜆𝑏.𝑏𝑎)𝑐
7.(𝜆𝑥𝑦𝑧.𝑥𝑧(𝑦𝑧))(𝜆𝑥.𝑧)(𝜆𝑥.𝑎)</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 27
1.12 Answers
Please note: At this time, this is the only chapter in the book for
which we have provided answers. We provide them here due
to the importance of being able to check your understanding
of this material and the relative difficulty of checking answers
that you probably wrote by hand in a notebook.
Equivalence Exercises
1.b
2.c
3.b
Combinators
1.𝜆𝑥.𝑥𝑥𝑥 is indeed a combinator, it refers only to the variable
x which is introduced as an argument.
2.𝜆𝑥𝑦.𝑧𝑥 is not a combinator, the variable z was not intro-
duced as an argument and is thus a free variable.
3.𝜆𝑥𝑦𝑧.𝑥𝑦(𝑧𝑥) is a combinator, all terms are bound. The head
is𝜆𝑥𝑦𝑧.and the body is 𝑥𝑦(𝑧𝑥). None of the arguments in
the head have been applied so it’s irreducible. The vari-
ables x, y, and z are all bound in the head and are not free.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 28
This makes the lambda a combinator - no occurrences of
free variables.
4.𝜆𝑥𝑦𝑧.𝑥𝑦(𝑧𝑥𝑦) is a combinator. The lambda has the head
𝜆𝑥𝑦𝑧.and the body: 𝑥𝑦(𝑧𝑥𝑦) . Again, none of the arguments
have been applied so it’s irreducible. All that is diﬀerent
is that the bound variable y is referenced twice rather
than once. There are still no free variables so this is also a
combinator.
5.𝜆𝑥𝑦.𝑥𝑦(𝑧𝑥𝑦) is not a combinator, z is free. Note that z isn’t
bound in the head.
Normal form or diverge?
1.𝜆𝑥.𝑥𝑥𝑥 doesn’t diverge, has no further reduction steps. If
it had been applied to itself, it would diverge, but by itself
does not as it is already in normal form.
2.(𝜆𝑧.𝑧𝑧)(𝜆𝑦.𝑦𝑦) diverges, it never reaches a point where the
reduction is done. This is the omega term we showed you
earlier, with diﬀerent names for the bindings. It’s alpha
equivalent to(𝜆𝑥.𝑥𝑥)(𝜆𝑥.𝑥𝑥) .
3.(𝜆𝑥.𝑥𝑥𝑥)𝑧 doesn’t diverge, it reduces to 𝑧𝑧𝑧.
Betareduce Thefollowingareevaluatedin normalorder , which
is where terms in the outer-most and left-most positions get</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 29
evaluated (applied) first. This means that if all terms are in
the outermost position (none are nested), then it’s left-to-right
application order.
1.(𝜆𝑎𝑏𝑐.𝑐𝑏𝑎)𝑧𝑧(𝜆𝑤𝑣.𝑤)
(𝜆𝑎.𝜆𝑏.𝜆𝑐.𝑐𝑏𝑎)(𝑧)𝑧(𝜆𝑤.𝜆𝑣.𝑤)
(𝜆𝑏.𝜆𝑐.𝑐𝑏𝑧)(𝑧)(𝜆𝑤.𝜆𝑣.𝑤)
(𝜆𝑐.𝑐𝑧𝑧)(𝜆𝑤.𝜆𝑣.𝑤)
(𝜆𝑤.𝜆𝑣.𝑤)(𝑧)𝑧
(𝜆𝑣.𝑧)(𝑧)
𝑧
2.(𝜆𝑥.𝜆𝑦.𝑥𝑦𝑦)(𝜆𝑎.𝑎)𝑏
(𝜆𝑦(𝜆𝑎.𝑎)𝑦𝑦)(𝑏)
(𝜆𝑎.𝑎)(𝑏)𝑏
𝑏𝑏
3.(𝜆𝑦.𝑦)(𝜆𝑥.𝑥𝑥)(𝜆𝑧.𝑧𝑞)
(𝜆𝑥.𝑥𝑥)(𝜆𝑧.𝑧𝑞)
(𝜆𝑧.𝑧𝑞)(𝜆𝑧.𝑧𝑞)
(𝜆𝑧.𝑧𝑞)(𝑞)
𝑞𝑞
4.(𝜆𝑧.𝑧)(𝜆𝑧.𝑧𝑧)(𝜆𝑧.𝑧𝑦)
(𝜆𝑧.𝑧𝑧)(𝜆𝑧.𝑧𝑦)
(𝜆𝑧.𝑧𝑦)(𝜆𝑧.𝑧𝑦)
(𝜆𝑧.𝑧𝑦)(𝑦)
𝑦𝑦</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 30
5.(𝜆𝑥.𝜆𝑦.𝑥𝑦𝑦)(𝜆𝑦.𝑦)𝑦
(𝜆𝑦(𝜆𝑦.𝑦)𝑦𝑦)(𝑦)
(𝜆𝑦.𝑦)(𝑦)𝑦
𝑦𝑦
6.(𝜆𝑎.𝑎𝑎)(𝜆𝑏.𝑏𝑎)𝑐
(𝜆𝑏.𝑏𝑎)(𝜆𝑏.𝑏𝑎)𝑐
(𝜆𝑏.𝑏𝑎)(𝑎)𝑐
𝑎𝑎𝑐
7.Steps we took
a)(𝜆𝑥𝑦𝑧.𝑥𝑧(𝑦𝑧))(𝜆𝑥.𝑧)(𝜆𝑥.𝑎)
b)(𝜆𝑥.𝜆𝑦.𝜆𝑧.𝑥𝑧(𝑦𝑧))(𝜆𝑥.𝑧)(𝜆𝑥.𝑎)
c)(𝜆𝑦.𝜆𝑧1(𝜆𝑥.𝑧)𝑧1(𝑦𝑧1))(𝜆𝑥.𝑎)
d)(𝜆𝑧1.(𝜆𝑥.𝑧)(𝑧1)((𝜆𝑥.𝑎)𝑧1))
e)(𝜆𝑧1.𝑧((𝜆𝑥.𝑎)(𝑧1)))
f)(𝜆𝑧1.𝑧𝑎) The𝑧1notation allows us to distinguish two
variables named 𝑧that came from diﬀerent places.
One is bound by the first head; the second is a free
variable in the second lambda expression.
How we got there, step by step
a)Our expression we’ll reduce.
b)Add the implied lambdas to introduce each argument.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 31
c)Apply the leftmost 𝑥and bind it to (𝜆𝑥.𝑧), rename
leftmost 𝑧to𝑧1for clarity to avoid confusion with the
other z. Hereafter, “z” is exclusively the z in (𝜆𝑥.𝑧).
d)Apply𝑦, it gets bound to (𝜆𝑥.𝑎).
e)Can’t apply z1 to anything, evaluation strategy is nor-
mal order so leftmost outermost is the order of the
day. Our leftmost, outermost lambda has no remain-
ing arguments to be applied so we now examine the
terms nested within to see if they are in normal form.
(𝜆𝑥.𝑧)gets applied to 𝑧1, tosses the 𝑧1away and returns
𝑧.𝑧is now being applied to ((𝜆𝑥.𝑎)(𝑧1)) .
f)Cannot reduce 𝑧further, it’s free and we know noth-
ing, so we go inside yet another nesting and reduce
((𝜆𝑥.𝑎)(𝑧1)) .𝜆𝑥.𝑎gets applied to 𝑧1, but tosses it away
and returns the free variable 𝑎. The𝑎is now part of
the body of that expression. All of our terms are in
normal order now.
1.13 Definitions
1.Thelambda in lambda calculus is the greek letter 𝜆used
to introduce, or abstract, arguments for binding in an
expression.
2.A lambda abstraction is an anonymous function or lambda</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 32
term.
(𝜆𝑥.𝑥+1)
The head of the expression, 𝜆𝑥., abstracts out the term
𝑥+1. We can apply it to any 𝑥and recompute diﬀerent
results for each 𝑥we applied the lambda to.
3.Application is how one evaluates or reduces lambdas, this
binds the argument to whatever the lambda was applied
to. Computations are performed in lambda calculus by
applying lambdas to arguments until you run out of ar-
guments to apply lambdas to.
(𝜆𝑥.𝑥)1
This example reduces to 1, the identity 𝜆𝑥.𝑥was applied
to the value 1,𝑥was bound to 1, and the lambda’s body is
𝑥, so it just kicks the 1out. In a sense, applying the 𝜆𝑥.𝑥
consumed it. Wereduced the amount of structure we had.
4.Lambda calculus is a formal system for expressing pro-
grams in terms of abstraction and application.
5.Normal order is a common evaluation strategy in lambda
calculi. Normal order means evaluating (ie, applying or
beta reducing) the leftmost outermost lambdas first, eval-
uating terms nested within after you’ve run out of argu-
ments to apply. Normal order isn’t how Haskell code is
evaluated - it’s call-by-need instead. We’ll explain this more</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 33
later. Answers to the evaluation exercises were written in
normal order.
1.14 Follow-up resources
These are optional and intended only to oﬀer suggestions on
how you might deepen your understanding of the preceding
topic. Ordered approximately from most approachable to
most thorough.
1.Raul Rojas. A Tutorial Introduction to the Lambda Calcu-
lus
http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf
2.Henk Barendregt; Erik Barendsen. Introduction to
Lambda Calculus
http://www.cse.chalmers.se/research/group/logic/
TypesSS05/Extra/geuvers.pdf
3.Jean-Yves Girard; P. Taylor; Yves Lafon. Proofs and Types
http://www.paultaylor.eu/stable/prot.pdf</p>
<p>Chapter 2
Hello, Haskell!
Functions are beacons of
constancy in a sea of
turmoil.
Mike Hammond
34</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 35
2.1 Hello, Haskell
Welcome to your first step in learning Haskell. Before you be-
gin with the main course of this book, you will need to install
the necessary tools in order to complete the exercises as you
work through the book. At this time, we recommend installing
Stack, which will install GHC Haskell, the interactive environ-
ment called GHCi, and a project build tool and dependency
manager all at once.
You can find the installation instructions online at http://
docs.haskellstack.org/en/stable/README/ , and there is also great
documentation that can help you get started using Stack. You
can also find installation instructions at https://github.com/
bitemyapp/learnhaskell ; there you will also find advice on learn-
ing Haskell and links to more exercises that may supplement
what you’re doing with this book.
Therestofthischapterwillassumethatyouhavecompleted
the installation and are ready to begin working. In this chapter,
you will
•use Haskell code in the interactive environment and also
from source files;
•understand the building blocks of Haskell: expressions
and functions;</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 36
•learn some features of Haskell syntax and conventions of
good Haskell style;
•modify simple functions.
2.2 Interacting with Haskell code
Haskell oﬀers two primary ways of working with code. The
first is inputting it directly into the interactive environment
known as GHCi, or the REPL. The second is typing it into a
text editor, saving, and then loading that source file into GHCi.
This section oﬀers an introduction to each method.
Using the REPL
REPL is an acronym short for read-eval-print loop . REPLs are
interactive programming environments where you can input
code, have it evaluated, and see the result. They originated
with Lisp but are now common to modern programming
languages including Haskell.
Assuming you’ve completed your installation, you should
be able to open your terminal or command prompt, type ghci
orstack ghci1, hit enter, and see something like the following:
GHCi, version 7.10.3:
1If you have installed GHC outside of Stack, then you should be able to open it with
just the ghcicommand, but if your only GHC installation is what Stack installed, then you
will need stack ghci .</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 37
http://www.haskell.org/ghc/ :? for help
Prelude&gt;
Ifyouused stack ghci2therewasprobablyalotmorestartup
text, and the prompt might be something other than Prelude .
That’s all fine. You may also have a diﬀerent version of GHC.
As long as your GHC version is between 7.8 and 8.0, it should
be compatible with everything in this book.
Now try entering some simple arithmetic at your prompt:
Prelude&gt; 2 + 2
4
Prelude&gt; 7 &lt; 9
True
Prelude&gt; 10 ^ 2
100
If you can enter simple equations at the prompt and get the
expected results, congratulations — you are now a functional
programmer! More to the point, your REPL is working well
and you are ready to proceed.
To exit GHCi, use the command :quitor:q.
What is Prelude ?Prelude is a library of standard functions.
Opening GHCi or Stack GHCi automatically loads those func-
2At this point in the book, you don’t need to use stack ghci , but in later chapters when
we’re importing a lot of modules and building projects, it will be much more convenient
to use it.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 38
tions so they can be used without needing to do anything
special. You can turn Prelude oﬀ, as we will show you later, and
there are alternative preludes, though we won’t use them in
the book. Prelude is contained in Haskell’s basepackage, which
can be found at https://www.stackage.org/package/base . You’ll
see us mention sometimes that something or other is “in base”
which means it’s contained in that large standard package.
GHCi commands
Throughout the book, we’ll be using GHCi commands, such
as:quitand:infoin the REPL. Special commands that only
GHCi understands begin with the :character. :quitisnot
Haskell code; it’s just a GHCi feature.
We will present them in the text spelled out, but they can
generally be abbreviated to just the colon and the first letter.
That is, :quitbecomes :q,:infobecomes :iand so forth. It’s
good to type the word out the first few times you use it, to help
you remember what the abbreviation stands for, but after a
few mentions, we will start abbreviating them.
Working from source files
As nice as REPLs are, usually you want to store code in a file
so you can build it incrementally. Almost all nontrivial pro-
gramming you do will involve editing libraries or applications
made of nested directories containing files with Haskell code</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 39
in them. The basic process is to have the code and imports
(more on that later) in a file, load it into the REPL, and interact
with it there as you’re building, modifying, and testing it.
You’ll need a file named test.hs . The.hsfile extension de-
notes a Haskell source code file. Depending on your setup and
the workflow you’re comfortable with, you can make a file by
that name and then open it in your text editor or you can open
your text editor, open a new file, and then save the file with
that file name.
Then enter the following code into the file and save it:
sayHello ::String-&gt;IO()
sayHello x=
putStrLn ( &quot;Hello, &quot; ++x++&quot;!&quot;)
Here,::is a way to write down a type signature. You can
think of it as saying hasthetype . So,sayHello has the type String
-&gt; IO () . These first chapters are focused on syntax, and we’ll
talk about types in a later chapter.
Theninthesamedirectorywhereyou’vestoredyour test.hs
file, open your ghciREPL and do the following:
Prelude&gt; :load test.hs
Prelude&gt; sayHello &quot;Haskell&quot;
Hello, Haskell!
Prelude&gt;</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 40
After using :loadto load your test.hs , thesayHello function
is visible in the REPL and you can pass it a string argument,
such as “Haskell” (note the quotation marks), and see the out-
put.
You may notice that after loading code from a source file,
the GHCi prompt is no longer Prelude&gt; . To return to the
Prelude&gt; prompt, usethecommand :m, whichisshortfor :module .
This will unload the file from GHCi, so the code in that file
will no longer be in scope in your REPL.
2.3 Understanding expressions
Everything in Haskell is an expression or declaration. Expres-
sionsmay be values, combinations of values, and/or functions
applied to values. Expressions evaluate to a result. In the case
of a literal value, the evaluation is trivial as it only evaluates
to itself. In the case of an arithmetic equation, the evaluation
process is the process of computing the operator and its ar-
guments, as you might expect. But, even though not all of
your programs will be about doing arithmetic, all of Haskell’s
expressions work in a similar way, evaluating to a result in a
predictable, transparent manner. Expressions are the building
blocks of our programs, and programs themselves are one big
expression made of smaller expressions.
Regarding declarations , it suffices to say for now that they
are top-level bindings which allows us to name expressions.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 41
We can then use those names to refer to them multiple times
without copying and pasting the expressions.
The following are all expressions:
1
1+1
&quot;Icarus&quot;
Each can be examined in the GHCi REPL by entering the
code at the prompt, then hitting ‘enter’ to see the result of
evaluating the expression. The numeric value 1, for example,
has no further reduction step, so it stands for itself.
If you haven’t already, open up your terminal and get your
REPL going to start following along with the code examples.
When we enter this into GHCi:
Prelude&gt; 1
1
We see 1 printed because it cannot be reduced any further.
In the next example, GHCi reduces the expression 1 + 2to
3, then prints the number 3. The reduction terminates with
the value 3 because there are no more terms to evaluate:
Prelude&gt; 1 + 2
3</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 42
Expressions can be nested in numbers limited only by our
willingness to take the time to write them down, much like in
arithmetic:
Prelude&gt; (1 + 2) * 3
9
Prelude&gt; ((1 + 2) * 3) + 100
109
You can keep expanding on this, nesting as many expres-
sions as you’d like and evaluating them. But, we don’t have to
limit ourselves to expressions such as these.
Normal form We say that expressions are in normal form
when there are no more evaluation steps that can be taken,
or, put diﬀerently, when they’ve reached an irreducible form.
The normal form of 1 + 1is2. Why? Because the expression 1</p>
<ul>
<li>1can be evaluated or reduced by applying the addition oper-
ator to the two arguments. In other words, 1 + 1is a reducible
expression, while 2is an expression but is no longer reducible
— it can’t evaluate into anything other than itself. Reducible ex-
pressions are also called redexes . While we will generally refer
to this process as evaluation or reduction, you may also hear
it called “normalizing” or “executing” an expression, though
these are somewhat imprecise.</li>
</ul>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 43
2.4 Functions
Expressions are the most basic unit of a Haskell program, and
functions are a specific type of expression. Functions in Haskell
are related to functions in mathematics, which is to say they
map an input or set of inputs to an output. A function is an
expression that is applied to an argument and always returns a
result. Because they are built purely of expressions, they will
always evaluate to the same result when given the same values.
As in the lambda calculus, all functions in Haskell take one
argument and return one result. The way to think of this is that,
in Haskell, when it seems we are passing multiple arguments to
a function, we are actually applying a series of nested functions,
each to one argument. This is called currying .
You may have noticed that the expressions we’ve looked
at so far use literal values with no variables or abstractions.
Functions allow us to abstract the parts of code we’d want to
reuse for diﬀerent literal values. Instead of nesting addition
expressions, for example, we could write a function that would
add the value we wanted wherever we called that function.
Forexample, sayyouhadabunchofexpressionsyouneeded
to multiply by 3. You could keep entering them as individual
expressions like this:
Prelude&gt; (1 + 2) * 3</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 44
9
Prelude&gt; (4 + 5) * 3
27
Prelude&gt; (10 + 5) * 3
45
But you don’t want to do that. Functions are how we factor
out the pattern into something we can reuse with diﬀerent in-
puts. You do that by naming the function and introducing an
independent variable as the argument to the function. Func-
tions can also appear in the expressions that form the bodies
of other functions or be used as arguments to functions, just
as any other value can be.
In this case, we have a series of expressions that we want to
multiply by 3. Let’s think in terms of a function: what part is
common to all the expressions? What part varies? We know we
have to give functions a name and apply them to an argument,
so what could we call this function and what sort of argument
might we apply it to?
The common pattern is the * 3bit. The part that varies
is the addition expression before it, so we will make that a
variable. Wewillnameourfunctionandapplyittothevariable.
When we input a value for the variable, our function will
evaluate that, multiply it by 3, and return a result. In the next
section, we will formalize this into a Haskell function.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 45
Defining functions
Function definitions all share a few things in common. First,
they start with the name of the function. This is followed by
the formal parameters3of the function, separated only by white
space. Next there is an equal sign, which expresses equality of
the terms. Finally there is an expression that is the body of
the function and can be evaluated to return a value.
Defining functions in a Haskell source code file and in GHCi
are a little diﬀerent. To introduce definitions of values or
functions in GHCi, you must use let,4which looks like this:
Prelude&gt; let triple x = x * 3
In a source file we would enter it like this:
triplex=x<em>3
Let’s examine each part of that:
triple x =x</em>3
-- [1] [2] [3] [ 4 ]
3In practice, the terms argument andparameter are often used interchangeably, but
there is a diﬀerence. Argument properly refers to the value(s) that are passed to the
function’s parameters when the function is applied, not to the variables that represent
them in the function definition (or those in the type signature). See the definitions at the
end of the chapter for more information.
4This has changed as of the release of GHC 8.0.1; using letin declarations in GHCi is
no longer necessary. As we assume most readers of this edition will be using an earlier
version of GHC, we have kept the letnotation throughout the book, and this shouldn’t
cause any errors or breakage.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 46
1.This is the name of the function we are defining; it is a
function declaration . Note that it begins with a lowercase
letter.
2.This is the parameter of the function. The parameters
of our function correspond to the head of a lambda and
bind variables that appear in the body expression.
3.The=is used to define (or declare ) values and functions.
This isnothow we test for equality between two values in
Haskell.
4.This is the body of the function, an expression that could
be evaluated if the function is applied to a value. If triple
is applied, the argument it’s applied to will be the value
to which the 𝑥is bound. Here the expression x * 3consti-
tutes the body of the function. So, if you have an expres-
sion like triple 6 ,𝑥is bound to 6. Since you’ve applied the
function, you can also replace the fully applied function
with its body and bound arguments.
Capitalization matters! Function names start with lowercase
letters. Sometimes for clarity in function names, you may
want camelCase style, and that is good style provided the first
letter remains lowercase.
Variables must also begin with lowercase letters. They need
not be single letters.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 47
Playing with the triple function First, try entering the triple
function directly into the REPL using let. Now call the func-
tion by name and introduce a numeric value for the 𝑥argu-
ment:
Prelude&gt; triple 2
6
Next, enter the second version (the one without let) into a
source file and save the file. Load it into GHCi, using the :load
or:lcommand. Once it’s loaded, you can call the function
at the prompt using the function name, triple, followed by
a numeric value, just as you did in the REPL example above.
Try using diﬀerent values for 𝑥— integer values or other arith-
metic expressions. Then try changing the function itself in
the source file and reloading it to see what changes. You can
use:reload , or:r, to reload the same file.
2.5 Evaluation
When we talk about evaluating an expression, we’re talking
about reducing the terms until the expression reaches its sim-
plest form. Once a term has reached its simplest form, we say
that it is irreducible or finished evaluating. Usually, we call this
a value. Haskell uses a nonstrict evaluation (sometimes called
“lazy evaluation”) strategy which defers evaluation of terms
until they’re forced by other terms referring to them.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 48
Values are irreducible, but applications of functions to ar-
guments are reducible. Reducing an expression means evalu-
ating the terms until you’re left with a value. As in the lambda
calculus, application is evaluation: applying a function to an
argument allows evaluation or reduction.
Values are expressions, but cannot be reduced further. Val-
ues are a terminal point of reduction:
1
&quot;Icarus&quot;
The following expressions can be reduced to a value:
1+1
2*3+1
Each can be evaluated in the REPL, which reduces the ex-
pressions and then prints what it reduced to.
Let’s get back to our triple function. Calling the function
by name and applying it to an argument makes it a reducible
expression. In a pure functional language like Haskell, we can
replace applications of functions with their definitions and get
the same result, like in math. As a result when we see:
triple2
We can know that, since triple is defined as x = x * 3 , the
expression is equivalent to:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 49
triple2
-- [triple x = x * 3; x:= 2]
2*3
6
We’ve applied triple to the value 2 and then reduced the
expression to the final result 6. Our expression triple 2 is in
canonical or normalform when it reaches the number 6 because
the value 6 has no remaining reducible expressions.
Haskell doesn’t evaluate everything to canonical or normal
form by default. Instead, it only evaluates to weak head normal
form (WHNF) by default. What this means is that not every-
thing will get reduced to its irreducible form immediately, so
this:
(\f-&gt;(1,2+f))2
reduces to the following in WHNF:
(1,2+2)
This representation is an approximation, but the key point
here is that 2 + 2is not evaluated to 4 until the last possible
moment.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 50
Exercises: Comprehension Check
1.Given the following lines of code as they might appear
in a source file, how would you change them to use them
directly in the REPL?
halfx=x/2
squarex=x<em>x
2.Write one function that has one parameter and works
for all the following expressions. Be sure to name the
function.
3.14</em>(5<em>5)
3.14</em>(10<em>10)
3.14</em>(2<em>2)
3.14</em>(4*4)
3.There is a value in Prelude calledpi. Rewrite your function
to usepiinstead of 3.14.
2.6 Infix operators
Functions in Haskell default to prefix syntax, meaning that the
function being applied is at the beginning of the expression
rather than the middle. We saw that with our triple function,</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 51
and we see it with standard functions such as the identity, or
id, function. This function returns whatever value it is given
as an argument:
Prelude&gt; id 1
1
While this is the default syntax for functions, not all func-
tions are prefix. There are a group of operators, such as the
arithmetic operators we’ve been using, that are indeed func-
tions (they apply to arguments to produce an output) but ap-
pear by default in an infix position.
Operators are functions which can be used in infix style.
All operators are functions; not all functions are operators.
Whiletriple andidare prefix functions ( notoperators), the +
function is an infix operator:
Prelude&gt; 1 + 1
2
Now we’ll try a few other arithmetic operators:
Prelude&gt; 100 + 100
200
Prelude&gt; 768395 * 21356345
16410108716275
Prelude&gt; 123123 / 123</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 52
1001.0
Prelude&gt; 476 - 36
440
Prelude&gt; 10 / 4
2.5
You can sometimes use functions infix style, with a small
change in syntax:
Prelude&gt; 10 <code>div</code> 4
2
Prelude&gt; div 10 4
2
And you can use infix operators in prefix fashion by wrap-
ping them in parentheses:
Prelude&gt; (+) 100 100
200
Prelude&gt; (*) 768395 21356345
16410108716275
Prelude&gt; (/) 123123 123
1001.0
If the function name is alphanumeric, it is a prefix function
by default, and not all prefix functions can be made infix. If</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 53
the name is a symbol, it is infix by default but can be made
prefix by wrapping it in parentheses.5
Associativity and precedence
As you may remember from your math classes, there’s a de-
fault associativity and precedence to the infix operators (<em>),
(+),(-), and(/).
We can ask GHCi for information such as associativity and
precedence of operators and functions by using the :infocom-
mand. When you ask GHCi for the :infoabout an operator
or function, it provides the type information. It also tells you
whether it’s an infix operator, and, if it is, its associativity and
precedence. Let’s talk about that associativity and precedence
briefly. We will elide the type information and so forth for
now.
Here’s what the code in Prelude says for (</em>),(+), and(-)at
time of writing:
5For people who like nitpicky details: you cannot make a prefix function into an infix
function using backticks, then wrap that in parentheses and make it into a prefix function.
We’re not clear why you’d want to do that anyway. Cut it out.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 54
:info (<em>)
infixl 7</em>
-- [1] [2] [3]
:info (+) (-)
infixl6+
infixl6-
1.infixl means it’s an infix operator; the lmeans it’s left
associative.
2.7 is the precedence: higher is applied first, on a scale of
0-9.
3.Infix function name: in this case, multiplication.
The information about addition and subtraction tell us they
are both left-associative, infix operators with the same prece-
dence (6).
Let’s play with parentheses and see what it means that these
associate to the left. Continue to follow along with the code
via the REPL:
This:
2<em>3</em>4
is evaluated as if it were:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 55
(2*3)*4
because of left associativity.
Here’s an example of a right-associative infix operator:
Prelude&gt; :info (^)
infixr 8 ^
-- [1] [2] [3]
1.infixr means infix operator; the rmeans it’s rightassocia-
tive.
2.8 is the precedence. Higher precedence, indicated by
higher numbers, is applied first, so this is higher prece-
dence than multiplication (7), addition, or subtraction
(both 6).
3.Infix function name: in this case, exponentiation.
It was hard to tell with multiplication why associativity mat-
tered, because multiplication is commutative. So shifting the
parentheses around never changes the result. Exponentiation,
however, is not associative and thus makes a prime candidate
for demonstrating left vs. right associativity.
Prelude&gt; 2 ^ 3 ^ 4
2417851639229258349412352
Prelude&gt; 2 ^ (3 ^ 4)</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 56
2417851639229258349412352
Prelude&gt; (2 ^ 3) ^ 4
4096
As you can see, adding parentheses starting from the right-
handsideoftheexpressionwhentheoperatorisright-associative
doesn’t change anything. However, if we parenthesize from
theleft, we get a diﬀerent result when the expression is evalu-
ated.
Your intuitions about precedence, associativity, and paren-
thesization from math classes will generally hold in Haskell:
2+3*4
(2+3)*4
What’s the diﬀerence between these two? Why are they
diﬀerent?
Exercises: Parentheses and Association
Below are some pairs of functions that are alike except for
parenthesization. Read them carefully and decide if the paren-
theses change the results of the function. Check your work in
GHCi.
1.a)8 + 7 * 9</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 57
b)(8 + 7) * 9
2.a)perimeter x y = (x * 2) + (y * 2)
b)perimeter x y = x * 2 + y * 2
3.a)f x = x / 2 + 9
b)f x = x / (2 + 9)
2.7 Declaring values
The order of declarations in a source code file doesn’t matter
because GHCi loads the entire file at once, so it knows all the
values that have been defined. On the other hand, when you
enter them one by one into the REPL, the order does matter.
For example, we can declare a series of expressions in the
REPL like this:
Prelude&gt; let y = 10
Prelude&gt; let x = 10 * 5 + y
Prelude&gt; let myResult = x * 5
As we saw above with the triple function, we have to use
letto declare something in the REPL.
We can now type the names of the values and hit enter to
see their values:
Prelude&gt; x</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 58
60
Prelude&gt; y
10
Prelude&gt; myResult
300
Let’s see how to declare those values in a file called learn.hs .
First, we declare the name of our module so it can be imported
by name in a project (we won’t be doing a project of this size for
a while yet, but it’s good to get in the habit of having module
names):
-- learn.hs
moduleLearnwhere
x=10<em>5+y
myResult =x</em>5
y=10
Module names are capitalized. Also, in the variable name,
we’ve used camelCase: the first letter is still lowercase, but we
use an uppercase to delineate a word boundary for readability.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 59
Troubleshooting
It is easy to make mistakes in the process of typing learn.hs
into your editor. We’ll look at a few common mistakes in
this section. One thing to keep in mind is that indentation of
Haskell code is significant and can change the meaning of the
code. Incorrect indentation of code can also break your code.
Use spaces, nottabs, to indent your source code.
In general, whitespace is significant in Haskell. Efficient
use of whitespace makes the syntax more concise. This can
take some getting used to if you’ve been working in another
programming language. Whitespace is often the only mark of
a function call, unless parentheses are necessary due to con-
flicting precedence. Trailing whitespace, that is, extraneous
whitespace at the end of lines of code, is considered bad style.
In source code files, indentation often replaces syntactic
markers like curly brackets, semicolons, and parentheses. The
basic rule is that code that is part of an expression should be
indented under the beginning of that expression, even when
the beginning of the expression is not at the leftmost margin.
Furthermore, parts of the expression that are grouped should
be indented to the same level. For example, in a block of code
introduced by letordo, you might see something like this:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 60
let
x=3
y=4
-- or
letx=3
y=4
This wouldn’t work in a source file unless they were embed-
ded in a top-level declaration.
Noticethatthetwodefinitionsthatarepartoftheexpression
line up in either case. It is incorrect to write:
letx=3
y=4
-- or
let
x=3
y=4
If you have an expression that has multiple parts, your
indentation will follow a pattern like this:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 61
foox=
lety=x<em>2
z=x^2
in2</em>y*z
Notice that the definitions of 𝑦and𝑧line up, and the def-
initions of letandinare also aligned. As you work through
the book, pay attention to the indentation patterns as we have
them printed. There are many cases where improper inden-
tation will cause code not to work. Indentation can easily go
wrong in a copy-and-paste job as well.
If you make a mistake like breaking up the declaration of 𝑥
such that the rest of the expression began at the beginning of
the next line:
moduleLearnwhere
-- module declaration at the top
x=10
<em>5+y
myResult =x</em>5
y=10
You might see an error like:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 62
Prelude&gt; :l code/learn.hs
[1 of 1] Compiling Learn
code/learn.hs:10:1:
parse error on input ‘<em>’
Failed, modules loaded: none.
Note that the first line of the error message tells you where
the error occurred: code/learn.hs:10:1 indicates that the mis-
take is in line 10, column 1, of the named file. That can make it
easier to find the problem that needs to be fixed. Please note
that the exact line and column numbers in your own error
messages might be diﬀerent from ours, depending on how
you’ve entered the code into the file.
The way to fix this is to either put it all on one line, like this:
x=10</em>5+y
or to make certain when you break up lines of code that the
second line begins at least one space from the beginning of
that line (either of the following should work):</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 63
x=10
<em>5+y
-- or
x=10
<em>5+y
The second one looks a little better. Generally, you should
reserve breaking up of lines for when you have code exceeding
100 columns in width.
Another possible error is not starting a declaration at the
beginning (left) column of the line:
-- learn.hs
moduleLearnwhere
x=10</em>5+y
myResult =x</em>5
y=10
See that space before 𝑥? That will cause an error like:
Prelude&gt; :l code/learn.hs</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 64
[1 of 1] Compiling Learn
code/learn.hs:11:1:
parse error on input ‘myResult’
Failed, modules loaded: none.
This may confuse you, as myResult is not where you need to
modify your code. The error is only an extraneous space, but
all declarations in the module must start at the same column.
The column that all declarations within a module must start
in is determined by the first declaration in the module. In this
case, the error message gives a location that is diﬀerent from
where you should fix the problem because all the compiler
knows is that the declaration of 𝑥made a single space the ap-
propriate indentation for all declarations within that module,
and the declaration of myResult began a column too early.
It is possible to fix this error by indenting the myResult and
𝑦declarations to the same level as the indented 𝑥declaration:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 65
-- learn.hs
moduleLearnwhere
x=10<em>5+y
myResult =x</em>5
y=10
However, this is considered bad style and is not standard
Haskell practice. There is almost never a good reason to indent
all your declarations in this way, but noting this gives us some
idea of how the compiler is reading the code. It is better, when
confronted with an error message like this, to make sure that
your first declaration is at the leftmost margin and proceed
from there.
Another possible mistake is that you might’ve missed the
second -in the--used to comment out source lines of code.
So this code:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 66
-learn.hs
moduleLearnwhere
x=10<em>5+y
myResult =x</em>5
y=10
will cause this error:
code/learn.hs:7:1:
parse error on input ‘module’
Failed, modules loaded: none.
Note again that it says the parse error occurred at the be-
ginning of the module declaration, but the issue is that the
comment line, - learn.hs , had only one dash, when it needed
two to form a syntactically correct Haskell comment.
Now we can see how to work with code that is saved in a
source file from GHCi without manually copying and pasting
the definitions into our REPL. Assuming we open our REPL
in the same directory as we have learn.hs saved, we can do the
following:
Prelude&gt; :load learn.hs</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 67
[1 of 1] Compiling Learn
Ok, modules loaded: Learn.
Prelude&gt; x
60
Prelude&gt; y
10
Prelude&gt; myResult
300
Exercises: Heal the Sick
The following code samples are broken and won’t compile.
The first two are as you might enter into the REPL; the third
is from a source file. Find the mistakes and fix them so that
they will.
1.let area x = 3. 14 * (x * x)
2.let double x = b * 2
3.x=7
y=10
f=x+y
2.8 Arithmetic functions in Haskell
This section will explore some basic arithmetic using some
common operators and functions for arithmetic. We’ll focus</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 68
on the following subset of them:
Operator Name Purpose/application</p>
<ul>
<li>plus addition</li>
</ul>
<ul>
<li>minus subtraction</li>
</ul>
<ul>
<li>asterisk multiplication
/ slash fractional division
div divide integral division, round down
mod modulo like ‘rem’, but after modular division
quot quotient integral division, round towards zero
rem remainder remainder after division
At the risk of stating the obvious, “integral” division refers
to division of integers. Because it’s integral and not fractional,
it takes integers as arguments and returns integers as results.
That’s why the results are rounded.
Here’s an example of each in the REPL:
Prelude&gt; 1 + 1
2
Prelude&gt; 1 - 1
0
Prelude&gt; 1 * 1
1
Prelude&gt; 1 / 1
1.0</li>
</ul>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 69
Prelude&gt; div 1 1
1
Prelude&gt; mod 1 1
0
Prelude&gt; quot 1 1
1
Prelude&gt; rem 1 1
0
You will usually want divfor integral division, due to the
waydivandquotround:
-- rounds down
Prelude&gt; div 20 (-6)
-4
-- rounds toward zero
Prelude&gt; quot 20 (-6)
-3
Also,remandmodhave slightly diﬀerent use cases; we’ll look
atmodin a little more detail in this chapter. We will cover (/)
in more detail in a later chapter, as that will require some
explanation of types and typeclasses.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 70
Laws for quotients and remainders
Programming often makes use of more division and remain-
der functions than standard arithmetic does, and it’s helpful
to be familiar with the laws about quotandrem, anddivand
mod.6We’ll take a look at those here.
(quot x y)*y + (rem x y) == x
(div x y)<em>y + (mod x y) == x
We won’t walk through a proof exercise, but we can demon-
strate these laws a bit:
(quot x y)<em>y + (rem x y)
Given x is 10 and y is (-4)
(quot 10 (-4))</em>(-4) + (rem 10 (-4))
quot 10 (-4) == (-2) and rem 10 (-4) == 2
(-2)</em>(-4) + (2) == 10
10 == x
6From Lennart Augustsson’s blog http://augustss.blogspot.com or Stack Overflow an-
swer at http://stackoverflow.com/a/8111203</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 71
Yes, we got to the result we wanted.
Now for divandmod:
(div x y)<em>y + (mod x y)
Given x is 10 and y is (-4)
(div 10 (-4))</em>(-4) + (mod 10 (-4))
div 10 (-4) == (-3) and mod 10 (-4) == -2
(-3)*(-4) + (-2) == 10
10 == x
Our result indicates all is well in the world of integral divi-
sion.
Usingmod
This section is not a full discussion of modular arithmetic, but
we want to give more direction in how to use modin general,
for those who may be unfamiliar with it, and how it works in
Haskell specifically.
We’ve already mentioned that modgives the remainder of
a modular division. If you’re not already familiar with mod-</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 72
ular division, you may not understand the useful diﬀerence
between modandrem.
Modular arithmetic is a system of arithmetic for integers
where numbers “wrap around” upon reaching a certain value,
called the modulus . It is often explained in terms of a clock.
When we count time by a 12-hour clock, we have to wrap
the counting around the 12. For example, if the time is now
8:00 and you want to know what time it will be 8 hours from
now, you don’t simply add 8 + 8 and get a result of 16 o’clock.7
Instead, you wrap the count around every 12 hours. So,
adding 8 hours to 8:00 means that we add 4 hours to get to
the 12, and at the 12 we start over again as if it’s 0 and add the
remaining 4 hours of our 8, for an answer of 4:00. That is, 8
hours after 8:00 is 4:00.
This is arithmetic modulo 12. In our 12-hour clock, 12 is
equivalent to both itself and to 0, so the time at 12:00 is also,
in some sense 0:00. Arithmetic modulo 12 means that 12 is
both 12 and 0.
Often, this will give you the same answer that remdoes:
Prelude&gt; mod 15 12
3
Prelude&gt; rem 15 12
3
7Obviously, with a 24-hour clock, such a time is possible; however, if we were starting
from 8:00 p.m. and trying to find the time 8 hours later, the answer would not be 16:00
a.m. A 24-hour clock has a diﬀerent modulus than a 12-hour clock.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 73
Prelude&gt; mod 21 12
9
Prelude&gt; rem 21 12
9
Prelude&gt; mod 3 12
3
Prelude&gt; rem 3 12
3
If you’re wondering what the deal is with the last two ex-
amples, it’s because modandremcan only represent integral
division. If all you have to work with is integers, then dividing
a smaller number by a larger number results in an answer of
0 with a remainder of whatever the smaller number (the divi-
dend) is. If you want to divide a smaller number by a larger
number and return a fractional answer, then you need to use
(/), and you won’t have a remainder.
Let’s say we need to write a function that will determine
what day of the week it was or will be a certain number of
days before or after this one. For our purposes here, we will
assign a number to each day of the week, using 0 to represent
Sunday.8Then if today is Monday, and we want to know what
8Sure, you may naturally think of the days of week as being numbered 1-7. But
programmers like to index things from zero.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 74
day of the week it will be 23 days from now, we could do this:
Prelude&gt; mod (1 + 23) 7
3
The 1 represents Monday, the current day, while 23 is the
number of days we’re trying to add. Using modto wrap it around
the 7 means it will return a number that corresponds to a day
of the week in our numbering.
And 5 days from Saturday will be Thursday:
Prelude&gt; mod (6 + 5) 7
4
We can use remto do the same thing with apparently equiv-
alent accuracy:
Prelude&gt; rem (1 + 23) 7
3
However, if we want to subtract and find out what day of
the week it was some number of days ago, then we’ll see a
diﬀerence. Let’s try asking, if today is Wednesday (3), what
day it was 12 days ago:
Prelude&gt; mod (3 - 12) 7
5
Prelude&gt; rem (3 - 12) 7
-2</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 75
The version with modgives us a correct answer, while the rem
version does not.
One key diﬀerence here is that, in Haskell (not in all lan-
guages), if one or both arguments are negative, the results of
modwill have the same sign as the divisor, while the result of
remwill have the same sign as the dividend:
Prelude&gt; (-5) <code>mod</code> 2
1
Prelude&gt; 5 <code>mod</code> (-2)
-1
Prelude&gt; (-5) <code>mod</code> (-2)
-1
But:
Prelude&gt; (-5) <code>rem</code> 2
-1
Prelude&gt; 5 <code>rem</code> (-2)
1
Prelude&gt; (-5) <code>rem</code> (-2)
-1
Figuring out when you need modtakes some experience.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 76
Negative numbers
Due to the interaction of parentheses, currying, and infix syn-
tax, negative numbers get special treatment in Haskell.
If you want a value that is a negative number by itself, this
will work fine:
Prelude&gt; -1000
-1000
However, this will not work in some cases:
Prelude&gt; 1000 + -9
<interactive>:3:1:
Precedence parsing error
cannot mix ‘+’ [infixl 6] and
prefix <code>-</code> [infixl 6]
in the same infix expression
Fortunately, we were told about our mistake before any
of our code was executed. Note how the error message tells
you the problem has to do with precedence. Addition and
subtraction have the same precedence (6), and GHCi thinks
we are trying to add and subtract, not add a negative number,
so it doesn’t know how to resolve the precedence and evaluate
the expression. We need to make a small change before we
can add a positive and a negative number together:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 77
Prelude&gt; 1000 + (-9)
991
The negation of numbers in Haskell by the use of a unary -
is a form of syntactic sugar . Syntax is the grammar and struc-
ture of the text we use to express programs, and syntactic
sugar is a means for us to make that text easier to read and
write. Syntactic sugar can make the typing or reading of code
nicer but changes nothing about the semantics, or meaning, of
programs and doesn’t change how we solve problems in code.
Typically when code with syntactic sugar is processed by our
REPL or compiler, a simple transformation from the shorter
(“sweeter”) form to a more verbose, truer representation is
performed after the code has been parsed.
In the specific case of -, the syntactic sugar means the oper-
ator now has two possible interpretations. The two possible
interpretations of the syntactic -are that -is being used as an
alias for negate or that it is the subtraction function. The fol-
lowing are semantically identical (that is, they have the same
meaning, despite diﬀerent syntax) because the -is translated
intonegate :
Prelude&gt; 2000 + (-1234)
766
Prelude&gt; 2000 + (negate 1234)
766</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 78
Whereas this is -being used for subtraction:
Prelude&gt; 2000 - 1234
766
Fortunately, syntactic overloading like this isn’t common
in Haskell.
2.9 Parenthesization
Here we’ve listed the information that GHCi gives us for var-
ious infix operators. We have left the type signatures in, al-
though it is not directly relevant at this time. This will give
you a chance to look at the types if you’re curious and also
provide a more accurate picture of the :infocommand.
Prelude&gt; :info (^)
(^) :: (Num a, Integral b) =&gt; a -&gt; b -&gt; a
infixr 8 ^
Prelude&gt; :info (<em>)
class Num a where
(</em>) :: a -&gt; a -&gt; a
infixl 7 *
Prelude&gt; :info (+)
class Num a where</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 79
(+) :: a -&gt; a -&gt; a
infixl 6 +
Prelude&gt; :info (-)
class Num a where
(-) :: a -&gt; a -&gt; a
infixl 6 -
Prelude&gt; :info ($)
($) :: (a -&gt; b) -&gt; a -&gt; b
infixr 0 $
We should take a moment to explain and demonstrate the
($)operator as you will run into it fairly frequently in Haskell
code. The good news is it does almost nothing. The bad news
is this fact sometimes trips people up.
First, here’s the definition of ($):
f$a=f a
Immediately this seems a bit pointless until we remember
that it’s defined as an infix operator with the lowest possible
precedence. The ($)operator is a convenience for when you
want to express something with fewer pairs of parentheses:
Prelude&gt; (2^) (2 + 2)
16</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 80
-- can replace those parentheses
Prelude&gt; (2^) $ 2 + 2
16
-- without either parentheses or $
Prelude&gt; (2^) 2 + 2
6
The($)will allow everything to the right of it to be evalu-
ated first and can be used to delay function application. You’ll
see what we mean about delaying function application in par-
ticular when we get to Chapter 7 and use it with function
composition.
Also note that you can stack up multiple uses of ($)in the
same expression. For example, this works:
Prelude&gt; (2^) $ (+2) $ 3*2
256
But this does not:
Prelude&gt; (2^) $ 2 + 2 $ (*30)
A rather long and ugly type error about trying to use num-
bers as if they were functions follows. We can see why this
code doesn’t make sense if we examine the reduction steps:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 81
-- Remember ($)'s definition
f$a=f a
(2^)$2+2$(*30)
Given the right-associativity ( infixr ) of$we must begin at
the right-most position:
2+2$(*30)
-- reduce ($)
(2+2) (*30)
Then we must evaluate (2 + 2) before we can apply it:
4(*30)
You might think that this could evaluate as (4 * 30), but it’s
trying to apply 4 as if it was a function to the argument (*30)!
Writing expressions like (*30)is called sectioning .
Now let’s flip that expression around a bit so it works and
then walk through a reduction:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 82
(2^)$(*30)$2+2
-- must evaluate right-side first
(2^)$(*30)$2+2
-- application of the function (*30) to the
-- expression (2 + 2) forces evaluation
(2^)$(*30)4
-- then we reduce (*30) 4
(2^)$120
-- reduce ($) again.
(2^)120
-- reduce (2^)
1329227995784915872903807060280344576
Some Haskellers find parentheses more readable than the
dollar sign, but it’s too common in idiomatic Haskell code for
you to not at least be familiar with it.
Parenthesizing infix operators
There are times when you want to refer to an infix function
without applying any arguments, and there are also times
when you want to use them as prefix operators instead of infix.
In both cases you must wrap the operator in parentheses. Let’s
look at how we use infix operators as prefixes.
If your infix function is &gt;&gt;then you must write (&gt;&gt;)to refer
to it as a value. (+)is the addition infix function without any</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 83
arguments applied yet and (+1)is the same addition function
but with one argument applied, making it return the next
argument it’s applied to plus one:
Prelude&gt; 1 + 2
3
Prelude&gt; (+) 1 2
3
Prelude&gt; (+1) 2
3
The last case is known as sectioning and allows you to pass
around partially applied functions. With commutative func-
tions, such as addition, it makes no diﬀerence if you use (+1)
or(1+)because the order of the arguments won’t change the
result.
If you use sectioning with a function that is not commuta-
tive, the order matters:
Prelude&gt; (1/) 2
0.5
Prelude&gt; (/1) 2
2.0
Subtraction, (-), is a special case. These will work:
Prelude&gt; 2 - 1</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 84
1
Prelude&gt; (-) 2 1
1
The following, however, won’t work:
Prelude&gt; (-2) 1
Enclosing a value inside the parentheses with the -indi-
cates to GHCi that it’s the argument of a function. Because
the-function represents negation, not subtraction, when it’s
applied to a single argument, GHCi does not know what to do
with that, and so it returns an error message. Here, -is a case
of syntactic overloading disambiguated by how it is used.
You can use sectioning for subtraction, but it must be the
first argument:
Prelude&gt; let x = 5
Prelude&gt; let y = (1 -)
Prelude&gt; y x
-4
Or instead of (- x), you can write (subtract x):
Prelude&gt; (subtract 2) 3
1</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 85
It may not be immediately obvious why you would ever
want to do this, but you will see this syntax used throughout the
book, for example, once we start wanting to apply functions
to each value inside a list or other data structure.
2.10 Let and where
You will often see letandwhereused to introduce components
of expressions, and they seem similar. It takes some practice
to get used to the appropriate times to use each.
The contrast here is that letintroduces an expression , so it
can be used wherever you can have an expression, but whereis
adeclaration and is bound to a surrounding syntactic construct.
We’ll start with an example of where:
-- FunctionWithWhere.hs
moduleFunctionWithWhere where
printInc n=print plusTwo
whereplusTwo =n+2
And if we use this in the REPL:
Prelude&gt; :l FunctionWithWhere.hs
[1 of 1] Compiling FunctionWithWhere ...</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 86
Ok, modules loaded: FunctionWithWhere.
Prelude&gt; printInc 1
3
Prelude&gt;
Now we have the same function, but using letin the place
ofwhere:
-- FunctionWithLet.hs
moduleFunctionWithLet where
printInc2 n= letplusTwo =n+2
inprint plusTwo
When you see letfollowed by in, you’re looking at a let
expression . Here’s that function in the REPL:
Prelude&gt; :load FunctionWithLet.hs
[1 of 1] Compiling FunctionWithLet ...
Ok, modules loaded: FunctionWithLet.
Prelude&gt; printInc2 3
5
If you loaded FunctionWithLet in the same REPL session as
FunctionWithWhere , then it will have unloaded the first one be-
fore loading the new one:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 87
Prelude&gt; :load FunctionWithWhere.hs
[1 of 1] Compiling FunctionWithWhere ...
Ok, modules loaded: FunctionWithWhere.
Prelude&gt; printInc 1
3
Prelude&gt; :load FunctionWithLet.hs
[1 of 1] Compiling FunctionWithLet ...
Ok, modules loaded: FunctionWithLet.
Prelude&gt; printInc2 10
12
Prelude&gt; printInc 10
<interactive>:6:1:
Not in scope: ‘printInc’
Perhaps you meant ‘printInc2’ (line 4)
printInc isn’t in scope anymore because GHCi unloaded
everything you’d defined or loaded after you used :loadto load
theFunctionWithLet.hs source file. Scopeis the area of source
code where a binding of a variable applies.
That is one limitation of the :loadcommand in GHCi. As
we build larger projects that require having multiple modules
in scope, we will use a project manager called Stack rather
than GHCi itself.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 88
Exercises: A Head Code
Now for some exercises. First, determine in your head what
the following expressions will return, then validate in the
REPL:
1.letx=5inx
2.letx=5inx<em>x
3.letx=5; y=6inx</em>y
4.letx=3; y=1000inx+3
Above, you entered some letexpressions into your REPL
to evaluate them. Now, we’re going to open a file and rewrite
someletexpressions using wheredeclarations. You will have
to give the value you’re binding a name, although the name
can be a single letter if you like. For example,
-- this should work in GHCi
letx=5; y=6inx<em>y
could be rewritten as
-- put this in a file
mult1 =x</em>y
wherex=5
y=6</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 89
Making the equals signs line up is a stylistic choice. As long
as things are nested in that way, the equals signs do not have
to line up. But notice we use a name that we will use to refer
to this value in the REPL:
Prelude&gt; :l practice.hs
[1 of 1] Compiling Main
Ok, modules loaded: Main.
Prelude&gt; mult1
30
The prompt changes to <em>Maininstead of Prelude to indicate
that you have a module called Mainloaded.
Rewrite with whereclauses:
1.letx=3; y=1000inx</em>3+y
2.lety=10; x=10<em>5+yinx</em>5
3.letx=7
y=negate x
z=y*10
inz/x+y
Note: the filename you choose is unimportant except for
the.hsextension.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 90
2.11 Chapter Exercises
The goal for all the following exercises is to get you playing
with code and forming hypotheses about what it should do.
Read the code carefully, using what we’ve learned so far. Gen-
erate a hypothesis about what you think the code will do. Play
with it in the REPL and find out where you were right or wrong.
Parenthesization
Given what we know about the precedence of (<em>),(+), and(^),
how can we parenthesize the following expressions more ex-
plicitly without changing their results? Put together an answer
you think is correct, then test in the GHCi REPL.
For example, we want to make this more explicit
2+2</em>3-3
This will produce the same result:
2+(2<em>3)-3
Attempt the above on the following expressions:
1.2+2</em>3-1
2.(^)10$1+1
3.2^2*4^5+1</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 91
Equivalent expressions
Which of the following pairs of expressions will return the
same result when evaluated? Try to reason them out by read-
ing the code and then enter them into the REPL to check your
work:
1.1+1
2
2.10^2
10+9<em>10
3.400-37
(-)37400
4.100<code>div</code>3
100/3
5.2</em>5+18
2*(5+18)</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 92
More fun with functions
Here is a bit of code as it might be entered into a source file.
Remember that when you write code in a source file, the order
is unimportant, but when writing code directly into the REPL
the order does matter. Given that, look at this code and rewrite
it such that it could be evaluated in the REPL (remember: you
may need letwhen entering it directly into the REPL). Be sure
to enter your code into the REPL to make sure it evaluates
correctly.
z=7
x=y^2
waxOn=x*5
y=z+8
1.Now you have a value called waxOnin your REPL. What do
you think will happen if you enter:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 93
10+waxOn
-- or
(+10) waxOn
-- or
(-)15waxOn
-- or
(-) waxOn 15
2.Earlier we looked at a function called triple . While your
REPL has waxOnin session, re-enter the triple function at
the prompt:
lettriple x =x*3
3.Now, whatwillhappenifweenterthisatourGHCiprompt?
What do you think will happen first, considering what role
waxOnis playing in this function call? Then enter it, see
what does happen, and check your understanding:
triplewaxOn
4.Rewrite waxOnas an expression with a whereclause in your
source file. Load it into your REPL and make sure it still
works as expected.
5.To the same source file where you have waxOn, add the
triple function. Remember: You don’t need letand the</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 94
function name should be at the left margin (that is, not
nested as one of the waxOnexpressions). Make sure it works
by loading it into your REPL and then entering triple
waxOnagain at the REPL prompt. You should have the
same answer as you did above.
6.Now, without changing what you’ve done so far in that
file, add a new function called waxOff that looks like this:
waxOffx=triple x
7.Load the source file into your REPL and enter waxOff waxOn
at the prompt.
You now have a function, waxOff that can be applied to a
variety of arguments — not just waxOnbut any (numeric)
value you want to put in for 𝑥. Play with that a bit. What
is the result of waxOff 10 orwaxOff (-50) ? Try modifying
yourwaxOff function to do something new — perhaps
you want to first triple the 𝑥value and then square it or
divide it by 10. Spend some time getting comfortable with
modifying the source file code, reloading it, and checking
your modification in the REPL.
2.12 Definitions
1.The terms argument andparameter are often used inter-
changeably. However, it is worthwhile to understand the</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 95
distinction. A parameter , or formal parameter, represents a
value that will be passed to the function when the func-
tion is called. Thus, parameters are usually variables. An
argument is an input value the function is applied to. A
function’s parameter is bound to the value of an argument
when the function is applied to that argument. For exam-
ple, inf x = x + 2 which takes an argument and returns
that value added to 2, 𝑥is the one parameter of our func-
tion. We run the code by applying 𝑓to some argument.
If the argument we passed to the parameter 𝑥were 2, our
result would be 4. However, arguments can themselves
be variables or be expressions that include variables, thus
the distinction is not always clear. When we use “param-
eter” in this book, it will always be referring to formal
parameters, usually in a type signature, but we’ve taken
the liberty of using “argument” somewhat more loosely.
2.Anexpression is a combination of symbols that conforms
to syntactic rules and can be evaluated to some result. In
Haskell, an expression is a well-structured combination
of constants, variables, and functions. While irreducible
constants are technically expressions, we usually refer to
those as “values”, so we usually mean “reducible expres-
sion” when we use the term expression .
3.Avalueis an expression that cannot be reduced or evalu-
ated any further. 2 * 2is an expression, but not a value,</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 96
whereas what it evaluates to, 4, is a value.
4.Afunction is a mathematical object whose capabilities are
limited to being applied to an argument and returning a
result. Functions can be described as a list of ordered pairs
of their inputs and the resulting outputs, like a mapping.
Given the function f x = x + 2 applied to the argument
2, we would have the ordered pair (2, 4) of its input and
output.
5.Infixnotation is the style used in arithmetic and logic. Infix
means that the operator is placed between the operands
orarguments . An example would be the plus sign in an
expression like 2 + 2.
6.Operators are functions that are infix by default. In Haskell,
operators must use symbols and not alphanumeric char-
acters.
7.Syntactic sugar is syntax within a programming language
designed to make expressions easier to write or read.
2.13 Follow-up resources
1.Haskell wiki article on Let vs. Where
https://wiki.haskell.org/Let_vs._Where
2.How to desugar Haskell code; Gabriel Gonzalez</p>
<p>Chapter 3
Strings
Like punning,
programming is a play on
words
Alan Perlis
97</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 98
3.1 Printing strings
So far we’ve been doing arithmetic using simple expressions.
In this chapter, we will turn our attention to a diﬀerent type
of data called String .
Most programming languages refer to the data structures
used to contain text as “strings,” usually represented as se-
quences, or lists, of characters. In this section, we will
•take an introductory look at types to understand the data
structure called String ;
•talk about the special syntax, or syntactic sugar, used for
strings;
•print strings in the REPL environment;
•work with some standard functions that operate on this
datatype.
3.2 A first look at types
First, since we will be working with strings, we want to start by
understanding what these data structures are in Haskell as well
as a bit of special syntax we use for them. We haven’t talked
much about types yet, although you saw some examples of
them in the last chapter. Types are important in Haskell, and
the next two chapters are entirely devoted to them.</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 99
Types are a way of categorizing values. There are sev-
eral types for numbers, for example, depending on whether
they are integers, fractional numbers, etc. There is a type
for boolean values, specifically the values TrueandFalse. The
types we are primarily concerned with in this chapter are Char
‘character’ and String .String s are lists of characters.
It is easy to find out the type of a value, expression, or
function in GHCi. We do this with the :typecommand.
Open up your REPL, enter :type 'a' at the prompt, and
you should see something like this:
Prelude&gt; :type 'a'
'a' :: Char
We’ll highlight a few things here. First, we’ve enclosed
our character in single quotes. This lets GHCi know that the
character is not a variable. If you enter :type a instead, it will
think it’s a variable and give you an error message that the 𝑎is
not in scope. That is, the variable 𝑎hasn’t been defined (is not
in scope), so it has no way to know what the type of it is.
Second, the ::symbol is read as “has the type.” You’ll see
this often in Haskell. Whenever you see that double colon,
you know you’re looking at a type signature. A type signature
is a line of code that defines the types for a value, expression,
or function.
And, finally, there is Char, the type. Charis the type that
includes alphabetic characters, Unicode characters, symbols,</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 100
etc. So, asking GHCi :type 'a' , that is, “what is the type of ‘a’?”,
gives us the information, 'a' :: Char , that is, “‘a’ has the type
of Char.”
Now, let’s try a string of text. This time we have to use
double quotation marks, not single, to tell GHCi we have a
string, not a single character:
Prelude&gt; :type &quot;Hello!&quot;
&quot;Hello!&quot; :: [Char]
We have something new in the type information. The
square brackets around Charhere are the syntactic sugar for a
list.String is atype alias , or type synonym, for a list of Char. A
type alias is what it sounds like: we use one name for a type,
usually for convenience, that has a diﬀerent type name under-
neath. Here String is another name for a list of characters. By
using the name String we are able to visually diﬀerentiate it
from other types of lists. When we talk about lists in more
detail later, we’ll see why the square brackets are considered
syntactic sugar; for now, we only need to understand that
GHCi says “Hello!” has the type list of Char.
3.3 Printing simple strings
Now, let’s see how to print strings of text in the REPL:
Prelude&gt; print &quot;hello world!&quot;</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 101
&quot;hello world!&quot;
We used printto tell GHCi to print the string to the display,
so it does, with the quotation marks still around it. The print
function is not specific to strings of text, though; it can be used
to print diﬀerent types of data to the screen.
The following also tell GHCi to print to the screen but are
specific to String :
Prelude&gt; putStrLn &quot;hello world!&quot;
hello world!
Prelude&gt;
Prelude&gt; putStr &quot;hello world!&quot;
hello world!Prelude&gt;
You can probably see that putStr andputStrLn are similar,
with one key diﬀerence. We also notice that both of these print
the string to the display without the quotation marks. This is
because, while they are superficially similar to print, they have
a diﬀerent type than printdoes. Functions that are similar on
the surface can behave diﬀerently depending on the type or
category they belong to.
Next, let’s take a look at how to do these things from source
files. Type the following into a file named print1.hs :</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 102
-- print1.hs
modulePrint1where
main::IO()
main=putStrLn &quot;hello world!&quot;
Here’s what you should see when you load it in GHCi and
runmain:
Prelude&gt; :l print1.hs
[1 of 1] Compiling Print1
Ok, modules loaded: Print1.
*Print1&gt; main
hello world!
*Print1&gt;
First, note that your Prelude&gt; prompt may have changed
to reflect the name of the module you loaded. You can use
:module or:mto unload the module and return to Prelude if
you wish. You can also set your prompt to something specific,
which means it won’t change every time you load or unload a
module1:
Prelude&gt; :set prompt &quot;λ&gt; &quot;
λ&gt; :r
1You can set it permanently if you prefer by setting the configuration in your ~/.ghci
file. You may have to create that file yourself in order to do so.</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 103
Ok, modules loaded: Print1.
λ&gt; main
hello world!
λ&gt;
Looking at the code, mainis the default action when you
build an executable or run it in a REPL. It is not a function but
is often a series of instructions to execute, which can include
applying functions and producing side-eﬀects. When building
a project with Stack, having a mainexecutable in a Main.hs file
is obligatory, but you can have source files and load them in
GHCi without necessarily having a mainblock.
As you can see, mainhas the type IO (). IO, or I/O, stands
for input/output. In Haskell, it is a special type, called IO,
used when the result of running the program involves eﬀects
beyond evaluating a function or expression. Printing to the
screen is an eﬀect, so printing the output of a module must be
wrapped in this IOtype. When you enter functions directly
into the REPL, GHCi implicitly understands and implements
IOwithout you having to specify that. Since the mainaction is
the default executable, you will see it in a lot of source files
that we build from here on out. We will explain its meaning
in more detail in a later chapter.
Let’s start another file:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 104
-- print2.hs
modulePrint2where
main::IO()
main= do
putStrLn &quot;Count to four for me:&quot;
putStr &quot;one, two&quot;
putStr &quot;, three, and&quot;
putStrLn &quot; four!&quot;
Thisdosyntax is a special syntax that allows for sequencing
actions. It is most commonly used to sequence the actions
that constitute your program, some of which will necessarily
perform eﬀects such as printing to the screen (that’s why the
obligatory type of mainisIO ()).donotation isn’t strictly neces-
sary, but since it often makes for more readable code than the
alternatives, you’ll see it a lot.
Here’s what you should see when you run this one:
Prelude&gt; :l print2.hs
[1 of 1] Compiling Print2
Ok, modules loaded: Print2.
Prelude&gt; main
Count to four for me:
one, two, three, and four!
Prelude&gt;</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 105
For a bit of fun, change the invocations of putStr toputStrLn
and vice versa. Rerun the program and see what happens. The
LninputStrLn indicates that it starts a new line.
String concatenation
Toconcatenate something means to link together . Usually when
we talk about concatenation in programming we’re talking
about linear sequences such as lists or strings of text. If we
concatenate two strings &quot;Curry&quot; and&quot; Rocks!&quot; we will get the
string&quot;Curry Rocks!&quot; . Note the space at the beginning of &quot;
Rocks!&quot; . Without that, we’d get &quot;CurryRocks!&quot; .
Let’s start a new text file and type the following:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 106
-- print3.hs
modulePrint3where
myGreeting ::String
myGreeting =&quot;hello&quot; ++&quot; world!&quot;
hello::String
hello=&quot;hello&quot;
world::String
world=&quot;world!&quot;
main::IO()
main= do
putStrLn myGreeting
putStrLn secondGreeting
wheresecondGreeting =
concat [hello, &quot; &quot;, world]
We used ::to declare the types of each top-level expression.
It isn’t strictly necessary, as the compiler can infer these types,
but it is a good habit to be in as you write longer programs.
Remember, String is a type synonym for [Char]. You can
try changing the type signatures to reflect that and see if it
changes anything in the program execution.</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 107
If you execute this, you should see something like:
Prelude&gt; :load print3.hs
[1 of 1] Compiling Print3
Ok, modules loaded: Print3.
*Print3&gt; main
hello world!
hello world!
*Print3&gt;
This little exercise demonstrates a few things:
1.We defined values at the top level of a module: ( myGreeting ,
hello,world, andmain). That is, they were declared at the
top level so that they are available throughout the module.
2.We specify explicit types for top-level definitions.
3.We concatenate strings with (++)andconcat .
3.4 Top-level versus local definitions
What does it mean for something to be at the top level of a
module? It doesn’t necessarily mean it’s defined at the top of
the file. When the compiler reads the file, it will see all the
top-level declarations, no matter what order they come in the</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 108
file (with some limitations which we’ll see later). Top-level
declarations are not nested within anything else and they are
in scope throughout the whole module.
We can contrast a top-level definition with a local definition.
To be locally defined would mean the declaration is nested
within some other expression and is not visible outside that
expression. We practiced this in the previous chapter with let
andwhere. Here’s an example for review:
moduleTopOrLocal where
topLevelFunction ::Integer -&gt;Integer
topLevelFunction x=
x+woot+topLevelValue
wherewoot::Integer
woot=10
topLevelValue ::Integer
topLevelValue =5
In the above, you could import and use topLevelFunction
ortopLevelValue from another module, and they are accessi-
ble to everything else in the module. However, wootis eﬀec-
tively invisible outside of topLevelFunction . Thewhereandlet
clauses in Haskell introduce local bindings or declarations.
To bind or declare something means to give an expression a</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 109
name. You could pass around and use an anonymous version
oftopLevelFunction manually, but giving it a name and reusing
it by that name is less repetitious.
Also note we explicitly declared the type of wootin thewhere
clause, using the ::syntax. This wasn’t necessary (Haskell’s
type inference would’ve figured it out), but it was done here
to show you how. Be sure to load and run this code in your
REPL:
Prelude&gt; :l TopOrLocal.hs
[1 of 1] Compiling TopOrLocal
Ok, modules loaded: TopOrLocal.
*TopOrLocal&gt; topLevelFunction 5
20
Experiment with diﬀerent arguments and make sure you
understand the results you’re getting by walking through the
arithmetic in your head (or on paper).
Exercises: Scope
1.These lines of code are from a REPL session. Is 𝑦in scope
for𝑧?
Prelude&gt; let x = 5
Prelude&gt; let y = 7
Prelude&gt; let z = x * y</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 110
2.These lines of code are from a REPL session. Is ℎin scope
for𝑔? Go with your gut here.
Prelude&gt; let f = 3
Prelude&gt; let g = 6 * f + h
3.This code sample is from a source file. Is everything we
need to execute areain scope?
aread=pi*(r<em>r)
r=d/2
4.This code is also from a source file. Now are 𝑟and𝑑in
scope for area?
aread=pi</em>(r*r)
wherer=d/2
3.5 Types of concatenation functions
Let’s look at the types of (++)andconcat. The++function is
an infix operator. When we need to refer to an infix operator
in a position that is not infix — such as when we are using it
in a prefix position or having it stand alone in order to query
its type — we must put parentheses around it. On the other
hand,concat is a normal (not infix) function, so parentheses
aren’t necessary:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 111
++ has the type [a] -&gt; [a] -&gt; [a]
concat has the type [[a]] -&gt; [a]
Here’s how we query that in GHCi:
Prelude&gt; :t (++)
(++) :: [a] -&gt; [a] -&gt; [a]
Prelude&gt; :t concat
concat :: [[a]] -&gt; [a]
The type of concat says that we have a list of lists as input
and we will return a list. It will have the same values inside it
as the list of lists did; it just flattens it into one list structure, in
a manner of speaking. A String is a list, a list of Charspecifically,
andconcat can work on lists of strings or lists of lists of other
things:
Prelude&gt; concat [[1, 2], [3, 4, 5], [6, 7]]
[1,2,3,4,5,6,7]
Prelude&gt; concat [&quot;Iowa&quot;, &quot;Melman&quot;, &quot;Django&quot;]
&quot;IowaMelmanDjango&quot;
(n.b., Assuming you are using GHC 7.10 or higher, if you
check this type signature in your REPL, you will see a dif-
ference. We’ll explain it in detail later; for now, please read
Foldable t =&gt; t [a] as being [[a]]. TheFoldable t , for our cur-
rent purposes, can be thought of as another list. In truth, list is</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 112
only one of the possible types here — types that have instances
of theFoldable typeclass — but right now, lists are the only one
we care about.)
But what do these types mean? Here’s how we can break it
down:
(++)::[a]-&gt;[a]-&gt;[a]
-- [1] [2] [3]
Everything after the ::is about our types, not our values.
The ‘a’ inside the list type constructor []is a type variable.
1.Take an argument of type [a]. This type is a list of ele-
ments of some type 𝑎. This function does not know what
type𝑎is. It doesn’t need to know. In the context of the
program, the type of 𝑎will be known and made concrete
at some point.
2.Take another argument of type [a], a list of elements
whose type we don’t know. Because the variables are the
same, they must be the same type throughout (a == a).
3.Return a result of type [a].
As we’ll see, because String is a type of list, the operators
we use with strings can also be used on lists of other types,
such as lists of numbers. The type [a]means that we have
a list with elements of a type 𝑎we do not yet know. If we</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 113
use the operators to concatenate lists of numbers, then the
𝑎in[a]will be some type of number (for example, integers).
If we are concatenating lists of characters, then 𝑎represents
aCharbecause String is[Char]. The type variable 𝑎in[a]is
polymorphic. Polymorphism is an important feature of Haskell.
For concatenation, every list must be the same type of list; we
cannot concatenate a list of numbers with a list of characters,
for example. However, since the 𝑎is a variable at the type level,
the literal values in each list we concatenate need not be the
same, only the same type. In other words, 𝑎must equal 𝑎(a ==
a).
Prelude&gt; &quot;hello&quot; ++ &quot; Chris&quot;
&quot;hello Chris&quot;
But:
Prelude&gt; &quot;hello&quot; ++ [1, 2, 3]
<interactive>:14:13:
No instance for (Num Char) arising
from the literal ‘1’
In the expression: 1
In the second argument of ‘(++)’,
namely ‘[1, 2, 3]’
In the expression: &quot;hello&quot; ++ [1, 2, 3]</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 114
In the first example, we have two strings, so the type of 𝑎
matches — they’re both Charin[Char] , even though the literal
values are diﬀerent. Since the type matches, no type error
occurs and we see the concatenated result.
In the second example, we have two lists (a String and a
list of numbers) whose types do not match, so we get the
error message. GHCi asks for an instance of the numeric
typeclass Numfor the type Char.Typeclasses provide definitions
of operations, or functions, that can be shared across sets of
types. For now, you can understand this message as telling
you the types don’t match so it can’t concatenate the two lists.
Exercises: Syntax Errors
Read the syntax of the following functions and decide whether
it will compile. Test them in your REPL and try to fix the
syntax errors where they occur.
1.++ [1, 2, 3] [4, 5, 6]
2.'&lt;3' ++ ' Haskell'
3.concat [&quot;&lt;3&quot;, &quot; Haskell&quot;]</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 115
3.6 Concatenation and scoping
We will use parentheses to call ++as a prefix (not infix) function:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 116
-- print3flipped.hs
modulePrint3Flipped where
myGreeting ::String
myGreeting =(++)&quot;hello&quot; &quot; world!&quot;
hello::String
hello=&quot;hello&quot;
world::String
world=&quot;world!&quot;
main::IO()
main= do
putStrLn myGreeting
putStrLn secondGreeting
wheresecondGreeting =
(++) hello (( ++)&quot; &quot;world)
-- could've been:
-- secondGreeting =
-- hello ++ &quot; &quot; ++ world
InsecondGreeting , using++as a prefix function forces us to
shift some things around. Parenthesizing it that way empha-
sizes the right associativity of the ++function. Since it’s an infix</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 117
operator, you can check for yourself that it’s right associative:
Prelude&gt; :i (++)
(++) :: [a] -&gt; [a] -&gt; [a] -- Defined in ‘GHC.Base’
infixr 5 ++
Thewhereclause creates local bindings for expressions that
are not visible at the top level. In other words, the whereclause
inmainintroduces a definition visible only within the expres-
sion or function it’s attached to, rather than making it visible to
theentiremodule. Somethingvisibleatthetoplevelisinscope
for all parts of the module and may be exported by the module
or imported by a diﬀerent module. Local definitions, on the
other hand, are only visible to that one function. You cannot
import into a diﬀerent module and reuse secondGreeting .
To illustrate:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 118
-- print3broken.hs
modulePrint3Broken where
printSecond ::IO()
printSecond = do
putStrLn greeting
main::IO()
main= do
putStrLn greeting
printSecond
wheregreeting =&quot;Yarrrrr&quot;
You should get an error like this:
Prelude&gt; :l print3broken.hs
[1 of 1] Compiling Print3Broken
( print3broken.hs, interpreted )
print3broken.hs:6:12: Not in scope: ‘greeting’
Failed, modules loaded: none.
Let’s take a closer look at this error:
print3broken.hs:6:12: Not in scope: ‘greeting’</p>
<h1 id="12-3-4"><a class="header" href="#12-3-4">[1][2] [3] [4]</a></h1>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 119
1.The line the error occurred on: in this case, line 6.
2.The column the error occurred on: column 12. Text
on computers is often described in terms of lines and
columns. These line and column numbers are about lines
and columns in your text file containing the source code.
3.The actual problem: we refer to something not in scope,
that is, not visible to theprintSecond function.
4.The thing we referred to that isn’t visible or in scope.
Now make the Print3Broken code compile. It should print
“Yarrrrr” twice on two diﬀerent lines and then exit.
3.7 More list functions
Since a String is a specialized type of list, you can use standard
list operations on strings as well.
Here are some examples:
Prelude&gt; :t 'c'
'c' :: Char
Prelude&gt; :t &quot;c&quot;
&quot;c&quot; :: [Char]
-- [Char] is String
The(:)operator, called cons, builds a list:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 120
Prelude&gt; 'c' : &quot;hris&quot;
&quot;chris&quot;
Prelude&gt; 'P' : &quot;&quot;
&quot;P&quot;
Next up, headreturns the head or first element of a list:
Prelude&gt; head &quot;Papuchon&quot;
'P'
The complementary function tailreturns the list with the
head chopped oﬀ:
Prelude&gt; tail &quot;Papuchon&quot;
&quot;apuchon&quot;
takereturns the specified number of elements from the list,
starting from the left:
Prelude&gt; take 1 &quot;Papuchon&quot;
&quot;P&quot;
Prelude&gt; take 0 &quot;Papuchon&quot;
&quot;&quot;
Prelude&gt; take 6 &quot;Papuchon&quot;
&quot;Papuch&quot;
Anddropreturns the remainder of the list after the specified
number of elements has been dropped:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 121
Prelude&gt; drop 4 &quot;Papuchon&quot;
&quot;chon&quot;
Prelude&gt; drop 9001 &quot;Papuchon&quot;
&quot;&quot;
Prelude&gt; drop 1 &quot;Papuchon&quot;
&quot;apuchon&quot;
We’ve already seen the (++)operator:
Prelude&gt; &quot;Papu&quot; ++ &quot;chon&quot;
&quot;Papuchon&quot;
Prelude&gt; &quot;Papu&quot; ++ &quot;&quot;
&quot;Papu&quot;
The infix operator, (!!), returns the element that is in the
specified position in the list. Note that this is an indexing func-
tion, and indices start from 0. That means the first element of
your list is 0, not 1, when using this function:
Prelude&gt; &quot;Papuchon&quot; !! 0
'P'
Prelude&gt; &quot;Papuchon&quot; !! 4
'c'
Note that while all these functions are standard Prelude func-
tions, many of them are considered unsafe. They are unsafe
because they do not cover the case where they are given an</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 122
empty list as input. Instead they throw out an error message,
orexception :
Prelude&gt; head &quot;&quot;
*** Exception: Prelude.head: empty list
Prelude&gt; &quot;&quot; !! 4
*** Exception: Prelude.!!: index too large
This isn’t ideal behavior, so the use of these functions is
considered unwise for programs of any real size or complexity,
although we will use them in these first few chapters. We will
address how to cover all cases and make safer versions of such
functions in a later chapter.
3.8 Chapter Exercises
Reading syntax
1.For the following lines of code, read the syntax carefully
and decide if they are written correctly. Test them in your
REPL after you’ve decided to check your work. Correct
as many as you can.
a)concat[[1,2,3], [4,5,6]]
b)++[1,2,3] [4,5,6]
c)(++)&quot;hello&quot; &quot; world&quot;</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 123
d)[&quot;hello&quot; ++&quot; world]
e)4!!&quot;hello&quot;
f)(!!)&quot;hello&quot; 4
g)take&quot;4 lovely&quot;
h)take3&quot;awesome&quot;
2.Next we have two sets: the first set is lines of code and
the other is a set of results. Read the code and figure out
which results came from which lines of code. Be sure to
test them in the REPL.
a)concat[[1<em>6], [2</em>6], [3<em>6]]
b)&quot;rain&quot;++drop2&quot;elbow&quot;
c)10</em>head [1,2,3]
d)(take3&quot;Julie&quot;)++(tail&quot;yes&quot;)
e)concat[tail [1,2,3],
tail [4,5,6],
tail [7,8,9]]
Can you match each of the previous expressions to one
of these results presented in a scrambled order?
a)&quot;Jules&quot;
b)[2,3,5,6,8,9]</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 124
c)&quot;rainbow&quot;
d)[6,12,18]
e)10
Building functions
1.Given the list-manipulation functions mentioned in this
chapter, write functions that take the following inputs and
return the expected outputs. Do them directly in your
REPL and use the takeanddropfunctions you’ve already
seen.
Example
-- If you apply your function
-- to this value:
&quot;Hello World&quot;
-- Your function should return:
&quot;ello World&quot;
The following would be a fine solution:
Prelude&gt; drop 1 &quot;Hello World&quot;
&quot;ello World&quot;</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 125
Now write expressions to perform the following trans-
formations, just with the functions you’ve seen in this
chapter. You do not need to do anything clever here.
a)-- Given
&quot;Curry is awesome&quot;
-- Return
&quot;Curry is awesome!&quot;
b)-- Given
&quot;Curry is awesome!&quot;
-- Return
&quot;y&quot;
c)-- Given
&quot;Curry is awesome!&quot;
-- Return
&quot;awesome!&quot;
2.Now take each of the above and rewrite it in a source
file as a general function that could take diﬀerent string
inputs as arguments but retain the same behavior. Use
a variable as the argument to your (named) functions. If
you’re unsure how to do this, refresh your memory by
looking at the waxOff exercise from the previous chapter
and the TopOrLocal module from this chapter.</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 126
3.Write a function of type String -&gt; Char which returns the
third character in a String . Remember to give the function
a name and apply it to a variable, not a specific String,
so that it could be reused for diﬀerent String inputs, as
demonstrated (feel free to name the function something
else. Be sure to fill in the type signature and fill in the
function definition after the equals sign):
thirdLetter ::
thirdLetter x=
-- If you apply your function
-- to this value:
&quot;Curry is awesome&quot;
-- Your function should return
`r'
Note that programming languages conventionally start
indexing things by zero, so getting the zeroth index of a
string will get you the first letter. Accordingly, indexing
with 3 will get you the fourth. Keep this in mind as you
write this function.
4.Now change that function so the string operated on is
always the same and the variable represents the number
of the letter you want to return (you can use “Curry is</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 127
awesome!” as your string input or a diﬀerent string if you
prefer).
letterIndex ::Int-&gt;Char
letterIndex x=
5.Using the takeanddropfunctions we looked at above, see
if you can write a function called rvrs(an abbreviation of
‘reverse’ used because there is a function called ‘reverse’
already in Prelude, so if you call your function the same
name, you’ll get an error message). rvrsshould take the
string “Curry is awesome” and return the result “awesome
is Curry.” This may not be the most lovely Haskell code
you will ever write, but it is quite possible using only what
we’ve learned so far. First write it as a single function in
a source file. This doesn’t need to, and shouldn’t, work
for reversing the words of anysentence. You’re expected
only to slice and dice this particular string with takeand
drop.
6.Let’s see if we can expand that function into a module.
Why would we want to? By expanding it into a module,
we can add more functions later that can interact with
each other. We can also then export it to other modules
if we want to and use this code in those other modules.
There are diﬀerent ways you could lay it out, but for the</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 128
sake of convenience, we’ll show you a sample layout so
that you can fill in the blanks:
moduleReverse where
rvrs::String-&gt;String
rvrsx=
main::IO()
main=print()
Into the parentheses after printyou’ll need to fill in your
function name rvrsplus the argument you’re applying
rvrsto, in this case “Curry is awesome.” That rvrsfunction
plus its argument are now the argument to print. It’s
important to put them inside the parentheses so that that
function gets applied and evaluated first, and then that
result is printed.
Of course, we have also mentioned that you can use the $
symbol to avoid using parentheses, too. Try modifying
your main function to use that instead of the parentheses.
3.9 Definitions
1.AString is a sequence of characters. In Haskell, String is
represented by a linked-list of Charvalues, aka [Char] .</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 129
2.Atypeor datatype is a classification of values or data.
Types in Haskell determine what values are members
of the type or that inhabit the type. Unlike in other lan-
guages, datatypes in Haskell by default do not delimit the
operations that can be performed on that data.
3.Concatenation is the joining together of sequences of val-
ues. Often in Haskell this is meant with respect to the
[], or list, datatype, which also applies to String which is
[Char] . Theconcatenation function in Haskell is (++)which
has type [a] -&gt; [a] -&gt; [a] . For example:
Prelude&gt; &quot;tacos&quot; ++ &quot; &quot; ++ &quot;rock&quot;
&quot;tacos rock&quot;
4.Scope is where a variable referred to by name is valid.
Another word used with the same meaning is visibility ,
because if a variable isn’t visible it’s not in scope.
5.Local bindings are bindings local to particular expressions.
The primary delineation here from top level bindings is
thatlocalbindings cannot be imported by other programs
or modules.
6.Toplevelbindings in Haskell are bindings that stand outside
of any other declaration. The main feature of top-level</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 130
bindings is that they can be made available to other mod-
ules within your programs or to other people’s programs.
7.Data structures are a way of organizing data so that the
data can be accessed conveniently or efficiently.</p>
<p>Chapter 4
Basic datatypes
There are many ways of
trying to understand
programs. People often
rely too much on one
way, which is called
“debugging” and consists
of running a
partly-understood
program to see if it does
what you expected.
Another way, which ML
advocates, is to install
some means of
understanding in the very
programs themselves.
Robin Milner
131</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 132
4.1 Basic Datatypes
Haskell has a robust and expressive type system. Types play an
important role in the readability, safety, and maintainability of
Haskell code as they allow us to classify and delimit data, thus
restricting the forms of data our programs can process. Types,
also called datatypes , provide the means to build programs
more quickly and also allow for greater ease of maintenance.
As we learn more Haskell, we’ll learn how to leverage types
in a way that lets us accomplish the same things but with less
code.
So far, we’ve looked at expressions involving numbers, char-
acters, and lists of characters, also called strings. These are
some of the standard datatypes and are built into the standard
library. While those are useful datatypes and cover a lot of
types of values, they don’t cover every type of data. In this
chapter, we will
•review types we have seen in previous chapters;
•learn about datatypes, type constructors, and data con-
structors;
•work with predefined datatypes;
•learn more about type signatures and a bit about type-
classes.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 133
4.2 What are types?
Expressions, when evaluated, reduce to values. Every value
has a type. Types are how we group a set of values together
that share something in common. Sometimes that common-
ality is abstract; sometimes it’s a specific model of a particular
concept or domain. If you’ve taken a mathematics course that
covered sets, thinking about types as being like sets will help
guide your intuition on what types are and how they work in
a mathematical1sense.
4.3 Anatomy of a data declaration
Data declarations are how datatypes are defined.
The type constructor is the name of the type and is capi-
talized. When you are reading or writing type signatures (the
type level of your code), the type names or type constructors
are what you use.
Data constructors are the values that inhabit the type they
are defined in. They are the values that show up in your code,
at the term level instead of the type level. By term level , we
mean they are the values as they appear in your code or the
values that your code evaluates to.
1Set theory is the study of mathematical collections of objects. Set theory was a
precursor to type theory, the latter being used prolifically in the design of programming
languages like Haskell. Logical operations like disjunction (or) and conjunction (and) used
in the manipulation of sets have equivalents in Haskell’s type system.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 134
We will start with a basic datatype to see how datatypes are
structured and get acquainted with the vocabulary. Boolisn’t a
datatype we’ve seen yet in the book, but it provides for truth
values. It is named after the great logician George Boole and
the system of logic named for him. Because there are only
two truth values, there are only two data constructors:
-- the definition of Bool
dataBool=False|True
-- [1] [2] [3] [4]
1.Type constructor for datatype Bool. This is the name of
the type and shows up in type signatures.
2.Data constructor for the value False.
3.Pipe|indicates a sum type or logical disjunction: or. So, a
Boolvalue is TrueorFalse.
4.Data constructor for the value True.
The whole thing is called a data declaration. Data declara-
tions do not always follow precisely the same pattern — there
are datatypes that use logical conjunction ( and) instead of dis-
junction, and some type constructors and data constructors
may have arguments. The thing they have in common is the
keyword datafollowed by the type constructor (or name of
the type that will appear in type signatures), the equals sign to</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 135
denote a definition, and then data constructors (or names of
values that inhabit your term-level code).
You can find the datatype definition for built-in datatypes
by using :infoin GHCi:
Prelude&gt; :info Bool
data Bool = False | True
Let’s look at where diﬀerent parts of datatypes show up
in our code. If we query the type information for a function
callednotwe see that it takes one Boolvalue and returns another
Boolvalue, so the type signature makes reference to the type
constructor, or datatype name:
Prelude&gt; :t not
not :: Bool -&gt; Bool
But when we use the notfunction, we use the data construc-
tors, or values:
Prelude&gt; not True
False
And our expression evaluates to another data constructor,
or value — in this case, the other data constructor for the same
datatype.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 136
Exercises: Mood Swing
Given the following datatype, answer the following questions:
dataMood=Blah|Wootderiving Show
Thederiving Show part is not something we’ve explained
yet. For now, all we’ll say is that when you make your own
datatypes, deriving Showallows the values of that type to be
printed to the screen. We’ll talk about it more when we talk
about typeclasses in detail.
1.What is the type constructor, or name of this type?
2.If the function requires a Moodvalue, what are the values
you could possibly use?
3.We are trying to write a function changeMood to change
Chris’s mood instantaneously. It should act like notin
that, given one value, it returns the othervalue of the same
type. So far, we’ve written a type signature changeMood ::
Mood -&gt; Woot . What’s wrong with that?
4.Now we want to write the function that changes his mood.
Given an input mood, it gives us the other one. Fix any
mistakes and complete the function:
changeMood Mood=Woot
changeMood _ =Blah</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 137
We’re doing something here called pattern matching . We
can define a function by matching on a data constructor,
or value, and describing the behavior that the function
should have based on which value it matches. The un-
derscore in the second line denotes a catch-all, otherwise
case. So, in the first line of the function, we’re telling it
what to do in the case of a specific input. In the second
one, we’re telling it what to do regardless of all potential
inputs. It’s trivial when there are only two potential values
of a given type, but as we deal with more complex cases,
it can be convenient.
5.Enter all of the above — datatype (including the deriving
Showbit), your corrected type signature, and the corrected
function into a source file. Load it and run it in GHCi to
make sure you got it right.
4.4 Numeric types
Let’s look next at numeric types, because we’ve already seen
these types in previous chapters, and numbers are familiar
territory. It’s important to understand that Haskell does not
use only one type of number. For most purposes, the types of
numbers we need to be concerned with are:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 138
Integral numbers These are whole numbers, positive and
negative.
1.Int: This type is a fixed-precision integer. By “fixed pre-
cision,” we mean it has a range, with a maximum and a
minimum, and so it cannot be arbitrarily large or small
— more about this in a moment.
2.Integer : This type is also for integers, but this one supports
arbitrarily large (or small) numbers.
Fractional These are not integers. Fractional values include
the following four types:
1.Float: This is the type used for single-precision float-
ing point numbers. Fixed-point number representations
have immutable numbers of digits assigned for the parts
of the number before and after the decimal point. In
contrast, floating point can shift how many bits it uses to
represent numbers before or after the decimal point. This
flexibility does, however, mean that floating point arith-
metic violates some common assumptions and should
only be used with great care. Generally, floating point
numbers should not be used at all in business applications.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 139
2.Double : This is a double-precision floating point number
type. It has twice as many bits with which to describe
numbers as the Floattype.
3.Rational : This is a fractional number that represents a
ratio of two integers. The value 1 / 2 :: Rational will be a
value carrying two Integer values, the numerator 1and the
denominator 2, and represents a ratio of 1 to 2. Rational is
arbitrarily precise but not as efficient as Scientific .
4.Scientific : This is a space efficient and almost arbitrary
precision scientific number type. Scientific numbers are
represented using scientific notation. It stores the coef-
ficient as an Integer and the exponent as an Int. Since
Intisn’t arbitrarily large, there is technically a limit to
the size of number you can express with Scientific , but
hitting that limit is quite unlikely. Scientific is available
in a library2and can be installed using cabal install or
stack install .
These numeric datatypes all have instances of a typeclass
calledNum. We will talk about typeclasses in the upcoming
chapters, but as we look at the types in this section, you will
seeNumlisted in some of the type information.
Typeclasses are a way of adding functionality to types that
is reusable across all the types that have instances of that type-
2Hackage page for scientific :https://hackage.haskell.org/package/scientific</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 140
class.Numis a typeclass for which most numeric types will
have an instance because there are standard functions that are
convenient to have available for all types of numbers. The Num
typeclass is what provides your standard (+),(-), and(*)oper-
ators along with a few others. Any type that has an instance of
Numcan be used with those functions. An instance defines how
the functions work for that specific type. We will talk about
typeclasses in much more detail soon.
Integral numbers
As we noted above, there are two main types of integral num-
bers:IntandInteger .
Integral numbers are whole numbers with no fractional
component. The following are integral numbers:
1219932442353464675685678
The following are not integral numbers:
1.31/2
Integer
The numbers of type Integer are the sorts of numbers we’re
used to working with in arithmetic equations that involve
whole numbers. They can be positive or negative, and Integer
extends as far in either direction as one needs them to go.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 141
TheBooldatatype only has two possible values, so we can list
them explicitly as data constructors. In the case of Integer , and
most numeric datatypes, these data constructors are not writ-
ten out because they include an infinite series of whole num-
bers. We’d need infinite data constructors stretching up and
down from zero. Hypothetically we could represent Integer as
a sum of three cases, recursive constructors headed towards
negative infinity, zero, and recursive constructors headed to-
wards positive infinity. This representation would be terribly
inefficient so there’s some GHC magic sprinkled on it.
Why do we have Int?
TheIntnumeric types are artifacts of what computer hardware
has supported natively over the years. Most programs should
useInteger , notInt, unless the limitations of the type are un-
derstood and the additional performance makes a diﬀerence.
The danger of Intand the related types Int8,Int16, et al. is
that they cannot express arbitrarily large quantities of infor-
mation. Since they are integral, this means they cannot be
arbitrarily large in the positive or negative sense.
Here’s what happens if we try to represent a number too
large for Int8:
Prelude&gt; import GHC.Int
Prelude&gt; 127 :: Int8</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 142
127
Prelude&gt; 128 :: Int8
<interactive>:11:1: Warning:
Literal 128 is out of the
Int8 range -128..127
If you are trying to write a large
negative literal,
use NegativeLiterals
-128
Prelude&gt; (127 + 1) :: Int8
-128
The syntax you see there, :: Int8 is us assigning the Int8
type to these numbers. As we will explain in more detail in
the next chapter, numbers are polymorphic under the surface,
and the compiler doesn’t assign them a concrete type until it
is forced to. It would be weird and unexpected if the compiler
defaulted all numbers to Int8, so in order to reproduce the
situation of having a number too large for an Inttype, we had
to assign that concrete type to it.
As you can see, 127 is fine because it is within the range of
valid values of type Int8, but 128 gives you a warning about
the impending overflow, and 127 + 1 overflows the bounds
and resets back to its smallest numeric value. Because the
memory the value is allowed to occupy is fixed for Int8, it</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 143
cannot grow to accommodate the value 128 the way Integer
can. Here the 8 represents how many bits the type uses to
represent integral numbers.3Being of a fixed size can be
useful in some applications, but most of the time, Integer is
preferred.
You can find out the minimum and maximum bounds of
numeric types using maxBound andminBound from the Bounded
typeclass. Here’s an example using our Int8andInt16example:
Prelude&gt; import GHC.Int
Prelude&gt; :t minBound
minBound :: Bounded a =&gt; a
Prelude&gt; :t maxBound
maxBound :: Bounded a =&gt; a
Prelude&gt; minBound :: Int8
-128
Prelude&gt; minBound :: Int16
-32768
Prelude&gt; minBound :: Int32
-2147483648
Prelude&gt; minBound :: Int64
-9223372036854775808
3The representation used for the fixed-size Inttypes is two’s complement .</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 144
Prelude&gt; maxBound :: Int8
127
Prelude&gt; maxBound :: Int16
32767
Prelude&gt; maxBound :: Int32
2147483647
Prelude&gt; maxBound :: Int64
9223372036854775807
Thus you can find the limitations of possible values for
any type that has an instance of that particular typeclass. In
this case, we are able to find out the range of values we can
represent with an Int8is -128 to 127.
You can find out if a type has an instance of Bounded , or any
other typeclass, by asking GHCi for the :infofor that type.
Doing this will also give you the datatype representation for
the type you queried:
Prelude&gt; :i Int
data Int = GHC.Types.I# GHC.Prim.Int#
-- Defined in ‘GHC.Enum’
instance Bounded Int
Intof course has many more typeclass instances, but Bounded
is the one we cared about at this time.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 145
Fractional numbers
The four common Fractional types in use in Haskell are Float,
Double ,Rational , andScientific .Rational ,Double , andFloatcome
with your install of GHC. Scientific comes from a library, as
we mentioned previously. Rational andScientific are arbi-
trary precision, with the latter being more efficient. Arbitrary
precision means that these can be used to do calculations re-
quiring a high degree of precision rather than being limited
to a specific degree of precision, the way FloatandDouble are.
You almost never want a Floatunless you’re doing graphics
programming such as with OpenGL.
Some computations involving numbers will be fractional
rather than integral. A good example of this is the division
function (/)which has the type:
Prelude&gt; :t (/)
(/) :: Fractional a =&gt; a -&gt; a -&gt; a
The notation Fractional a =&gt; denotes a typeclass constraint .
It tells us the type variable 𝑎must implement the Fractional
typeclass. Whatever type of number 𝑎turns out to be, it must
be a type that has an instance of the Fractional typeclass; that
is, there must be a declaration of how the operations from
that typeclass will work for the type. The /function will take
one number that implements Fractional , divide it by another</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 146
of the same type, and return a value of the same type as the
result.
Fractional is a typeclass that requires types to already have
an instance of the Numtypeclass. We describe this relation-
ship between typeclasses by saying that Numis a superclass of
Fractional . So(+)and other functions from the Numtypeclass
can be used with Fractional numbers, but functions from the
Fractional typeclass cannot be used with all types that have a
Numinstance:
Here’s what happens when we use (/)in the REPL:
Prelude&gt; 1 / 2
0.5
Prelude&gt; 4 / 2
2.0
Note that even when we had a whole number as a result,
the result was fractional. This is because values of Fractional
a =&gt; a default to the floating point type Double. In most cases,
you won’t want to explicitly use Double. You may be better
oﬀ using the arbitrary precision sibling to Integer ,Scientific .
Most people do not find it easy to reason about floating point
arithmetic and find it difficult to code around the quirks (those
quirks exist by design, but that’s another story), so in order
to avoid making mistakes, use arbitrary-precision types as a
matter of course.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 147
4.5 Comparing values
Up to this point, most of our operations with numbers have
involved doing simple arithmetic. We can also compare num-
bers to determine whether they are equal, greater than, or less
than:
Prelude&gt; let x = 5
Prelude&gt; x == 5
True
Prelude&gt; x == 6
False
Prelude&gt; x &lt; 7
True
Prelude&gt; x &gt; 3
True
Prelude&gt; x /= 5
False
Notice here that we first declared a value for 𝑥using the
standard equals sign. Now we know that for the remainder of
our REPL session, all instances of 𝑥will be the value 5. Because
the equals sign in Haskell is already used to define variables
and functions, we must use a double equals sign, ==, to have
the specific meaning is equal to . The/=symbol means is not
equal to . The other symbols should already be familiar to you.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 148
Having done this, we see that GHCi is returning a result of
eitherTrueorFalse, depending on whether the expression is
true or false. TrueandFalseare the data constructors for the
Booldatatype we saw above. If you look at the type information
for any of these infix operators, you’ll find the result type listed
asBool:
Prelude&gt; :t (==)
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool
Prelude&gt; :t (&lt;)
(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool
Notice that we get some typeclass constraints again. Eqis a
typeclass that includes everything that can be compared and
determined to be equal in value; Ordis a typeclass that includes
all things that can be ordered. Note that neither of these is
limited to numbers. Numbers can be compared and ordered,
of course, but so can letters, so this typeclass constraint allows
for flexibility. These equality and comparison functions can
take any values that can be said to have equal value or can be
ordered. The rest of the type information tells us that it takes
one of these values, compares it to another value of the same
type, and returns a Boolvalue. As we’ve already seen, the Bool
values are TrueorFalse.
With this information, let’s try playing with some other
values:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 149
Prelude&gt; 'a' == 'a'
True
Prelude&gt; 'a' == 'b'
False
Prelude&gt; 'a' &lt; 'b'
True
Prelude&gt; 'a' &gt; 'b'
False
Prelude&gt; 'a' == 'A'
False
Prelude&gt; &quot;Julie&quot; == &quot;Chris&quot;
False
We know that alphabetical characters can be ordered, al-
though we do not normally think of ‘a’ as being “less than” ‘b.’
But we can understand that here it means ‘a’ comes before ‘b’ in
alphabetical order. Further, we see this also works with strings
such as “Julie” or “Chris.” GHCi has faithfully determined that
those two strings are not equal in value.
Now use your REPL to determine whether ‘a’ or ‘A’ is greater.
Next, take a look at this sample and see if you can figure out
why GHCi returns the given results:
Prelude&gt; &quot;Julie&quot; &gt; &quot;Chris&quot;
True
Prelude&gt; &quot;Chris&quot; &gt; &quot;Julie&quot;
False</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 150
Good to see Haskell code that reflects reality. “Julie” is
greater than “Chris” because J &gt;C, if the words had been “Back”
and “Brack” then it would’ve skipped the first letter to deter-
mine which was greater because B == B, then “Brack” would
have been greater because ‘r’ &gt;‘a’ in the lexicographic ordering.
Note that this is leaning on the Ordtypeclass instances for the
list type andChar. You can only compare lists of items where
the items themselves also have an instance of Ord. Accordingly,
the following will work because CharandInteger have instances
ofOrd:
Prelude&gt; ['a', 'b'] &gt; ['b', 'a']
False
Prelude&gt; 1 &gt; 2
False
Prelude&gt; [1, 2] &gt; [2, 1]
False
A datatype that has no instance of Ordwill not work with
these functions:
Prelude&gt; data Mood = G | B deriving Show
Prelude&gt; [G, B]
[G,B]
Prelude&gt; [G, B] &gt; [B, G]
<interactive>:28:14:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 151
No instance for (Ord Mood) arising
from a use of ‘&gt;’
In the expression: [G, B] &gt; [B, G]
In an equation for ‘it’:
it = [G, B] &gt; [B, G]
“No instance for (Ord Mood) ” means it doesn’t have an Ord
instance to know how to order these values.
Here is another thing that doesn’t work with these functions:
Prelude&gt; &quot;Julie&quot; == 8
<interactive>:38:12:
No instance for (Num [Char]) arising from
the literal ‘8’
In the second argument of ‘(==)’,
namely ‘8’
In the expression: &quot;Julie&quot; == 8
In an equation for ‘it’: it = &quot;Julie&quot; == 8
We said above that comparison functions are polymorphic
and can work with a lot of diﬀerent types. But we also noted
that the type information only admitted values of matching
types. Once you’ve given a term-level value that is a String
such as “Julie,” the type is determined and the other argument
must have the same type. The error message we see above is</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 152
telling us that the type of the literal value 8 doesn’t match the
type of the first value, and for this function, it must.
4.6 Go on and Bool me
TheBooldatatype comes standard in the Prelude . As we saw
earlier, Boolis a sum type with two constructors:
dataBool=False|True
This declaration creates a datatype with the type construc-
torBool, and we refer to specific types by their type construc-
tors. We use type constructors in type signatures, not in the
expressions that make up our term-level code. The type con-
structor Booltakes no arguments (some type constructors do
take arguments). The definition of Boolabove also creates two
data constructors, TrueandFalse. Both of these values are of
typeBool. Any function that accepts values of type Bool must
allow for the possibility of TrueorFalse; you cannot specify
in the type that it should only accept one specific value. An
English language formulation of this datatype would be some-
thing like: “The datatype Boolis represented by the values True
orFalse.”
Remember, you can find the type of any value by asking
for it in GHCi, just as you can with functions:
Prelude&gt; :t True</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 153
True :: Bool
Prelude&gt; :t &quot;Julie&quot;
&quot;Julie&quot; :: [Char]
Now let’s have some fun with Bool. We’ll start by reviewing
thenotfunction:
Prelude&gt; :t not
not :: Bool -&gt; Bool
Prelude&gt; not True
False
Note that we capitalize TrueandFalsebecause they are our
data constructors. What happens if you try to use notwithout
capitalizing them?
Let’s try something slightly more complex:
Prelude&gt; let x = 5
Prelude&gt; not (x == 5)
False
Prelude&gt; not (x &gt; 7)
True
We know that comparison functions evaluate to a Boolvalue,
so we can use them with not.
Let’splaywithinfixoperatorsthatdealdirectlywithboolean
logic. How do we use Booland these associated functions?</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 154
First,(&amp;&amp;)is the infix operator for boolean conjunction. The
first example reads, colloquially, “true and true:”
Prelude&gt; True &amp;&amp; True
True
Prelude&gt; (8 &gt; 4) &amp;&amp; (4 &gt; 5)
False
Prelude&gt; not (True &amp;&amp; True)
False
The infix operator for boolean disjunction is (||), so the
first example here reads “false or true:”
Prelude&gt; False || True
True
Prelude&gt; (8 &gt; 4) || (4 &gt; 5)
True
Prelude&gt; not ((8 &gt; 4) || (4 &gt; 5))
False
We can look up info about datatypes that are in scope (if
they’re not in scope, we have to import the module they live
in to bring them into scope) using the :infocommand GHCi
provides. Scope is a way to refer to where a named binding to
an expression is valid. When we say something is in scope , it
means you can use that expression by its bound name, either
because it was defined in the same function or module, or</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 155
because you imported it. So, it’s visible to the program we’re
trying to run right now. What is built into Haskell’s Prelude
module is significant because everything in it is automatically
imported and in scope. For now, this is what we want so we
don’t have to write every function from scratch.
Exercises: Find the Mistakes
The following lines of code may have mistakes — some of
them won’t compile! You know what you need to do.
1.not True &amp;&amp; true
2.not (x = 6)
3.(1 * 2) &gt; 5
4.[Merry] &gt; [Happy]
5.[1, 2, 3] ++ &quot;look at me!&quot;
Conditionals with if-then-else
Haskell doesn’t have ‘if’ statements, but it does have if ex-
pressions . It’s a built-in bit of syntax that works with the Bool
datatype.
Prelude&gt; let t = &quot;Truthin'&quot;
Prelude&gt; let f = &quot;Falsin'&quot;</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 156
Prelude&gt; if True then t else f
&quot;Truthin'&quot;
The expression if True evaluates to True, hence we return 𝑡.
Prelude&gt; if False then t else f
&quot;Falsin'&quot;
Prelude&gt; :t if True then t else f
if True then &quot;Truthin'&quot; else &quot;Falsin'&quot;
:: [Char]
Andif False evaluates to False, so we return the elsevalue.
The type of the whole expression is String (aka[Char] ) because
that’s the type of the value that is returned as a result.
The structure here is:
if CONDITION
then EXPRESSION_A
else EXPRESSION_B
If the condition (which must evaluate to Bool) reduces to the
valueTrue, thenEXPRESSION_A istheresult, otherwise EXPRESSION_B .
If-expressions can be thought of as a way to choose between
two values. You can embed a variety of expressions within
theifof an if-then-else, as long as it evaluates to Bool. The
types of the expressions in the thenandelseclauses must be
the same, as in the following:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 157
Prelude&gt; let x = 0
Prelude&gt; let a = &quot;AWESOME&quot;
Prelude&gt; let w = &quot;wut&quot;
Prelude&gt; if (x + 1 == 1) then a else w
&quot;AWESOME&quot;
Here’s how it reduces:
-- Given:
x=0
if(x+1==1)then&quot;AWESOME&quot; else&quot;wut&quot;
-- x is zero
if(0+1==1)then&quot;AWESOME&quot; else&quot;wut&quot;
-- reduce 0 + 1 so we can see
-- if it's equal to 1
if(1==1)then&quot;AWESOME&quot; else&quot;wut&quot;
-- Does 1 equal 1?
ifTruethen&quot;AWESOME&quot; else&quot;wut&quot;
-- pick the branch based on the Bool value
&quot;AWESOME&quot;
-- dunzo</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 158
But this does not work:
Prelude&gt; let dog = &quot;adopt a dog&quot;
Prelude&gt; let cat = &quot;or a cat&quot;
Prelude&gt; let x = 0
Prelude&gt; if x * 100 then dog else cat
<interactive>:15:7:
No instance for (Num Bool) arising
from a use of ‘*’
In the expression: (x * 100)
In the expression:
if (x * 100)
then &quot;adopt a dog&quot;
else &quot;or a cat&quot;
In an equation for ‘it’:
it = if (x * 100)
then &quot;adopt a dog&quot;
else &quot;or a cat&quot;
We got this type error because the condition passed to the
if-expression is of type Num a =&gt; a , notBoolandBooldoesn’t
implement the Numtypeclass. To oversimplify, (x * 100) evalu-
ates to a numeric result, and numbers aren’t truth values. It
would have typechecked had the condition been x * 100 == 0</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 159
orx * 100 == 9001 . In those cases, it would’ve been an equality
check of two numbers which reduces to a Boolvalue.
Here’s an example of a function that uses a Boolvalue in an
if-expression:
-- greetIfCool1.hs
moduleGreetIfCool1 where
greetIfCool ::String-&gt;IO()
greetIfCool coolness =
ifcool
thenputStrLn &quot;eyyyyy. What's shakin'?&quot;
else
putStrLn &quot;pshhhh.&quot;
wherecool=
coolness ==&quot;downright frosty yo&quot;
When you test this in the REPL, it should play out like this:
Prelude&gt; :l greetIfCool1.hs
[1 of 1] Compiling GreetIfCool1
Ok, modules loaded: GreetIfCool1.
Prelude&gt; greetIfCool &quot;downright frosty yo&quot;
eyyyyy. What's shakin'?
Prelude&gt; greetIfCool &quot;please love me&quot;
pshhhh.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 160
Also note that greetIfCool could’ve been written with cool
being a function rather than a value defined against the argu-
ment directly like so:
-- greetIfCool2.hs
moduleGreetIfCool2 where
greetIfCool ::String-&gt;IO()
greetIfCool coolness =
ifcool coolness
thenputStrLn &quot;eyyyyy. What's shakin'?&quot;
else
putStrLn &quot;pshhhh.&quot;
wherecool v=
v==&quot;downright frosty yo&quot;
4.7 Tuples
Tupleis a type that allows you to store and pass around multiple
values within a single value. Tuples have a distinctive, built-
in syntax that is used at both type and term levels, and each
tuple has a fixed number of constituents. We refer to tuples
by the number of values in each tuple: the two-tuple or pair,
for example, has two values inside it, (x, y); the three-tuple
or triple has three, (x, y, z) , and so on. This number is also</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 161
known as the tuple’s arity. As we will see, the values within a
tuple do not have to be of the same type.
We will start by looking at the two-tuple, a tuple with two
elements. The two-tuple is expressed at both the type level and
term level with the constructor (,). The datatype declaration
looks like this:
Prelude&gt;:info (,)
data(,) a b =(,) a b
This is diﬀerent from the Booltype we looked at earlier in a
couple of important ways, even apart from that special type
constructor syntax. The first is that it has two parameters,
represented by the type variables 𝑎and𝑏. Those have to be
applied to concrete types, much as variables at the term level
have to be applied to values to evaluate a function. The second
major diﬀerence is that this is a product type , not a sum type.
A product type represents a logical conjunction: you must
supplybotharguments to construct a value.
Notice that the two type variables are diﬀerent, so that al-
lows for tuples that contain values of two diﬀerent types. The
types are not, however, required to be diﬀerent:
λ&gt; (,) 8 10
(8,10)
λ&gt; (,) 8 &quot;Julie&quot;
(8,&quot;Julie&quot;)</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 162
λ&gt; (,) True 'c'
(True,'c')
But if we try to apply it to only one argument:
λ&gt; (,) 9
<interactive>:34:1:
No instance for (Show (b0 -&gt; (a0, b0)))
(maybe you haven't applied enough
arguments to a function?)
arising from a use of ‘print’
In the first argument of ‘print’,
namely ‘it’
In a stmt of an interactive
GHCi command: print it
Well, look at that error. This is one we will explore in detail
soon, but for now the important part is the part in parenthe-
ses: we haven’t applied the function — in this case, the data
constructor — to enough arguments.
The two-tuple in Haskell has some default convenience
functions for getting the first or second value. They’re named
fstandsnd:
fst::(a, b)-&gt;a
snd::(a, b)-&gt;b</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 163
The type signature tells us there’s nothing those functions
could do other than return the first or second value, respec-
tively.
Here are some examples of manipulating tuples, specifically
the two-tuple:
Prelude&gt; let myTup = (1 :: Integer, &quot;blah&quot;)
Prelude&gt; :t myTup
myTup :: (Integer, [Char])
Prelude&gt; fst myTup
1
Prelude&gt; snd myTup
&quot;blah&quot;
Prelude&gt; import Data.Tuple
Prelude&gt; swap myTup
(&quot;blah&quot;,1)
We had to import Data.Tuple because swapisn’t included in
thePrelude .
We can also combine tuples with other expressions:
Prelude&gt; 2 + fst (1, 2)
3
Prelude&gt; 2 + snd (1, 2)
4
The(x, y) syntax of the tuple is special. The constructors
you use in the type signatures and in your code (terms) are</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 164
syntactically identical even though they’re diﬀerent things.
Sometimes that type constructor is referred to without the
type variables explicitly inside of it such as (,). Other times,
you’ll see (a, b) — particularly in type signatures.
You can use that syntax to pattern match when you write
functions, too. One nice thing about that is that the func-
tion definition can look very much like the type signature
sometimes. For example, we can implement fstandsndfor
ourselves like this:
fst'::(a, b)-&gt;a
fst'(a, b)=a
snd'::(a, b)-&gt;b
snd'(a, b)=b
Let’s look at another example of pattern matching on tuples:
tupFunc ::(Int, [a])
-&gt;(Int, [a])
-&gt;(Int, [a])
tupFunc (a, b) (c, d) =
((a+c), (b++d))
It’s generally unwise to use tuples of an overly large size,
both for efficiency and sanity reasons. Most tuples you see will
be( , , , , ) (5-tuple) or smaller.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 165
4.8 Lists
Lists are another type used to contain multiple values within
a single value. However, they diﬀer from tuples in three im-
portant ways: First, all elements of a list must be of the same
type. Second, lists have their own distinct []syntax. Like the
tuple syntax, it is used for both the type constructor in type
signatures and at the term level to express list values. Third,
the number of values that will be in the list isn’t specified in
the type — unlike tuples where the arity is set in the type and
immutable.
Here’s an example for your REPL:
Prelude&gt; let p = &quot;Papuchon&quot;
Prelude&gt; let awesome = [p, &quot;curry&quot;, &quot;:)&quot;]
Prelude&gt; awesome
[&quot;Papuchon&quot;,&quot;curry&quot;,&quot;:)&quot;]
Prelude&gt; :t awesome
awesome :: [[Char]]
First thing to note is that awesome is a list of lists of Charvalues
because it is a list of strings, and String is a type alias for [Char] .
This means all the functions and operations valid for lists of
any value, usually expressed as [a], are valid for String because
[Char] is more specific than [a].</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 166
Prelude&gt; let s = &quot;The Simons&quot;
Prelude&gt; let also = [&quot;Quake&quot;, s]
Prelude&gt; :t (++)
(++) :: [a] -&gt; [a] -&gt; [a]
Prelude&gt; awesome ++ also
[&quot;Papuchon&quot;,
&quot;curry&quot;,
&quot;:)&quot;,
&quot;Quake&quot;,
&quot;The Simons&quot;]
Prelude&gt; let allAwesome = [awesome, also]
Prelude&gt; allAwesome
[[&quot;Papuchon&quot;,&quot;curry&quot;,&quot;:)&quot;],
[&quot;Quake&quot;,&quot;The Simons&quot;]]
Prelude&gt; :t allAwesome
allAwesome :: [[[Char]]]
Prelude&gt; :t concat
concat :: [[a]] -&gt; [a]
Prelude&gt; concat allAwesome
[&quot;Papuchon&quot;,
&quot;curry&quot;,
&quot;:)&quot;,
&quot;Quake&quot;,
&quot;The Simons&quot;]
We’ll save a full exploration of the list datatype until we</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 167
get to the chapter on lists. The list data structure gets a whole
chapter because lists have some interesting complexity, we’re
going to use them to demonstrate some things about Haskell’s
nonstrict evaluation, and there are manystandard functions
and constructs that can be used with lists.
4.9 Chapter Exercises
As in previous chapters, you will gain more by working out the
answer before you check what GHCi tells you, but be sure
to use your REPL to check your answers to the following
exercises. Also, you will need to have the awesome ,also, and
allAwesome code from above in scope for this REPL session. For
convenience of reference, here are those values again:
awesome =[&quot;Papuchon&quot; ,&quot;curry&quot;,&quot;:)&quot;]
also=[&quot;Quake&quot;,&quot;The Simons&quot; ]
allAwesome =[awesome, also]
length is a function that takes a list and returns a result that
tells how many items are in the list.
1.Given the definition of length above, what would the type
signature be? How many arguments, of what type does it
take? What is the type of the result it evaluates to?
2.What are the results of the following expressions?</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 168
a)length [1, 2, 3, 4, 5]
b)length [(1, 2), (2, 3), (3, 4)]
c)length allAwesome
d)length (concat allAwesome)
3.Given what we know about numeric types and the type
signature of length, look at these two expressions. One
works and one returns an error. Determine which will
return an error and why.
(n.b., you will find Foldable t =&gt; t a representing [a], as
withconcat inthepreviouschapter. Again, consider Foldable
tto represent a list here, even though list is only one of
the possible types.)
Prelude&gt; 6 / 3
-- and
Prelude&gt; 6 / length [1, 2, 3]
4.How can you fix the broken code from the preceding
exercise using a diﬀerent division function/operator?
5.What is the type of the expression 2 + 3 == 5 ? What would
we expect as a result?
6.What is the type and expected result value of the follow-
ing:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 169
Prelude&gt; let x = 5
Prelude&gt; x + 3 == 5
7.Below are some bits of code. Which will work? Why or
why not? If they will work, what value would these reduce
to?
Prelude&gt; length allAwesome == 2
Prelude&gt; length [1, 'a', 3, 'b']
Prelude&gt; length allAwesome + length awesome
Prelude&gt; (8 == 8) &amp;&amp; ('b' &lt; 'a')
Prelude&gt; (8 == 8) &amp;&amp; 9
8.Write a function that tells you whether or not a given
String (or list) is a palindrome. Here you’ll want to use
a function called reverse a predefined function that does
what it sounds like.
reverse :: [a] -&gt; [a]
reverse &quot;blah&quot;
&quot;halb&quot;
isPalindrome ::(Eqa)=&gt;[a]-&gt;Bool
isPalindrome x=undefined
9.Write a function to return the absolute value of a number
using if-then-else</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 170
myAbs::Integer -&gt;Integer
myAbs=undefined
10.Fill in the definition of the following function, using fst
andsnd:
f::(a, b)-&gt;(c, d)-&gt;((b, d), (a, c))
f=undefined
Correcting syntax
In the following examples, you’ll be shown syntactically incor-
rect code. Type it in and try to correct it in your text editor,
validating it with GHC or GHCi.
1.Here, we want a function that adds 1 to the length of a
string argument and returns that result.
x=(+)
Fxs=w'x'1
wherew=length xs
2.This is supposed to be the identity function, id.
\X=x
3.When fixed, this function will return 1 from the value (1,
2).</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 171
f(a b)=A
Match the function names to their types
1.Which of the following types is the type of show?
a)showa=&gt;a-&gt;String
b)Showa-&gt;a-&gt;String
c)Showa=&gt;a-&gt;String
2.Which of the following types is the type of (==)?
a)a-&gt;a-&gt;Bool
b)Eqa=&gt;a-&gt;a-&gt;Bool
c)Eqa-&gt;a-&gt;a-&gt;Bool
d)Eqa=&gt;A-&gt;Bool
3.Which of the following types is the type of fst?
a)(a, b)-&gt;a
b)b-&gt;a
c)(a, b)-&gt;b
4.Which of the following types is the type of (+)?
a)(+)::Numa-&gt;a-&gt;a-&gt;Bool
b)(+)::Numa=&gt;a-&gt;a-&gt;Bool</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 172
c)(+)::num a=&gt;a-&gt;a-&gt;a
d)(+)::Numa=&gt;a-&gt;a-&gt;a
e)(+)::a-&gt;a-&gt;a
4.10 Definitions
1.Atupleis an ordered grouping of values. In Haskell, you
cannot have a tuple with only one element, but there is a
zero tuple also called unitor(). The types of the elements
of tuples are allowed to vary, so you can have both (String,
String) or (Integer, String). Tuples in Haskell are the usual
means of briefly carrying around multiple values without
giving that combination its own name.
2.Atypeclass is a set of operations defined with respect to
a polymorphic type. When a type has an instance of a
typeclass, values of that type can be used in the standard
operations defined for that typeclass. In Haskell, type-
classes are unique pairings of class and concrete instance.
This means that if a given type 𝑎has an instance of Eq, it
hasonlyone instance of Eq.
3.Data constructors in Haskell provide a means of creating
values that inhabit a given type. Data constructors in
Haskell have a type and can either be constant values
(nullary) or take one or more arguments, like functions.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 173
In the following example, Catis a nullary data constructor
forPetandDogis a data constructor that takes an argument:
-- Why name a cat?
-- They don't answer anyway.
typeName=String
dataPet=Cat|DogName
The data constructors have the following types:
Prelude&gt; :t Cat
Cat :: Pet
Prelude&gt; :t Dog
Dog :: Name -&gt; Pet
4.Type constructors in Haskell are notvalues and can only be
used in type signatures. Just as data declarations generate
data constructors to create values that inhabit that type,
data declarations generate type constructors which can be
used to denote that type. In the above example, Petis the
type constructor. A guideline for diﬀerentiating the two
kinds of constructors is that type constructors always go
to the left of the =in a data declaration.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 174
5.Data declarations define new datatypes in Haskell. Data
declarations always create a new type constructor, but may
ormaynot create new data constructors. Data declarations
are how we refer to the entire definition that begins with
thedatakeyword.
6.Atype alias is a way to refer to a type constructor or type
constant by an alternate name, usually to communicate
something more specific or for brevity.
typeName=String
-- creates a new type alias Name of the
-- type String <em>not</em> a data declaration,
-- just a type alias declaration
7.Arityis the number of arguments a function accepts. This
notion is a little slippery in Haskell as, due to currying, all
functions are 1-arity and we handle accepting multiple
arguments by nesting functions.
8.Polymorphism in Haskell means being able to write code
in terms of values which may be one of several, or any,
type. Polymorphism in Haskell is either parametric or
constrained . The identity function, id, is an example of a
parametrically polymorphic function:
id::a-&gt;a
idx=x</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 175
Hereidworks for a value of anytype because it doesn’t
use any information specific to a given type or set of types.
Whereas, the following function isEqual :
isEqual ::Eqa=&gt;a-&gt;a-&gt;Bool
isEqual x y=x==y
Is polymorphic, but constrained orbounded to the set of
types which have an instance of the Eqtypeclass. The dif-
ferent kinds of polymorphism will be discussed in greater
detail in a later chapter.
4.11 Names and variables
Names
In Haskell there are seven categories of entities that have
names: functions, term-level variables, data constructors, type
variables, type constructors, typeclasses, and modules. Term-
level variables and data constructors exist in your terms. Term
levelis where your values live and is the code that executes
when your program is running. At the type level , which is used
during the static analysis &amp; verification of your program, we
have type variables, type constructors, and typeclasses. Lastly,
for the purpose of organizing our code into coherent group-
ings across diﬀerent files, we have modules.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 176
Conventions for variables
Haskell uses a lot of variables, and some conventions have
developed. It’s not critical that you memorize this, because for
the most part, these are merely conventions, but familiarizing
yourself with them will help you read Haskell code.
Type variables (that is, variables in type signatures) gener-
ally start at 𝑎and go from there: 𝑎,𝑏,𝑐, and so forth. You may
sometimes see them with numbers appended to them, e.g., 𝑎1.
Functions can be used as arguments and in that case are
typically labeled with variables starting at 𝑓(followed by 𝑔and
so on). They may sometimes have numbers appended (e.g., 𝑓1)
and may also sometimes be decorated with the′character as
in𝑓′. This would be pronounced “eﬀ-prime,” should you have
need to say it aloud. Usually this denotes a function that is
closely related to or a helper function to function 𝑓. Functions
may also be given variable names that are not on this spectrum
as a mnemonic. For example, a function that results in a list
of prime numbers might be called 𝑝, or a function that fetches
some text might be called 𝑡𝑥𝑡.
Variables do not have to be a single letter. In small programs,
they often are; in larger programs, they usually should not
be a single letter. If there are many variables in a function
or program, as is common, it is helpful to have descriptive
variable names. It is often advisable in domain-specific code</p>
<p>CHAPTER 4. BECAUSE PIGS CAN’T FLY 177
to use domain-specific variable names.
Arguments to functions are most often given names start-
ing at𝑥, again occasionally seen numbered as in 𝑥1. Other
single-letter variable names may be chosen when they serve a
mnemonic role, such as choosing 𝑟to represent a value that is
the radius of a circle.
If you have a list of things you have named 𝑥, by convention
that will usually be called 𝑥𝑠, that is, the plural of 𝑥. You will
see this convention often in the form (x:xs) , which means you
have a list in which the head of the list is 𝑥and the rest of the
list is𝑥𝑠.
All of these, though, are conventions, not definite rules.
While we will generally adhere to the conventions in this book,
any Haskell code you see out in the wild may not. Calling a
type variable 𝑥instead of 𝑎is not going to break anything. As
in the lambda calculus, the names don’t have any inherent
meaning. We oﬀer this information as a descriptive guide of
Haskell conventions, not as rules you must follow in your own
code.</p>
<p>Chapter 5
Types
She was the single
artificer of the world
In which she sang. And
when she sang, the sea,
Whatever self it had,
became the self
That was her song, for she
was the maker.
Wallace Stevens, “The
Idea of Order at Key
West”
178</p>
<p>CHAPTER 5. TYPES 179
5.1 Types
In the last chapter, we looked at some built-in datatypes, such
asBooland tuples and had a brief run-in with the typeclasses
NumandEq. However, a deep understanding of types and how to
read and interpret them is fundamental to reading and writing
Haskell.
As we have seen, a datatype declaration defines a type con-
structor and data constructors. Data constructors are the val-
ues of a particular type; they are also functions that let us
create data, or values, of a particular type, although it will
take some time before the full import of this becomes clear.
In Haskell, you cannot create untyped data, so except for a
sprinkling of syntactic sugar for things like numbers or func-
tions, everything originates in a data constructor from some
definition of a type.
In this chapter, we’re going to take a deeper look at the type
system and
•learn more about querying and reading type signatures;
•see that currying has, unfortunately, nothing to do with
food;
•take a closer look at diﬀerent kinds of polymorphism;
•look at type inference and how to declare types for our
functions.</p>
<p>CHAPTER 5. TYPES 180
5.2 What are types for?
Haskell is an implementation of a pure lambda calculus, in
the sense that it isn’t much more than syntactic sugar over the
basic system of variables, abstractions, and applications that
constitute the rules of the lambda calculus — at least, of a typed
lambda calculus. Developments in logic, mathematics, and
computer science led to the discovery (or invention, take your
pick) of a typed lambda calculus called System F in the 1970s.
Haskell has improved on System F in some key ways, such as
by allowing general recursion (more on that in a later chapter)
and the Hindley-Milnersystemto permit type inference (more
on that later in this chapter), but the core logic is the same.
So, why do we want types? Type systems in logic and math-
ematics have been designed to impose constraints that enforce
correctness. For our purposes, we can say that well-designed
type systems help eliminate some classes of errors as well as
concerns such as what the eﬀect of a conditional over a non-
Boolean value might be. A type system defines the associations
between diﬀerent parts of a program and checks that all the
parts fit together in a logically consistent, provably correct
way.
Let’s consider a short, somewhat oversimplified example.
TheBooltype is a set with two inhabitants, TrueandFalse, as
we saw in the last chapter. Anytime the value TrueorFalse
occurs in a Haskell program, the typechecker will know they’re</p>
<p>CHAPTER 5. TYPES 181
members of the Booltype. The inverse is that whenever the
typeBoolis declared in a type signature, the compiler will
expect one of those two values and only one of those two
values; you get a type error if you try to pass a number where
aBoolis expected.
In Haskell, where typing is static, typechecking occurs at
compile time . That means many errors will be caught before
you try to execute, or run, your program. The diﬀerence isn’t
always obvious because GHCi allows you to typecheck things
interactively, as you’re writing them, as well as execute them if
they typecheck. No type system can eliminate all possibilities
for error, so the possibility of runtime errors and exceptions
still exists, and testing of programs is necessary, but the type
system reduces the number and kinds of tests you must write.
Good type systems can also enable compiler optimizations,
because the compiler can know and predict certain things
about the execution of a program based on the types. Types
can also serve as documentation of your program, which is
one reason we encourage you to declare types (that is, write
the type signatures) for your functions. It won’t matter too
much when you’re writing small programs, but as programs
get longer, type signatures can help you read your program
and remember what you were doing, and help anyone else
who might be trying to use your code as well.
You may feel that Haskell’s type system requires a lot of up-</p>
<p>CHAPTER 5. TYPES 182
front work. This upfront cost comes with a later payoﬀ: code
that is safer and, down the line, easier to maintain. Working
with a good type system can eliminate those tests that only
check that you’re passing the right sort of data around, and
since tests are more code that you have to write (correctly) and
maintain, it will eventually save you time and eﬀort.
Many, perhaps most, programming languages have type
systems that feel like haggling with a petty merchant. However,
we believe Haskell provides a type system that more closely
resembles a quiet, pleasant conversation with a colleague than
an argument in the bazaar. Much of what we suggest with
regards to putting code in a file, loading it in a REPL, querying
types in the REPL, and so forth, is about creating habits con-
ducive to having this pleasant back and forth with your type
system.
5.3 How to read type signatures
In previous chapters, we’ve seen that we can query types in
the REPL with the :typeor:tcommand. You can query types
for functions, partially applied functions, and values, which
are, in a way, fully applied functions.
When we query the types of values, we see something like
this:
Prelude&gt; :type 't'</p>
<p>CHAPTER 5. TYPES 183
't' :: Char -- 't' has the type Char
Prelude&gt; :type &quot;julie&quot;
&quot;julie&quot; :: [Char] -- &quot;julie&quot; has the type String
Prelude&gt; :type True
True :: Bool -- True has the type Bool
When we query the types of numeric values, we see type-
class information instead of a concrete type, because the com-
piler doesn’t know which specific numeric type a value is until
the type is either declared or the compiler is forced to infer
a specific type based on the function. For example, 13may
look like an integer to us, but that would only allow us to use it
in computations that take integers (and not, say, in fractional
division). For that reason, the compiler gives it the type with
the broadest applicability (most polymorphic) and says it’s a
constrained polymorphic Num a =&gt; a value:
Prelude&gt; :type 13
13 :: Num a =&gt; a
-- we can give it a concrete type
-- by declaring it
Prelude&gt; let x = 13 :: Integer
Prelude&gt; :t x
x :: Integer</p>
<p>CHAPTER 5. TYPES 184
You can also query the type signatures of functions, as we’ve
seen:
Prelude&gt; :type not
not :: Bool -&gt; Bool
This takes one input of a Boolvalue and returns one Bool
value. Given that type, there aren’t too many things it even
coulddo.1
Understanding the function type
The arrow, (-&gt;), is the type constructor for functions in Haskell.
It’s baked into the language, but syntactically it works in very
much the same way as all the other types you’ve seen so far. It’s
a type constructor, like Bool, except the (-&gt;)type constructor
takes arguments and has no data constructors:
Prelude&gt; :info (-&gt;)
data (-&gt;) a b
-- some further information is elided
If you compare this to the type constructor for the two-
tuple, you see the similarity:
Prelude&gt; :info (,)
data (,) a b = (,) a b
1Four, to be precise. But if we assume that the standard Prelude functions are generally
useful functions, it helps narrow it down considerably.</p>
<p>CHAPTER 5. TYPES 185
We saw earlier that the tuple constructor needs to be applied
to two values in order to construct a tuple. A function must
similarly have two arguments — one input and one result —
in order to be a function. Unlike the tuple constructor, though,
the function type has no data constructors. The value that
shows up at term level is the function. Functions are values .
As we’ve said, the hallmark of a function is that it can be
applied , and the structure of the type demonstrates this. The
arrow is an infixoperator that has two parameters and associates
to the right (although function application is left associative).
The parameterization suggests that we will apply the function
to some argument that will be bound to the first parameter,
with the second parameter, 𝑏, representing the return or result
type. We will cover these things in more detail throughout
this chapter.
Let’s return to reading type signatures. The function fstis
a value of type (a, b) -&gt; a where-&gt;is an infix type constructor
that takes two arguments:
fst::(a, b) -&gt;a
-- [1] [2] [3]
1.The first parameter of fsthas the type (a, b). Note that
the tuple type itself (,)takes two arguments 𝑎and𝑏.
2.The function type, (-&gt;), has two parameters. One is (a,
b)and one is the result 𝑎.</p>
<p>CHAPTER 5. TYPES 186
3.The result of the function, which has type 𝑎. It’s the same
𝑎that was in the tuple (a, b) .
How do we know it’s the same 𝑎? We can say that we know
the input type 𝑎and the output type 𝑎must be the same type,
and we can see that nothing happens between the input and the
output; that is, there is no operation that comes between them
that could transform that 𝑎into some other value of that type.
Let’s look at another function:
Prelude&gt; :type length
length :: [a] -&gt; Int
Thelength function takes one argument that is a list — note
the square brackets — and returns an Intresult. The Intresult
in this case will be the number of items in the list. The type
of the inhabitants of the list is left unspecified; this function
does not care — in fact, cannot care — what types of values
are inside the list.
Typeclass-constrained type variables
Next, let’s look at the types of some arithmetic functions. You
may recall that the act of wrapping an infix operator in paren-
theses allows us to use the function just like a normal prefix
function, including being able to query the type:
Prelude&gt; :type (+)</p>
<p>CHAPTER 5. TYPES 187
(+) :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; :type (/)
(/) :: Fractional a =&gt; a -&gt; a -&gt; a
To describe these casually, we could say addition takes one
numeric argument, adds it to a second numeric argument of
the same type, and returns a numeric value of the same type
as a result. Similarly, the fractional division function takes a
fractional value, divides it by a second fractional value, and
returns a third fractional value as a result. This isn’t precise,
but it will do for now.
The compiler gives the least specific and most general type
it can. Instead of limiting this function to a concrete type, we
get a typeclass-constrained polymorphic type variable. We’ll
save a fuller explanation of typeclasses for the next chapter.
What we need to know here is that each typeclass oﬀers a stan-
dard set of functions that can be used across several concrete
types. When a typeclass is constraining a type variable in this
way, the variable could represent any of the concrete types
that have instances of that typeclass so that specific operations
on which the function depends are defined for that type. We
say it’s constrained because we still don’t know the concrete
type of 𝑎, but we do know it can onlybe one of the types that
has the required typeclass instance.
This generalization of numberhood is what lets us use the
same numerical literals to represent numeric values of dif-</p>
<p>CHAPTER 5. TYPES 188
ferent types. We can start with a Num a =&gt; a value and then
create specific versions of it with a concrete type using the ::
to assign a type to the value:
Prelude&gt; let fifteen = 15
Prelude&gt; :t fifteen
fifteen :: Num a =&gt; a
Prelude&gt; let fifteenInt = fifteen :: Int
Prelude&gt; let fifteenDouble = fifteen :: Double
Prelude&gt; :t fifteenInt
fifteenInt :: Int
Prelude&gt; :t fifteenDouble
fifteenDouble :: Double
We went from Num a =&gt; a toIntandDouble. This works be-
causeIntandDouble each have an instance of the Numtypeclass:
Prelude&gt; :info Num
[...irrelevant bits elided...]
instance Num Int -- Defined in ‘GHC.Num’
instance Num Double -- Defined in ‘GHC.Float’
Since they both have instances of Num, the operations from
Num, such as addition, are defined for both of them:
Prelude&gt; fifteenInt + fifteenInt
30</p>
<p>CHAPTER 5. TYPES 189
Prelude&gt; fifteenDouble + fifteenDouble
30.0
We can also make more specific versions of our Num a =&gt; a
value named fifteen by using it in a way that requires it to
become something more specific:
Prelude&gt; fifteenDouble + fifteen
30.0
Prelude&gt; fifteenInt + fifteen
30
What we cannot do is this:
Prelude&gt; fifteenDouble + fifteenInt
Couldn't match expected type ‘Double’
with actual type ‘Int’
In the second argument of ‘(+)’,
namely ‘fifteenInt’
In the expression: fifteenDouble + fifteenInt
We can’t add those two values because their types are no
longer polymorphic, and their concrete types are diﬀerent so
they have diﬀerent definitions of how to implement addition.
The type error message contrasts the actual type with the ex-
pected type . The actual type is what we provided; the expected</p>
<p>CHAPTER 5. TYPES 190
type is what the compiler expected. Since we had fifteenDouble
as our first argument, it expected the second value to also have
the type Double but itactually has the type Int.
A type signature might have multiple typeclass constraints
on one or more of the variables. You will sometimes see (or
write) type signatures such as:
(Numa,Numb)=&gt;a-&gt;b-&gt;b
-- or
(Orda,Numa)=&gt;a-&gt;a-&gt;Ordering
Here, the constraints look like a tuple, although they don’t
add another function argument that you must provide, and
they don’t appear as a tuple at the value or term level. Nothing
to the left of the typeclass arrow, =&gt;, shows up at term level. The
tuple of constraints doesrepresent a product, or conjunction,
of constraints.
In the first example above, there are two constraints, one
for each variable. Both 𝑎and𝑏must have instances of the
Numtypeclass. In the second example, both of the constraints
are on the one variable 𝑎— that is, 𝑎must be a type that
implements bothOrdandNum.</p>
<p>CHAPTER 5. TYPES 191
Exercises: Type Matching
Below you’ll find a list of several standard functions we’ve
talked about previously. Under that is a list of their type sig-
natures. Match the function to its type signature. Try to do
it without peeking at the type signatures (either in the text or
in GHCi) and then check your work. You may find it easier to
start from the types and work out what you think a function
of that type would do.
1.Functions:
a)not
b)length
c)concat
d)head
e)(&lt;)
2.Type signatures:
a)_ ::[a]-&gt;a
b)_ ::[[a]]-&gt;[a]
c)_ ::Bool-&gt;Bool
d)_ ::[a]-&gt;Int
e)_ ::Orda=&gt;a-&gt;a-&gt;Bool</p>
<p>CHAPTER 5. TYPES 192
5.4 Currying
As in the lambda calculus, arguments ( plural) is a shorthand
for the truth in Haskell: all functions in Haskell take one argu-
ment and return one result. Other programming languages,
if you have any experience with them, typically allow you to
define functions that can take multiple arguments. There is
no support for this built into Haskell. Instead there are syn-
tactic conveniences that construct curried functions by default.
Currying refers to the nesting of multiple functions, each ac-
cepting one argument and returning one result, to allow the
illusion of multiple-parameter functions.
The arrows we’ve seen in type signatures denote the func-
tion type. We looked at the datatype definition earlier, but
let’s review:
data(-&gt;) a b
In order to have a function, you must have one input, the 𝑎,
to apply the function to, and you’ll get one result, the 𝑏, back.
Each arrow in a type signature represents one argument and
one result, with the final type being the final result. If you
are constructing a function that requires multiple parameters,
then the 𝑏can be another function (the 𝑎can be another func-
tion as well). In that case, just like in lambda abstractions that
have multiple heads, they are nested.</p>
<p>CHAPTER 5. TYPES 193
Let’s break this down by looking at the type signature for
addition, a function that needs multiple inputs:
(+)::Numa=&gt;a-&gt;a-&gt;a
-- | 1 |
(+)::Numa=&gt;a-&gt;a-&gt;a
-- | 2 |
(+)::Numa=&gt;a-&gt;a-&gt;a
-- [3]
1.Here is the typeclass constraint saying that 𝑎must have
an instance of Num. Addition is defined in the Numtypeclass.
2.The boundaries of 2 demarcate what you might call the
two parameters to the function (+), but all functions in
Haskell take one argument and return one result. This is
because functions in Haskell are nested like Matryoshka
dolls in order to accept “multiple” arguments. The way
the(-&gt;)type constructor for functions works means a -&gt;
a -&gt; a represents successive function applications, each
taking one argument and returning one result. The dif-
ference is that the function at the outermost layer is re-
turning another function that accepts the next argument.
This is called currying.</p>
<p>CHAPTER 5. TYPES 194
3.This is the result type for this function. It will be a number
of the same type as the two inputs.
The way the type constructor for functions, (-&gt;), is defined
makes currying the default in Haskell. This is because it is an
infix operator and right associative. Because it associates to
the right, types are implicitly parenthesized like so:
f::a-&gt;a-&gt;a
-- associates to
f::a-&gt;(a-&gt;a)
and
map::(a-&gt;b)-&gt;[a]-&gt;[b]
-- associates into
map::(a-&gt;b)-&gt;([a]-&gt;[b])
Let’s see if we can unpack the notion of a right-associating
infix operator giving us curried functions. The association
here, or grouping into parentheses, is not to control prece-
dence or order of evaluation; it only serves to group the pa-
rameters into argument and result, since there can only be</p>
<p>CHAPTER 5. TYPES 195
one argument and one result per arrow. Since all the arrows
have the same precedence, the associativity does not change
the precedence or order of evaluation.
Remember, when we have a lambda expression that appears
to have two parameters, they are nested lambdas. Applying the
expression to one argument returns a function that awaits ap-
plication to a second argument. After you apply it to a second
argument, you have a final result. You can nest more lambdas
than two, of course, but the process is the same: one argument,
one result, even though that result may be a function awaiting
application to another argument.
The type constructor for functions and the types we see
above are the same thing, but written in Haskell. When there
are “two arguments” in Haskell, we apply our function to an
argument, just like when we apply a lambda expression to an
argument, and then return a result that is a function and needs
to be applied to a second argument.
Explicit parenthesization, as when an input parameter is
itself a function (such as in map, above), may be used to indicate
order of evaluation, but the implicit associativity of the func-
tion type does not mean the inner or final set of parentheses,
i.e., the result type, evaluates first. Application is evaluation;
in other words, the only way to evaluate anything is by apply-
ing functions, and function application is leftassociative. So,
the leftmost, or outermost, arguments will be evaluated first,
assuming anything gets evaluated (since Haskell is nonstrict,</p>
<p>CHAPTER 5. TYPES 196
you can’t assume that anything will be evaluated, but this will
be more clear later).
Partial application
Currying may be interesting, but many people wonder what
the practical eﬀect or value of currying is. We’ll look now at
a strategy called partial application to see what currying does
for us. It’s something we’ll explore more as we go through the
book as well.
We use the double colon to assign a type. Making the type
concrete will eliminate the typeclass constraint:
addStuff ::Integer -&gt;Integer -&gt;Integer
addStuff a b=a+b+5
So,addStuff appears to take two Integer arguments and re-
turn an Integer result. But after loading that in GHCi we see
that it is taking one argument and returning a function that
takes one argument and returns one result:
Prelude&gt; :t addStuff
addStuff :: Integer -&gt; Integer -&gt; Integer
Prelude&gt; let addTen = addStuff 5
Prelude&gt; :t addTen
addTen :: Integer -&gt; Integer
Prelude&gt; let fifteen = addTen 5</p>
<p>CHAPTER 5. TYPES 197
Prelude&gt; fifteen
15
Prelude&gt; addTen 15
25
Prelude&gt; addStuff 5 5
15
Herefifteen is equal to addStuff 5 5 , because addTen is equal
toaddStuff 5 . The ability to apply only some of a function’s ar-
guments is called partial application. This lets us reuse addStuff
and create a new function from it with one of the arguments
applied.
If we recall that (-&gt;)is a type constructor and associates to
the right, this becomes more clear:
addStuff ::Integer -&gt;Integer -&gt;Integer
-- with explicit parenthesization
addStuff ::Integer -&gt;(Integer -&gt;Integer)
Applying addStuff to oneInteger argument gave us the func-
tionaddTen , which is the return function of addStuff . Applying
addTen to anInteger argument gives us a return value, so the
type of fifteen isInteger — no more function arrows.
Let’s check our understanding with a function that isn’t
commutative:</p>
<p>CHAPTER 5. TYPES 198
subtractStuff ::Integer
-&gt;Integer
-&gt;Integer
subtractStuff x y=x-y-10
subtractOne =subtractStuff 1
Prelude&gt; :t subtractOne
subtractOne :: Integer -&gt; Integer
Prelude&gt; let result = subtractOne 11
Prelude&gt; result
-20
Why did we get this result? Because of the order in which
we applied arguments, result is equal to 1 - 11 - 10 .
Manual currying and uncurrying
Haskell is curried by default, but you can uncurry functions.
Uncurrying means un-nesting the functions and replacing the
two functions with a tuple of two values (these would be the two
values you want to use as arguments). If you uncurry (+), the
type changes from Num a =&gt; a -&gt; a -&gt; a toNum a =&gt; (a, a) -&gt; a
which better fits the description “takes two arguments, returns
one result” than curried functions. Some older functional
languages default to using a product type like tuples to express
multiple arguments.</p>
<p>CHAPTER 5. TYPES 199
•Uncurried functions: One function, many arguments
•Curried functions: Many functions, one argument apiece
You can also desugar the automatic currying yourself, by
nesting the arguments with lambdas, though there’s rarely a
reason to do so.
We’ll use anonymous lambda syntax here to show you some
examples of uncurrying. You may want to review anonymous
lambda syntax or try comparing these functions directly and
thinking of the backslash as a lambda:
indexanonymous function ! syntax
nonsense ::Bool-&gt;Integer
nonsense True=805
nonsense False=31337
curriedFunction ::Integer
-&gt;Bool
-&gt;Integer
curriedFunction i b=
i+(nonsense b)
uncurriedFunction ::(Integer,Bool)
-&gt;Integer
uncurriedFunction (i, b)=
i+(nonsense b)</p>
<p>CHAPTER 5. TYPES 200
anonymous ::Integer -&gt;Bool-&gt;Integer
anonymous =\i b-&gt;i+(nonsense b)
anonNested ::Integer
-&gt;Bool
-&gt;Integer
anonNested =
\i-&gt;\b-&gt;i+(nonsense b)
Then when we test the functions from the REPL:
Prelude&gt; curriedFunction 10 False
31347
Prelude&gt; anonymous 10 False
31347
Prelude&gt; anonNested 10 False
31347
They are all the same function, all giving the same results.
InanonNested , we manually nested the anonymous lambdas to
get a function that was semantically identical to curriedFunction
but didn’t leverage the automatic currying. This means func-
tions that seemto accept multiple arguments such as with a -&gt;
a -&gt; a -&gt; a arehigher-order functions : they yield more function
values as each argument is applied until there are no more (-&gt;)
type constructors and it terminates in a non-function value.</p>
<p>CHAPTER 5. TYPES 201
Currying and uncurrying existing functions
It turns out, we can curry and uncurry functions with multiple
parameters generically without writing new code for each one.
Consider the following example for currying:
Prelude&gt; let curry f a b = f (a, b)
Prelude&gt; :t curry
curry :: ((t1, t2) -&gt; t) -&gt; t1 -&gt; t2 -&gt; t
Prelude&gt; :t fst
fst :: (a, b) -&gt; a
Prelude&gt; :t curry fst
curry fst :: t -&gt; b -&gt; t
Prelude&gt; fst (1, 2)
1
Prelude&gt; curry fst 1 2
1
Then for uncurrying:
Prelude&gt; let uncurry f (a, b) = f a b
Prelude&gt; :t uncurry
uncurry :: (t1 -&gt; t2 -&gt; t) -&gt; (t1, t2) -&gt; t
Prelude&gt; :t (+)
(+) :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; (+) 1 2
3</p>
<p>CHAPTER 5. TYPES 202
Prelude&gt; uncurry (+) (1, 2)
3
Currying and uncurrying functions of three or more argu-
ments automatically is quite possible, but trickier. We’ll leave
that be, but investigate on your own if you like.
Sectioning
We mentioned sectioning in Chapter 2, and now that we’ve
talked a bit more about currying and partial application, it
may be more clear what’s happening there. The term section-
ingspecifically refers to partial application of infix operators,
which has a special syntax and allows you to choose whether
the argument you’re partially applying the operator to is the
first or second argument:
Prelude&gt; let x = 5
Prelude&gt; let y = (2^)
Prelude&gt; let z = (^2)
Prelude&gt; y x
32
Prelude&gt; z x
25
With commutative functions such as addition, the argu-
ment order does not matter. We will usually section addition</p>
<p>CHAPTER 5. TYPES 203
as, for example, (+3), but when we start using partially applied
functions a lot with maps and folds and so forth, you’ll be able
to see the diﬀerence that the argument order can make with
noncommutative operators.
This does not only work with arithmetic, though:
Prelude&gt; let celebrate = (++ &quot; woot!&quot;)
Prelude&gt; celebrate &quot;naptime&quot;
&quot;naptime woot!&quot;
Prelude&gt; celebrate &quot;dogs&quot;
&quot;dogs woot!&quot;
You can also use the syntax with functions that are normally
prefix if you use the backticks to make them infix (note the
..is a shorthand for constructing a list of all the elements
between the first and last values given — go ahead and play
with this in your REPL):
Prelude&gt; elem 9 [1..10]
True
Prelude&gt; 9 <code>elem</code> [1..10]
True
Prelude&gt; let c = (<code>elem</code> [1..10])
Prelude&gt; c 9
True
Prelude&gt; c 25
False</p>
<p>CHAPTER 5. TYPES 204
If you partially applied elemin its usual prefix form, then
the argument you apply it to would necessarily be the first
argument:
Prelude&gt; let hasTen = elem 10
Prelude&gt; hasTen [1..9]
False
Prelude&gt; hasTen [5..15]
True
Partial application is common enough in Haskell that, over
time, you’ll develop an intuition for it. The sectioning syntax
exists to allow some freedom in which argument of a binary
operator you apply the function to.
Exercises: Type Arguments
Given a function and its type, tell us what type results from
applying some or all of the arguments.
You can check your work in the REPL like this (using the
first question as an example):
Prelude&gt; let f :: a -&gt; a -&gt; a -&gt; a; f = undefined
Prelude&gt; let x :: Char; x = undefined
Prelude&gt; :t f x</p>
<p>CHAPTER 5. TYPES 205
It turns out that you can check the types of things that aren’t
implemented yet, so long as you give GHCi an undefined to
bind the signature to.
1.If the type of fisa -&gt; a -&gt; a -&gt; a , and the type of 𝑥isChar
then the type of f xis
a)Char -&gt; Char -&gt; Char
b)x -&gt; x -&gt; x -&gt; x
c)a -&gt; a -&gt; a
d)a -&gt; a -&gt; a -&gt; Char
2.If the type of gisa -&gt; b -&gt; c -&gt; b , then the type of
g 0 'c' &quot;woot&quot; is
a)String
b)Char -&gt; String
c)Int
d)Char
3.If the type of his(Num a, Num b) =&gt; a -&gt; b -&gt; b , then the
type of
h 1.0 2 is:
a)Double
b)Integer</p>
<p>CHAPTER 5. TYPES 206
c)Integral b =&gt; b
d)Num b =&gt; b
Note that because the type variables 𝑎and𝑏are diﬀerent,
the compiler mustassume that the types could be diﬀerent.
4.If the type of his(Num a, Num b) =&gt; a -&gt; b -&gt; b , then the
type of
h 1 (5.5 :: Double) is
a)Integer
b)Fractional b =&gt; b
c)Double
d)Num b =&gt; b
5.If the type of jackal is(Ord a, Eq b) =&gt; a -&gt; b -&gt; a , then
the type of
jackal &quot;keyboard&quot; &quot;has the word jackal in it&quot;
a)[Char]
b)Eq b =&gt; b
c)b -&gt; [Char]
d)b
e)Eq b =&gt; b -&gt; [Char]</p>
<p>CHAPTER 5. TYPES 207
6.If the type of jackal is(Ord a, Eq b) =&gt; a -&gt; b -&gt; a , then
the type of
jackal &quot;keyboard&quot;
a)b
b)Eq b =&gt; b
c)[Char]
d)b -&gt; [Char]
e)Eq b =&gt; b -&gt; [Char]
7.If the type of kessel is(Ord a, Num b) =&gt; a -&gt; b -&gt; a , then
the type of
kessel 1 2 is
a)Integer
b)Int
c)a
d)(Num a, Ord a) =&gt; a
e)Ord a =&gt; a
f)Num a =&gt; a
8.If the type of kessel is(Ord a, Num b) =&gt; a -&gt; b -&gt; a , then
the type of
kessel 1 (2 :: Integer) is
a)(Num a, Ord a) =&gt; a</p>
<p>CHAPTER 5. TYPES 208
b)Int
c)a
d)Num a =&gt; a
e)Ord a =&gt; a
f)Integer
9.If the type of kessel is(Ord a, Num b) =&gt; a -&gt; b -&gt; a , then
the type of
kessel (1 :: Integer) 2 is
a)Num a =&gt; a
b)Ord a =&gt; a
c)Integer
d)(Num a, Ord a) =&gt; a
e)a
5.5 Polymorphism
Polymorph is a word of relatively recent provenance. It was
invented in the early 19th century from the Greek words poly
for “many” and morph for “form”. The -icsuffix in polymorphic
means “made of.” So, ‘polymorphic’ means “made of many
forms.” In programming, this is understood to be in contrast
withmonomorphic , “made of one form.”</p>
<p>CHAPTER 5. TYPES 209
Polymorphic type variables give us the ability to implement
expressions that can accept arguments and return results of
diﬀerent types without having to write variations on the same
expression for each type. It would be inefficient if you were
doing arithmetic and had to write the same code over and
over for diﬀerent numeric types. The good news is the nu-
merical functions that come with your GHC installation and
thePrelude are polymorphic by default. Broadly speaking,
type signatures may have three kinds of types: concrete, con-
strained polymorphic, or parametrically polymorphic.
In Haskell, polymorphism divides into two categories: para-
metric polymorphism andconstrained polymorphism . If you’ve
encountered polymorphism before, it was probably a form
of constrained, often called ad-hoc, polymorphism. Ad-hoc
polymorphism2in Haskell is implemented with typeclasses.
Parametric polymorphism is broader than ad-hoc polymor-
phism. Parametric polymorphism refers to type variables, or
parameters , that are fully polymorphic. When unconstrained
by a typeclass, their final, concrete type could be anything.
Constrained polymorphism, on the other hand, puts typeclass
constraints on the variable, decreasing the number of concrete
types it could be, but increasing what you can do with it by
defining and bringing into scope a set of operations.
2Wadler’s paper on making Ad-hoc polymorphism less ad-hoc http://people.csail.
mit.edu/dnj/teaching/6898/papers/wadler88.pdf</p>
<p>CHAPTER 5. TYPES 210
Recall that when you see a lowercase name in a type sig-
nature, it is a type variable and polymorphic (like 𝑎,𝑡, etc). If
the type is capitalized, it is a specific, concrete type such as Int,
Bool, etc.
Let’s consider a parametrically polymorphic function: iden-
tity. Theidfunction comes with the Prelude and is called the
identity function because it is the identity for any value in
our language. In the next example, the type variable 𝑎is para-
metrically polymorphic and not constrained by a typeclass.
Passing any value to idwill return the same value:
id::a-&gt;a
This type says: for all 𝑎, get an argument of some type 𝑎
and return a value of the same type 𝑎.
This is the maximally polymorphic signature for id. It
allows this function to work with any type of data:
Prelude&gt; id 1
1
Prelude&gt; id &quot;blah&quot;
&quot;blah&quot;
Prelude&gt; let inc = (+1)
Prelude&gt; inc 2
3
Prelude&gt; (id inc) 2
3</p>
<p>CHAPTER 5. TYPES 211
Based on the type of id, we are guaranteed this behavior —
it cannot do anything else! The 𝑎in the type signature cannot
change because the type variable gets fixed to a concrete type
throughout the entire type signature (a == a). If one applies
idto a value of type Int, the𝑎is fixed to type Int. By default,
type variables are resolved at the left-most part of the type
signature and are fixed once sufficient information to bind
them to a concrete type is available.
The arguments in parametrically polymorphic functions,
likeid, could be anything, any type or typeclass, so the terms
of the function are more restricted because there are no meth-
ods or information attached to them. With the type id :: a
-&gt; a, it can do nothing other than return 𝑎because there is
no information or method attached to its parameter at all —
nothing can be done with𝑎. On the other hand, a function like
negate, with a similar-appearing type signature of Num a =&gt; a
-&gt; aconstrains the 𝑎variable as an instance of the Numtypeclass.
Now𝑎has fewer concrete types it could be, but there is a set of
methods you can use, a set of things that can be done with 𝑎.
If a variable represents a set of possible values, then a type
variable represents a set of possible types. When there is no
typeclass constraint, the set of possible types a variable could
represent is eﬀectively unlimited. Typeclass constraints limit
the set of potential types (and, thus, potential values) while
also passing along the common functions that can be used
with those values.</p>
<p>CHAPTER 5. TYPES 212
Concrete types have even more flexibility in terms of com-
putation. This has to do with the additive nature of typeclasses.
For example, an Intis only an Int, but it can make use of the
methods of the NumandIntegral typeclasses because it has in-
stances of both. We can describe Numas asuperclass of several
other numeric typeclasses that all inherit operations from Num.
In sum, if a variable could be anything , then there’s little
that can be done to it because it has no methods. If it can
besometypes (say, a type that has an instance of Num), then
it has some methods. If it is a concrete type, you lose the
type flexibility but, due to the additive nature of typeclass
inheritance, gain more potential methods. It’s important to
note that this inheritance extends downward from a superclass,
such as Num, to subclasses, such as Integral and then Int, but not
the other way around. That is, if something has an instance
ofNumbut not an instance of Integral , it can’t implement the
methods of the Integral typeclass. A subclass cannot override
the methods of its superclass.
A function is polymorphic when its type signature has vari-
ables that can represent more than one type. That is, its param-
eters are polymorphic. Parametric polymorphism refers to
fully polymorphic (unconstrained by a typeclass) parameters.
Parametricity is the property we get from having parametric
polymorphism. Parametricity means that the behavior of a
function with respect to the types of its (parametrically poly-</p>
<p>CHAPTER 5. TYPES 213
morphic) arguments is uniform. The behavior can notchange
just because it was applied to an argument of a diﬀerent type.
Exercises: Parametricity
All you can do with a parametrically polymorphic value is pass
or not pass it to some other expression. Prove that to yourself
with these small demonstrations.
1.Given the type a -&gt; a, which is the type for id, attempt
to make a function that terminates successfully that does
something other than returning the same value. This is
impossible, but you should try it anyway.
2.We can get a more comfortable appreciation of para-
metricity by looking at a -&gt; a -&gt; a . This hypothetical
function a -&gt; a -&gt; a has two–and only two–implementa-
tions. Write both possible versions of a -&gt; a -&gt; a . After
doing so, try to violate the constraints of parametrically
polymorphic values we outlined above.
3.Implement a -&gt; b -&gt; b . How many implementations can
it have? Does the behavior change when the types of 𝑎
and𝑏change?</p>
<p>CHAPTER 5. TYPES 214
Polymorphic constants
We’ve seen that there are several types of numbers in Haskell
and that there are restrictions on using diﬀerent types of num-
bers in diﬀerent functions. But intuitively we see it would be
odd if we could not do arithmetic along the lines of -10 + 6.3 .
Well, let’s try it:
Prelude&gt; (-10) + 6.3
-3.7
That works just fine. Why? Let’s look at the types and see if
we can find out:
Prelude&gt; :t (-10) + 6.3
(-10) + 6.3 :: Fractional a =&gt; a
Prelude&gt; :t (-10)
(-10) :: Num a =&gt; a
Numeric literals like (-10) and 6.3 are polymorphic and stay
so until given a more specific type. The Num a =&gt; orFractional
a =&gt;is a typeclass constraint and the 𝑎is the type variable
in scope. In the type for the entire equation, we see that the
compiler inferred that it was working with Fractional numbers.
It had to, to accommodate the fractional number 6.3. Fine,
but what about (-10)? We see that the type of (-10) is given
maximum polymorphism by only being an instance of the</p>
<p>CHAPTER 5. TYPES 215
Numtypeclass, which could be any type of number. We call
this a polymorphic constant; (-10) is not a variable, of course,
but the type that it instantiates could be any numeric type, so
its underlying representation is polymorphic. It will have to
resolve into a concrete type at some point in order to evaluate.
We can force the compiler to be more specific about the
types of numbers by declaring the type:
Prelude&gt; let x = 5 + 5
Prelude&gt; :t x
x :: Num a =&gt; a
Prelude&gt; let x = 5 + 5 :: Int
Prelude&gt; :t x
x :: Int
In the first example, we did not specify a type for the num-
bers, so the type signature defaulted to the broadest interpre-
tation, but in the second version, we told the compiler to use
theInttype.
Working around constraints
Previously, we’ve looked at a function called length that takes
a list and counts the number of members and returns that
number as an Intvalue. We saw in the last chapter that because
Intis not a Fractional number, this function won’t work:</p>
<p>CHAPTER 5. TYPES 216
Prelude&gt; 6 / length [1, 2, 3]
No instance for (Fractional Int) arising
from a use of ‘/’
In the expression: 6 / length [1, 2, 3]
In an equation for ‘it’: it = 6 / length [1, 2, 3]
Heretheproblemis length isn’tpolymorphicenough. Fractional
includes several types of numbers, but Intisn’t one of them,
and that’s all length can return. Haskell does oﬀer ways to
work around this type of conflict, though. In this case, we
will use a function called fromIntegral that takes an integral
value and forces it to implement the Numtypeclass, rendering
it polymorphic. Here’s what the type signature looks like:
Prelude&gt; :type fromIntegral
fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b
So, it takes a value, 𝑎, of anIntegral type and returns it as
a value, 𝑏, of any Numtype. Let’s see how that works with our
fractional division problem:
Prelude&gt; 6 / fromIntegral (length [1, 2, 3])
2.0
And now all is right with the world once again.</p>
<p>CHAPTER 5. TYPES 217
5.6 Type inference
Haskell does not obligate us to assert a type for every expres-
sion or value in our programs because it has type inference .
Type inference is an algorithm for determining the types of
expressions. Haskell’s type inference is built on an extended
version of the Damas-Hindley-Milner type system.
Haskell will infer the most generally applicable (polymor-
phic) type that is still correct. Essentially, the compiler starts
from the values whose types it knows and then works out the
types of the other values. As you mature as a Haskell pro-
grammer, you’ll find this is principally useful for when you’re
still figuring out new code rather than for code that is “done”.
Once your program is “done,” you will certainly know the
types of all the functions, and it’s considered good practice
to explicitly declare them. Remember when we suggested
that a good type system was like a pleasant conversation with
a colleague? Think of type inference as a helpful colleague
working through a problem with you.
For example, we can write idourselves:
Prelude&gt; let ourId x = x
Prelude&gt; :t ourId
ourId :: t -&gt; t
Prelude&gt; ourId 1
1</p>
<p>CHAPTER 5. TYPES 218
Prelude&gt; ourId &quot;blah&quot;
&quot;blah&quot;
Here we let GHCi infer the type of ourIditself. Due to alpha
equivalence, the diﬀerence in letters ( 𝑡here versus 𝑎above)
makes no diﬀerence. Type variables have no meaning outside
of the type signatures where they are bound.
For this function, we again ask the compiler to infer the
type:
Prelude&gt; let myGreet x = x ++ &quot; Julie&quot;
Prelude&gt; myGreet &quot;hello&quot;
&quot;hello Julie&quot;
Prelude&gt; :type myGreet
myGreet :: [Char] -&gt; [Char]
The compiler knows the function (++)and has one value to
work with already that it knows is a String. It doesn’t have to
work very hard to infer a type signature from that information.
If, however, we take out the string value and replace it with
another variable, see what happens:
Prelude&gt; let myGreet x y = x ++ y
Prelude&gt; :type myGreet
myGreet :: [a] -&gt; [a] -&gt; [a]
We’re back to a polymorphic type signature, the same sig-
nature for (++)itself, because the compiler has no information</p>
<p>CHAPTER 5. TYPES 219
by which to infer the types for any of those variables (other
than that they are lists of some sort).
Let’s see type inference at work. Open your editor of choice
and enter the following snippet:
-- typeInference1.hs
moduleTypeInference1 where
f::Numa=&gt;a-&gt;a-&gt;a
fx y=x+y+3
Then load the code into GHCi to experiment:
Prelude&gt; :l typeInference1.hs
[1 of 1] Compiling TypeInference1
Ok, modules loaded: TypeInference1.
Prelude&gt; f 1 2
6
Prelude&gt; :t f
f :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; :t f 1
f 1 :: Num a =&gt; a -&gt; a
Because the numeric literals in Haskell have the (typeclass
constrained) polymorphic type Num a =&gt; a , we don’t get a more
specific type when applying 𝑓to 1.</p>
<p>CHAPTER 5. TYPES 220
Look at what happens when we elide the explicit type sig-
nature for 𝑓:
-- typeInference2.hs
moduleTypeInference2 where
fx y=x+y+3
No type signature for 𝑓, so does it compile? Does it work?
Prelude&gt; :l typeInference2.hs
[1 of 1] Compiling TypeInference2
Ok, modules loaded: TypeInference2.
Prelude&gt; :t f
f :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; f 1 2
6
Nothing changes. In certain cases there might be a change,
usually when you are using typeclasses in a way that doesn’t
make it clear which type you mean unless you assert one.
Exercises: Apply Yourself
Look at these pairs of functions. One function is unapplied,
so the compiler will infer maximally polymorphic type. The
second function has been applied to a value, so the inferred</p>
<p>CHAPTER 5. TYPES 221
type signature may have become concrete, or at least less
polymorphic. Figure out how the type would change and why,
make a note of what you think the new inferred type would
be and then check your work in GHCi.
1.-- Type signature of general function
(++)::[a]-&gt;[a]-&gt;[a]
-- How might that change when we apply
-- it to the following value?
myConcat x=x++&quot; yo&quot;
2.-- General function
(*)::Numa=&gt;a-&gt;a-&gt;a
-- Applied to a value
myMultx=(x/3)*5
3.take::Int-&gt;[a]-&gt;[a]
myTakex=take x&quot;hey you&quot;
4.(&gt;)::Orda=&gt;a-&gt;a-&gt;Bool
myComx=x&gt;(length [ 1..10])</p>
<p>CHAPTER 5. TYPES 222
5.(&lt;)::Orda=&gt;a-&gt;a-&gt;Bool
myAlphx=x&lt;'z'
5.7 Asserting types for declarations
Most of the time, we want to declare our types, rather than
relying on type inference. Adding type signatures to your code
can provide guidance to you as you write your functions. It
can also help the compiler give you information about where
your code is going wrong. As programs become longer and
more complex, type signatures become even more important,
as they help you or other programmers trying to use your
code read it and figure out what it’s supposed to do. This
section will look at how to declare types. We will start with
some trivial examples.
You may remember the triple function we’ve seen before.
If we allow the compiler to infer the type, we end up with this:
Prelude&gt; let triple x = x * 3
Prelude&gt; :type triple
triple :: Num a =&gt; a -&gt; a
Here the triple function was made from the (<em>)function
which has type (</em>) :: Num a =&gt; a -&gt; a -&gt; a , but we have al-
ready applied one of the arguments, which is the 3, so there is</p>
<p>CHAPTER 5. TYPES 223
one less parameter in this type signature. It is still polymor-
phic because it can’t tell what type 3 is yet. If, however, we
want to ensure that our inputs and result may only be integers,
this is how we declare that:
Prelude&gt; let triple x = x * 3 :: Integer
Prelude&gt; :t triple
triple :: Integer -&gt; Integer
Note the typeclass constraint is gone because Integer imple-
mentsNum, so that constraint is redundant.
Here’s another example of a type declaration for our triple
function; this one is more like what you would see in a source
file:
-- type declaration
triple::Integer -&gt;Integer
-- function declaration
triplex=x*3
This is how most Haskell code you look at will be laid out,
with separate top-level declarations for types and functions.
Such top-level declarations are in scope throughout the mod-
ule.</p>
<p>CHAPTER 5. TYPES 224
It is possible, though uncommon, to declare types locally
withletandwhere. Here’sanexampleofassigningatypewithin
awhereclause:
triplex=tripleItYo x
wheretripleItYo ::Integer -&gt;Integer
tripleItYo y =y*3
We don’t have to assert the type of triple :
Prelude&gt; :t triple
triple :: Integer -&gt; Integer
The assertion in the whereclause narrowed our type down
fromNum a =&gt; a -&gt; a toInteger -&gt; Integer . GHC will pick up
and propagate type information for inference from appli-
cations of functions, sub-expressions, definitions — almost
anywhere. The type inference is strong with this one.
Thereareconstraints on our ability to declare types. For
example, if we try to make the (+)function return a String , we
get an error message:
Prelude&gt; let x = 5 + 5 :: String
No instance for (Num String) arising from a use of ‘+’
In the expression: 5 + 5 :: String
In an equation for ‘x’: x = 5 + 5 :: String</p>
<p>CHAPTER 5. TYPES 225
This function cannot accept arguments of type String. In
this case, it’s overdetermined, both because the (+)function
is limited to types implementing the Numtypeclass and also
because we’ve already passed it two numeric literals as values.
The numeric literals could be any of several numeric types
under the hood, but they can’t be String because String does
not implement the Numtypeclass.
5.8 Chapter Exercises
Welcome to another round of “Knowing is not enough; we
must apply.”
Multiple choice
1.A value of type [a]is
a)a list of alphabetic characters
b)a list of lists
c)a list whose elements are all of some type 𝑎
d)a list whose elements are all of diﬀerent types
2.A function of type [[a]] -&gt; [a] could
a)take a list of strings as an argument
b)transform a character into a string</p>
<p>CHAPTER 5. TYPES 226
c)transform a string into a list of strings
d)take two arguments
3.A function of type [a] -&gt; Int -&gt; a
a)takes one argument
b)returns one element of type 𝑎from a list
c)must return an Intvalue
d)is completely fictional
4.A function of type (a, b) -&gt; a
a)takes a list argument and returns a Charvalue
b)has zero arguments
c)takes a tuple argument and returns the first value
d)requires that 𝑎and𝑏be of diﬀerent types
Determine the type
For the following functions, determine the type of the spec-
ified value. We suggest you type them into a file and load
the contents of the file in GHCi. In all likelihood, it initially
will not have the polymorphic types you might expect due to
themonomorphism restriction . That means that top-level dec-
larations by default will have a concrete type if any can be
determined. You can fix this by setting up your file like so:</p>
<p>CHAPTER 5. TYPES 227
{-# LANGUAGE NoMonomorphismRestriction #-}
moduleDetermineTheType where
-- simple example
example =1
If you had not included the NoMonomorphismRestriction exten-
sion,example would have had the type Integer instead of Num a
=&gt; a. Do your best to determine the mostpolymorphic type
an expression could have in the following exercises.
1.All function applications return a value. Determine the
value returned by these function applications and the type
of that value.
a)(*9)6
b)head[(0,&quot;doge&quot;),(1,&quot;kitteh&quot; )]
c)head[(0::Integer ,&quot;doge&quot;),(1,&quot;kitteh&quot; )]
d)ifFalsethenTrueelseFalse
e)length[1,2,3,4,5]
f)(length [ 1,2,3,4])&gt;(length &quot;TACOCAT&quot; )
2.Given</p>
<p>CHAPTER 5. TYPES 228
x=5
y=x+5
w=y<em>10
What is the type of w?
3.Given
x=5
y=x+5
zy=y</em>10
What is the type of z?
4.Given
x=5
y=x+5
f=4/y
What is the type of f?
5.Given
x=&quot;Julie&quot;
y=&quot; &lt;3 &quot;
z=&quot;Haskell&quot;
f=x++y++z
What is the type of f?</p>
<p>CHAPTER 5. TYPES 229
Does it compile?
For each set of expressions, figure out which expression, if any,
causes the compiler to squawk at you (n.b. we do not mean
literal squawking) and why. Fix it if you can.
1.bigNum=(^)5$10
wahoo=bigNum$10
2.x=print
y=print&quot;woohoo!&quot;
z=x&quot;hello world&quot;
3.a=(+)
b=5
c=b10
d=c200
4.a=12+b
b=10000*c
Type variable or specific type constructor?
1.You will be shown a type declaration, and you should
categorize each type. The choices are a fully polymorphic
type variable, constrained polymorphic type variable, or
concrete type constructor.</p>
<p>CHAPTER 5. TYPES 230
f::Numa=&gt;a-&gt;b-&gt;Int-&gt;Int
-- [0] [1] [2] [3]
Here, the answer would be: constrained polymorphic
(Num) ([0]), fully polymorphic ([1]), and concrete ([2] and
[3]).
2.Categorize each component of the type signature as de-
scribed in the previous example.
f::zed-&gt;Zed-&gt;Blah
3.Categorize each component of the type signature
f::Enumb=&gt;a-&gt;b-&gt;C
4.Categorize each component of the type signature
f::f-&gt;g-&gt;C
Write a type signature
For the following expressions, please add a type signature. You
should be able to rely on GHCi type inference to check your
work, although you might not have precisely the same answer
as GHCi gives (due to polymorphism, etc).
1.While we haven’t fully explained this syntax yet, you’ve
seen it in Chapter 2 and as a solution to an exercise in</p>
<p>CHAPTER 5. TYPES 231
Chapter 4. This syntax is a way of destructuring a single
element of a list by pattern matching.
functionH ::
functionH (x:_)=x
2.functionC ::
functionC x y=
if(x&gt;y)thenTrueelseFalse
3.functionS ::
functionS (x, y)=y
Given a type, write the function
You will be shown a type and a function that needs to be writ-
ten. Use the information the type provides to determine what
the function should do. We’ll also tell you how many ways
there are to write the function. Syntactically diﬀerent but
semantically equivalent implementations are not counted as
being diﬀerent. For example, writing a function one way then
rewriting the semantically identical function but using anony-
mous lambda syntax does not count as two implementations.
To make things a little easier, we’ll demonstrate how to solve
this kind of exercise. Given:</p>
<p>CHAPTER 5. TYPES 232
myFunc::(x-&gt;y)
-&gt;(y-&gt;z)
-&gt;c
-&gt;(a, x)
-&gt;(a, z)
myFuncxToY yToZ _(a, x)=undefined
Talking through the above, we have a function that takes
four arguments. The final result is a tuple with the type (a,
z). It turns out, the 𝑐argument is nowhere in our results and
there’s nothing to do with it, so we use the underscore to ignore
that. We named the two function arguments by their types
and pattern matched on the tuple argument. The only way to
get the second value of the tuple from the type 𝑥to the type 𝑧
is to use bothof the functions furnished to us. If we tried the
following:
myFuncxToY yToZ _(a, x)=
(a, (xToY x))
We would get a type error that it expected the type 𝑧but
the actual type was 𝑦. That’s because we’re on the right path,
but not quite done yet! Accordingly, the following should
typecheck:</p>
<p>CHAPTER 5. TYPES 233
myFunc::(x-&gt;y)
-&gt;(y-&gt;z)
-&gt;c
-&gt;(a, x)
-&gt;(a, z)
myFuncxToY yToZ _(a, x)=
(a, (yToZ (xToY x)))
1.There is only one function definition that typechecks and
doesn’t go into an infinite loop when you run it.
i::a-&gt;a
i=undefined
2.There is only one version that works.
c::a-&gt;b-&gt;a
c=undefined
3.Given alpha equivalence are c''andc(see above) the same
thing?
c''::b-&gt;a-&gt;b
c''= ?
4.Only one version that works.
c'::a-&gt;b-&gt;b
c'=undefined</p>
<p>CHAPTER 5. TYPES 234
5.There are multiple possibilities, at least two of which
you’ve seen in previous chapters.
r::[a]-&gt;[a]
r=undefined
6.Only one version that will typecheck.
co::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
co=undefined
7.One version will typecheck.
a::(a-&gt;c)-&gt;a-&gt;a
a=undefined
8.One version will typecheck.
a'::(a-&gt;b)-&gt;a-&gt;b
a'=undefined
Fix it
Won’t someone take pity on this poor broken code and fix it
up? Be sure to check carefully for things like capitalization,
parentheses, and indentation.
1.module sing where</p>
<p>CHAPTER 5. TYPES 235
fstString :: [Char] ++ [Char]
fstString x = x ++ &quot; in the rain&quot;
sndString :: [Char] -&gt; Char
sndString x = x ++ &quot; over the rainbow&quot;
sing = if (x &gt; y) then fstString x or sndString y
where x = &quot;Singin&quot;
x = &quot;Somewhere&quot;
2.Now that it’s fixed, make a minor change and make it sing
the other song. If you’re lucky, you’ll end up with both
songs stuck in your head!
3.-- arith3broken.hs
moduleArith3Broken where
main::IO()
Main= do
print1+2
putStrLn 10
print (negate -1)
print (( +)0blah)
whereblah=negate1</p>
<p>CHAPTER 5. TYPES 236
Type-Kwon-Do
The name is courtesy of Phillip Wright.3Thank you for the
idea!
The focus here is on manipulating terms in order to get the
types to fit. This sortof exercise is something you’ll encounter
in writing real Haskell code, so the practice will make it easier
to deal with when you get there. Practicing this will make you
better at writing ordinary code as well.
Weprovidethetypesandbottomedout(declaredas undefined )
terms.Bottom andundefined will be explained in more detail
later. The contents of the terms are irrelevant here. You’ll use
only the declarations provided and what the Prelude provides
by default unless otherwise specified. Your goal is to make the
???’d declaration pass the typechecker by modifying it alone.
Here’s a worked example for how we present these exercises
and how you are expected to solve them. Given the following:
3https://twitter.com/SixBitProxyWax</p>
<p>CHAPTER 5. TYPES 237
dataWoot
dataBlah
f::Woot-&gt;Blah
f=undefined
g::(Blah,Woot)-&gt;(Blah,Blah)
g= ???
Here it’s 𝑔that you’re supposed to implement; however,
you can’t evaluate anything. You’re to only use type-checking
and type-inference to validate your answers. Also note that
we’re using a trick for defining datatypes which can be named
in a type signature, but have no values. Here’s an example of
a valid solution:
g::(Blah,Woot)-&gt;(Blah,Blah)
g(b, w)=(b, f w)
The idea is to only fill in what we’ve marked with ???.
Not all terms will always be used in the intended solution for a
problem.</p>
<p>CHAPTER 5. TYPES 238
1.f::Int-&gt;String
f=undefined
g::String-&gt;Char
g=undefined
h::Int-&gt;Char
h= ???
2.dataA
dataB
dataC
q::A-&gt;B
q=undefined
w::B-&gt;C
w=undefined
e::A-&gt;C
e= ???</p>
<p>CHAPTER 5. TYPES 239
3.dataX
dataY
dataZ
xz::X-&gt;Z
xz=undefined
yz::Y-&gt;Z
yz=undefined
xform::(X,Y)-&gt;(Z,Z)
xform= ???
4.munge::(x-&gt;y)
-&gt;(y-&gt;(w, z))
-&gt;x
-&gt;w
munge= ???
5.9 Definitions
1.Polymorphism refers to type variables which may refer to
more than one concrete type. In Haskell, this will usually
manifest as parametric orad-hoc polymorphism. By hav-
ing a larger set of types, we intersect the commonalities</p>
<p>CHAPTER 5. TYPES 240
of them all to produce a smaller set of correct terms. This
makes it less likely we’ll write an incorrect program and
lets us reuse the code with other types.
2.Type inference is a faculty some programming languages,
most notably Haskell and ML, have to inferprincipal types
from terms without needing explicit type annotations.
There are, in some cases, terms in Haskell which can be
well-typed but which have no principal type. In those
cases, an explicit type annotation must be added.
With respect to Haskell, the principal type is the most
generic type which still typechecks. More generally, Prin-
cipal type is a property of the type system you’re interact-
ing with. Principal typing holds for that type system if a
type can be found for a term in an environment for which
all other types for that term are instances of the principal
type. Here are some examples:</p>
<p>CHAPTER 5. TYPES 241
-- Given the inferred types
a
Numa=&gt;a
Int
-- The principal type here is the
-- parametrically polymorphic 'a'.
-- Given these types
(Orda,Numa)=&gt;a
Integer
-- The principal type is
-- (Ord a, Num a) =&gt; a
3.Type variable is a way to refer to an unspecified type or
set of types in Haskell type signatures. Type variables
ordinarily will be equal to themselves throughout a type
signature. Let us consider some examples.
id::a-&gt;a
-- One type variable 'a' that occurs twice,
-- once as an argument, once as a result.
-- Parametrically polymorphic, could be
-- strictly anything</p>
<p>CHAPTER 5. TYPES 242
(+)::Numa=&gt;a-&gt;a-&gt;a
-- One type variable 'a', constrained
-- to needing an instance of Num. Two
-- arguments, one result.
-- All the same type.
4.Atypeclass is a means of expressing faculties or interfaces
that multiple datatypes may have in common. This en-
ables us to write code exclusively in terms of those com-
monalities without repeating yourself for each instance.
Just as one may sum values of type Int,Integer ,Float,
Double , andRational , we can avoid having diﬀerent (+),(*),
(-),negate , etc. functions for each by unifying them into
a single typeclass. Importantly, these can then be used
withalltypes that have a Numinstance. Thus, a typeclass
provides us a means to write code in terms of those oper-
ators and have our functions be compatible with all types
that have instances of that typeclass, whether they already
exist or are yet to be invented (by you, perhaps).
5.Parametricity is the property that holds in the presence of
parametric polymorphism. Parametricity states that the
behavior of a function will be uniform across all concrete
applications of the function. Parametricity4tells us that</p>
<p>CHAPTER 5. TYPES 243
the function:
id::a-&gt;a
Can be understood to have the same exact behavior for
every type in Haskell without us needing to see how it
was written. It is the same property that tells us:
const::a-&gt;b-&gt;a
constmustreturn the first value — parametricity and the
definition of the type requires it!
f::a-&gt;a-&gt;a
Here,𝑓can only return the first or second value, nothing
else, and it will always return one or the other consistently
without changing. If the function 𝑓made use of (+)or
(*), its type would necessarily be constrained by the type-
class Num and thus be an example of ad-hoc, rather than
parametric, polymorphism.
blahFunc ::b-&gt;String
blahFunc totally ignores its argument and is eﬀectively a
constant value of type String which requires a throw-away
argument for no reason.
4Examples are courtesy of the @parametricity twitter account.
https://twitter.com/parametricity</p>
<p>CHAPTER 5. TYPES 244
convList ::a-&gt;[a]
Unless the result is [], the resulting list has values that are
all the same value. The list will always be the same length.
6.Ad-hoc polymorphism (sometimes called “constrained poly-
morphism”) is polymorphism that applies one or more
typeclass constraints to what would’ve otherwise been a
parametrically polymorphic type variable. Here, rather
than representing a uniformity of behavior across all con-
crete applications, the purpose of ad-hoc polymorphism
istoallowthefunctionstohavediﬀerentbehaviorforeach
instance. This ad-hoc-ness is constrained by the types
in the typeclass that defines the methods and Haskell’s
requirement that typeclass instances be unique for a given
type. For any given combination of typeclass and a type,
such as OrdandBool, there must only exist one unique
instance in scope. This makes it considerably easier to
reason about typeclasses. See the example for a disam-
biguation.</p>
<p>CHAPTER 5. TYPES 245
(+)::Numa=&gt;a-&gt;a-&gt;a
-- the above function is leveraging
-- ad-hoc polymorphism via the
-- Num typeclass
c'::a-&gt;a-&gt;a
-- This function is not,
-- it's parametrically polymorphic in 'a'.
7.Amodule is the unit of organization that the Haskell pro-
gramming language uses to collect together declarations
of values, functions, data types, typeclasses, and typeclass
instances. Any time you use “import” in Haskell, you are
importing declarations from a module . Let us look at an
example from the chapter exercises:
{-# LANGUAGE NoMonomorphismRestriction #-}
moduleDetermineTheType where
-- ^ name of our module
Here we made our Haskell source file have a module and
we named it DetermineTheType . We included a directive to
the compiler to disable the monomorphism restriction</p>
<p>CHAPTER 5. TYPES 246
before we declared the module. Also consider the follow-
ing example using import :
importData.Aeson (encode)
-- ^ the module Data.Aeson
importDatabase.Persist
-- ^ the module Database.Persist
In the above example, we are importing the function
encode declared in the module Data.Aeson along with any
typeclass instances. With the module Database.Persist we
are importing everything it makes available.
5.10 Follow-up resources
1.Luis Damas; Robin Milner. Principal type-schemes for
functional programs
2.Christopher Strachey. Fundamental Concepts in Pro-
gramming Languages
Popular origin of the parametric/ad-hoc polymorphism
distinction.</p>
<p>Chapter 6
Typeclasses
A blank cheque kills
creativity.
Mokokoma Mokhonoana
247</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 248
6.1 Typeclasses
You may have realized that it is very difficult to talk about or
understand Haskell’s type system without also talking about
typeclasses. So far we’ve been focused on the way they interact
with type variables and numeric types, especially. This chapter
explains some important predefined typeclasses, only some
of which have to do with numbers, and provides more detail
about how typeclasses work more generally. In this chapter,
we will
•examine the typeclasses Eq,Num,Ord,Enum, andShow;
•learn about type-defaulting typeclasses and typeclass in-
heritance;
•look at some common but often implicit functions that
create side eﬀects.
6.2 What are typeclasses?
Typeclasses and types in Haskell are, in a sense, opposites.
Where a declaration of a type defines how that type in partic-
ular is created, a declaration of a typeclass defines how a set
of types are consumed or used in computations. This tension
is related to the expression problem which is about defining
code in terms of how data is created or processed. As Philip</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 249
Wadler put it, “The goal is to define a datatype by cases, where
one can add new cases to the datatype and new functions over
the datatype, without recompiling existing code, and while
retaining static type safety (e.g., no casts).”1If you know other
programming languages with a similar concept, it may help to
think of typeclasses as being like interfaces to data that can work
across multiple datatypes. The latter facility is why typeclasses
are a means of ad hoc polymorphism — ad hoc because type-
class code is dispatched by type, something we will explain
later in this chapter. We will continue calling it constrained
polymorphism, though, as we think that term is generally
more clear.
Typeclasses allow us to generalize over a set of types in
order to define and execute a standard set of features for those
types. For example, the ability to test values for equality is
useful, and we’d want to be able to use that function for data
of various types. In fact, we can test any data of a type that
implements the typeclass known as Eqfor equality. We do
not need separate equality functions for each diﬀerent type
of data; as long as our datatype implements, or instantiates,
theEqtypeclass, we can use the standard functions. Similarly,
all the numeric literals and their various types implement a
typeclass called Num, which defines a standard set of operators
that can be used with any type of numbers.
1Philip Wadler, “The Expression Problem” http://homepages.inf.ed.ac.uk/wadler/
papers/expression/expression.txt</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 250
We’ll get into more detail about what it means for a type
to have an “instance” of a typeclass in this chapter, but briefly
stated, it means that there is code that defines how the values
and functions from that typeclass work for that type. When
you use a typeclass method with one of the types that has such
an instance, the compiler looks up the code that dictates how
the function works for that type. We’ll see this more as we
write our own instances.
6.3 Back to Bool
Let’s return briefly to the Booltype to get a feel for what type-
class information looks like. As you may recall, we can use
the GHCi command :infoto query information, including
typeclass information about any function or type (and some
values):
Prelude&gt; :info Bool
data Bool = False | True
instance Bounded Bool
instance Enum Bool
instance Eq Bool
instance Ord Bool
instance Read Bool
instance Show Bool</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 251
The information includes the data declaration for Booland
which typeclasses it already has instances of. It also tells you
where the datatype and its instances are defined for the com-
piler, if you want to look at the source code, but we’ve left that
information out.
Let’s look at that list of instances. Each of these instances
is a typeclass that Boolimplements, and the instances are the
unique specifications of how Boolmakes use of the methods
from that typeclass. In this chapter, we’re only going to exam-
ine a few of these, namely Eq,Ord, andShow. Briefly, however,
they mean the following:
1.instance Bounded Bool –Bounded for types that have an up-
per and lower bound
2.instance Enum Bool –Enumfor things that can be enumer-
ated
3.instance Eq Bool –Eqfor things that can be tested for equal-
ity
4.instance Ord Bool –Ordfor things that can be put into a
sequential order
5.instance Read Bool –Readparses strings into things. Don’t
use it. No seriously, don’t.
6.instance Show Bool –Showrenders things into strings.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 252
Typeclasses have a hierarchy of sorts,2as you might recall
from our discussion of numeric types. All Fractional numbers
implement the Numtypeclass, but not all NumareFractional . All
members of Ordmust be members of Eq, and all members of
Enummust be members of Ord. To be able to put something
in an enumerated list, they must be able to be ordered; to be
able to order something, they must be able to be compared
for equality.
6.4 Eq
In Haskell, equality is implemented with a typeclass called Eq.
Some programming languages bake equality into every object
in the language, but some datatypes do not have a sensible
notion of equality3, so Haskell does not encode equality into
every type. Eqallows us to use standard measures of equality
for quite a few datatypes, though.
Eqis defined this way:
Prelude&gt; :info Eq
class Eq a where
(==) :: a -&gt; a -&gt; Bool
2You can use a search engine like Hoogle at http://haskell.org/hoogle to find informa-
tion on Haskell datatypes and typeclasses. Hoogle is a Haskell API search engine, which
allows you to search many standard Haskell libraries by function name or type signature.
As you become fluent in Haskell types, you will be able to input the type of the function
you want and find the functions that match.
3Most importantly, the function type does not have an Eqinstance for reasons we will
not get into here.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 253
(/=) :: a -&gt; a -&gt; Bool
First, it tells us we have a typeclass called Eqwhere there are
two basic functions, equality and nonequality, and gives their
type signatures. Next it lists the instances of Eq:
-- partial list
instance Eq a =&gt; Eq [a]
instance Eq Ordering
instance Eq Int
instance Eq Float
instance Eq Double
instance Eq Char
instance Eq Bool
instance (Eq a, Eq b) =&gt; Eq (a, b)
instance Eq ()
instance Eq a =&gt; Eq (Maybe a)
instance Eq Integer
We see several numeric types, our old friend Bool,Char(un-
surprising, as we’ve seen that we can compare characters for
equality), and tuples. We know from this that any time we are
using data of these types, we are implementing the Eqtypeclass
and therefore have generic functions we can use to compare
their equality. Any type that has an instance of this typeclass
implements the methods of the typeclass.
Here are some examples using this typeclass:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 254
Prelude&gt; 132 == 132
True
Prelude&gt; 132 /= 132
False
Prelude&gt; (1, 2) == (1, 1)
False
Prelude&gt; (1, 1) == (1, 2)
False
Prelude&gt; &quot;doge&quot; == &quot;doge&quot;
True
Prelude&gt; &quot;doge&quot; == &quot;doggie&quot;
False
The types of (==)and(/=)inEqtell us something important
about these functions:
(==)::Eqa=&gt;a-&gt;a-&gt;Bool
(/=)::Eqa=&gt;a-&gt;a-&gt;Bool
Given these types, we know that they can be used for any
type𝑎which implements the Eqtypeclass. We also know that
both functions will take two arguments of the same type 𝑎and
returnBool. We know they have to be the same because 𝑎must
equal𝑎in the same type signature.
When we apply (==)to a single argument, we can see how
it specializes the arguments:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 255
(==) ::Eqa=&gt;a-&gt;a-&gt;Bool
-- if we specialized (==)
-- for [Char] aka String
(==)
::[Char]-&gt;[Char]-&gt;Bool
(==)&quot;cat&quot;
:: [Char]-&gt;Bool
(==)&quot;cat&quot;&quot;cat&quot;
:: Bool
You can experiment with this further in the REPL to see
how applying types to arguments makes the type variables
more specific.
What happens if the first two arguments 𝑎and𝑎aren’t the
same type?
Prelude F M&gt; (1, 2) == &quot;puppies!&quot;
Couldn't match expected type ‘(t0, t1)’
with actual type ‘[Char]’
In the second argument of ‘(==)’, namely ‘&quot;puppies!&quot;’
In the expression: (1, 2) == &quot;puppies!&quot;
In an equation for ‘it’: it = (1, 2) == &quot;puppies!&quot;
Let’s break down this type error:
Couldn't match expected type ‘(t0, t1)’</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 256
with actual type ‘[Char]’
This error means our [Char] wasn’t the tuple of types 𝑡0and
𝑡1that was expected. (t0, t1) was expected for the second
argument (where we supplied &quot;puppies!&quot; ) because that’s the
type of the first argument. Remember: the type of 𝑎is usually
setbytheleftmostoccurrenceandcan’tchangeinthesignature
Eq a =&gt; a -&gt; a -&gt; Bool .
Applying (==)toInteger will bind the 𝑎type variable to
Integer . This is as if the signature changed to:
EqInteger =&gt;Integer -&gt;Integer -&gt;Bool
The typeclass constraint Eq Integer =&gt; gets dropped because
it’s redundant. We can see the issue more clearly if we look at
the typeclass instances on the 2-tuple (,):
data(,) a b =(,) a b
instance (Eqa,Eqb)=&gt;Eq(a, b)
instance (Orda,Ordb)=&gt;Ord(a, b)
instance (Reada,Readb)=&gt;Read(a, b)
instance (Showa,Showb)=&gt;Show(a, b)
We saw the Eqinstance of (,)getting used earlier when we
tested code like (1, 2) == (1, 2) . Critically, the Eqinstance of
(a, b) relies on the Eqinstances of 𝑎and𝑏. This tells us the
equality of two tuples (a, b) depends on the equality of their
constituent values 𝑎and𝑏. This is why this works:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 257
Prelude&gt; (1, 'a') == (2, 'b')
False
But neither of these will work:
Prelude&gt; (1, 2) == ('a', 'b')
Prelude&gt; (1, 'a') == ('a', 1)
Typeclass deriving Typeclass instances we can magically de-
rive are Eq,Ord,Enum,Bounded ,Read, andShow, though there are
some constraints on deriving some of these. Deriving means
you don’t have to manually write instances of these typeclasses
for each new datatype you create. We’ll address this a bit more
in the chapter on Algebraic Datatypes.
6.5 Writing typeclass instances
We haven’t talked much about writing your own datatypes yet,
or about writing your own typeclass; however, you can and
will do both. In either case, you will sometimes find yourself
needing to write your own typeclass instances. While Eqis one
of the typeclasses you can simply derive, it’s also one of the
least complicated typeclasses to write instances for, so we’re
going to use it here, to demonstrate how to write your own
instances.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 258
Eq instances
As we’ve seen, Eqprovides instances for determining equality
of values, so making an instance of it for a given datatype is
usually straightforward.
You can investigate a typeclass by referring to the Hack-
age documentation for that typeclass. Typeclasses like Eq
come with the core baselibrary that is located at http://hackage.
haskell.org/package/base .Eqspecifically is located at http://
hackage.haskell.org/package/base/docs/Data-Eq.html .
In that documentation, you’ll want to note a particular bit
of wording:
Minimal complete definition: either == or /=.
This tells you what methods you need to define to have
a valid Eqinstance. In this case, either (==)(equal) or (/=)
(unequal) will suffice, as one can be defined as the negation
of the other. Why not only (==)? Although it’s rare, you may
have something clever to do for each case that could make
equality checking faster for a particular datatype, so you’re
allowed to specify both if you want to. We won’t do that here
because (/=)is the negation of (==), and we won’t be working
with any clever datatypes.
First, we’ll work with a tiny, trivial datatype called... Trivial !</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 259
dataTrivial =
Trivial
With no deriving clause hanging oﬀ the butt of this datatype
declaration, we’ll have no typeclass instances of any kind. If we
try to load this up and test equality without adding anything
further, GHC will throw a type error:
Prelude&gt; Trivial == Trivial
No instance for (Eq Trivial) arising
from a use of ‘==’
In the expression: Trivial == Trivial
In an equation for ‘it’: it = Trivial == Trivial
GHC can’t find an instance of Eqfor our datatype Trivial .
We could’ve had GHC generate one for us using deriving Eq
or we could’ve written one, but we did neither, so none exists
and it fails at compile time. In some languages, this sort of
mistake doesn’t become known until your code is already in
the middle of executing.
Unlike other languages, Haskell does not provide universal
stringification ( Show/ print) or equality ( Eq(value equality) or
pointer equality) as this is not always sound or safe, regardless
of what programming language you’re using.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 260
So we must write our own! Fortunately, with Trivial this
is...trivial. Keep your typeclass instances for a type in the same
file as that type (we’ll explain why later):
dataTrivial =
Trivial'
instance EqTrivial where
Trivial' ==Trivial' =True
And that’s it! We wrote an instance that tells the compiler
how to test this datatype for equality. Data constructors and
type constructors often have the same name in Haskell, and
that can get confusing. We used the single quote at the end of
the data constructor here because they don’t have to have the
same name and it might make it easier to follow the examples.
If you load this up, you have only one possible expression
you can construct here:
Prelude&gt; Trivial' == Trivial'
True
Let’s drill down a bit into how this instance stuﬀ works:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 261
instance EqTrivial where
-- [1] [2] [3] [4]
Trivial' ==Trivial' =True
-- [5] [6] [7] [8]
instance EqTrivial where
(==)Trivial' Trivial' =True
-- [ 9 ]
1.The keyword instance here begins a declaration of a type-
classinstance. TypeclassinstancesarehowyoutellHaskell
how equality, stringification ( Show), orderability ( Ord), enu-
meration ( Enum) or other typeclasses should work for a
particular datatype. Without this instance, we can’t test
the values for equality even though the answer will never
vary in the case of this particular datatype.
2.The first name to follow the instance is the typeclass the
instance is providing. Here that is Eq.
3.The type the instance is being provided for. In this case,
we’reimplementingthe Eqtypeclass fortheTrivial datatype.
4.The keyword whereterminates the initial declaration and
beginning of the instance. What follows are the methods
(functions) being implemented.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 262
5.The data constructor (value) Trivial' is the first argument
to the==function we’re providing. Here we’re defining ==
using infix notation so the first argument is to the left.
6.The infix function ==, this is what we’re defining in this
declaration.
7.The second argument, which is the value Trivial' . Since
==is infix here, the second argument is to the right of ==.
8.The result of Trivial' == Trivial' , that is, True.
9.We could’ve written the definition of (==)using prefix no-
tation instead of infix by wrapping the operator in paren-
theses. Note this is being shown as an alterative; you can’t
have two typeclass instances for the same type. Typeclass
instances are unique to a given type. You can try having
both in the same file, but you’ll get an error.
Okay, let’s stretch our legs a bit and try something a bit less
Trivial ! We’ll make our own datatypes — one for the days of
the week and one for the date that makes use of the DayOfWeek
type:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 263
dataDayOfWeek =
Mon|Tue|Weds|Thu|Fri|Sat|Sun
-- day of week and numerical day of month
dataDate=
DateDayOfWeek Int
Since these are not prebaked datatypes in Haskell, they have
no typeclass instances at all. As they stand, there is nothing you
can do with them because no operations are defined for them.
Let’s fix that. The first Eqinstance we’ll write is for DayOfWeek
and is a bit tedious to write out:
instance EqDayOfWeek where
(==)MonMon=True
(==)TueTue=True
(==)WedsWeds=True
(==)ThuThu=True
(==)FriFri=True
(==)SatSat=True
(==)SunSun=True
(==)_ _ = False
Now we’ll write an Eqinstance for our Datetype. This one is
more interesting:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 264
instance EqDatewhere
(==) (Dateweekday dayOfMonth)
(Dateweekday' dayOfMonth') =
weekday ==weekday'
&amp;&amp;dayOfMonth ==dayOfMonth'
In theEqinstance for Date, we didn’t recapitulate how equal-
ity forDayOfWeek andIntvalues worked; we simply said that the
dates were equal if all of their constituent values were equal.
Note, also, that the compiler already expects the arguments
ofDateto be aDayOfWeek value and an Intso we do not need to
specify that. Based on what it knows about those three types,
this is enough information for us to test Datevalues for equality.
Does it work?
Prelude&gt; Date Thu 10 == Date Thu 10
True
Prelude&gt; Date Thu 10 == Date Thu 11
False
Prelude&gt; Date Thu 10 == Date Weds 10
False
It compiles, and it returns what we want after three cursory
checks — ship it!
We’ll point out one other thing about these types:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 265
Prelude&gt; Date Thu 10
<interactive>:26:1:
No instance for (Show Date) arising from a use of ‘print’
In a stmt of an interactive GHCi command: print it
We wrote an Eqinstance, so we can test the values for equal-
ity, but we can’t print them in the REPL because we provided
noShowinstance. If you’d like to fix that, you can stick a deriving
Showclause on the end of each of the datatypes above.
Partial functions — not so strange danger
We’ve mentioned partial application of functions previously,
but the term partial function refers to something diﬀerent. A
partial function is one that doesn’t handle all the possible cases,
so there are possible scenarios in which we haven’t defined
any way for the code to evaluate.
We need to take care to avoid partial functions in general
in Haskell, but this must be especially kept in mind when we
have a type with multiple cases such as DayOfWeek . What if we
had made a mistake in the Eqinstance?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 266
dataDayOfWeek =
Mon|Tue|Weds|Thu|Fri|Sat|Sun
instance EqDayOfWeek where
(==)MonMon=True
(==)TueTue=True
(==)WedsWeds=True
(==)ThuThu=True
(==)FriFri=True
(==)SatSat=True
(==)SunSun=True
What if the arguments are diﬀerent? We forgot our uncon-
ditional case. This will appear to be fine whenever the argu-
ments are the same, but blow up in our faces when they’re
not:
Prelude&gt; Mon == Mon
True
Prelude&gt; Mon == Tue
*** Exception: code/derivingInstances.hs:
(19,3)-(25,23):
Non-exhaustive patterns in function ==
Well, that stinks. We definitely didn’t start learning Haskell
because we wanted stuﬀ to blow up at runtime. So what gives?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 267
The good news is there issomething you can do to get more
help from GHC on this. If we turn all warnings on with the
-Wallflag in our REPL (or in our build configuration), then
GHC will let us know when we’re not handling all cases:
Prelude&gt; :set -Wall
Prelude&gt; :l code/derivingInstances.hs
[1 of 1] Compiling DerivingInstances
code/derivingInstances.hs:19:3: Warning:
Pattern match(es) are non-exhaustive
In an equation for ‘==’:
Patterns not matched:
Mon Tue
Mon Weds
Mon Thu
Mon Fri
...
Ok, modules loaded: DerivingInstances.
You’ll find that if you fix your instance and provide the
fallback case that returns False, it’ll stop squawking about the
non-exhaustive patterns.
Partial functions are not only a concern with typeclass in-
stances, though. We will discuss this more in the next chapter,
but it’s also a concern with any function that doesn’t handle all</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 268
possible inputs, such as this, that blows up anytime the input
isn’t 2:
f::Int-&gt;Bool
f2=True
If you compile or load this, you’ll get another warning (as-
suming you still have -Wallturned on). In this case, because
Intis ahugetype with many values, it’s using notation that says
you’re not handling all inputs that aren’t the number 2:
Pattern match(es) are non-exhaustive
In an equation for ‘f’:
Patterns not matched:
GHC.Types.I# #x with #x <code>notElem</code> [2#]
If you add another case such that you’re handling one more
input, it will add that to the set of values you are handling:
f::Int-&gt;Bool
f1=True
f2=True
Pattern match(es) are non-exhaustive
In an equation for ‘f’:
Patterns not matched:
GHC.Types.I# #x with #x <code>notElem</code> [1#, 2#]</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 269
f::Int-&gt;Bool
f1=True
f2=True
f3=True
Pattern match(es) are non-exhaustive
In an equation for ‘f’:
Patterns not matched:
GHC.Types.I# #x with #x <code>notElem</code> [1#, 2#, 3#]
So on and so forth. The real answer here is to have an
unconditional case that matches everything. The following
will compile without complaint and is not partial:
f::Int-&gt;Bool
f1=True
f2=True
f3=True
f_ =False
Another solution is to use a datatype that isn’t hugelikeInt
if you only have a few cases you want to consider.
-- Seriously. It's huge.
Prelude&gt; minBound :: Int
-9223372036854775808</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 270
Prelude&gt; maxBound :: Int
9223372036854775807
If you want your data to describe only a handful of cases,
write them down in a sum type like the DayOfWeek datatype we
showed you earlier. Don’t use Intas an implicit sum type as C
programmers commonly do.
Sometimes we need to ask for more
When we’re writing an instance of a typeclass such as Eqfor
something with polymorphic parameters, such as Identity
below, we’ll sometimes need to require our argument or argu-
ments to provide some typeclass instances for us in order to
write an instance for the datatype containing them:
dataIdentity a=
Identity a
instance Eq(Identity a)where
(==) (Identity v) (Identity v')=v==v'
What we want to do here is rely on whatever Eqinstances the
argument to Identity (written as 𝑎in the datatype declaration
and𝑣in the instance definition) has already. There is one
problem with this as it stands, though:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 271
No instance for (Eq a) arising from a use of ‘==’
Possible fix: add (Eq a) to the
context of the instance declaration
In the expression: v == v'
In an equation for ‘==’:
(==) (Identity v) (Identity v') = v == v'
In the instance declaration for ‘Eq (Identity a)’
The problem here is that 𝑣and𝑣′are both of type 𝑎but we
don’t know anything about 𝑎. In this case, we can’t assume
it has an Eqinstance. However, we can use the same type-
class constraint syntax we saw with functions, in our instance
declaration:
instance Eqa=&gt;Eq(Identity a)where
(==) (Identity v) (Identity v')=v==v'
Now it’ll work because we know 𝑎has to have an instance of
Eq. Additionally, Haskell will ensure we don’t attempt to check
equality with values that don’t have an Eqinstance at compile
time:
Prelude&gt; Identity NoEqInst == Identity NoEqInst
No instance for (Eq NoEqInst)
arising from a use of ‘==’</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 272
In the expression:
Identity NoEqInst == Identity NoEqInst
In an equation for ‘it’:
it = Identity NoEqInst == Identity NoEqInst
We could ask for more than we need in order to obtain an
answer, such as below where we ask for an Ordinstance for 𝑎,
but there’s no reason to do so since Eqrequires less than Ord
and does enough for what we need here:
instance Orda=&gt;Eq(Identity a)where
(==) (Identity v) (Identity v')=
compare v v' ==EQ
That will compile, but it’s not clear why you’d do it. Maybe
you have your own secret reasons.
Exercises: Eq Instances
Write the Eqinstance for the datatype provided.
1.It’s not a typo, we’re just being cute with the name.
dataTisAnInteger =
TisAnInteger</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 273
2.dataTwoIntegers =
TwoInteger Integer
3.dataStringOrInt =
TisAnInt Int
|TisAString String
4.dataPaira=
Paira a
5.dataTuplea b=
Tuplea b
6.dataWhicha=
ThisOne a
|ThatOne a
7.dataEitherOr a b=
Helloa
|Goodbye b
6.6 Num
We have seen a lot of Numat this point, so we’ll try not to go
on too long about it. It is a typeclass implemented by most
numeric types. As we did with Eqwe will query the information
and examine its set of predefined functions:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 274
classNumawhere
(+)::a-&gt;a-&gt;a
(*)::a-&gt;a-&gt;a
(-)::a-&gt;a-&gt;a
negate::a-&gt;a
abs::a-&gt;a
signum::a-&gt;a
fromInteger ::Integer -&gt;a
And its list of instances (not quite complete):
instance NumInteger
instance NumInt
instance NumFloat
instance NumDouble
We’ve seen most of this information before, in one form
or another: common arithmetic functions with their type
signatures at the top ( fromInteger is similar to fromIntegral but
restricted to Integer rather than all integral numbers) plus a list
of types that implement this typeclass, numeric types we’ve
looked at previously. No surprises here.
Integral
The typeclass called Integral has the following definition:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 275
class(Reala,Enuma)=&gt;Integral awhere
quot::a-&gt;a-&gt;a
rem::a-&gt;a-&gt;a
div::a-&gt;a-&gt;a
mod::a-&gt;a-&gt;a
quotRem ::a-&gt;a-&gt;(a, a)
divMod::a-&gt;a-&gt;(a, a)
toInteger ::a-&gt;Integer
The typeclass constraint (Real a, Enum a) =&gt; means that any
type that implements Integral must already have instances for
RealandEnumtypeclasses. In a very real sense the tuple syntax
here denotes the conjunction of typeclass constraints on your
type variables. An integral type must be both a real number
and enumerable and therefore may employ the methods of
each of those typeclasses. In turn, the Realtypeclass itself re-
quires an instance of Num. So, the Integral typeclass may put
the methods of RealandNuminto eﬀect (in addition to those
ofEnum). Since Realcannot override the methods of Num, this
typeclass inheritance is onlyadditive and the ambiguity prob-
lems caused by multiple inheritance in some programming
languages — the so-called “deadly diamond of death” — are
avoided.
Exercises: Tuple Experiment Look at the types given for
quotRem anddivMod . What do you think those functions do? Test</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 276
your hypotheses by playing with them in the REPL. We’ve
given you a sample to start with below:
Prelude&gt; let ones x = snd (divMod x 10)
Fractional
Numis a superclass of Fractional . TheFractional typeclass is
defined as follows:
class(Numa)=&gt;Fractional awhere
(/) ::a-&gt;a-&gt;a
recip ::a-&gt;a
fromRational ::Rational -&gt;a
This typeclass declaration creates a class named Fractional
which requires its type argument 𝑎to have an instance of Num
in order to create an instance of Fractional . This is another
example of typeclass inheritance. Fractional applies to fewer
numbers than Numdoes, and instances of the Fractional class
can use the functions defined in Num, but not all Numcan use
the functions defined in Fractional because nothing in Num’s
definition requires an instance of Fractional . There is a chart
at the end of the chapter to help you visualize this information.
We can see this with ordinary functions:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 277
First let’s consider this function, intentionally without a
type provided:
divideThenAdd x y=(x/y)+1
We’ll load this with a type that asks only for a Numinstance:
divideThenAdd ::Numa=&gt;a-&gt;a-&gt;a
divideThenAdd x y=(x/y)+1
And you’ll get the type error:
Could not deduce (Fractional a)
arising from a use of ‘/’
from the context (Num a)
bound by the type signature for
divideThenAdd :: Num a =&gt; a -&gt; a -&gt; a
Now if we only cared about having the Numconstraint, we
couldmodifyourfunctiontonotuse (/)whichrequires Fractional :
-- This works fine.
-- (+) and (-) are both provided by Num
subtractThenAdd ::Numa=&gt;a-&gt;a-&gt;a
subtractThenAdd x y=(x-y)+1</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 278
Or we can change the type rather than modifying the func-
tion itself:
-- This works fine.
divideThenAdd ::Fractional a
=&gt;a-&gt;a-&gt;a
divideThenAdd x y=(x/y)+1
Put on your thinking cap Why didn’t we need to make the
type of the function we wrote require both typeclasses? Why
didn’t we have to do this:
f::(Numa,Fractional a)=&gt;a-&gt;a-&gt;a
Consider what it means for something to be a subset of a
larger set of objects.
6.7 Type-defaulting typeclasses
When you have a typeclass-constrained (ad hoc) polymorphic
value and need to evaluate it, the polymorphism must be re-
solved to a specific concrete type. The concrete type must
have an instance for all the required typeclass instances (that
is, if it is required to implement NumandFractional then the
concrete type can’t be an Int). Ordinarily the concrete type</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 279
would come from the type signature you’ve specified or from
type inference, such as when a Num a =&gt; a is used in an expres-
sion that expects an Integer which forces the polymorphic
number value to concretize as an Integer . But in some cases,
particularly when you’re working in the GHCi REPL, you will
not have specified a concrete type for a polymorphic value. In
those situations, the typeclass will default to a concrete type,
and the default types are already set in the libraries.
When we do this in the REPL:
Prelude&gt; 1 / 2
0.5
Our result 0.5appears the way it does because it defaults to
Double . Using the type assignment operator ::we can assign a
more specific type and circumvent the default to Double :
Prelude&gt; 1 / 2 :: Float
0.5
Prelude&gt; 1 / 2 :: Double
0.5
Prelude&gt; 1 / 2 :: Rational
1 % 2
The Haskell Report4specifies the following defaults relevant
to numerical computations:
4The Haskell Report is the standard that specifies the language and standard libraries</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 280
default Num Integer
default Real Integer
default Enum Integer
default Integral Integer
default Fractional Double
default RealFrac Double
default Floating Double
default RealFloat Double
Num,Real, etc., are typeclasses, and Integer andDouble are
the types they default to. This type defaulting for Fractional
means that:
(/)::Fractional a=&gt;a-&gt;a-&gt;a
changes to
(/)::Double-&gt;Double-&gt;Double
if you don’t specify the concrete type desired for (/). A
similar example but for Integral would be
div::Integral a=&gt;a-&gt;a-&gt;a
defaulting to
div::Integer -&gt;Integer -&gt;Integer
for Haskell. The most recent version is Haskell Report 2010, which can be found at
https://www.haskell.org/onlinereport/haskell2010/ .</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 281
The typeclass constraint is superfluous when the types are
concrete. On the other hand, you must specify which type-
classes you want type variables to have implemented. The use
of polymorphic values without the ability to infer a specific
type and no default rule will cause GHC to complain about an
ambiguous type.
The following will work because all the types below imple-
ment the Numtypeclass:
Prelude&gt; let x = 5 + 5 :: Int
Prelude&gt; x
10
Prelude&gt; let x = 5 + 5 :: Integer
Prelude&gt; x
10
Prelude&gt; let x = 5 + 5 :: Float
Prelude&gt; x
10.0
Prelude&gt; let x = 5 + 5 :: Double
Prelude&gt; x
10.0
Now we can make this type more specific, and the process</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 282
will be similar. In this case, let’s use Integer which implements
Num:
let x = 10 :: Integer
let y = 5 :: Integer
-- These are the declared types for these
-- functions, because they're from Num.
(+) :: Num a =&gt; a -&gt; a -&gt; a
(*) :: Num a =&gt; a -&gt; a -&gt; a
(-) :: Num a =&gt; a -&gt; a -&gt; a
Now any functions from Numare going to automatically get
specialized to Integer when we apply them to the 𝑥or𝑦values:
Prelude&gt; :t (x+)
(x+) :: Integer -&gt; Integer
-- For
(+) :: Num a =&gt; a -&gt; a -&gt; a
-- When 'a' is Integer
(+) :: Integer -&gt; Integer -&gt; Integer
-- Apply the first argument
(x+) :: Integer -&gt; Integer
-- Applying the second and last argument
(x+y) :: Integer</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 283
-- Final result was Integer.
We can declare more specific (monomorphic) functions
from more general (polymorphic) functions:
let add = (+) :: Integer -&gt; Integer -&gt; Integer
We cannot go in the other direction, because we lost the
generality of Numwhen we specialized to Integer :
Prelude&gt; :t id
id :: a -&gt; a
Prelude&gt; let numId = id :: Num a =&gt; a -&gt; a
Prelude&gt; let intId = numId :: Integer -&gt; Integer
Prelude&gt; let altNumId = intId :: Num a =&gt; a -&gt; a
Could not deduce (a1 ~ Integer)
from the context (Num a)
bound by the inferred type of
altNumId :: Num a =&gt; a -&gt; a
or from (Num a1)
bound by an expression type signature:
Num a1 =&gt; a1 -&gt; a1
‘a1’ is a rigid type variable bound by
an expression type signature:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 284
Num a1 =&gt; a1 -&gt; a1
Expected type: a1 -&gt; a1
Actual type: Integer -&gt; Integer
In the expression: intId :: Num a =&gt; a -&gt; a
In an equation for ‘altNumId’:
altNumId = intId :: Num a =&gt; a -&gt; a
Theexpectedtype and the actualtype don’t match. Remember,
the actual type is the type we provided; the expected type
is what the compiler expects. Here, the actual type is more
concrete than the expected type. Types can be made more
specific, but not more general or polymorphic.
6.8 Ord
Next we’ll take a look at a typeclass called Ord. We’ve previously
noted that this typeclass covers the types of things that can be
put in order. If you use :infoforOrdin your REPL, you will
find a very large number of instances for this typeclass. We’re
going to pare it down a bit and focus on the essentials, but, as
always, we encourage you to explore this further on your own:
Prelude&gt; :info Ord</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 285
class Eq a =&gt; Ord a where
compare :: a -&gt; a -&gt; Ordering
(&lt;) :: a -&gt; a -&gt; Bool
(&gt;=) :: a -&gt; a -&gt; Bool
(&gt;) :: a -&gt; a -&gt; Bool
(&lt;=) :: a -&gt; a -&gt; Bool
max :: a -&gt; a -&gt; a
min :: a -&gt; a -&gt; a
instance Ord a =&gt; Ord (Maybe a)
instance (Ord a, Ord b) =&gt; Ord (Either a b)
instance Ord Integer
instance Ord a =&gt; Ord [a]
instance Ord Ordering
instance Ord Int
instance Ord Float
instance Ord Double
instance Ord Char
instance Ord Bool
Notably, at the top, we have another typeclass constraint.
Ordis constrained by Eqbecause if you’re going to compare
items in a list and put them in order, you need a way to de-
termine if they are equal. So, Ordrequires Eqand its methods.
The functions that come standard in this class have to do with
ordering. Some of them will give you a result of Bool, and</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 286
we’ve played a bit with those functions. Let’s see what a few
others do:
Prelude&gt; compare 7 8
LT
Prelude&gt; compare 4 (-4)
GT
Prelude&gt; compare 4 4
EQ
Prelude&gt; compare &quot;Julie&quot; &quot;Chris&quot;
GT
Prelude&gt; compare True False
GT
Prelude&gt; compare True True
EQ
Thecompare function works for any of the types listed above
that implement the Ordtypeclass, including Bool, but unlike
the&lt;, &gt;, &gt;= and&lt;=operators, this returns an Ordering value
instead of a Boolvalue.
You may notice that Trueis greater than False. Proximally
this is due to how the Booldatatype is defined: False | True .
There may be a more interesting underlying reason if you
prefer to ponder the philosophical implications.
Themaxandminfunctions work in a similarly straightfor-
ward fashion for any type that implements this typeclass:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 287
Prelude&gt; max 7 8
8
Prelude&gt; min 10 (-10)
-10
Prelude&gt; max (3, 4) (2, 3)
(3,4)
Prelude&gt; min [2, 3, 4, 5] [3, 4, 5, 6]
[2,3,4,5]
Prelude&gt; max &quot;Julie&quot; &quot;Chris&quot;
&quot;Julie&quot;
By looking at the type signature, we can see that these func-
tions have two parameters. If you want to use these to deter-
mine the maximum or minimum of three values, you can nest
them:
Prelude&gt; max 7 (max 8 9)
9
If you try to give it too few arguments, you will get this
strange-seeming message:
Prelude&gt; max &quot;Julie&quot;
No instance for (Show ([Char] -&gt; [Char]))
-- [1] [2] [ 3 ]
arising from a use of ‘print’</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 288
-- [4]
In a stmt of an interactive GHCi command: print it
-- [ 5 ]
1.Haskell couldn’t find an instance of a typeclass for a value
of a given type.
2.The typeclass it couldn’t find an instance for was Show, the
typeclass that allows GHCi to print values in your terminal.
More on this in the following sections.
3.It couldn’t find an instance of Showfor the type String -&gt;
String . Nothing with type (-&gt;)should have a Showinstance
as a general rule because (-&gt;)denotes a function rather
than a constant value.
4.We wanted an instance of Showbecause we (indirectly)
invoked printwhich has type print :: Show a =&gt; a -&gt; IO
()— note the constraint for Show.
5.The interactive GHCi command print it invoked print
on our behalf.
Any time we ask GHCi to print a return value in our ter-
minal, we are indirectly invoking print, which has the type
Show a =&gt; a -&gt; IO () . The first argument to printmust have an
instance of Show. The error message is because maxapplied to</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 289
a single String argument needs another argument before it’ll
return a String (aka[Char] ) value that is Show-able or printable.
Until we apply it to a second argument, it’s still a function,
and a function has no instance of Show. The request to print
a function, rather than a constant value, results in this error
message.
Ord instances
We’ll see more examples of writing instances as we proceed
in the book and explain more thoroughly how to write your
own datatypes. We wrote some Eqinstances earlier. Now we’ll
practice our instance-writing skills (this is one of the most
necessary skills in Haskell) by writing Ordinstances.
When you derive Ordinstances for a datatype, they rely on
the way the datatype is defined, but if you write your own
instance, you can define the behavior you want. We’ll use the
days of the week again to demonstrate:
dataDayOfWeek =
Mon|Tue|Weds|Thu|Fri|Sat|Sun
deriving (Ord,Show)
We only derived OrdandShowthere because you should still
have the Eqinstance we wrote for this datatype in scope. If you
don’t, you have two options: bring it back into scope by putting
it into the file you’re currently using, or derive an Eqinstance</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 290
for the datatype now by adding it inside the parentheses. You
can’t have an Ordinstance unless you also have an Eqinstance,
so the compiler will complain if you don’t do one (not both)
of those two things.
Values to the left are less than values to the right, as if they
were placed on a number line:
Prelude&gt; Mon &gt; Tue
False
Prelude&gt; Sun &gt; Mon
True
Prelude&gt; compare Tue Weds
LT
But if we wanted to express that Friday is always the best
day, we can write our own Ordinstance to express that:
dataDayOfWeek =
Mon|Tue|Weds|Thu|Fri|Sat|Sun
deriving (Eq,Show)
instance OrdDayOfWeek where
compare FriFri=EQ
compare Fri_ =GT
compare _Fri=LT
compare _ _ = EQ</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 291
Now, if we compare Friday to any other day, Friday is always
greater. All other days, you notice, are equal in value:
Prelude&gt; compare Fri Sat
GT
Prelude&gt; compare Sat Mon
EQ
Prelude&gt; compare Fri Mon
GT
Prelude&gt; compare Sat Fri
LT
Prelude&gt; Mon &gt; Fri
False
Prelude&gt; Fri &gt; Sat
True
But we did derive an Eqinstance above, so we do get the
expected equality behavior:
Prelude&gt; Sat == Mon
False
Prelude&gt; Fri == Fri
True
A few things to keep in mind about writing Ordinstances:
First, it is wise to ensure that your Ordinstances agree with your
Eqinstances, whether the Eqinstances are derived or manually</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 292
written. If x == y , thencompare x y should return EQ. Also, you
want your Ordinstances to define a sensible total order. You
ensure this in part by covering all cases and not writing partial
instances, as we noted above with Eq. In general, your Ord
instance should be written such that, when compare x y returns
LT, thencompare y x returns GT.
Ord implies Eq
The following isn’t going to typecheck for reasons we already
covered:
check'::a-&gt;a-&gt;Bool
check'a a'=a==a'
The error we get mentions that we need Eq, which makes
sense!
No instance for (Eq a) arising from a use of ‘==’
Possible fix:
add (Eq a) to the context of
the type signature for check' :: a -&gt; a -&gt; Bool
In the expression: a == a'
In an equation for ‘check'’: check' a a' = a == a'
But what if we add Ordinstead of Eqas it asks?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 293
check'::Orda=&gt;a-&gt;a-&gt;Bool
check'a a'=a==a'
It should compile. Now, Ordisn’t what GHC asked for, so
why did it work? It worked because anything that provides an
instance of Ordmustby definition also already have an instance
ofEq. How do we know? As we said above, logically it makes
sense that you can’t order things without the ability to check
for equality, but we can also check :info Ord in GHCi:
Prelude&gt; :info Ord
class Eq a =&gt; Ord a where
... buncha noise we don't care about...
The class definition of Ordsays that any 𝑎which wants to
define an Ordinstance must already provide an Eqinstance. We
can say that Eqis asuperclass ofOrd.
Usually, you want the minimally sufficient set of constraints
on all your functions — so we would use Eqinstead of Ordif the
above example was “real” code — but we did this so you could
get an idea of how constraints and superclassing in Haskell
work.
Exercises: Will They Work?
Next, take a look at the following code examples and try to
decide if they will work, what result they will return if they do,</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 294
and why or why not (be sure, as always, to test them in your
REPL once you have decided on your answer):
1.max(length [ 1,2,3])
(length [ 8,9,10,11,12])
2.compare (3<em>4) (3</em>5)
3.compare &quot;Julie&quot; True
4.(5+3)&gt;(3+6)
6.9 Enum
A typeclass known as Enumthat we have mentioned previously
seems similar to Ordbut is slightly diﬀerent. This typeclass
covers types that are enumerable, therefore have known pre-
decessors and successors. We shall try not to belabor the point,
because you are probably developing a good idea of how to
query and make use of typeclass information:
Prelude&gt; :info Enum
class Enum a where
succ :: a -&gt; a
pred :: a -&gt; a
toEnum :: Int -&gt; a
fromEnum :: a -&gt; Int</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 295
enumFrom :: a -&gt; [a]
enumFromThen :: a -&gt; a -&gt; [a]
enumFromTo :: a -&gt; a -&gt; [a]
enumFromThenTo :: a -&gt; a -&gt; a -&gt; [a]
instance Enum Ordering
instance Enum Integer
instance Enum Int
instance Enum Char
instance Enum Bool
instance Enum ()
instance Enum Float
instance Enum Double
Numbers and characters are known to have predictable
successors and predecessors, so these are paradigmatic cases
of enumerability:
Prelude&gt; succ 4
5
Prelude&gt; pred 'd'
'c'
Prelude&gt; succ 4.5
5.5
You can also see that some of these functions return a result
of a list type. They take a starting value and build a list with</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 296
the succeeding items of the same type:
Prelude&gt; enumFromTo 3 8
[3,4,5,6,7,8]
Prelude&gt; enumFromTo 'a' 'f'
&quot;abcdef&quot;
Finally, let’s take a short look at enumFromThenTo :
Prelude&gt; enumFromThenTo 1 10 100
[1,10,19,28,37,46,55,64,73,82,91,100]
Take a look at the resulting list and see if you can find the
pattern: what does this function do? What happens if we give
it the values 0 10 100 instead? How about 'a' 'c' 'z' ?
6.10 Show
Showis a typeclass that provides for the creating of human-
readable string representations of structured data. GHCi uses
Showto create String values it can print in the terminal.
Showis not a serialization format. Serialization is how data
is rendered to a textual or binary format for persistence or
communicating with other computers over a network. An
example of persistence would be saving data to a file on disk.
Showis not suitable for any of these purposes; it’s expressly for
human readability.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 297
The typeclass information looks like this (truncated):
classShowawhere
showsPrec ::Int-&gt;a-&gt;ShowS
show::a-&gt;String
showList ::[a]-&gt;ShowS
instance Showa=&gt;Show[a]
instance ShowOrdering
instance Showa=&gt;Show(Maybea)
instance ShowInteger
instance ShowInt
instance ShowChar
instance ShowBool
instance Show()
instance ShowFloat
instance ShowDouble
Importantly, we see that various number types, Boolvalues,
tuples, and characters are all already instances of Show. That is,
they have a defined ability to be printed to the screen. There is
also a function showwhich takes a polymorphic 𝑎and returns
it as aString , allowing it to be printed.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 298
Printing and side eﬀects
When you ask GHCi to return the result of an expression and
print it to the screen, you are indirectly invoking a function
calledprintthat we encountered briefly in the chapter about
printing and again in the section about Ordand the error mes-
sage that results from passing the maxfunction too few argu-
ments. As understanding printis important to understanding
this typeclass, we’re going to digress a bit and talk about it in
more detail.
Haskell is a pure functional programming language. The
functional part of that comes from the fact that programs are
written as functions, similar to mathematical equations, in
which an operation is applied to some arguments to produce
a result. The purepart of our description of Haskell means
expressions in Haskell can be expressed exclusively in terms
of a lambda calculus.
It may not seem obvious that printing results to the screen
could be a source of worry. The function is not just applied
to the arguments that are in its scope but also asked to aﬀect
the world outside its scope in some way, namely by showing
you its result on a screen. This is known as a side eﬀect , a po-
tentially observable result apart from the value the expression
evaluates to. Haskell manages eﬀects by separating eﬀectful
computations from pure computations in ways that preserve
the predictability and safety of function evaluation. Impor-</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 299
tantly, eﬀect-bearing computations themselves become more
composable and easier to reason about. The benefits of ex-
plicit eﬀects include the fact that it makes it relatively easy to
reason about and predict the results of our functions.
What sets Haskell apart from most other functional pro-
gramming languages is that it introduced and refined a means
of writing ordinary programs that talk to the outside world
without adding anything to the pure lambda calculus it is
founded on. This property — being lambda calculus and
nothing more — is what makes Haskell a purely functional
programming language.
TheprintfunctionissometimesinvokedindirectlybyGHCi,
but its type explicitly reveals that it is eﬀectful. Up to now,
we’ve been covering over how this works, but it’s time to dive
a bit deeper.
printis defined in the Prelude standard as a function to out-
put “a value of any printable type to the standard output device.
Printable types are those that are instances of class Show; print
converts values to strings for output using the show operation
and adds a newline.” Let’s look at the type of print:
Prelude&gt; :t print
print :: Show a =&gt; a -&gt; IO ()
As we see, printtakes an argument 𝑎that must be a type with
an instance of the Showtypeclass and returns an IO ()result.
This result is an IOaction that returns a value of the type ().</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 300
We saw this IO ()result previously when we talked about
printing strings. We also noted that it is the obligatory type
ofmainin a source code file. This is because running mainonly
produces side eﬀects. indexmain@ main
Statedassimplyaspossible, anI/O(input/output, frequently
written ‘IO’ without a slash; when referring to the Haskell
datatype, there is no slash) action is an action that, when per-
formed, has side eﬀects, including reading from input and
printing to the screen and will contain a return value. The
()denotes an empty tuple, which we refer to as unit. Unit
is a value, and also a type that has only this one inhabitant,
that essentially represents nothing. Printing a string to the
terminal doesn’t have a meaningful return value. But an IO
action, like any expression in Haskell, can’t return nothing ; it
must return something. So we use this empty tuple to rep-
resent the return value at the end of our I/O action. That is,
theprintfunction will first do the I/O action of printing the
string to the terminal and then complete the action, marking
an end to the execution of the function and a delimitation of
the side eﬀects, by returning this empty nothing tuple. It does
not print the empty tuple to the screen, but it is implicitly
there. The simplest way to think about the diﬀerence between
a value with a typical type like String and the same type but
fromIOsuch as with IO String is thatIOactions are formulas.
When you have a value of type IO String it’s more of a meansof
producing aString , which may require performing side eﬀects</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 301
along the way before you get your String value.
This is a String value:
myVal::String
This value is a method or means of obtaining a value, by
performing eﬀects or I/O, of type String :
ioString ::IOString
AnIOactionisperformedwhenwecall mainforourprogram,
as we have seen. But we also perform an IOaction when we
invokeprintimplicitly or explicitly. indexmain@ main
Working with Show
Up to now, we have only been deriving typeclass instances
forShowbecause deriving usually gives us the result we want
without a lot of fuss. Having a Showinstance is crucial to being
able to print anything to the terminal, so we’re going to look at
some examples of why Showis important and how it is imple-
mented. Invoking the Showtypeclass also invokes its methods,
specifically a method of taking your values and turning them
into values that can be printed to the screen.
A minimal implementation of an instance of Showonly re-
quires that showorshowsPrec be implemented, as in the follow-
ing example:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 302
dataMood=Blah
instance ShowMoodwhere
show_ =&quot;Blah&quot;
Prelude&gt; Blah
Blah
Here’s what happens in GHCi when you define a datatype
and ask GHCi to show it without the instance for the Show
typeclass:
Prelude&gt; data Mood = Blah
Prelude&gt; Blah
No instance for (Show Mood) arising
from a use of ‘print’
In a stmt of an interactive GHCi command: print it
Next let’s look at how you define a datatype to have an in-
stance of Show. We can derive the Showinstance for Moodbecause
it’s one of the typeclasses GHC supports deriving instances for
by default:
Prelude&gt; data Mood = Blah deriving Show
Prelude&gt; Blah
Blah</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 303
And, in fact, most of the time that’s what you’ll do for your
own datatypes. In the chapter on building projects, we will
need to write a custom instance for Show, though, so that should
give you something exciting to look forward to.
6.11 Read
TheReadtypeclass...well, it’s... there. You’ll notice that, like Show,
a lot of types have instances of Read. This typeclass is essentially
the opposite of Show. Where Showtakes things and turns them
into human-readable strings, Readtakes strings and turns them
into things. Like Show, it’s not a serialization format. So, what’s
the problem? We gave that dire warning against using Read
earlier in the chapter, but this doesn’t seem like a big deal,
right?
The problem is in the String type. A String is a list, which
could be empty in some cases, or stretch on to infinity in other
cases.
We can begin to understand this by examining the types:
Prelude&gt; :t read
read :: Read a =&gt; String -&gt; a
There’s no way Read a =&gt; String -&gt; a will always work. Let’s
consider a type like Integer which has a Readinstance. We are in
no way guaranteed that the String will be a valid representation</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 304
of anInteger value. A String value can be anytext. That’s way
too big of a type for things we want to parse into numbers!
We can prove this for ourselves in the REPL:
Prelude&gt; read &quot;1234567&quot; :: Integer
1234567
Prelude&gt; read &quot;BLAH&quot; :: Integer
*** Exception: Prelude.read: no parse
That exception is a runtime error and means that readis a
partial function , a function that doesn’t return a proper value
as a result for all possible inputs. We have ways of cleaning
this up we’ll explain and demonstrate later. We should strive
to avoid writing or using such functions in Haskell because
Haskell gives us the tools necessary to avoid senseless sources
of errors in our code.
6.12 Instances are dispatched by type
We’ve said a few times, without explaining it, that typeclasses
are dispatched by type, but it’s an important thing to under-
stand. Typeclasses are defined by the set of operations and
values all instances will provide. Typeclass instances are unique
pairings of the typeclass and a type. They define the ways to
implement the typeclass methods for that type.
We’re going to walk through some code to illustrate what
this all means. The first thing you will see is that we’ve written</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 305
our own typeclass and instances for demonstration purposes.
Those details aren’t important for understanding this code.
Just remember:
•a typeclass defines a set of functions and/or values;
•types have instances of that typeclass;
•the instances specify the ways that type uses the functions
of the typeclass.
This is vacuous and silly. This is only to make a point. Please
do not write typeclasses like this:
classNumberish awhere
fromNumber ::Integer -&gt;a
toNumber ::a-&gt;Integer
-- pretend newtype is data for now
newtype Age=
AgeInteger
deriving (Eq,Show)
instance Numberish Agewhere
fromNumber n =Agen
toNumber ( Agen)=n</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 306
newtype Year=
YearInteger
deriving (Eq,Show)
instance Numberish Yearwhere
fromNumber n =Yearn
toNumber ( Yearn)=n
Then suppose we write a function using this typeclass and
the two types and instances:
sumNumberish ::Numberish a=&gt;a-&gt;a-&gt;a
sumNumberish a a'=fromNumber summed
whereintegerOfA =toNumber a
integerOfAPrime =toNumber a'
summed=
integerOfA +integerOfAPrime
Now let us think about this for a moment. The class def-
inition of Numberish doesn’t define any termsor code we can
compile and execute, only types. The code lives in the in-
stances for AgeandYear. So how does Haskell know where to
find code?
Prelude&gt; sumNumberish (Age 10) (Age 10)
Age 20</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 307
In the above, it knew to use the instance of Numberish forAge
because it could see that our arguments to sumNumberish were
of type Age. We can see this with the type inference, too:
Prelude&gt; :t sumNumberish
sumNumberish :: Numberish a =&gt; a -&gt; a -&gt; a
Prelude&gt; :t sumNumberish (Age 10)
sumNumberish (Age 10) :: Age -&gt; Age
After the first parameter is applied to a value of type Age, it
knows that all other occurrences of type Numberish a =&gt; a must
beAge.
To see a case where we’re notproviding enough information
to Haskell for it to identify a concrete type with which to get
the appropriate instance, we’re going to change our typeclass
and associated instances:
(This is even worse than the last one. Don’t use typeclasses
to define default values. Seriously. Haskell ninjas will find you
and replace your toothpaste with muddy chalk.)
classNumberish awhere
fromNumber ::Integer -&gt;a
toNumber ::a-&gt;Integer
defaultNumber ::a</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 308
instance Numberish Agewhere
fromNumber n =Agen
toNumber ( Agen)=n
defaultNumber =Age65
instance Numberish Yearwhere
fromNumber n =Yearn
toNumber ( Yearn)=n
defaultNumber =Year1988
Then in the REPL, we can see that in some cases, there’s no
way for Haskell to know what we want!
Prelude&gt; defaultNumber
No instance for (Show a0) arising
from a use of ‘print’
The type variable ‘a0’ is ambiguous
Note: there are several potential instances:
instance Show a =&gt; Show (Maybe a)
instance Show Ordering
instance Show Integer
...plus 24 others
This fails because it has no idea what type defaultNumber is
other than that it’s provided for by Numberish ’s instances. But</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 309
the good news is, even if it’s a value and doesn’t take any argu-
ments, we have a means of telling Haskell what we want:
Prelude&gt; defaultNumber :: Age
Age 65
Prelude&gt; defaultNumber :: Year
Year 1988
Just assign the type you expect and it works fine! Here,
Haskell is using the type assertion to dispatch , or specify, what
typeclass instance we want to get our defaultNumber from.
Why not write a typeclass like this? For reasons we’ll explain
when we talk about Monoid , it’s important that your typeclasses
have laws and rules about how they work. Numberish is a bit...
arbitrary. There are better ways to express what it does in
Haskell than a typeclass. Functions and values alone suffice
here.
6.13 Gimme more operations
We talked about the diﬀerent kinds of polymorphism in type
signatures — constrained versus parametric. Having no con-
straint on our term-level values means they could be any type,
but there isn’t much we can do with them. The methods and
operations are in the typeclasses, and so we get more utility</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 310
by specifying typeclass constraints. If your types are more
general than your terms are, then you need to constrain your
types with the typeclasses that provide the operations you
want to use. We looked at some examples of this in the sec-
tions above about Integral andFractional , but in this section,
we’ll be more specific about how to modify type signatures to
fit the terms.
We’ll start by looking at some examples of times when we
need to change our types because they’re more general than
our terms allow:
add::a-&gt;a-&gt;a
addx y=x+y
If you load it up, you’ll get the following error:
No instance for (Num a) arising from a use of ‘+’
Possible fix:
add (Num a) to the context of
the type signature for add :: a -&gt; a -&gt; a
Fortunately, this is one of those cases where GHC knows
precisely what the problem is and how to remedy it. We need
to add a Numconstraint to the type 𝑎. But why? Because our
function can’t accept a value of strictly anytype. We need
something that has an instance of Numbecause the (+)function
comes from Num:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 311
add::Numa=&gt;a-&gt;a-&gt;a
addx y=x+y
With the constraint added to the type, it works fine! What
if we use a method from another operation?
addWeird ::Numa=&gt;a-&gt;a-&gt;a
addWeird x y=
ifx&gt;1
thenx+y
elsex
We get another error, but once again GHC helps us out, so
long as we resist the pull of tunnel vision5and look at what it’s
telling us:
Could not deduce (Ord a) arising from a use of ‘&gt;’
from the context (Num a)
bound by the type signature for
addWeird :: Num a =&gt; a -&gt; a -&gt; a
Possible fix:
add (Ord a) to the context of
the type signature for
addWeird :: Num a =&gt; a -&gt; a -&gt; a
5All programmers experience this. Just slow down and you’ll be okay.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 312
The problem is that having a Numconstraint on our type 𝑎
isn’t enough. Numdoesn’t imply Ord. Given that, we have to add
another constraint which is what GHC told us to do:
addWeird ::(Orda,Numa)=&gt;a-&gt;a-&gt;a
addWeird x y=
ifx&gt;1
thenx+y
elsex
Now this should typecheck because our constraints are ask-
ing that 𝑎have instances of NumandOrd.
Concrete types imply all the typeclasses they
provide
We’ll be repurposing some examples from earlier in the chap-
ter, modifying them to all have a concrete type in the place of
𝑎:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 313
add::Int-&gt;Int-&gt;Int
addx y=x+y
addWeird ::Int-&gt;Int-&gt;Int
addWeird x y=
ifx&gt;1
thenx+y
elsex
check'::Int-&gt;Int-&gt;Bool
check'a a'=a==a'
These will all typecheck! This is because the Inttype has
the typeclasses Num,Eq, andOrdall implemented. We don’t need
to sayOrd Int =&gt; Int -&gt; Int -&gt; Int because it doesn’t add any
information. A concrete type either has a typeclass instance or
it doesn’t — adding the constraint means nothing. A concrete
type always implies the typeclasses that are provided for it.
There are some caveats to keep in mind here when it comes
to using concrete types. One of the nice things about para-
metricity and typeclasses is that you are being explicit about
what you mean to do withyour data which means you are
less likely to make a mistake. Intis a big datatype with many
inhabitants and many typeclasses and operations defined for
it — it could be easy to make a function that does something
unintended. Whereas if we were to write a function, even if we</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 314
hadIntvalues in mind for it, which used a polymorphic type
constrained by the typeclass instances we wanted, we could
ensure we only used the operations we intended. This isn’t a
panacea, but it can be worth avoiding concrete types for these
(and other) reasons sometimes.
6.14 Chapter Exercises
Multiple choice
1.The Eq class
a)includes all types in Haskell
b)is the same as the Ord class
c)makes equality tests possible
d)only includes numeric types
2.The typeclass Ord
a)allows any two values to be compared
b)is a subclass of Eq
c)is a superclass of Eq
d)has no instance for Bool
3.Suppose the typeclass Ord has an operator &gt;. What is the
type of &gt;?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 315
a)Ord a =&gt; a -&gt; a -&gt; Bool
b)Ord a =&gt; Int -&gt; Bool
c)Ord a =&gt; a -&gt; Char
d)Ord a =&gt; Char -&gt; [Char]
4.Inx = divMod 16 12
a)the type of 𝑥is Integer
b)the value of 𝑥is undecidable
c)the type of 𝑥is a tuple
d)𝑥is equal to 12 / 16
5.The typeclass Integral includes
a)Int and Integer numbers
b)integral, real, and fractional numbers
c)Schrodinger’s cat
d)only positive numbers
Does it typecheck?
For this section of exercises, you’ll be practicing looking for
type and typeclass errors.
For example, printIt will not work because functions like
𝑥have no instance of Show, the typeclass that lets you convert
things to Strings (usually for printing):</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 316
x::Int-&gt;Int
xblah=blah+20
printIt ::IO()
printIt =putStrLn (show x)
Here’s the type error you get if you try to load the code:
No instance for (Show (Int -&gt; Int)) arising
from a use of ‘show’
In the first argument of ‘putStrLn’, namely ‘(show x)’
In the expression: putStrLn (show x)
In an equation for ‘printIt’: printIt = putStrLn (show x)
It’s saying it can’t find an implementation of the typeclass
Showfor the type Int -&gt; Int , which makes sense. Nothing with
the function type constructor (-&gt;)has an instance of Show6by
default in Haskell.
Examine the following code and decide whether it will type-
check. Then load it in GHCi and see if you were correct. If
it doesn’t typecheck, try to match the type error against your
understanding of why it didn’t work. If you can, fix the error
and re-run the code.
6For an explanation and justification of why functions in Haskell cannot have a
Showinstance, see the wiki page on this topic. https://wiki.haskell.org/Show_instance_for_
functions</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 317
1.Does the following code typecheck? If not, why not?
dataPerson=PersonBool
printPerson ::Person-&gt;IO()
printPerson person=putStrLn (show person)
2.Does the following typecheck? If not, why not?
dataMood=Blah
|Wootderiving Show
settleDown x= ifx==Woot
thenBlah
elsex
3.If you were able to get settleDown to typecheck:
a)What values are acceptable inputs to that function?
b)What will happen if you try to run settleDown 9 ? Why?
c)What will happen if you try to run Blah &gt; Woot ? Why?
4.Does the following typecheck? If not, why not?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 318
typeSubject =String
typeVerb=String
typeObject=String
dataSentence =
Sentence Subject VerbObject
deriving (Eq,Show)
s1=Sentence &quot;dogs&quot;&quot;drool&quot;
s2=Sentence &quot;Julie&quot; &quot;loves&quot; &quot;dogs&quot;
Given a datatype declaration, what can we do?
Given the following datatype definitions:
dataRocks=
RocksStringderiving (Eq,Show)
dataYeah=
YeahBoolderiving (Eq,Show)
dataPapu=
PapuRocksYeah
deriving (Eq,Show)</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 319
Which of the following will typecheck? For the ones that
don’t typecheck, why don’t they?
1.phew=Papu&quot;chases&quot; True
2.truth=Papu(Rocks&quot;chomskydoz&quot; )
(YeahTrue)
3.equalityForall ::Papu-&gt;Papu-&gt;Bool
equalityForall p p'=p==p'
4.comparePapus ::Papu-&gt;Papu-&gt;Bool
comparePapus p p'=p&gt;p'
Match the types
We’re going to give you two types and their implementations.
Then we’re going to ask you if you can substitute the second
typeforthefirst. Youcantestthisbytypingthefirstdeclaration
and its type into a file and editing in the new one, loading to
see if it fails. Don’tguess, test all your answers!
1.For the following definition.
a)i::Numa=&gt;a
i=1
b)Try replacing the type signature with the following:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 320
i::a
After you’ve formulated your own answer, then tested
that answer and believe you understand why you were
right or wrong, make sure to use GHCi to check what
type GHC infersfor the definitions we provide without
a type assigned. For example, for this one, you’d type
in:
Prelude&gt; let i = 1
Prelude&gt; :t i
-- Result elided intentionally.
2.a)f::Float
f=1.0
b)f::Numa=&gt;a
3.a)f::Float
f=1.0
b)f::Fractional a=&gt;a
4.Hint for the following: type :info RealFrac in your REPL.
a)f::Float
f=1.0
b)f::RealFrac a=&gt;a</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 321
5.a)freud::a-&gt;a
freudx=x
b)freud::Orda=&gt;a-&gt;a
6.a)freud'::a-&gt;a
freud'x=x
b)freud'::Int-&gt;Int
7.a)myX=1::Int
sigmund ::Int-&gt;Int
sigmund x=myX
b)sigmund ::a-&gt;a
8.a)myX=1::Int
sigmund' ::Int-&gt;Int
sigmund' x=myX
b)sigmund' ::Numa=&gt;a-&gt;a
9.a)You’ll need to import sortfromData.List .
jung::Orda=&gt;[a]-&gt;a
jungxs=head (sort xs)
b)jung::[Int]-&gt;Int
10.a)young::[Char]-&gt;Char
youngxs=head (sort xs)</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 322
b)young::Orda=&gt;[a]-&gt;a
11.a)mySort::[Char]-&gt;[Char]
mySort=sort
signifier ::[Char]-&gt;Char
signifier xs=head (mySort xs)
b)signifier ::Orda=&gt;[a]-&gt;a
Type-Kwon-Do Two: Electric Typealoo
Round Two! Same rules apply — you’re trying to fill in terms
(code) which’ll fit the type. The idea with these exercises is that
you’ll derive the implementation from the type information.
You’ll probably need to use stuﬀ from Prelude.
1.chk::Eqb=&gt;(a-&gt;b)-&gt;a-&gt;b-&gt;Bool
chk= ???
2.-- Hint: use some arithmetic operation to
-- combine values of type 'b'. Pick one.
arith::Numb
=&gt;(a-&gt;b)
-&gt;Integer
-&gt;a
-&gt;b
arith= ???</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 323
6.15 Chapter Definitions
1.Typeclass inheritance is when a typeclass has a superclass.
This is a way of expressing that a typeclass requires another
typeclass to be available for a given type before you can
write an instance.
classNuma=&gt;Fractional awhere
(/)::a-&gt;a-&gt;a
recip::a-&gt;a
fromRational ::Rational -&gt;a
Here the typeclass Fractional inherits fromNum. We could
also say that Numis asuperclass ofFractional . The long
and short of it is that if you want to write an instance of
Fractional for some 𝑎, that type 𝑎, must already have an
instance of Numbefore you may do so.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 324
-- Even though in principle
-- this could work, it will fail because
-- Nada doesn't have a Num instance
newtype Nada=
NadaDoublederiving (Eq,Show)
instance Fractional Nadawhere
(Nadax)/(Naday)=Nada(x/y)
recip (Nadan)=Nada(recip n)
fromRational r =Nada(fromRational r)
Then if you try to load it:
No instance for (Num Nada)
arising from the superclasses
of an instance declaration
In the instance declaration for
‘Fractional Nada’
You need a Numinstance first. Can’t write one that makes
sense? Then you’re not allowed to have a Fractional in-
stance either. Them’s the rules.
2.Eﬀects are how we refer to observable actions programs may
take other than compute a value. If a function modifies</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 325
some state or interacts with the outside world in a manner
that can be observed, then we say it has an eﬀecton the
world.
3.IOis the type for values whose evaluation bears the possi-
bility of causing side eﬀects, such as printing text, reading
text input from the user, reading or writing files, or con-
necting to remote computers. This will be explained in
muchmore depth in the chapter on IO.
4.Aninstance is the definition of how a typeclass should
work for a given type. Instances are unique for a given
combination of typeclass and type.
5.In Haskell we have derivedinstances so that obvious or com-
mon typeclasses, such as Eq,Enum,Ord, andShowcan have
the instances generated based only on how the datatype
is defined. This is so programmers can make use of these
conveniences without writing the code themselves, over
and over.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 326
6.16 Typeclass inheritance, partial
This is not a complete chart of typeclass inheritance. It illus-
trates the relationship between a few of the typeclasses we’ve
talked about in this chapter. You can see, for example, that
the subclass Fractional inherits from the superclass Numbut not
vice versa. While many types have instances of ShowandRead,
they aren’t superclasses, so we’ve left them out of the chart for
clarity.
Figure 6.1: Chart of some typeclasses and their parentage.
Only the typeclasses seen so far are included.
6.17 Follow-up resources
1.P. Wadler and S. Blott. How to make ad-hoc polymor-
phism less ad hoc.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 327
http://www.cse.iitk.ac.in/users/karkare/courses/2010/cs653/
Papers/ad-hoc-polymorphism.pdf
2.Cordelia V. Hall, Kevin Hammond, Simon L. Peyton Jones,
and Philip L. Wadler. Typeclasses in Haskell.
http://ropas.snu.ac.kr/lib/dock/HaHaJoWa1996.pdf</p>
<p>Chapter 7
More functional patterns
I would like to be able to
always…divide the things
up into as many pieces as
I can, each of which I
understand separately. I
would like to understand
the way of adding things
up, independently of
what it is I’m adding up.
Gerald Sussman
328</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 329
7.1 Make it func-y
You might be asking yourself what this chapter is all about:
haven’t we been talking about functions all along? We have,
but as you might guess from the fact that Haskell is a functional
programming language, there is more to say — so much more!
A function is an instruction for producing an output from
an input, or argument. Functions are applied to arguments
which binds their parameters to values. The fully applied
function with its arguments is then evaluated to produce the
output or result. In this chapter we will demonstrate
•Haskell functions are first-class entities that
•can be values in expressions, lists, or tuples;
•can be passed as arguments to a function;
•can be returned from a function as a result;
•make use of syntactic patterns.
7.2 Arguments and parameters
As you know from our discussion of currying, functions in
Haskell may appear to have multiple parameters but this is
only the surface appearance; in fact, all functions take one
argument and return one result. We construct functions in</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 330
Haskell through various syntactic means of denoting that an
expression takes arguments. Functions are defined by the fact
that they can be applied to an argument and return a result.
All Haskell values can be arguments to functions. A value
that can be used as an argument to a function is a first-class
value. In Haskell, this includes functions, which can be argu-
ments to more functions still. Not all programming languages
allow this, but hopefully the earlier discussion of the function
type and currying have given an idea of how and why this
works.
Setting parameters
You name parameters to functions in Haskell by declaring
them between the name of the function, which is always at
the left margin, and the equals sign, separating the name from
both the function name and the equals sign with white space.
The name is a variable, and when we apply the function to
an argument, the value of the argument is bound, or unified,
with the named parameter in our function definition.
First we’ll define a value with no parameters:
myNum::Integer
myNum=1
myVal=myNum</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 331
If we query the type of myVal:
Prelude&gt; :t myVal
myVal :: Integer
The value myValhas the same type as myNumbecause it is equal
to it. We can see from the type that it’s a value without any
parameters, so we can’t apply it to anything.
Now let’s introduce a parameter named 𝑓:
myNum::Integer
myNum=1
myValf=myNum
And let’s see how that changed the type:
Prelude&gt; :t myVal
myVal :: t -&gt; Integer
Bywriting 𝑓aftermyValweparameterized myVal, whichchanges
the type from Integer tot -&gt; Integer . The type 𝑡is polymor-
phic because we don’t do anything with it — it could be any-
thing. We didn’t do anything with 𝑓so the maximally poly-
morphic type was inferred. If we do something with 𝑓, the
type will change:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 332
Prelude&gt; let myNum = 1 :: Integer
Prelude&gt; let myVal f = f + myNum
Prelude&gt; :t myVal
myVal :: Integer -&gt; Integer
Now it knows 𝑓has to be of type Integer because we added
it tomyNum.
We can tell a simple value from a function in part because
a value is not applied to any arguments, while functions nec-
essarily have parameters that can be applied to arguments.
Although Haskell functions only take one argument per
function, we can declare multiple parameters in a term-level
function definition:
myNum::Numa=&gt;a
myNum=1
-- [1]
myVal::Numa=&gt;a-&gt;a
myValf=f+myNum
-- [2]
stillAFunction ::[a]-&gt;[a]-&gt;[a]-&gt;[a]
stillAFunction a b c=a++b++c
-- [ 3 ]</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 333
1.Declaration of a value of type Num a =&gt; a . We can tell it’s
not a function because no parameters are named between
the name of the declared value and the =, so it accepts no
arguments, and the value 1 is not a function.
2.Here𝑓is a name for a parameter to the function myVal. It
represents the possibility of being applied to, or bound
to, an input value. The function type is Num a =&gt; a -&gt; a .
If you assign the type Integer tomyNum, as we had above,
myNumandmyValwould have the types Integer andInteger
-&gt; Integer , respectively.
3.Here𝑎,𝑏, and𝑐represent parameters for the function.
The underlying logic is of nested functions each applied
to one argument, rather than one function taking several
arguments, but this is how it appears at term level.
Notice what happens to the types as we name more param-
eters:
Prelude&gt; let myVal f g = myNum
Prelude&gt; :t myVal
myVal :: t -&gt; t1 -&gt; Integer
Prelude&gt; let myVal f g h = myNum
Prelude&gt; :t myVal
myVal :: t -&gt; t1 -&gt; t2 -&gt; Integer</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 334
Here the types are t,t1, andt2which could be diﬀerent
types. They are allowed but notrequired to be diﬀerent types.
They’re all polymorphic because we gave the type inference
nothing to go on with respect to what type they could be. The
type variables are diﬀerent because nothing in our code is
preventing them from varying, so they are potentially dif-
ferent types. The inference infers the most polymorphic type
that works.
Binding variables to values
Let’s consider how the binding of variables works. Applying
a function binds its parameters to values. Type parameters
become bound to a type, and function variables are bound
to a value. The binding of variables concerns not only the
application of function arguments, but also things like let
expressions and whereclauses. Consider the following function:
addOne::Integer -&gt;Integer
addOnex=x+1
We don’t know the result until the addOne function is applied
to anInteger value argument. When addOne is applied to a
value, we say that 𝑥is nowbound to the value the function was
applied to. Until a function’s arguments have been applied,</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 335
thereby binding the parameters to values, we cannot make use
of the result of the function.
addOne1-- x is now bound to 1
addOne1=1+1
=2
addOne10-- x is bound to 10
addOne10=10+1
=11
In addition to binding variables through function applica-
tion, we can use letexpressions to declare and bind variables
as well:
bindExp ::Integer -&gt;String
bindExp x=
lety=5in
&quot;the integer was: &quot; ++show x
++&quot; and y was: &quot; ++show y
Inshow y ,𝑦is in scope because the letexpression binds the
variable 𝑦to 5.𝑦is only in scope insidetheletexpression. Let’s
see something that won’t work:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 336
bindExp ::Integer -&gt;String
bindExp x=
letz=y+xin
lety=5in
&quot;the integer was: &quot;
++show x++&quot; and y was: &quot;
++show y++&quot; and z was: &quot;
++show z
You should see an error, “Not in scope: ‘y’”. We are trying
to make 𝑧equal a value constructed from 𝑥and𝑦.𝑥is in
scope because the function argument is visible anywhere in
the function. However, 𝑦is bound in the expression that let z
= …wraps, so it’s not in scope yet — that is, it’s not visible to
the main function.
In some cases, function arguments are not visible in the
function if they have been shadowed. Let’s look at a case of
shadowing :
bindExp ::Integer -&gt;String
bindExp x=
letx=10; y=5in
&quot;the integer was: &quot; ++show x
++&quot; and y was: &quot; ++show y
If you apply this to an argument, you’ll notice the result
never changes:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 337
Prelude&gt; bindExp 9001
&quot;the integer was: 10 and y was: 5&quot;
This is because the reference to 𝑥arising from the argument
𝑥was shadowed by the 𝑥from the letbinding. The definition
of𝑥that is innermost in the code (where the function name at
the left margin is the outside ) takes precedence because Haskell
islexically scoped . Lexical scoping means that resolving the
value for a named entity depends on the location in the code
and the lexical context, for example in letandwhereclauses.
Among other things, this makes it easier to know what values
referred to by name are and where they come from. Let’s
annotate the previous example and we’ll see what is meant
here:
bindExp ::Integer -&gt;String
bindExp x= letx=10
-- [1] [2]
y=5
in&quot;x: &quot;++show x
-- [3]
++&quot; y: &quot;++show y
1.The parameter 𝑥introduced in the definition of bindExp .
This gets shadowed by the 𝑥in[2].</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 338
2.This is a let-binding of 𝑥and shadows the definition of 𝑥
introduced as an argument at [1].
3.A use of the 𝑥bound by [2]. Given Haskell’s static (lexical)
scoping it will always refer to the 𝑥defined as x = 10 in the
letbinding!
You can also see the eﬀect of shadowing a name in scope in
GHCi using the letstatements you’ve been kicking around all
along:
Prelude&gt; let x = 5
Prelude&gt; let y = x + 5
Prelude&gt; y
10
Prelude&gt; y * 10
100
Prelude&gt; let z y = y * 10
Prelude&gt; x
5
Prelude&gt; y
10
Prelude&gt; z 9
90
-- but
Prelude&gt; z y</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 339
100
Note that while 𝑦is bound in GHCi’s scope to x + 5, the
introduction of z y = y * 10 creates a new inner scope which
shadowed the name𝑦. Now, when we call 𝑧, GHCi will use the
value we pass as 𝑦to evaluate the expression, not necessarily
the value 10from the letstatement y = x + 5 . Using 𝑦as an ar-
gument to 𝑧, as in the last example, means the value of 𝑦from
the outer scope is passed to 𝑧as an argument. The lexically
innermost binding for a variable of a particular name always
takes precedence. It does not matter that the 𝑦in𝑧’s parame-
ters has the same name as the 𝑦from earlier in GHCi: 𝑦will
always be bound to the value that 𝑧is applied to. (Incidentally,
the seeming-sequentiality of defining things in GHCi is, under
the hood, a never-ending series of nested lambda expressions,
similar to the way functions can seem to accept multiple argu-
ments but are, at root, a series of nested functions).
7.3 Anonymous functions
We have already seen how to write anonymous functions using
the lambda syntax represented by a backslash. Anonymous
means “without a name” and that gives us a clue to why we have
this syntax — to construct functions and use them without
giving them a name.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 340
Forexample, earlierwelookedatthisnamed, i.e., not anony-
mous, function:
triple::Integer -&gt;Integer
triplex=x<em>3
And here is the same function but with anonymous function
syntax:
(\x-&gt;x</em>3)::Integer -&gt;Integer
You need the parentheses for the type assertion :: Integer
-&gt; Integer to apply to the entire anonymous function and not
just the Num a =&gt; a value 3. You can give this function a name,
making it not anonymous anymore, in GHCi like this:
Prelude&gt; :{
*Main| let trip :: Integer -&gt; Integer
<em>Main| trip = \x -&gt; x</em>3
*Main| :}
Prelude&gt;
Similarly, to apply an anonymous function we’ll often need
to wrap it in parentheses so that our intent is clear:
Prelude&gt; (\x -&gt; x * 3) 5
15
Prelude&gt; \x -&gt; x * 3 1</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 341
Could not deduce (Num (a0 -&gt; a))</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../HaskellProgramming/HaskellProgramming.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../HaskellProgramming/part2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../HaskellProgramming/HaskellProgramming.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../HaskellProgramming/part2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
