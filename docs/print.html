<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>KnowledgeBase</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="HaskellProgramming/HaskellProgramming.html"><strong aria-hidden="true">1.</strong> Haskell Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="HaskellProgramming/part1.html"><strong aria-hidden="true">1.1.</strong> Part1</a></li><li class="chapter-item expanded "><a href="HaskellProgramming/part2.html"><strong aria-hidden="true">1.2.</strong> Part2</a></li><li class="chapter-item expanded "><a href="HaskellProgramming/part3.html"><strong aria-hidden="true">1.3.</strong> Part3</a></li><li class="chapter-item expanded "><a href="HaskellProgramming/part4.html"><strong aria-hidden="true">1.4.</strong> Part4</a></li><li class="chapter-item expanded "><a href="HaskellProgramming/part5.html"><strong aria-hidden="true">1.5.</strong> Part5</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">KnowledgeBase</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><strong>HaskellProgramming</strong></p>
<div style="break-before: page; page-break-before: always;"></div><p>i
Reader feedback
‚ÄúAstonishingly insightful examples. This book is a lot like
having a good teacher ‚Äî it never fails to provide the low-end
information even though I have already moved on. So just
like a good teacher isn‚Äôt presumptuous in what I‚Äôm supposed
to know (which might force me to try and save face in case I
do not, yet), information conveniently resurfaces.‚Äù ‚Äì David
Deutsch
‚ÄúWhen @haskellbook is done, it will be an unexpected mile-
stone for #haskell. There will forever be Haskell before, and
Haskell after.‚Äù ‚Äì Jason Kuhrt
‚ÄúI feel safe recommending Haskell to beginners now that
@haskellbook is available, which is very beginner friendly‚Äù ‚Äì
Gabriel Gonzalez
‚Äú‚ÄùStructure and Interpretation of Computer Programs‚Äù has
its credit, but @haskellbook is now my #1 recommendation
for FP beginners.‚Äù ‚Äì Irio Musskopf
‚ÄúThe book is long, but not slow ‚Äî a large fraction of it is
made up of examples and exercises. You can tell it‚Äôs written
by someone who‚Äôs taught Haskell to programmers before.‚Äù ‚Äì
Christopher Jones</p>
<p>ii
‚ÄúI already have a lot of experience with Haskell, but I‚Äôve
never felt confident in it the way this book has made me feel.‚Äù
‚Äì Alain O‚ÄôDea
‚ÄúReal deal with @haskellbook is that you don‚Äôt just learn
Haskell; you get a hands on experience as to why functional
programming works.‚Äù ‚Äì George Makrydakis
‚ÄúOne of my goals this year is to evangelize @haskellbook
and @HaskellForMac. I think these tools will make anyone
who uses them better. I want to get comfortable with it so that
I can shift how I think about Swift.‚Äù ‚Äì Janie Clayton</p>
<p>Contents
Reader feedback . . . . . . . . . . . . . . . . . . . . . . . . . . i
Contents iii
Authors‚Äô preface . . . . . . . . . . . . . . . . . . . . . . . . . . . xx
Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . xxv
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxix
Why This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . xxix
A few words to new programmers . . . . . . . . . . . . . . . xxxiv
Haskevangelism . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxv
What‚Äôs in this book? . . . . . . . . . . . . . . . . . . . . . . . . xxxix
Best practices for examples and exercises . . . . . . . . . . xliii
1 All You Need is Lambda 1
1.1 All You Need is Lambda . . . . . . . . . . . . . . . 2
1.2 What is functional programming? . . . . . . . . 2
1.3 What is a function? . . . . . . . . . . . . . . . . . . 4
1.4 The structure of lambda terms . . . . . . . . . . 7
1.5 Beta reduction . . . . . . . . . . . . . . . . . . . . . 10
1.6 Multiple arguments . . . . . . . . . . . . . . . . . . 15
1.7 Evaluation is simplification . . . . . . . . . . . . . 20
1.8 Combinators . . . . . . . . . . . . . . . . . . . . . . 21
iii</p>
<p>CONTENTS iv
1.9 Divergence . . . . . . . . . . . . . . . . . . . . . . . 23
1.10 Summary . . . . . . . . . . . . . . . . . . . . . . . . 24
1.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 25
1.12 Answers . . . . . . . . . . . . . . . . . . . . . . . . . 27
1.13 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 31
1.14 Follow-up resources . . . . . . . . . . . . . . . . . 33
2 Hello, Haskell! 34
2.1 Hello, Haskell . . . . . . . . . . . . . . . . . . . . . . 35
2.2 Interacting with Haskell code . . . . . . . . . . . 36
2.3 Understanding expressions . . . . . . . . . . . . . 40
2.4 Functions . . . . . . . . . . . . . . . . . . . . . . . . 43
2.5 Evaluation . . . . . . . . . . . . . . . . . . . . . . . . 47
2.6 Infix operators . . . . . . . . . . . . . . . . . . . . . 50
2.7 Declaring values . . . . . . . . . . . . . . . . . . . . 57
2.8 Arithmetic functions in Haskell . . . . . . . . . . 67
2.9 Parenthesization . . . . . . . . . . . . . . . . . . . . 78
2.10 Let and where . . . . . . . . . . . . . . . . . . . . . 85
2.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 90
2.12 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 94
2.13 Follow-up resources . . . . . . . . . . . . . . . . . 96
3 Strings 97
3.1 Printing strings . . . . . . . . . . . . . . . . . . . . . 98
3.2 A first look at types . . . . . . . . . . . . . . . . . . 98
3.3 Printing simple strings . . . . . . . . . . . . . . . . 100</p>
<p>CONTENTS v
3.4 Top-level versus local definitions . . . . . . . . . 107
3.5 Types of concatenation functions . . . . . . . . . 110
3.6 Concatenation and scoping . . . . . . . . . . . . . 115
3.7 More list functions . . . . . . . . . . . . . . . . . . 119
3.8 Chapter Exercises . . . . . . . . . . . . . . . . . . . 122
3.9 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 128
4 Basic datatypes 131
4.1 Basic Datatypes . . . . . . . . . . . . . . . . . . . . 132
4.2 What are types? . . . . . . . . . . . . . . . . . . . . 133
4.3 Anatomy of a data declaration . . . . . . . . . . . 133
4.4 Numeric types . . . . . . . . . . . . . . . . . . . . . 137
4.5 Comparing values . . . . . . . . . . . . . . . . . . . 147
4.6 Go on and Bool me . . . . . . . . . . . . . . . . . . 152
4.7 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . 160
4.8 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
4.9 Chapter Exercises . . . . . . . . . . . . . . . . . . . 167
4.10 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 172
4.11 Names and variables . . . . . . . . . . . . . . . . . 175
5 Types 178
5.1 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
5.2 What are types for? . . . . . . . . . . . . . . . . . . 180
5.3 How to read type signatures . . . . . . . . . . . . 182
5.4 Currying . . . . . . . . . . . . . . . . . . . . . . . . . 192
5.5 Polymorphism . . . . . . . . . . . . . . . . . . . . . 208</p>
<p>CONTENTS vi
5.6 Type inference . . . . . . . . . . . . . . . . . . . . . 217
5.7 Asserting types for declarations . . . . . . . . . . 222
5.8 Chapter Exercises . . . . . . . . . . . . . . . . . . . 225
5.9 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 239
5.10 Follow-up resources . . . . . . . . . . . . . . . . . 246
6 Typeclasses 247
6.1 Typeclasses . . . . . . . . . . . . . . . . . . . . . . . 248
6.2 What are typeclasses? . . . . . . . . . . . . . . . . . 248
6.3 Back to Bool . . . . . . . . . . . . . . . . . . . . . . 250
6.4 Eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
6.5 Writing typeclass instances . . . . . . . . . . . . . 257
6.6 Num . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
6.7 Type-defaulting typeclasses . . . . . . . . . . . . 278
6.8 Ord . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
6.9 Enum . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
6.10 Show . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
6.11 Read . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
6.12 Instances are dispatched by type . . . . . . . . . 304
6.13 Gimme more operations . . . . . . . . . . . . . . 309
6.14 Chapter Exercises . . . . . . . . . . . . . . . . . . . 314
6.15 Chapter Definitions . . . . . . . . . . . . . . . . . . 323
6.16 Typeclass inheritance, partial . . . . . . . . . . . 326
6.17 Follow-up resources . . . . . . . . . . . . . . . . . 326
7 More functional patterns 328</p>
<p>CONTENTS vii
7.1 Make it func-y . . . . . . . . . . . . . . . . . . . . . 329
7.2 Arguments and parameters . . . . . . . . . . . . . 329
7.3 Anonymous functions . . . . . . . . . . . . . . . . 339
7.4 Pattern matching . . . . . . . . . . . . . . . . . . . 344
7.5 Case expressions . . . . . . . . . . . . . . . . . . . . 360
7.6 Higher-order functions . . . . . . . . . . . . . . . 365
7.7 Guards . . . . . . . . . . . . . . . . . . . . . . . . . . 377
7.8 Function composition . . . . . . . . . . . . . . . . 387
7.9 Pointfree style . . . . . . . . . . . . . . . . . . . . . 392
7.10 Demonstrating composition . . . . . . . . . . . . 396
7.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 400
7.12 Chapter Definitions . . . . . . . . . . . . . . . . . . 406
7.13 Follow-up resources . . . . . . . . . . . . . . . . . 417
8 Recursion 419
8.1 Recursion . . . . . . . . . . . . . . . . . . . . . . . . 420
8.2 Factorial! . . . . . . . . . . . . . . . . . . . . . . . . . 421
8.3 Bottom . . . . . . . . . . . . . . . . . . . . . . . . . . 431
8.4 Fibonacci numbers . . . . . . . . . . . . . . . . . . 435
8.5 Integral division from scratch . . . . . . . . . . . 441
8.6 Chapter Exercises . . . . . . . . . . . . . . . . . . . 448
8.7 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 455
9 Lists 457
9.1 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 458
9.2 The list datatype . . . . . . . . . . . . . . . . . . . . 458</p>
<p>CONTENTS viii
9.3 Pattern matching on lists . . . . . . . . . . . . . . 460
9.4 List‚Äôs syntactic sugar . . . . . . . . . . . . . . . . . 464
9.5 Using ranges to construct lists . . . . . . . . . . . 465
9.6 Extracting portions of lists . . . . . . . . . . . . . 469
9.7 List comprehensions . . . . . . . . . . . . . . . . . 477
9.8 Spines and nonstrict evaluation . . . . . . . . . . 485
9.9 Transforming lists of values . . . . . . . . . . . . 500
9.10 Filtering lists of values . . . . . . . . . . . . . . . . 511
9.11 Zipping lists . . . . . . . . . . . . . . . . . . . . . . . 513
9.12 Chapter Exercises . . . . . . . . . . . . . . . . . . . 517
9.13 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 526
9.14 Follow-up resources . . . . . . . . . . . . . . . . . 529
10 Folding lists 530
10.1 Folds . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
10.2 Bringing you into the fold . . . . . . . . . . . . . . 531
10.3 Recursive patterns . . . . . . . . . . . . . . . . . . . 534
10.4 Fold right . . . . . . . . . . . . . . . . . . . . . . . . 535
10.5 Fold left . . . . . . . . . . . . . . . . . . . . . . . . . 548
10.6 How to write fold functions . . . . . . . . . . . . . 561
10.7 Folding and evaluation . . . . . . . . . . . . . . . . 568
10.8 Summary . . . . . . . . . . . . . . . . . . . . . . . . 571
10.9 Scans . . . . . . . . . . . . . . . . . . . . . . . . . . . 573
10.10 Chapter Exercises . . . . . . . . . . . . . . . . . . . 578
10.11 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 585
10.12 Follow-up resources . . . . . . . . . . . . . . . . . 589</p>
<p>CONTENTS ix
11 Algebraic datatypes 590
11.1 Algebraic datatypes . . . . . . . . . . . . . . . . . . 591
11.2 Data declarations review . . . . . . . . . . . . . . . 592
11.3 Data and type constructors . . . . . . . . . . . . . 594
11.4 Type constructors and kinds . . . . . . . . . . . . 597
11.5 Data constructors and values . . . . . . . . . . . . 599
11.6 What‚Äôs a type and what‚Äôs data? . . . . . . . . . . . 605
11.7 Data constructor arities . . . . . . . . . . . . . . . 611
11.8 What makes these datatypes algebraic? . . . . . 614
11.9 newtype . . . . . . . . . . . . . . . . . . . . . . . . . 620
11.10 Sum types . . . . . . . . . . . . . . . . . . . . . . . . 627
11.11 Product types . . . . . . . . . . . . . . . . . . . . . . 631
11.12 Normal form . . . . . . . . . . . . . . . . . . . . . . 636
11.13 Constructing and deconstructing values . . . . 642
11.14 Function type is exponential . . . . . . . . . . . . 667
11.15 Higher-kinded datatypes . . . . . . . . . . . . . . 674
11.16 Lists are polymorphic . . . . . . . . . . . . . . . . 677
11.17 Binary Tree . . . . . . . . . . . . . . . . . . . . . . . 681
11.18 Chapter Exercises . . . . . . . . . . . . . . . . . . . 690
11.19 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 703
12 Signaling adversity 704
12.1 Signaling adversity . . . . . . . . . . . . . . . . . . 705
12.2 How I learned to stop worrying and love Nothing 705
12.3 Bleating either . . . . . . . . . . . . . . . . . . . . . 709
12.4 Kinds, a thousand stars in your types . . . . . . 720</p>
<p>CONTENTS x
12.5 Chapter Exercises . . . . . . . . . . . . . . . . . . . 732
12.6 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 748
13 Building projects 750
13.1 Modules . . . . . . . . . . . . . . . . . . . . . . . . . 751
13.2 Making packages with Stack . . . . . . . . . . . . 753
13.3 Working with a basic project . . . . . . . . . . . . 754
13.4 Making our project a library . . . . . . . . . . . . 759
13.5 Module exports . . . . . . . . . . . . . . . . . . . . 762
13.6 More on importing modules . . . . . . . . . . . . 765
13.7 Making our program interactive . . . . . . . . . 773
13.8 do syntax and IO . . . . . . . . . . . . . . . . . . . . 779
13.9 Hangman game . . . . . . . . . . . . . . . . . . . . 784
13.10 Step One: Importing modules . . . . . . . . . . . 787
13.11 Step Two: Generating a word list . . . . . . . . . 793
13.12 Step Three: Making a puzzle . . . . . . . . . . . . 798
13.13 Adding a newtype . . . . . . . . . . . . . . . . . . . 810
13.14 Chapter exercises . . . . . . . . . . . . . . . . . . . 811
13.15 Follow-up resources . . . . . . . . . . . . . . . . . 815
14 Testing 817
14.1 Testing . . . . . . . . . . . . . . . . . . . . . . . . . . 818
14.2 A quick tour of testing for the uninitiated . . . 819
14.3 Conventional testing . . . . . . . . . . . . . . . . . 821
14.4 Enter QuickCheck . . . . . . . . . . . . . . . . . . . 833
14.5 Morse code . . . . . . . . . . . . . . . . . . . . . . . 846</p>
<p>CONTENTS xi
14.6 Arbitrary instances . . . . . . . . . . . . . . . . . . 863
14.7 Chapter Exercises . . . . . . . . . . . . . . . . . . . 875
14.8 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 885
14.9 Follow-up resources . . . . . . . . . . . . . . . . . 886
15 Monoid, Semigroup 887
15.1 Monoids and semigroups . . . . . . . . . . . . . . 888
15.2 What we talk about when we talk about algebras 889
15.3 Monoid . . . . . . . . . . . . . . . . . . . . . . . . . . 890
15.4 How Monoid is defined in Haskell . . . . . . . . 892
15.5 Examples of using Monoid . . . . . . . . . . . . . 893
15.6 Why Integer doesn‚Äôt have a Monoid . . . . . . . 895
15.7 Why bother? . . . . . . . . . . . . . . . . . . . . . . 901
15.8 Laws . . . . . . . . . . . . . . . . . . . . . . . . . . . . 903
15.9 DiÔ¨Äerent instance, same representation . . . . . 908
15.10 Reusing algebras by asking for algebras . . . . . 911
15.11 Madness . . . . . . . . . . . . . . . . . . . . . . . . . 923
15.12 Better living through QuickCheck . . . . . . . . 925
15.13 Semigroup . . . . . . . . . . . . . . . . . . . . . . . . 936
15.14 Strength can be weakness . . . . . . . . . . . . . . 941
15.15 Chapter exercises . . . . . . . . . . . . . . . . . . . 944
15.16 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 955
15.17 Follow-up resources . . . . . . . . . . . . . . . . . 956
16 Functor 957
16.1 Functor . . . . . . . . . . . . . . . . . . . . . . . . . . 958</p>
<p>CONTENTS xii
16.2 What‚Äôs a functor? . . . . . . . . . . . . . . . . . . . 959
16.3 There‚Äôs a whole lot of fmapgoin‚Äô round . . . . . 962
16.4 Let‚Äôs talk about ùëì, baby . . . . . . . . . . . . . . . . 965
16.5 Functor Laws . . . . . . . . . . . . . . . . . . . . . . 979
16.6 The Good, the Bad, and the Ugly . . . . . . . . . 981
16.7 Commonly used functors . . . . . . . . . . . . . . 987
16.8 Transforming the unapplied type argument . . 1005
16.9 QuickChecking Functor instances . . . . . . . . 1010
16.10 Exercises: Instances of Func . . . . . . . . . . . . 1014
16.11 Ignoring possibilities . . . . . . . . . . . . . . . . . 1015
16.12 A somewhat surprising functor . . . . . . . . . . 1024
16.13 More structure, more functors . . . . . . . . . . . 1028
16.14 IO Functor . . . . . . . . . . . . . . . . . . . . . . . . 1030
16.15 What if we want to do something diÔ¨Äerent? . . 1034
16.16 Functors are unique to a datatype . . . . . . . . . 1039
16.17 Chapter exercises . . . . . . . . . . . . . . . . . . . 1041
16.18 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 1046
16.19 Follow-up resources . . . . . . . . . . . . . . . . . 1050
17 Applicative 1052
17.1 Applicative . . . . . . . . . . . . . . . . . . . . . . . 1053
17.2 Defining Applicative . . . . . . . . . . . . . . . . . 1054
17.3 Functor vs. Applicative . . . . . . . . . . . . . . . . 1057
17.4 Applicative functors are monoidal functors . . 1059
17.5 Applicative in use . . . . . . . . . . . . . . . . . . . 1067
17.6 Applicative laws . . . . . . . . . . . . . . . . . . . . 1106</p>
<p>CONTENTS xiii
17.7 You knew this was coming . . . . . . . . . . . . . 1115
17.8 ZipList Monoid . . . . . . . . . . . . . . . . . . . . 1120
17.9 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1135
17.10 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 1138
17.11 Follow-up resources . . . . . . . . . . . . . . . . . 1138
18 Monad 1140
18.1 Monad . . . . . . . . . . . . . . . . . . . . . . . . . . 1141
18.2 Sorry ‚Äî a monad is not a burrito . . . . . . . . . 1141
18.3 Do syntax and monads . . . . . . . . . . . . . . . . 1154
18.4 Examples of Monaduse . . . . . . . . . . . . . . . . 1163
18.5 Monad laws . . . . . . . . . . . . . . . . . . . . . . . 1188
18.6 Application and composition . . . . . . . . . . . 1199
18.7 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1206
18.8 Definition . . . . . . . . . . . . . . . . . . . . . . . . 1209
18.9 Follow-up resources . . . . . . . . . . . . . . . . . 1211
19 Applying structure 1212
19.1 Applied structure . . . . . . . . . . . . . . . . . . . 1213
19.2 Monoid . . . . . . . . . . . . . . . . . . . . . . . . . . . 1213
19.3 Functor . . . . . . . . . . . . . . . . . . . . . . . . . . 1221
19.4 Applicative . . . . . . . . . . . . . . . . . . . . . . . . 1226
19.5 Monad. . . . . . . . . . . . . . . . . . . . . . . . . . . . 1233
19.6 An end-to-end example: URL shortener . . . . 1237
19.7 That‚Äôs a wrap! . . . . . . . . . . . . . . . . . . . . . . 1257
19.8 Follow-up resources . . . . . . . . . . . . . . . . . 1258</p>
<p>CONTENTS xiv
20 Foldable 1259
20.1 Foldable . . . . . . . . . . . . . . . . . . . . . . . . . 1260
20.2 The Foldable class . . . . . . . . . . . . . . . . . . . 1261
20.3 Revenge of the monoids . . . . . . . . . . . . . . . 1262
20.4 Demonstrating Foldable instances . . . . . . . . . 1268
20.5 Some basic derived operations . . . . . . . . . . 1273
20.6 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1280
20.7 Follow-up resources . . . . . . . . . . . . . . . . . 1281
21 Traversable 1282
21.1 Traversable . . . . . . . . . . . . . . . . . . . . . . . 1283
21.2 The Traversable typeclass definition . . . . . . . 1284
21.3 sequenceA . . . . . . . . . . . . . . . . . . . . . . . . . 1285
21.4 traverse . . . . . . . . . . . . . . . . . . . . . . . . . . 1287
21.5 So, what‚Äôs Traversable for? . . . . . . . . . . . . . . 1291
21.6 Morse code revisited . . . . . . . . . . . . . . . . . 1292
21.7 Axing tedious code . . . . . . . . . . . . . . . . . . 1296
21.8 Do all the things . . . . . . . . . . . . . . . . . . . . 1300
21.9 Traversable instances . . . . . . . . . . . . . . . . . 1304
21.10 Traversable Laws . . . . . . . . . . . . . . . . . . . . 1307
21.11 Quality Control . . . . . . . . . . . . . . . . . . . . 1308
21.12 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1309
21.13 Follow-up resources . . . . . . . . . . . . . . . . . 1314
22 Reader 1315
22.1 Reader . . . . . . . . . . . . . . . . . . . . . . . . . . 1316</p>
<p>CONTENTS xv
22.2 A new beginning . . . . . . . . . . . . . . . . . . . . 1317
22.3 This is Reader . . . . . . . . . . . . . . . . . . . . . 1327
22.4 Breaking down the Functor of functions . . . . . 1328
22.5 But uh, Reader ? . . . . . . . . . . . . . . . . . . . . . 1334
22.6 Functions have an Applicative too . . . . . . . . . 1337
22.7 The Monadof functions . . . . . . . . . . . . . . . . 1345
22.8 Reader Monad by itself is boring . . . . . . . . . . . 1351
22.9 You can change what comes below, but not above 1354
22.10 You tend to see ReaderT , notReader . . . . . . . . . 1355
22.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1355
22.12 Definition . . . . . . . . . . . . . . . . . . . . . . . . 1362
22.13 Follow-up resources . . . . . . . . . . . . . . . . . 1363
23 State 1364
23.1 State . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1365
23.2 What is state? . . . . . . . . . . . . . . . . . . . . . . 1365
23.3 Random numbers . . . . . . . . . . . . . . . . . . . 1367
23.4 The Statenewtype . . . . . . . . . . . . . . . . . . . 1371
23.5 Throw down . . . . . . . . . . . . . . . . . . . . . . 1374
23.6 Write Statefor yourself . . . . . . . . . . . . . . . 1383
23.7 Get a coding job with one weird trick . . . . . . 1385
23.8 Chapter exercises . . . . . . . . . . . . . . . . . . . 1392
23.9 Follow-up resources . . . . . . . . . . . . . . . . . 1394
24 Parser combinators 1395
24.1 Parser combinators . . . . . . . . . . . . . . . . . . 1396</p>
<p>CONTENTS xvi
24.2 A few more words of introduction . . . . . . . . 1398
24.3 Understanding the parsing process . . . . . . . . 1399
24.4 Parsing fractions . . . . . . . . . . . . . . . . . . . . 1416
24.5 Haskell‚Äôs parsing ecosystem . . . . . . . . . . . . . 1425
24.6 Alternative . . . . . . . . . . . . . . . . . . . . . . . . 1429
24.7 Parsing configuration files . . . . . . . . . . . . . . 1444
24.8 Character and token parsers . . . . . . . . . . . . 1460
24.9 Polymorphic parsers . . . . . . . . . . . . . . . . . 1465
24.10 Marshalling from an AST to a datatype . . . . . 1474
24.11 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1491
24.12 Definitions . . . . . . . . . . . . . . . . . . . . . . . . 1500
24.13 Follow-up resources . . . . . . . . . . . . . . . . . 1501
25 Composing types 1504
25.1 Composing types . . . . . . . . . . . . . . . . . . . 1505
25.2 Common functions as types . . . . . . . . . . . . 1506
25.3 Two little functors sittin‚Äô in a tree,
L-I-F-T-I-N-G . . . . . . . . . . . . . . . . . . . . . 1511
25.4 Twinplicative . . . . . . . . . . . . . . . . . . . . . . 1514
25.5 Twonad? . . . . . . . . . . . . . . . . . . . . . . . . . 1516
25.6 Exercises: Compose Instances . . . . . . . . . . . 1518
25.7 Monad transformers . . . . . . . . . . . . . . . . . 1520
25.8 IdentityT . . . . . . . . . . . . . . . . . . . . . . . . . 1523
25.9 Finding a pattern . . . . . . . . . . . . . . . . . . . 1542
26 Monad transformers 1546</p>
<p>CONTENTS xvii
26.1 Monad transformers . . . . . . . . . . . . . . . . . 1547
26.2 MaybeT . . . . . . . . . . . . . . . . . . . . . . . . . . 1547
26.3 EitherT . . . . . . . . . . . . . . . . . . . . . . . . . . 1555
26.4 ReaderT . . . . . . . . . . . . . . . . . . . . . . . . . 1557
26.5 StateT . . . . . . . . . . . . . . . . . . . . . . . . . . . 1561
26.6 Types you probably don‚Äôt want to use . . . . . . 1566
26.7 Recovering an ordinary type from a transformer 1568
26.8 Lexically inner is structurally outer . . . . . . . 1570
26.9 MonadTrans . . . . . . . . . . . . . . . . . . . . . . 1574
26.10 MonadIO aka zoom-zoom . . . . . . . . . . . . . 1597
26.11 Monad transformers in use . . . . . . . . . . . . . 1601
26.12 Monads do not commute . . . . . . . . . . . . . . 1617
26.13 Transform if you want to . . . . . . . . . . . . . . 1617
26.14 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1618
26.15 Defintion . . . . . . . . . . . . . . . . . . . . . . . . . 1627
26.16 Follow-up resources . . . . . . . . . . . . . . . . . 1628
27 Nonstrictness 1629
27.1 Laziness . . . . . . . . . . . . . . . . . . . . . . . . . 1630
27.2 Observational Bottom Theory . . . . . . . . . . . 1631
27.3 Outside in, inside out . . . . . . . . . . . . . . . . . 1633
27.4 What does the other way look like? . . . . . . . . 1637
27.5 Can we make Haskell strict? . . . . . . . . . . . . . 1638
27.6 Call by name, call by need . . . . . . . . . . . . . 1657
27.7 Nonstrict evaluation changes what we can do . 1658
27.8 Thunk Life . . . . . . . . . . . . . . . . . . . . . . . 1660</p>
<p>CONTENTS xviii
27.9 Sharing is caring . . . . . . . . . . . . . . . . . . . . 1664
27.10 Refutable and irrefutable patterns . . . . . . . . 1686
27.11 Bang patterns . . . . . . . . . . . . . . . . . . . . . . 1689
27.12 Strict and StrictData . . . . . . . . . . . . . . . . . 1693
27.13 Adding strictness . . . . . . . . . . . . . . . . . . . . 1695
27.14 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1702
27.15 Follow-up resources . . . . . . . . . . . . . . . . . 1705
28 Basic libraries 1707
28.1 Basic libraries and data structures . . . . . . . . . 1708
28.2 Benchmarking with Criterion . . . . . . . . . . . 1709
28.3 Profiling your programs . . . . . . . . . . . . . . . 1727
28.4 Constant applicative forms . . . . . . . . . . . . . 1732
28.5 Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1737
28.6 Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1741
28.7 Sequence . . . . . . . . . . . . . . . . . . . . . . . . . 1744
28.8 Vector . . . . . . . . . . . . . . . . . . . . . . . . . . . 1748
28.9 String types . . . . . . . . . . . . . . . . . . . . . . . 1762
28.10 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1775
28.11 Follow-up resources . . . . . . . . . . . . . . . . . 1779
29 IO 1781
29.1 IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1782
29.2 Where IO explanations go astray . . . . . . . . . 1783
29.3 The reason we need this type . . . . . . . . . . . 1786
29.4 Sharing . . . . . . . . . . . . . . . . . . . . . . . . . . 1788</p>
<p>CONTENTS xix
29.5 IO doesn‚Äôt disable sharing for everything . . . . 1795
29.6 Purity is losing meaning . . . . . . . . . . . . . . . 1797
29.7 IO‚Äôs Functor, Applicative, and Monad . . . . . . 1800
29.8 Well, then, how do we MVar? . . . . . . . . . . . . 1806
29.9 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1809
29.10 Follow-up resources . . . . . . . . . . . . . . . . . 1810
30 When things go wrong 1812
30.1 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . 1813
30.2 The Exception class and methods . . . . . . . . . 1814
30.3 This machine kills programs . . . . . . . . . . . . 1825
30.4 Want either? Try! . . . . . . . . . . . . . . . . . . . 1832
30.5 The unbearable imprecision of trying . . . . . . 1837
30.6 Why throwIO? . . . . . . . . . . . . . . . . . . . . . 1840
30.7 Making our own exception types . . . . . . . . . 1844
30.8 Surprising interaction with bottom . . . . . . . . 1851
30.9 Asynchronous Exceptions . . . . . . . . . . . . . . 1853
30.10 Follow-up Reading . . . . . . . . . . . . . . . . . . 1857
31 Final project 1859
31.1 Final project . . . . . . . . . . . . . . . . . . . . . . . 1860
31.2 fingerd . . . . . . . . . . . . . . . . . . . . . . . . . . 1860
31.3 Exploring finger . . . . . . . . . . . . . . . . . . . . 1862
31.4 Slightly modernized fingerd . . . . . . . . . . . . 1872
31.5 Chapter Exercises . . . . . . . . . . . . . . . . . . . 1887</p>
<p>CONTENTS xx
Authors‚Äô preface
Chris‚Äôs story
I‚Äôve been programming for over 15 years, 8 of them profes-
sionally. I‚Äôve worked primarily in Common Lisp, Clojure, and
Python. I became interested in Haskell about 6 years ago.
Haskell was the language that made me aware that progress
is being made in programming language research and that
there are benefits to using a language with a design informed
by knowledge of those advancements.
I‚Äôve had type errors in Clojure that multiple professional
Clojure devs (including myself) couldn‚Äôt resolve in less than
2 hours because of the source-to-sink distance caused by dy-
namic typing. We had copious tests. We added println s ev-
erywhere. We tested individual functions from the REPL. It
still took ages. It was only 250 lines of Clojure. I did finally
fix it and found it was due to vectors in Clojure implementing
IFn. The crazy values that propagated from the IFnusage of
the vector allowed malformed data to propagate downward
far away from the origin of the problem. I‚Äôve had similar hap-
pen in Python and Common Lisp as well. The same issue
in Haskell would be trivially resolved in a minute or less be-
cause the typechecker will identify precisely where you were
inconsistent.
I use Haskell because I want to be able to refactor without</p>
<p>CONTENTS xxi
fear, because I want maintenance to be something I don‚Äôt re-
sent, so I can reuse code freely. This doesn‚Äôt come without
learning new things. The diÔ¨Äerence between people that are
‚Äúgood at math‚Äù who ‚Äúdo it in their head‚Äù and professional math-
ematicians is that the latter show their work and use tools that
help them get the job done. When you‚Äôre using a dynamically
typed language, you‚Äôre forcing yourself unnecessarily to do it
‚Äúin your head.‚Äù As a human with limited working memory, I
want all the help I can get to reason about and write correct
code. Haskell provides that help.
Haskell is not a difficult language to use ‚Äî quite the opposite.
I‚Äôm now able to tackle problems that I couldn‚Äôt have tackled
when I was primarily a Clojure, Common Lisp, or Python
user. Haskell is difficult to teach eÔ¨Äectively, and the ineÔ¨Äective
pedagogy has made it hard for many people to learn.
It doesn‚Äôt have to be that way.
I‚Äôve spent the last two years actively teaching Haskell on-
line and in person. Along the way, I started keeping notes
on exercises and methods of teaching specific concepts and
techniques that worked. Those notes eventually turned into
my guide for learning Haskell. I‚Äôm still learning how to teach
Haskell better by working with people locally in Austin, Texas,
as well as online in the IRC channel I made for beginners to
get help with learning Haskell.
I wrote this book because I had a hard time learning Haskell,
and I don‚Äôt want others to struggle the way I did.</p>
<p>CONTENTS xxii
Julie‚Äôs story
I met Chris Allen in spring 2014. We met on Twitter and
quickly became friends. As anyone who has encountered
Chris ‚Äî probably in any medium, but certainly on Twitter ‚Äî
knows, it doesn‚Äôt take long before he starts urging you to learn
Haskell.
I told him I had no interest in programming. I told him
nothing and nobody had ever been able to interest me in pro-
gramming before. When Chris learned of my background
in linguistics, he thought I might be interested in natural lan-
guage processing and exhorted me to learn Haskell for that
purpose. I remained unconvinced.
Then he tried a diÔ¨Äerent approach. He was spending a lot of
time gathering and evaluating resources for teaching Haskell
and refining his pedagogical techniques, and he convinced me
to try to learn Haskell so that he could gain the experience
of teaching a code-neophyte. Finally, with an ‚Äúanything for
science‚Äù attitude, I gave in.
Chris had already known that the available Haskell learning
materials each had problems, but I don‚Äôt think even he realized
just how frustrating they would be to me. All of the materials
I ran across relied on a background with other programming
languages and left many terms undefined or explained fea-
tures of Haskell by analogy (often faulty) to features of other
languages ‚Äî features I had no experience with.</p>
<p>CONTENTS xxiii
When I say I had no programming experience, I really, truly
mean it. I had to start from learning what a compiler does,
what version control means, what constitutes side eÔ¨Äects, what
is a library, what is a module, what on earth is a stack overflow.
At the time of this writing, that is where I was less than a year
ago; by the time we finish writing this book and it is published,
it will be a little over two years.
Eventually, as he realized that a new type of book for learn-
ing Haskell was necessary, he decided to write one. I agreed at
the time to be his guinea pig. He would send me chapters and
I would learn Haskell from them and send feedback. Through
the fall, we worked like this, on and oÔ¨Ä, in short bursts. Even-
tually we found it more efficient for me to take on authorship
duties. We developed a writing process where Chris made
the first pass at a chapter, scaÔ¨Äolding the material it needed to
cover. Then I filled in the parts that I understood and came
up with questions that would elaborate and clarify the parts I
didn‚Äôt already know. He answered my questions until I under-
stood, and I continued adding to and refining what was there.
We each wrote exercises ‚Äî I write much easier ones than he
does, but the variety is beneficial.
I have tried, throughout the process, to keep thinking from
the perspective of the absolute beginner. For one thing, I
wanted my own understanding of Haskell to deepen as I wrote
soIkeptquestioningthethingsIthoughtIknew. Also, Iwanted
this book to be accessible to everyone.</p>
<p>CONTENTS xxiv
In interacting with other Haskell learners I often hear that
other materials leave them feeling like Haskell is difficult and
mysterious, a programming language best left to wizards.
It doesn‚Äôt have to be that way.</p>
<p>CONTENTS xxv
Acknowledgements
This book developed out of many eÔ¨Äorts to teach and learn
Haskell, online and oÔ¨Ä. We could not have done this without
the help of the growing community of friendly Haskellers as
well as the Haskell learners who have graciously oÔ¨Äered time
to help us make the book better.
First and foremost, we owe a huge debt of gratitude to our
first-round reviewers, Angela May O‚ÄôConnor and Martin Vlk,
for their tremendous patience. We have sent them each some
very rough material, and they have been willing to work with
it and send detailed feedback about what worked and what
didn‚Äôt. Their reviews helped ensure the book is suitable for
both beginners and comprehensive. Also, they‚Äôre both just
wonderful people all around.
Martin DeMello, Daniel Gee, and Simon Yang have each
sent us (many) smart criticisms and helpful suggestions. The
book would have been shorter without their help, we think,
but it‚Äôs much more thorough and clear now.
A number of people have contributed feedback and tech-
nical review for limited parts of the book. Thanks to Sean
Chalmers, Erik de Castro Lopo, Alp Mestanogullari, Juan Al-
berto Sanchez, Jonathan Ferguson, Deborah Newton, Matt
Parsons, Peter Harpending, Josh Cartwright, Eric Mertens,
and George Makrydakis, who have all oÔ¨Äered critiques of our
writing and our technical coverage of diÔ¨Äerent topics.</p>
<p>CONTENTS xxvi
We have some very active early access readers who send us
a stream of feedback, everything from minor typographical
errors they find to questions about exercises, and we‚Äôre pleased
and grateful to have their input. The book would be messier
and the exercises less useful if not for their help. Julien Baley
and Jason Kuhrt have been particularly outstanding on this
front, not only representing a nontrivial portion of our reader
feedback over the course of several releases of the book, but
also catching things nobody else noticed.
The book cover was designed by David Deutsch (skore_de
on Twitter). He took pity on the state of our previous, original,
super special early access cover, and took it upon himself to
redesign it. We liked it so much we asked him to redo the book
web site as well. He‚Äôs a talented designer, and we‚Äôre grateful
for all the work he‚Äôs done for us.
A special thank-you is owed to Soryu Moronuki, Julie‚Äôs son,
who agreed to try to use the book to teach himself Haskell and
allowed us to use his feedback and occasionally blog about his
progress.
A warm hello to all the reading groups, both online and
in meatspace, that have formed to work through the book
together. We‚Äôve had some great feedback from these groups
and hope to visit with you all someday. We‚Äôre delighted to see
the Haskell community growing.
We would also like to thank Michael Neale for being funny
and letting us use something he said on Twitter as an epigraph.</p>
<p>CONTENTS xxvii
Some day we hope to buy the gentleman a beer.
Thank you as well to Steven Proctor for having hosted us on
his Functional Geekery podcast, and to Adam Stacoviak and
Jerod Santo for inviting us onto their podcast, The Changelog
‚Äî and to Zaki Manian for bringing us to Adam and Jerod‚Äôs
attention.
Chris I would like to thank the participants in the #haskell-
beginners IRC channel, the teachers and the students, who have
helped me practice and refine my teaching techniques. Many
of the exercises and approaches in the book would‚Äôve never
happened without the wonderful Haskell IRC community to
learn from.
I owe Alex Kurilin, Carter Schonwald, Aidan Coyne, and
Mark Wotton thanks for being there when I was reallybad at
teaching, being kind and patient friends, and for giving me
advice when I needed it. I wouldn‚Äôt have scratched this itch
without y‚Äôall.
Julie I would like to send a special shout-out to the Austin
Haskell meetup group, especially Sukant Hajra and Austin
Seipp for giving me the opportunity to teach the meetup.
The list of Haskellers who have responded to the kvetches
and confusions of a Haskell beginner with assistance, humor,
and advice would be very long indeed, but I owe special grati-
tude to Sooraj Bhat, Reid McKenzie, Dan Lien, Zaki Manian,</p>
<p>CONTENTS xxviii
and Alex Feldman-Crough for their help and encouragement.
I wouldn‚Äôt have made it through the last few months of fin-
ishing this thing without the patient advice and friendship of
Chris Martin.
My husband and children have tolerated me spending un-
countable hours immersed in the dark arts of thunkery. I am
grateful for their love, patience, and support and hope that
my kids will remember this: that it‚Äôs never too late to learn
something new. Besos, mijos.
Finally, a warm thank you to George Makrydakis for the
ongoing discussion on matters to do with math, programming,
and the weirding way.
Any errors in the book, of course, remain the sole responsi-
bility of the authors.</p>
<p>CONTENTS xxix
Introduction
Welcome to a new way to learn Haskell. Perhaps you are
coming to this book frustrated by previous attempts to learn
Haskell. Perhaps you have only the faintest notion of what
Haskell is. Perhaps you are coming here because you are not
convinced that anything will ever be better than Common
Lisp/Scala/Ruby/whatever language you love, and you want
to argue with us. Perhaps you were just looking for the 18
billionth (n.b.: this number may be inaccurate) monad tutorial,
certain that this time around you will understand monads
once and for all. Whatever your situation, welcome and read
on! It is our goal here to make Haskell as clear, painless, and
practical as we can, no matter what prior experiences you‚Äôre
bringing to the table.
Why This Book
If you are new to programming entirely, Haskell is a great
first language. Haskell is a general purpose, functional pro-
gramming1language. It‚Äôs applicable virtually anywhere one
would use a program to solve a problem, save for some specific
embedded applications. If you could write software to solve a
1Functional programming is a style of programming in which function calls, rather
than a series of instructions for the computer to execute, are the primary constructs of
your program. What it is doesn‚Äôt matter much right now; Haskell completely embodies
the functional style, so it will become clear over the course of the book.</p>
<p>CONTENTS xxx
problem, you could probably use Haskell.
If you are already a programmer, you may be looking to
enrich your skills by learning Haskell for a variety of reasons
‚Äî from love of pure functional programming itself to wanting
to write functional Scala code to finding a bridge to PureScript
or Idris. Languages such as Java are gradually adopting func-
tional concepts, but most were not designed to be functional
languages. Because Haskell is a pure functional language, it is
a fertile environment for mastering functional programming.
That way of thinking and problem solving is useful, no matter
what other languages you might know or learn. We‚Äôve heard
from readers who are finding this book useful to their work in
diverse languages such as Scala, F#, Frege, Swift, PureScript,
Idris, and Elm.
Haskell has a bit of a reputation for being difficult. Writing
Haskellmayseemtobemoredifficultupfront, notjustbecause
of the hassle of learning a language that is syntactically and
conceptually diÔ¨Äerent from a language you already know, but
also because of features such as strong typing that enforce
some discipline in how you write your code. But what seems
like a bug is a feature. Humans, unfortunately, have relatively
limited abilities of short-term memory and concentration,
even if we don‚Äôt like to admit it. We cannot track all relevant
metadata about our programs in our heads. Using up working
memory for anything a computer can do for us is counter-
productive, and computers are very good at keeping track of</p>
<p>CONTENTS xxxi
data for us, including metadata such as types.
We don‚Äôt write Haskell because we‚Äôre geniuses ‚Äî we use
tools like Haskell because they help us. Good tools like Haskell
enable us to work faster, make fewer mistakes, and have more
information about what our code is supposed to do as we read
it.
We use Haskell because it is easier (over the long run) and enables
us to do a better job. That‚Äôs it. There‚Äôs a ramp-up required in
order to get started, but that can be ameliorated with patience
and a willingness to work through exercises.
OK, but I was just looking for a monad tutorial...
The bad news is looking for an easy route into Haskell and
functional programming is how a lot of people end up think-
ing it‚Äôs ‚Äútoo hard‚Äù for them. The good news is we have a lot
of experience teaching and we don‚Äôt want that to happen to
anyone, but especially not you, gentle reader.
We encourage you to forget what you might already know
about programming and come at this course in Haskell with a
beginner‚Äôs mindset. Make yourself an empty vessel, ready to
let the types flow through you.
If you are an experienced programmer, learning Haskell is
more like learning to program all over again. Learning Haskell
imposes new ways of thinking about and structuring programs
on most people already comfortable with an imperative or</p>
<p>CONTENTS xxxii
untyped programming language. This makes it harder to
learn not because it is intrinsically harder, but because most
people who have learned at least a couple of programming
languages are accustomed to the process being trivial, and
their expectations have been set in a way that lends itself to
burnout and failure.
If Haskell is your first language, or even if it is not, you may
have noticed a specific problem with many Haskell learning
resources: they assume a certain level of background with
programming, so they frequently explain Haskell concepts in
terms, by analogy or by contrast, of programming concepts
from other languages. This is confusing for the student who
doesn‚Äôt know those other languages, but we posit that it is just
as unhelpful for experienced programmers. Most attempts to
compare Haskell with other languages only lead to a superficial
understanding of Haskell, and making analogies to loops and
other such constructs can lead to bad intuitions about how
Haskell code works. For all of these reasons, we have tried to
avoid relying on knowledge of other programming languages.
Just as you can‚Äôt achieve fluency in a human language so long
as you are still attempting direct translations of concepts and
structures from your native language to the target language,
it‚Äôs best to learn to understand Haskell on its own terms.</p>
<p>CONTENTS xxxiii
But I‚Äôve heard Haskell is hard...
There‚Äôs a wild rumor that goes around the internet from time
to time about needing a Ph.D. in mathematics and an under-
standing of monads just to write ‚Äúhello, world‚Äù2in Haskell.
We will write ‚Äúhello, world‚Äù in Chapter 3. We‚Äôre going to do
some arithmetic before that to get you used to function syntax
and application in Haskell, but you will not need a Ph.D. in
monadology to write it.
Intruth, therewill be a monad underlyingour ‚Äúhello, world,‚Äù
and by the end of the book, you willunderstand monads,
but you‚Äôll be interacting with monadic code long before you
understand how it all works. You‚Äôll find, at times, this book
goes into more detail than you strictly need to be able to write
Haskell successfully. There is no problem with that. You do
not need to understand everything in here perfectly on the
first try.
You are not a Spartan warrior who must come back with
your shield or on it. Returning later to investigate things more
deeply is an efficient technique, not a failure.
2Writing ‚Äúhello, world‚Äù in a new programming language is a standard sort of ‚Äúbaby‚Äôs
first program,‚Äù so the idea here is that if it‚Äôs difficult to write a ‚Äúhello, world‚Äù program,
then the language must be impossible. There are languages that have purposely made it
inhumanly difficult to write such programs, but Haskell is not one of them.</p>
<p>CONTENTS xxxiv
A few words to new programmers
We‚Äôve tried very hard to make this book as accessible as possi-
ble, no matter your level of previous experience. We have kept
comparisons and mentions of other languages to a minimum,
and we promise that if we compare something in Haskell to
something in another language, that comparison is not itself
crucial to understanding the Haskell ‚Äî it‚Äôs just a little extra for
those who do know the other language.
However, especially as the book progresses and the exercises
and projects get more ‚Äúreal,‚Äù there are going to be terms and
concepts that we do not have the space to explain fully but
that are relatively well known among programmers. You may
have to do internet searches for terms like JSON. The next
section of this introduction references things that you may not
know about but programmers will ‚Äî don‚Äôt panic. We think
you‚Äôll still get something out of reading it, but if not, it‚Äôs not
something to worry about. The fact that you don‚Äôt know every
term in this book before you come to it is not a sign that you
can‚Äôt learn Haskell or aren‚Äôt ready for this: it‚Äôs only a sign that
you don‚Äôt know everything yet , and since no one does, you‚Äôre in
fine company.
Along those same lines, this book does not oÔ¨Äer much in-
struction on using the terminal and text editor. The instruc-
tions provided assume you know how to find your way around
your terminal and understand how to do simple tasks like</p>
<p>CONTENTS xxxv
make a directory or open a file. Due to the number of text
editors available, we do not provide specific instructions for
any of them.3
If you need help or would like to start getting to know the
communities of functional programmers, there are several
options. The Freenode IRC channel #haskell-beginners has
teachers who will be glad to help you, and they especially
welcome questions regarding specific problems that you are
trying to solve.4There are also Slack channels and subreddits
where Haskellers congregate, along with a plethora of Haskell-
oriented blogs, many of which are mentioned in footnotes
and recommended readings throughout the book. Many of
our readers also program in languages like Swift and Scala, so
you may want to investigate those communities as well.
Haskevangelism
The rest of this introduction will give some background of
Haskell and will make reference to other programming lan-
3If you‚Äôre quite new and unsure what to do about text editors, you might consider
Atom. It‚Äôs free, open-source, and configurable. Sublime Text has served Julie well through-
out the writing of the book, but is not free. Chris uses Emacs most of the time; Emacs
is very popular among programmers, but has its own learning curve. Vim is another
popular text editor with itsown learning curve. If you have no experience with Emacs or
Vim, we‚Äôd really recommend sticking with something like Sublime or Atom for now.
4Freenode IRC (Internet Relay Chat) is a network of channels for textual chat. There
are other IRC networks around, as well as other group chat platforms, but the Freenode
IRC channels for Haskell are popular meeting places for the Haskell community. There
are several ways to access Freenode IRC, including Irssi and HexChat, if you‚Äôre interested
in getting to know the community in their natural habitat.</p>
<p>CONTENTS xxxvi
guages and styles. If you‚Äôre a new programmer, it is possible
not all of this will make sense, and that‚Äôs okay. The rest of the
book is written with beginners in mind, and the features we‚Äôre
outlining will make more sense as you work through the book.
We‚Äôre going to compare Haskell a bit with other languages
to demonstrate why we think using Haskell is valuable. Haskell
is a language in a progression of languages dating back to 1973,
when ML was invented by Robin Milner and others at the
University of Edinburgh. ML was itself influenced by ISWIM,
which was in turn influenced by ALGOL 60 and Lisp. We
mention this lineage because Haskell isn‚Äôtnew. The most pop-
ular implementation of Haskell, the Glasgow Haskell Compiler
(GHC), is mature and well-made. Haskell brings together some
nice design choices that make for a language that oÔ¨Äers more
expressiveness than Ruby, but more type safety than any lan-
guage presently in wide use commercially.
In 1968, the ALGOL68 dialect had the following features
built into the language:
1.User-defined record types.
2.User-defined sum types (unions not limited to simple
enumerations).
3.Switch/case expressions supporting the sum types.
4.Compile-time enforced constant values, declared with =
rather than :=.</p>
<p>CONTENTS xxxvii
5.Unified syntax for using value and reference types ‚Äî no
manual pointer dereferencing.
6.Closures with lexical scoping (without this, many func-
tional patterns fall apart).
7.Implementation-agnostic parallelized execution of pro-
cedures.
8.Multi-pass compilation ‚Äî you can declare stuÔ¨Ä after you
use it.
As of the early 21st century, many popular languages used
commercially don‚Äôt have anything equivalent to or better than
what ALGOL68 had. We mention this because we believe
technological progress in computer science, programming,
and programming languages is possible, desirable, and critical
to software becoming a true engineering discipline. By that,
we mean that while the phrase ‚Äúsoftware engineering‚Äù is in
common use, engineering disciplines involve the application
of both scientific and practical knowledge to the creation and
maintenance of better systems. As the available materials
change and as knowledge grows, so must engineers.
Haskell leverages more of the developments in program-
ming languages invented since ALGOL68 than most languages
in popular use, but with the added benefit of a mature imple-
mentation and sound design. Sometimes we hear Haskell be-
ing dismissed as ‚Äúacademic‚Äù because it is relatively up-to-date</p>
<p>CONTENTS xxxviii
with the current state of mathematics and computer science
research. In our view, that progress is good and helps us solve
practical problems in modern computing and software design.
Progress is possible and desirable, but it is not monotonic or
inevitable. The history of the world is riddled with examples
of uneven progress. For example, it is estimated that scurvy
killed two million sailors between the years 1500 and 1800.
Western culture has forgotten the cure for scurvy multiple
times. As early as 1614, the Surgeon General of the East In-
dia Company recommended bringing citrus on voyages for
scurvy. It saved lives, but the understanding of whycitrus
cured scurvy was incorrect. This led to the use of limes, which
have a lower vitamin C content than lemons, and scurvy re-
turned until ascorbic acid was discovered in 1932. Indiscipline
and stubbornness (the British Navy stuck with limes despite
sailors continuing to die from scurvy) can hold back progress.
We‚Äôd rather have a doctor who is willing to understand that
he makes mistakes, will be responsive to new information,
and even actively seek to expand his understanding rather
than one that hunkers down with a pet theory informed by
anecdote.
There are other ways to prevent scurvy, just as there are
other programming languages you can use to write software.
Or perhaps you are an explorer who doesn‚Äôt believe scurvy
can happen to you. But packing lemons provides some in-
surance on those long voyages. Similarly, having Haskell in</p>
<p>CONTENTS xxxix
your toolkit, even when it‚Äôs not your only tool, provides type
safety and predictability that can improve your software devel-
opment. Buggy software might not literally make your teeth
fall out, but software problems are far from trivial, and when
there are better ways to solve those problems ‚Äî not perfect,
but better ‚Äî it‚Äôs worth your time to investigate them.
Set your limes aside for now, and join us at the lemonade
stand.
What‚Äôs in this book?
This book is more of a course than a book, something to
be worked through. There are exercises sprinkled liberally
throughout the book; we encourage you to do them, even
when they seem simple. Those exercises are where the major-
ity of your epiphanies will come from. No amount of chatter-
ing, no matter how well structured and suited to your temper-
ament, will be as eÔ¨Äective as doing the work . If you do get to
a later chapter and find you did not understand a concept or
structure well enough, you may want to return to an earlier
chapter and do more exercises until you understand it.
We believe that spaced repetition and iterative deepening
are eÔ¨Äective strategies for learning, and the structure of the
book reflects this. You may notice we mention something
only briefly at first, then return to it over and over. As your
experience with Haskell deepens, you have a base from which</p>
<p>CONTENTS xl
to move to a deeper level of understanding. Try not to worry
that you don‚Äôt understand something completely the first time
we mention it. By moving through the exercises and returning
to concepts, you can develop a solid intuition for functional
programming.
Theexercisesinthefirstfewchaptersaredesignedtorapidly
familiarize you with basic Haskell syntax and type signatures,
but you should expect exercises to grow more challenging
in each successive chapter. Where possible, reason through
the code samples and exercises in your head first, then type
them out ‚Äî either into the REPL5or into a source file ‚Äî and
check to see if you were right. This will maximize your ability
to understand and reason about programs and about Haskell.
Later exercises may be difficult. If you get stuck on an exercise
for an extended period of time, proceed and return to it at a
later date.
We cover a mix of practical and abstract matters required
to use Haskell for a wide variety of projects. Chris‚Äôs experience
is principally with production backend systems and frontend
web applications. Julie is a linguist and teacher by training
and education, and learning Haskell was her first experience
with computer programming. The educational priorities of
this book are biased by those experiences. Our goal is to help
5This is short for read-eval-print loop, an interactive programming shell that evaluates
expressions and returns results in the same environment. The REPL we‚Äôll be using is
called GHCi ‚Äî ‚Äòi‚Äô for ‚Äúinteractive.‚Äù</p>
<p>CONTENTS xli
you not just write typesafe functional code but to understand
it on a deep enough level that you can go from here to more
advanced Haskell projects in a variety of ways, depending on
your own interests and priorities.
Each chapter focuses on diÔ¨Äerent aspects of a particular
topic. We start with a short introduction to the lambda calcu-
lus. What does this have to do with programming? All modern
functional languages are based on the lambda calculus, and a
passing familiarity with it will help you down the road with
Haskell. If you‚Äôve understood the lambda calculus, under-
standing the feature known as currying will be a breeze, for
example.
The next few chapters cover basic expressions and functions
in Haskell, some simple operations with strings (text), and a few
essential types. You may feel a strong temptation, especially if
you have programmed previously, to skim or skip those first
chapters. Please do not do this. Even if those first chapters are
covering concepts you‚Äôre familiar with, it‚Äôs important to spend
time getting comfortable with Haskell‚Äôs terse syntax, making
sure you understand the diÔ¨Äerence between working in the
REPL and working in source files, and becoming familiar with
the compiler‚Äôs sometimes quirky error messages. Certainly
you may work quickly through those chapters ‚Äî just don‚Äôt
skip them.
From there, we build both outward and upward so that your
understanding of Haskell both broadens and deepens. When</p>
<p>CONTENTS xlii
you finish this book, you will not just know what monads
are, you will know how to use them eÔ¨Äectively in your own
programs and understand the underlying algebra involved.
We promise ‚Äî you will. We only ask that you do not go on to
write a monad tutorial on your blog that explains how monads
are really just like jalapeno poppers.
In each chapter you can expect:
‚Ä¢additions to your vocabulary of standard functions;
‚Ä¢syntactic patterns that build on each other;
‚Ä¢theoretical foundations so you understand how Haskell
works;
‚Ä¢illustrative examples of how to read Haskell code;
‚Ä¢step-by-step demonstrations of how to write your own
functions;
‚Ä¢explanations of how to read common error messages and
how to avoid those errors;
‚Ä¢exercises of varying difficulty sprinkled throughout;
‚Ä¢definitions of important terms.
We have put definitions at the end of most chapters. Each
term is, of course, defined within the body of the chapter, but</p>
<p>CONTENTS xliii
we added separate definitions at the end as a point of review.
If you‚Äôve taken some time oÔ¨Ä between one chapter and the
next, the definitions can remind you of what you have already
learned, and, of course, they may be referred to any time you
need a refresher.
There are also recommendations at the end of most chap-
ters for followup reading. They are certainly not required but
are resources we personally found accessible and helpful that
may help you learn more about topics covered in the chapter.
Best practices for examples and exercises
We have tried to include a variety of examples and exercises in
each chapter. While we have made every eÔ¨Äort to include only
exercises that serve a clear pedagogical purpose, we recognize
that not all individuals enjoy or learn as much from every
type of demonstration or exercise. Also, since our readers
will necessarily come to the book with diÔ¨Äerent backgrounds,
some exercises may seem too easy or difficult to you but be
just right for someone else. Do your best to work through
as many exercises as seems practical for you. But if you skip
all the types and typeclasses exercises and then find yourself
confused when we get to Monoid, by all means, come back
and do more exercises until you understand.
Here are a few things to keep in mind to get the most out
of them:</p>
<p>CONTENTS xliv
‚Ä¢Examples are usually designed to demonstrate, with real
code, what we‚Äôve just talked or are about to talk about in
further detail.
‚Ä¢You are intended to typeall of the examples into the REPL
or a file and load them. We strongly encourage you to
attempt to modify the example and play with the code af-
ter you‚Äôve made it work. Forming hypotheses about what
eÔ¨Äect changes will have and verifying them is critical! It
is better to type the code examples and exercises yourself
rather than copy and paste because typing makes you pay
more attention to it.
‚Ä¢Sometimes the examples are designed intentionally to be
broken. Check surrounding prose if you‚Äôre confused by
an unexpected error as we will not show you code that
doesn‚Äôt work without commenting on the breakage. If it‚Äôs
still broken and it‚Äôs not supposed to be, you should start
checking your syntax and formatting for errors.
‚Ä¢Not every example is designed to be entered into the
REPL; not every example is designed to be entered into
a file. Once we have explained the syntactic diÔ¨Äerences
between files and REPL expressions, you are expected to
perform the translation between the two yourself. You
should be accustomed to working with code in an interac-
tive manner by the time you finish the book. You‚Äôll want</p>
<p>CONTENTS xlv
to gradually move away from typing code examples and
exercises, except in limited cases, directly into GHCi and
develop the habit of working in source files. Editing and
modifying code, as you will be doing a lot as you rework
exercises, is easier and more practical in a source file. You
will still load your code into GHCi to run it.
‚Ä¢You may want to keep exercises, especially longer ones, as
named modules. There are several exercises, especially
later in the book, that we return to several times and being
able to reload the work you‚Äôve already done and add only
the new parts will save you a lot of time and grief. We
have tried to note some of the exercises where this will
be especially helpful.
‚Ä¢Exercises at the end of the chapter may include some re-
view questions covering material from previous chapters
and are more or less ordered from least to most challeng-
ing. Your mileage may vary.
‚Ä¢Even exercises that seem easy can increase your fluency
in a topic. We do not fetishize difficulty for difficulty‚Äôs
sake. We just want you to understand the topics as well
as possible. That can mean coming at the same problem
from diÔ¨Äerent angles.
‚Ä¢We ask you to write and then rewrite (using diÔ¨Äerent
syntax) a lot of functions. Few problems have only one</p>
<p>CONTENTS xlvi
possible solution, and solving the same problem in dif-
ferent ways increases your fluency and comfort with the
way Haskell works (its syntax, its semantics, and in some
cases, its evaluation order).
‚Ä¢Do not feel obligated to do all the exercises in a single
sitting or even in a first pass through the chapter. In fact,
spaced repetition is generally a more eÔ¨Äective strategy.
‚Ä¢Some exercises, particularly in the earlier chapters, may
seem very contrived. Well, they are. But they are con-
trived to pinpoint certain lessons. As the book goes on
and you have more Haskell under your belt, the exercises
become less contrived and more like ‚Äúreal Haskell.‚Äù
‚Ä¢Another benefit to writing code in a source file and then
loading it into the REPL is that you can write comments
about the process you went through in solving a problem.
Writing out your own thought process can clarify your
thoughts and make the solving of similar problems easier.
At the very least, you can refer back to your comments
and learn from yourself.
‚Ä¢Sometimes we intentionally underspecify function def-
initions. You‚Äôll commonly see things like:
f=undefined</p>
<p>CONTENTS xlvii
Even when ùëìwill probably take named arguments in your
implementation, we‚Äôre not going to name them for you.
Nobody will scaÔ¨Äold your code for you in your future
projects, so don‚Äôt expect this book to either.</p>
<p>Chapter 1
All You Need is Lambda
Even the greatest
mathematicians, the ones
that we would put into
our mythology of great
mathematicians, had to
do a great deal of leg
work in order to get to
the solution in the end.
Daniel Tammett
1</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 2
1.1 All You Need is Lambda
This chapter provides a very brief introduction to the lambda
calculus, a model of computation devised in the 1930s by
Alonzo Church. A calculus is a method of calculation or rea-
soning; the lambda calculus is one process for formalizing a
method. Like Turing machines, the lambda calculus formal-
izes the concept of eÔ¨Äective computability, thus determining
which problems, or classes of problems, can be solved.
You may be wondering where the Haskell is. You may be
contemplating skipping this chapter. You may feel tempted
to skip ahead to the fun stuÔ¨Ä when we build a project.
DON‚ÄôT.
We‚Äôre starting from first principles here so that when we
get around to building projects you know what you‚Äôre doing.
You don‚Äôt start building a house from the attic down; you start
from the foundation. Lambda calculus is your foundation,
because Haskell is a lambda calculus.
1.2 What is functional programming?
Functionalprogrammingisacomputerprogrammingparadigm
that relies on functions modeled on mathematical functions.
The essence of functional programming is that programs are
a combination of expressions . Expressions include concrete
values, variables, and also functions. Functions have a more</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 3
specific definition: they are expressions that are applied to
an argument or input, and once applied, can be reduced or
evaluated . In Haskell, and in functional programming more
generally, functions are first-class : they can be used as values
or passed as arguments, or inputs, to yet more functions. We‚Äôll
define these terms more carefully as we progress through the
chapter.
Functional programming languages are all based on the
lambda calculus. Some languages in this general category
incorporate features into the language that aren‚Äôt translatable
into lambda expressions. Haskell is a purefunctional language,
because it does not. We‚Äôll address this notion of purity more
later in the book, but it isn‚Äôt a judgment of the moral worth of
other languages.
The word purity in functional programming is sometimes
also used to mean what is more properly called referential
transparency . Referential transparency means that the same
function, given the same values to evaluate, will always return
the same result in pure functional programming, as they do
in math.
Haskell‚Äôs pure functional basis also lends it a high degree
of abstraction and composability. Abstraction allows you to
write shorter, more concise programs by factoring common,
repeated structures into more generic code that can be reused.
Haskell programs are built from separate, independent func-
tions, kind of like LEGO¬Æ: the functions are bricks that can be</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 4
assembled and reassembled.
These features also make Haskell‚Äôs syntax rather minimalist,
as you‚Äôll soon see.
1.3 What is a function?
If we step back from using the word ‚Äúlambda,‚Äù you most likely
already know what a function is. A function is a relation be-
tween a set of possible inputs and a set of possible outputs. The
function itself defines and represents the relationship. When
you apply a function such as addition to two inputs, it maps
those two inputs to an output ‚Äî the sum of those numbers.
For example, let‚Äôs imagine a function named ùëìthat defines
the following relations where the first value is the input and
the second is the output:
ùëì(1) = ùê¥
ùëì(2) = ùêµ
ùëì(3) = ùê∂
The input set is {1,2,3} and the output set is {ùê¥,ùêµ,ùê∂} .1A
crucial point about how these relations are defined: our hypo-
thetical function will always return the value ùê¥given the input
1‚Äî no exceptions!
1For those who would like precise terminology, the input set is known as the domain.
The set of possible outputs for the function is called the codomain. All domains and</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 5
In contrast, the following is nota valid function:
ùëì(1) = ùëã
ùëì(1) = ùëå
ùëì(2) = ùëç
This gets back to the referential transparency we mentioned
earlier: given the same input, the output should be predictable.
Is the following function valid?
ùëì(1) = ùê¥
ùëì(2) = ùê¥
ùëì(3) = ùê¥
Yes, having the same output for more than one input is valid.
Imagine, for example, that you need a function that tests a
positive integer for being less than 10. You‚Äôd want it to return
Truewhen the input was less than 10 and Falsefor all other
cases. In that case, several diÔ¨Äerent inputs will result in the
output True; many more will give a result of False. DiÔ¨Äerent
inputs can lead to the same output.
codomains are sets of unique values. The subset of the codomain that contains possible
outputs related to diÔ¨Äerent inputs is known as the image. The mapping between the
domain and the image or codomain need not be one-to-one; in some cases, multiple
input values will map to the same value in the image, as when a function returns either
‚Äòtrue‚Äô or ‚Äòfalse‚Äô so that many diÔ¨Äerent inputs map to each of those output values. However,
a given input should not map to multiple outputs.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 6
What matters here is that the relationship of inputs and
outputs is defined by the function, and that the output is pre-
dictable when you know the input and the function definition.
In the above examples, we didn‚Äôt demonstrate a relationship
between the inputs and outputs. Let‚Äôs look at an example that
does define the relationship. This function is again named ùëì:
ùëì(ùë•) = ùë•+1
This function takes one argument, which we have named
ùë•. The relationship between the input, ùë•, and the output is
described in the function body. It will add 1 to whatever value
ùë•is and return that result. When we apply this function to a
value, such as 1, we substitute the value in for ùë•:
ùëì(1) = 1+1
ùëìapplied to 1 equals 1 + 1. That tells us how to map the input
to an output: 1 added to 1 becomes 2:
ùëì(1) = 2
Understanding functions in this way ‚Äî as a mapping of a
set of inputs to a set of outputs ‚Äî is crucial to understanding
functional programming.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 7
1.4 The structure of lambda terms
The lambda calculus has three basic components, or lambda
terms: expressions, variables, and abstractions. The word ex-
pression refers to a superset of all those things: an expression
can be a variable name, an abstraction, or a combination of
those things. The simplest expression is a single variable. Vari-
ables here have no meaning or value; they are only names for
potential inputs to functions.
Anabstraction is afunction . It is a lambda term that has a
head (a lambda) and a body and is applied to an argument. An
argument is an input value.
Abstractions consist of two parts: the headand the body.
The head of the function is a ùúÜ(lambda) followed by a variable
name. The body of the function is another expression. So, a
simple function might look like this:
ùúÜùë•.ùë•
The variable named in the head is the parameter andbinds
all instances of that same variable in the body of the function.
That means, when we apply this function to an argument,
eachùë•in the body of the function will have the value of that
argument. We‚Äôll demonstrate this in the next section.
In the previous section, we were talking about functions
calledùëì, but the lambda abstraction ùúÜùë•.ùë•has no name. It is an</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 8
anonymous function . A named function can be called by name
by another function; an anonymous function cannot.
Let‚Äôs break down the basic structure:
Œª x . x
^‚îÄ‚î¨‚îÄ^
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ extent of the head of the lambda.
Œª x . x
^‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ the single parameter of the
function. This binds any
variables with the same name
in the body of the function.
Œª x . x
^‚îÄ‚îÄ body, the expression the lambda
returns when applied. This is a
bound variable.
The dot ( .) separates the parameters of the lambda from
the function body.
The abstraction as a whole has no name, but the reason
we call it an abstraction is that it is a generalization, or abstrac-
tion, from a concrete instance of a problem, and it abstracts
through the introduction of names. The names stand for con-
crete values, but by using named variables, we allow for the</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 9
possibility of applying the general function to diÔ¨Äerent values
(or, perhaps even values of diÔ¨Äerent types, as we‚Äôll see later).
When we apply the abstraction to arguments, we replace the
names with values, making it concrete.
Alpha equivalence
Often when people express this function in lambda calculus
you‚Äôll see something like
ùúÜùë•.ùë•
The variable ùë•here is not semantically meaningful except in
its role in that single expression. Because of this, there‚Äôs a form
of equivalence between lambda terms called alpha equivalence .
This is a way of saying that:
ùúÜùë•.ùë•
ùúÜùëë.ùëë
ùúÜùëß.ùëß
all mean the same thing. They‚Äôre all the same function.
Let‚Äôs look next at what happens when we apply this abstrac-
tion to a value.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 10
1.5 Beta reduction
When we apply a function to an argument, we substitute the
input expression for all instances of bound variables within
the body of the abstraction. You also eliminate the head of the
abstraction, since its only purpose was to bind a variable. This
process is called beta reduction .
Let‚Äôs use the function we had above:
ùúÜùë•.ùë•
We‚Äôll do our first beta reduction using a number.2We apply
the function above to 2, substitute 2 for each bound variable
in the body of the function, and eliminate the head:
(ùúÜùë•.ùë•) 2
2
The only bound variable is the single ùë•, so applying this
function to 2 returns 2. This function is the identity function.3
All it does is accept a single argument ùë•and return that same
argument. The ùë•has no inherent meaning, but, because it
is bound in the head of this function, when the function is
2The lambda calculus can derive numbers from lambda abstractions, rather than using
the numerals we are familiar with, but the applications can become quite cumbersome
and difficult to read.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 11
applied to an argument, all instances of ùë•within the function
body must have the same value.
Let‚Äôs use an example that mixes some arithmetic into our
lambda calculus. We use the parentheses here to clarify that
thebodyexpressionis ùë•+1. In otherwords, wearenotapplying
the function to the 1:
(ùúÜùë•.ùë•+1)
What is the result if we apply this abstraction to 2? How
about to 10?
Beta reduction is this process of applying a lambda term
to an argument, replacing the bound variables with the value
of the argument, and eliminating the head. Eliminating the
head tells you the function has been applied.
We can also apply our identity function to another lambda
abstraction:
(ùúÜùë•.ùë•)(ùúÜùë¶.ùë¶)
In this case, we‚Äôd substitute the entire abstraction in for ùë•.
We‚Äôll use a new syntax here, [ùë• ‚à∂= ùëß] , to indicate that ùëßwill be
substituted for all occurrences of ùë•(hereùëßis the function ùúÜùë¶.ùë¶).
We reduce this application like this:
3Note that this is the same as the identity function in mathematical notation: u?(u?) = u? .
One diÔ¨Äerence is that u?(u?) = u? is a declaration involving a function named u?while the
above lambda abstraction isa function.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 12
(ùúÜùë•.ùë•)(ùúÜùë¶.ùë¶)
[ùë• ‚à∂= (ùúÜùë¶.ùë¶)]
ùúÜùë¶.ùë¶
Our final result is another identity function. There is no
argument to apply it to, so we have nothing to reduce.
Once more, but this time we‚Äôll add another argument:
(ùúÜùë•.ùë•)(ùúÜùë¶.ùë¶)ùëß
Applications in the lambda calculus are left associative . That
is, unless specific parentheses suggest otherwise, they associate,
or group, to the left. So, this:
(ùúÜùë•.ùë•)(ùúÜùë¶.ùë¶)ùëß
can be rewritten as:
((ùúÜùë•.ùë•)(ùúÜùë¶.ùë¶))ùëß
Onward with the reduction:
((ùúÜùë•.ùë•)(ùúÜùë¶.ùë¶))ùëß
[ùë• ‚à∂= (ùúÜùë¶.ùë¶)]
(ùúÜùë¶.ùë¶)ùëß
[ùë¶ ‚à∂= ùëß]
ùëß</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 13
We can‚Äôt reduce this any further as there is nothing left to
apply, and we know nothing about ùëß.
We‚Äôll look at functions below that have multiple heads and
alsofree variables (that is, variables in the body that are not
bound by the head), but the basic process will remain the same.
The process of beta reduction stops when there are either no
more heads, or lambdas, left to apply or no more arguments
to apply functions to. A computation therefore consists of an
initial lambda expression (or two, if you want to separate the
function and its input) plus a finite sequence of lambda terms,
each deduced from the preceding term by one application of
beta reduction. We keep following the rules of application,
substituting arguments in for bound variables until there are
no more heads left to evaluate or no more arguments to apply
them to.
Free variables
The purpose of the head of the function is to tell us which
variables to replace when we apply our function, that is, to
bind the variables. A bound variable must have the same value
throughout the expression.
But sometimes the body expression has variables that are
not named in the head. We call those variables free variables .
In the following expression:</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 14
ùúÜùë•.ùë•ùë¶
Theùë•in the body is a bound variable because it is named in
the head of the function, while the ùë¶is a free variable because
it is not. When we apply this function to an argument, nothing
can be done with the ùë¶. It remains irreducible.
That whole abstraction can be applied to an argument, ùëß,
like this: (ùúÜùë•.ùë•ùë¶)ùëß . We‚Äôll show an intermediate step, using the
:=syntax we introduced above, that most lambda calculus
literature does not show:
1.(ùúÜùë•.ùë•ùë¶)ùëß
We apply the lambda to the argument ùëß.
2.(ùúÜ[ùë• ‚à∂= ùëß].ùë•ùë¶)
Sinceùë•is the bound variable, all instances of ùë•in the body
of the function will be replaced with ùëß. The head will be
eliminated, and we replace any ùë•in the body with a ùëß.
3.ùëßùë¶
The head has been applied away, and there are no more
heads or bound variables. Since we know nothing about
ùëßorùë¶, we can reduce this no further.
Note that alpha equivalence does not apply to free vari-
ables. That is, ùúÜùë•.ùë•ùëßandùúÜùë•.ùë•ùë¶are not equivalent because ùëß
andùë¶might be diÔ¨Äerent things. However, ùúÜùë•ùë¶.ùë¶ùë• andùúÜùëéùëè.ùëèùëé</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 15
are equivalent due to alpha equivalence, as are ùúÜùë•.ùë•ùëßandùúÜùë¶.ùë¶ùëß
because the free variable is left alone.
1.6 Multiple arguments
Each lambda can only bind one parameter and can only accept
one argument. Functions that require multiple arguments
have multiple, nested heads. When you apply it once and
eliminate the first (leftmost) head, the next one is applied and
so on. This formulation was originally discovered by Moses
Sch√∂nfinkel in the 1920s but was later rediscovered and named
after Haskell Curry and is commonly called currying .
What we mean by this description is that the following:
ùúÜùë•ùë¶.ùë•ùë¶
is a convenient shorthand for two nested lambdas (one for
each argument, ùë•andùë¶):
ùúÜùë•.(ùúÜùë¶.ùë•ùë¶)
When you apply the first argument, you‚Äôre binding ùë•, elimi-
nating the outer lambda, and have ùúÜùë¶.ùë•ùë¶with x being whatever
the outer lambda was bound to.
To try to make this a little more concrete, let‚Äôs suppose
that we apply these lambdas to specific values. First, a simple
example with the identity function:</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 16
1.ùúÜùë•.ùë•
2.(ùúÜùë•.ùë•) 1
3.[ùë• ‚à∂= 1]
4.1
Now let‚Äôs look at a ‚Äúmultiple‚Äù argument lambda:
1.ùúÜùë•ùë¶.ùë•ùë¶
2.(ùúÜùë•ùë¶.ùë•ùë¶) 1 2
3.(ùúÜùë•.(ùúÜùë¶.ùë•ùë¶)) 1 2
4.[ùë• ‚à∂= 1]
5.(ùúÜùë¶.1ùë¶) 2
6.[ùë¶ ‚à∂= 2]
7.1 2
That wasn‚Äôt too interesting because it‚Äôs like nested identity
functions! We can‚Äôt meaningfully apply a 1 to a 2. Let‚Äôs try
something diÔ¨Äerent:
1.ùúÜùë•ùë¶.ùë•ùë¶
2.(ùúÜùë•ùë¶.ùë•ùë¶)(ùúÜùëß.ùëé) 1</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 17
3.(ùúÜùë•.(ùúÜùë¶.ùë•ùë¶))(ùúÜùëß.ùëé) 1
4.[ùë• ‚à∂= (ùúÜùëß.ùëé)]
5.(ùúÜùë¶.(ùúÜùëß.ùëé)ùë¶) 1
6.[ùë¶ ‚à∂= 1]
7.(ùúÜùëß.ùëé) 1 We still can apply this one more time.
8.[ùëß ‚à∂= 1] But there is no ùëßin the body of the function, so
there is nowhere to put a 1. We eliminate the head, and
the final result is
9.ùëé
It‚Äôs more common in academic lambda calculus materi-
als to refer to abstract variables rather than concrete values.
The process of beta reduction is the same, regardless. The
lambda calculus is a process or method, like a game with a few
simple rules for transforming lambdas, but no specific mean-
ing. We‚Äôve introduced concrete values to make the reduction
somewhat easier to see.
The next example uses only abstract variables. Due to al-
pha equivalence, you sometimes see expressions in lambda
calculus literature such as:
(ùúÜùë•ùë¶.ùë•ùë•ùë¶)(ùúÜùë•.ùë•ùë¶)(ùúÜùë•.ùë•ùëß)</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 18
The substitution process can become a tangle of ùë•s that are
not the same ùë•because each was bound by a diÔ¨Äerent head. To
help make the reduction easier to read we‚Äôre going to use dif-
ferent variables in each abstraction, but it‚Äôs worth emphasizing
that the name of the variable (the letter) has no meaning or
significance:
1.(ùúÜùë•ùë¶ùëß.ùë•ùëß(ùë¶ùëß))(ùúÜùëöùëõ.ùëö)(ùúÜùëù.ùëù)
2.(ùúÜùë•.ùúÜùë¶.ùúÜùëß.ùë•ùëß(ùë¶ùëß))(ùúÜùëö.ùúÜùëõ.ùëö)(ùúÜùëù.ùëù)
We‚Äôve not reduced or applied anything here, but made
the currying explicit.
3.(ùúÜùë¶.ùúÜùëß.(ùúÜùëö.ùúÜùëõ.ùëö)ùëß(ùë¶ùëß))(ùúÜùëù.ùëù)
Ourfirstreductionstepwastoapplytheoutermostlambda,
which was binding the ùë•, to the first argument, (ùúÜùëö.ùúÜùëõ.ùëö) .
4.ùúÜùëß.(ùúÜùëö.ùúÜùëõ.ùëö)(ùëß)((ùúÜùëù.ùëù)ùëß)
We applied the ùë¶and replaced the single occurrence of
ùë¶with the next argument, the term ùúÜùëù.ùëù. The outermost
lambda binding ùëßis, at this point, irreducible because it
has no argument to apply to. What remains is to go inside
the terms one layer at a time until we find something
reducible.
5.ùúÜùëß.(ùúÜùëõ.ùëß)((ùúÜùëù.ùëù)ùëß)
We can apply the lambda binding ùëöto the argument ùëß.
We keep searching for terms we can apply. The next thing</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 19
we can apply is the lambda binding ùëõto the lambda term
((ùúÜùëù.ùëù)ùëß) .
6.ùúÜùëß.ùëß
In the final step, the reduction takes a turn that might look
slightly odd. Here the outermost, leftmost reducible term
isùúÜùëõ.ùëßapplied to the entirety of ((ùúÜùëù.ùëù)ùëß) . As we saw in
an example above, it doesn‚Äôt matter what ùëõgot bound to,
ùúÜùëõ.ùëßunconditionally tosses the argument and returns ùëß.
So, we are left with an irreducible lambda expression.
Intermission: Equivalence Exercises
We‚Äôll give you a lambda expression. Keeping in mind both
alpha equivalence and how multiple heads are nested, choose
an answer that is equivalent to the listed lambda term.
1.ùúÜùë•ùë¶.ùë•ùëß
a)ùúÜùë•ùëß.ùë•ùëß
b)ùúÜùëöùëõ.ùëöùëß
c)ùúÜùëß.(ùúÜùë•.ùë•ùëß)
2.ùúÜùë•ùë¶.ùë•ùë•ùë¶
a)ùúÜùëöùëõ.ùëöùëõùëù
b)ùúÜùë•.(ùúÜùë¶.ùë•ùë¶)</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 20
c)ùúÜùëé.(ùúÜùëè.ùëéùëéùëè)
3.ùúÜùë•ùë¶ùëß.ùëßùë•
a)ùúÜùë•.(ùúÜùë¶.(ùúÜùëß.ùëß))
b)ùúÜùë°ùëúùë†.ùë†ùë°
c)ùúÜùëöùëõùëù.ùëöùëõ
1.7 Evaluation is simplification
There are multiple normal forms in lambda calculus, but here
when we refer to normal form we mean beta normal form . Beta
normalformiswhenyoucannotbetareduce(applylambdasto
arguments) the terms any further. This corresponds to a fully
evaluated expression, or, in programming, a fully executed
program. This is important to know so that you know when
you‚Äôre done evaluating an expression. It‚Äôs also valuable to have
an appreciation for evaluation as a form of simplification when
you get to the Haskell code as well.
Don‚Äôt be intimidated by calling the reduced form of an
expression its normal form. When you want to say ‚Äú2,‚Äù do
you say 2000/1000 each time or do you say 2? The expression
2000/1000 is not fully evaluated because the division function
has been fully applied (two arguments), so it could be reduced,
or evaluated. In other words, there‚Äôs a simpler form it can be</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 21
reduced to ‚Äî the number two. The normal form, therefore,
is 2.
The point is that if you have a function, such as (/), satu-
rated (all arguments applied) but you haven‚Äôt yet simplified it
to the final result then it is not fully evaluated, only applied.
Application is what makes evaluation/simplification possible.
Similarly, the normal form of the following is 600:
(10+2)‚àó100/2
We cannot reduce the number 600 any further. There are
no more functions that we can beta reduce. Normal form
means there is nothing left that can be reduced.
The identity function, ùúÜùë•.ùë•, is fully reduced (that is, in nor-
mal form) because it hasn‚Äôt yet been applied to anything. How-
ever,(ùúÜùë•.ùë•)ùëß isnotin beta normal form because the identity
function hasn‚Äôt been applied to a free variable ùëßand hasn‚Äôt
been reduced. If we did reduce it, the final result, in beta
normal form, would be ùëß.
1.8 Combinators
A combinator is a lambda term with no free variables. Combi-
nators, as the name suggests, serve only to combine the argu-
ments they are given.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 22
So the following are combinators because every term in the
body occurs in the head:
1.ùúÜùë•.ùë•
ùë•is the only variable and is bound because it is bound by
the enclosing lambda.
2.ùúÜùë•ùë¶.ùë•
3.ùúÜùë•ùë¶ùëß.ùë•ùëß(ùë¶ùëß)
And the following are not because there‚Äôs one or more free
variables:
1.ùúÜùë¶.ùë•
Hereùë¶is bound (it occurs in the head of the lambda) but
ùë•is free.
2.ùúÜùë•.ùë•ùëß
ùë•is bound and is used in the body, but ùëßis free.
We won‚Äôt have a lot to say about combinators per se. The
point is to call out a special class of lambda expressions that
canonlycombine the arguments it is given, without injecting
any new values or random data.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 23
1.9 Divergence
Not all reducible lambda terms reduce neatly to a beta normal
form. This isn‚Äôt because they‚Äôre already fully reduced, but
rather because they diverge . Divergence here means that the
reduction process never terminates or ends. Reducing terms
should ordinarily converge to beta normal form, and diver-
gence is the opposite of convergence, or normal form. Here‚Äôs
an example of a lambda term called omega that diverges:
1.(ùúÜùë•.ùë•ùë•)(ùúÜùë•.ùë•ùë•)
ùë•in the first lambda‚Äôs head becomes the second lambda
2.([ùë• ‚à∂= (ùúÜùë•.ùë•ùë•)]ùë•ùë•)
Using[ùë£ùëéùëü ‚à∂= ùëíùë•ùëùùëü] to denote what ùë•has been bound to.
3.(ùúÜùë•.ùë•ùë•)(ùúÜùë•.ùë•ùë•)
Substituting (ùúÜùë•.ùë•ùë•) for each occurence of ùë•. We‚Äôre back
to where we started and this reduction process never ends
‚Äî we can say omega diverges.
This matters in programming because terms that diverge
are terms that don‚Äôt produce an answer or meaningful result.
Understanding what will terminate means understanding what
programs will do useful work and return the answer we want.
We‚Äôll cover this idea more later.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 24
1.10 Summary
The main points you should take away from this chapter are:
‚Ä¢Functional programming is based on expressions that in-
clude variables or constant values, expressions combined
with other expressions, and functions.
‚Ä¢Functions have a head and a body and are those expres-
sions that can be applied to arguments and reduced, or
evaluated, to a result.
‚Ä¢Variables may be bound in the function declaration, and
every time a bound variable shows up in a function, it has
the same value.
‚Ä¢All functions take one argument and return one result.
‚Ä¢Functions are a mapping of a set of inputs to a set of
outputs. Given the same input, they always return the
same result.
These things all apply to Haskell, as they do to any pure
functional languages, because semantically Haskell is a lambda
calculus. Haskell is a typedlambda calculus ‚Äî more on types
later ‚Äî with a lot of surface-level decoration sprinkled on top,
to make it easier for humans to write, but the semantics of the
core language are the same as the lambda calculus. That is,</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 25
the meaning of Haskell programs is centered around evaluat-
ing expressions rather than executing instructions, although
Haskell has a way to execute instructions, too. We will still
be making reference to the lambda calculus when we write
about all the later, apparently very complex topics: function
composition, monads, parser combinators. Don‚Äôt worry if you
don‚Äôt know those words yet. If you understood this chapter,
you have the foundation you need to understand them all.
1.11 Chapter Exercises
We‚Äôre going to do the following exercises a bit diÔ¨Äerently than
what you‚Äôll see in the rest of the book, as we will be providing
some answers and explanations for the questions below.
Combinators Determine if each of the following are combi-
nators or not.
1.ùúÜùë•.ùë•ùë•ùë•
2.ùúÜùë•ùë¶.ùëßùë•
3.ùúÜùë•ùë¶ùëß.ùë•ùë¶(ùëßùë•)
4.ùúÜùë•ùë¶ùëß.ùë•ùë¶(ùëßùë•ùë¶)
5.ùúÜùë•ùë¶.ùë•ùë¶(ùëßùë•ùë¶)</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 26
Normal form or diverge? Determine if each of the following
can be reduced to a normal form or if they diverge.
1.ùúÜùë•.ùë•ùë•ùë•
2.(ùúÜùëß.ùëßùëß)(ùúÜùë¶.ùë¶ùë¶)
3.(ùúÜùë•.ùë•ùë•ùë•)ùëß
Beta reduce Evaluate (that is, beta reduce) each of the fol-
lowing expressions to normal form. We strongly recommend
writing out the steps on paper with a pencil or pen.
1.(ùúÜùëéùëèùëê.ùëêùëèùëé)ùëßùëß(ùúÜùë§ùë£.ùë§)
2.(ùúÜùë•.ùúÜùë¶.ùë•ùë¶ùë¶)(ùúÜùëé.ùëé)ùëè
3.(ùúÜùë¶.ùë¶)(ùúÜùë•.ùë•ùë•)(ùúÜùëß.ùëßùëû)
4.(ùúÜùëß.ùëß)(ùúÜùëß.ùëßùëß)(ùúÜùëß.ùëßùë¶)
Hint: alpha equivalence.
5.(ùúÜùë•.ùúÜùë¶.ùë•ùë¶ùë¶)(ùúÜùë¶.ùë¶)ùë¶
6.(ùúÜùëé.ùëéùëé)(ùúÜùëè.ùëèùëé)ùëê
7.(ùúÜùë•ùë¶ùëß.ùë•ùëß(ùë¶ùëß))(ùúÜùë•.ùëß)(ùúÜùë•.ùëé)</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 27
1.12 Answers
Please note: At this time, this is the only chapter in the book for
which we have provided answers. We provide them here due
to the importance of being able to check your understanding
of this material and the relative difficulty of checking answers
that you probably wrote by hand in a notebook.
Equivalence Exercises
1.b
2.c
3.b
Combinators
1.ùúÜùë•.ùë•ùë•ùë• is indeed a combinator, it refers only to the variable
x which is introduced as an argument.
2.ùúÜùë•ùë¶.ùëßùë• is not a combinator, the variable z was not intro-
duced as an argument and is thus a free variable.
3.ùúÜùë•ùë¶ùëß.ùë•ùë¶(ùëßùë•) is a combinator, all terms are bound. The head
isùúÜùë•ùë¶ùëß.and the body is ùë•ùë¶(ùëßùë•). None of the arguments in
the head have been applied so it‚Äôs irreducible. The vari-
ables x, y, and z are all bound in the head and are not free.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 28
This makes the lambda a combinator - no occurrences of
free variables.
4.ùúÜùë•ùë¶ùëß.ùë•ùë¶(ùëßùë•ùë¶) is a combinator. The lambda has the head
ùúÜùë•ùë¶ùëß.and the body: ùë•ùë¶(ùëßùë•ùë¶) . Again, none of the arguments
have been applied so it‚Äôs irreducible. All that is diÔ¨Äerent
is that the bound variable y is referenced twice rather
than once. There are still no free variables so this is also a
combinator.
5.ùúÜùë•ùë¶.ùë•ùë¶(ùëßùë•ùë¶) is not a combinator, z is free. Note that z isn‚Äôt
bound in the head.
Normal form or diverge?
1.ùúÜùë•.ùë•ùë•ùë• doesn‚Äôt diverge, has no further reduction steps. If
it had been applied to itself, it would diverge, but by itself
does not as it is already in normal form.
2.(ùúÜùëß.ùëßùëß)(ùúÜùë¶.ùë¶ùë¶) diverges, it never reaches a point where the
reduction is done. This is the omega term we showed you
earlier, with diÔ¨Äerent names for the bindings. It‚Äôs alpha
equivalent to(ùúÜùë•.ùë•ùë•)(ùúÜùë•.ùë•ùë•) .
3.(ùúÜùë•.ùë•ùë•ùë•)ùëß doesn‚Äôt diverge, it reduces to ùëßùëßùëß.
Betareduce Thefollowingareevaluatedin normalorder , which
is where terms in the outer-most and left-most positions get</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 29
evaluated (applied) first. This means that if all terms are in
the outermost position (none are nested), then it‚Äôs left-to-right
application order.
1.(ùúÜùëéùëèùëê.ùëêùëèùëé)ùëßùëß(ùúÜùë§ùë£.ùë§)
(ùúÜùëé.ùúÜùëè.ùúÜùëê.ùëêùëèùëé)(ùëß)ùëß(ùúÜùë§.ùúÜùë£.ùë§)
(ùúÜùëè.ùúÜùëê.ùëêùëèùëß)(ùëß)(ùúÜùë§.ùúÜùë£.ùë§)
(ùúÜùëê.ùëêùëßùëß)(ùúÜùë§.ùúÜùë£.ùë§)
(ùúÜùë§.ùúÜùë£.ùë§)(ùëß)ùëß
(ùúÜùë£.ùëß)(ùëß)
ùëß
2.(ùúÜùë•.ùúÜùë¶.ùë•ùë¶ùë¶)(ùúÜùëé.ùëé)ùëè
(ùúÜùë¶(ùúÜùëé.ùëé)ùë¶ùë¶)(ùëè)
(ùúÜùëé.ùëé)(ùëè)ùëè
ùëèùëè
3.(ùúÜùë¶.ùë¶)(ùúÜùë•.ùë•ùë•)(ùúÜùëß.ùëßùëû)
(ùúÜùë•.ùë•ùë•)(ùúÜùëß.ùëßùëû)
(ùúÜùëß.ùëßùëû)(ùúÜùëß.ùëßùëû)
(ùúÜùëß.ùëßùëû)(ùëû)
ùëûùëû
4.(ùúÜùëß.ùëß)(ùúÜùëß.ùëßùëß)(ùúÜùëß.ùëßùë¶)
(ùúÜùëß.ùëßùëß)(ùúÜùëß.ùëßùë¶)
(ùúÜùëß.ùëßùë¶)(ùúÜùëß.ùëßùë¶)
(ùúÜùëß.ùëßùë¶)(ùë¶)
ùë¶ùë¶</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 30
5.(ùúÜùë•.ùúÜùë¶.ùë•ùë¶ùë¶)(ùúÜùë¶.ùë¶)ùë¶
(ùúÜùë¶(ùúÜùë¶.ùë¶)ùë¶ùë¶)(ùë¶)
(ùúÜùë¶.ùë¶)(ùë¶)ùë¶
ùë¶ùë¶
6.(ùúÜùëé.ùëéùëé)(ùúÜùëè.ùëèùëé)ùëê
(ùúÜùëè.ùëèùëé)(ùúÜùëè.ùëèùëé)ùëê
(ùúÜùëè.ùëèùëé)(ùëé)ùëê
ùëéùëéùëê
7.Steps we took
a)(ùúÜùë•ùë¶ùëß.ùë•ùëß(ùë¶ùëß))(ùúÜùë•.ùëß)(ùúÜùë•.ùëé)
b)(ùúÜùë•.ùúÜùë¶.ùúÜùëß.ùë•ùëß(ùë¶ùëß))(ùúÜùë•.ùëß)(ùúÜùë•.ùëé)
c)(ùúÜùë¶.ùúÜùëß1(ùúÜùë•.ùëß)ùëß1(ùë¶ùëß1))(ùúÜùë•.ùëé)
d)(ùúÜùëß1.(ùúÜùë•.ùëß)(ùëß1)((ùúÜùë•.ùëé)ùëß1))
e)(ùúÜùëß1.ùëß((ùúÜùë•.ùëé)(ùëß1)))
f)(ùúÜùëß1.ùëßùëé) Theùëß1notation allows us to distinguish two
variables named ùëßthat came from diÔ¨Äerent places.
One is bound by the first head; the second is a free
variable in the second lambda expression.
How we got there, step by step
a)Our expression we‚Äôll reduce.
b)Add the implied lambdas to introduce each argument.</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 31
c)Apply the leftmost ùë•and bind it to (ùúÜùë•.ùëß), rename
leftmost ùëßtoùëß1for clarity to avoid confusion with the
other z. Hereafter, ‚Äúz‚Äù is exclusively the z in (ùúÜùë•.ùëß).
d)Applyùë¶, it gets bound to (ùúÜùë•.ùëé).
e)Can‚Äôt apply z1 to anything, evaluation strategy is nor-
mal order so leftmost outermost is the order of the
day. Our leftmost, outermost lambda has no remain-
ing arguments to be applied so we now examine the
terms nested within to see if they are in normal form.
(ùúÜùë•.ùëß)gets applied to ùëß1, tosses the ùëß1away and returns
ùëß.ùëßis now being applied to ((ùúÜùë•.ùëé)(ùëß1)) .
f)Cannot reduce ùëßfurther, it‚Äôs free and we know noth-
ing, so we go inside yet another nesting and reduce
((ùúÜùë•.ùëé)(ùëß1)) .ùúÜùë•.ùëégets applied to ùëß1, but tosses it away
and returns the free variable ùëé. Theùëéis now part of
the body of that expression. All of our terms are in
normal order now.
1.13 Definitions
1.Thelambda in lambda calculus is the greek letter ùúÜused
to introduce, or abstract, arguments for binding in an
expression.
2.A lambda abstraction is an anonymous function or lambda</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 32
term.
(ùúÜùë•.ùë•+1)
The head of the expression, ùúÜùë•., abstracts out the term
ùë•+1. We can apply it to any ùë•and recompute diÔ¨Äerent
results for each ùë•we applied the lambda to.
3.Application is how one evaluates or reduces lambdas, this
binds the argument to whatever the lambda was applied
to. Computations are performed in lambda calculus by
applying lambdas to arguments until you run out of ar-
guments to apply lambdas to.
(ùúÜùë•.ùë•)1
This example reduces to 1, the identity ùúÜùë•.ùë•was applied
to the value 1,ùë•was bound to 1, and the lambda‚Äôs body is
ùë•, so it just kicks the 1out. In a sense, applying the ùúÜùë•.ùë•
consumed it. Wereduced the amount of structure we had.
4.Lambda calculus is a formal system for expressing pro-
grams in terms of abstraction and application.
5.Normal order is a common evaluation strategy in lambda
calculi. Normal order means evaluating (ie, applying or
beta reducing) the leftmost outermost lambdas first, eval-
uating terms nested within after you‚Äôve run out of argu-
ments to apply. Normal order isn‚Äôt how Haskell code is
evaluated - it‚Äôs call-by-need instead. We‚Äôll explain this more</p>
<p>CHAPTER 1. ANYTHING FROM ALMOST NOTHING 33
later. Answers to the evaluation exercises were written in
normal order.
1.14 Follow-up resources
These are optional and intended only to oÔ¨Äer suggestions on
how you might deepen your understanding of the preceding
topic. Ordered approximately from most approachable to
most thorough.
1.Raul Rojas. A Tutorial Introduction to the Lambda Calcu-
lus
http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf
2.Henk Barendregt; Erik Barendsen. Introduction to
Lambda Calculus
http://www.cse.chalmers.se/research/group/logic/
TypesSS05/Extra/geuvers.pdf
3.Jean-Yves Girard; P. Taylor; Yves Lafon. Proofs and Types
http://www.paultaylor.eu/stable/prot.pdf</p>
<p>Chapter 2
Hello, Haskell!
Functions are beacons of
constancy in a sea of
turmoil.
Mike Hammond
34</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 35
2.1 Hello, Haskell
Welcome to your first step in learning Haskell. Before you be-
gin with the main course of this book, you will need to install
the necessary tools in order to complete the exercises as you
work through the book. At this time, we recommend installing
Stack, which will install GHC Haskell, the interactive environ-
ment called GHCi, and a project build tool and dependency
manager all at once.
You can find the installation instructions online at http://
docs.haskellstack.org/en/stable/README/ , and there is also great
documentation that can help you get started using Stack. You
can also find installation instructions at https://github.com/
bitemyapp/learnhaskell ; there you will also find advice on learn-
ing Haskell and links to more exercises that may supplement
what you‚Äôre doing with this book.
Therestofthischapterwillassumethatyouhavecompleted
the installation and are ready to begin working. In this chapter,
you will
‚Ä¢use Haskell code in the interactive environment and also
from source files;
‚Ä¢understand the building blocks of Haskell: expressions
and functions;</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 36
‚Ä¢learn some features of Haskell syntax and conventions of
good Haskell style;
‚Ä¢modify simple functions.
2.2 Interacting with Haskell code
Haskell oÔ¨Äers two primary ways of working with code. The
first is inputting it directly into the interactive environment
known as GHCi, or the REPL. The second is typing it into a
text editor, saving, and then loading that source file into GHCi.
This section oÔ¨Äers an introduction to each method.
Using the REPL
REPL is an acronym short for read-eval-print loop . REPLs are
interactive programming environments where you can input
code, have it evaluated, and see the result. They originated
with Lisp but are now common to modern programming
languages including Haskell.
Assuming you‚Äôve completed your installation, you should
be able to open your terminal or command prompt, type ghci
orstack ghci1, hit enter, and see something like the following:
GHCi, version 7.10.3:
1If you have installed GHC outside of Stack, then you should be able to open it with
just the ghcicommand, but if your only GHC installation is what Stack installed, then you
will need stack ghci .</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 37
http://www.haskell.org/ghc/ :? for help
Prelude&gt;
Ifyouused stack ghci2therewasprobablyalotmorestartup
text, and the prompt might be something other than Prelude .
That‚Äôs all fine. You may also have a diÔ¨Äerent version of GHC.
As long as your GHC version is between 7.8 and 8.0, it should
be compatible with everything in this book.
Now try entering some simple arithmetic at your prompt:
Prelude&gt; 2 + 2
4
Prelude&gt; 7 &lt; 9
True
Prelude&gt; 10 ^ 2
100
If you can enter simple equations at the prompt and get the
expected results, congratulations ‚Äî you are now a functional
programmer! More to the point, your REPL is working well
and you are ready to proceed.
To exit GHCi, use the command :quitor:q.
What is Prelude ?Prelude is a library of standard functions.
Opening GHCi or Stack GHCi automatically loads those func-
2At this point in the book, you don‚Äôt need to use stack ghci , but in later chapters when
we‚Äôre importing a lot of modules and building projects, it will be much more convenient
to use it.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 38
tions so they can be used without needing to do anything
special. You can turn Prelude oÔ¨Ä, as we will show you later, and
there are alternative preludes, though we won‚Äôt use them in
the book. Prelude is contained in Haskell‚Äôs basepackage, which
can be found at https://www.stackage.org/package/base . You‚Äôll
see us mention sometimes that something or other is ‚Äúin base‚Äù
which means it‚Äôs contained in that large standard package.
GHCi commands
Throughout the book, we‚Äôll be using GHCi commands, such
as:quitand:infoin the REPL. Special commands that only
GHCi understands begin with the :character. :quitisnot
Haskell code; it‚Äôs just a GHCi feature.
We will present them in the text spelled out, but they can
generally be abbreviated to just the colon and the first letter.
That is, :quitbecomes :q,:infobecomes :iand so forth. It‚Äôs
good to type the word out the first few times you use it, to help
you remember what the abbreviation stands for, but after a
few mentions, we will start abbreviating them.
Working from source files
As nice as REPLs are, usually you want to store code in a file
so you can build it incrementally. Almost all nontrivial pro-
gramming you do will involve editing libraries or applications
made of nested directories containing files with Haskell code</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 39
in them. The basic process is to have the code and imports
(more on that later) in a file, load it into the REPL, and interact
with it there as you‚Äôre building, modifying, and testing it.
You‚Äôll need a file named test.hs . The.hsfile extension de-
notes a Haskell source code file. Depending on your setup and
the workflow you‚Äôre comfortable with, you can make a file by
that name and then open it in your text editor or you can open
your text editor, open a new file, and then save the file with
that file name.
Then enter the following code into the file and save it:
sayHello ::String-&gt;IO()
sayHello x=
putStrLn ( &quot;Hello, &quot; ++x++&quot;!&quot;)
Here,::is a way to write down a type signature. You can
think of it as saying hasthetype . So,sayHello has the type String
-&gt; IO () . These first chapters are focused on syntax, and we‚Äôll
talk about types in a later chapter.
Theninthesamedirectorywhereyou‚Äôvestoredyour test.hs
file, open your ghciREPL and do the following:
Prelude&gt; :load test.hs
Prelude&gt; sayHello &quot;Haskell&quot;
Hello, Haskell!
Prelude&gt;</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 40
After using :loadto load your test.hs , thesayHello function
is visible in the REPL and you can pass it a string argument,
such as ‚ÄúHaskell‚Äù (note the quotation marks), and see the out-
put.
You may notice that after loading code from a source file,
the GHCi prompt is no longer Prelude&gt; . To return to the
Prelude&gt; prompt, usethecommand :m, whichisshortfor :module .
This will unload the file from GHCi, so the code in that file
will no longer be in scope in your REPL.
2.3 Understanding expressions
Everything in Haskell is an expression or declaration. Expres-
sionsmay be values, combinations of values, and/or functions
applied to values. Expressions evaluate to a result. In the case
of a literal value, the evaluation is trivial as it only evaluates
to itself. In the case of an arithmetic equation, the evaluation
process is the process of computing the operator and its ar-
guments, as you might expect. But, even though not all of
your programs will be about doing arithmetic, all of Haskell‚Äôs
expressions work in a similar way, evaluating to a result in a
predictable, transparent manner. Expressions are the building
blocks of our programs, and programs themselves are one big
expression made of smaller expressions.
Regarding declarations , it suffices to say for now that they
are top-level bindings which allows us to name expressions.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 41
We can then use those names to refer to them multiple times
without copying and pasting the expressions.
The following are all expressions:
1
1+1
&quot;Icarus&quot;
Each can be examined in the GHCi REPL by entering the
code at the prompt, then hitting ‚Äòenter‚Äô to see the result of
evaluating the expression. The numeric value 1, for example,
has no further reduction step, so it stands for itself.
If you haven‚Äôt already, open up your terminal and get your
REPL going to start following along with the code examples.
When we enter this into GHCi:
Prelude&gt; 1
1
We see 1 printed because it cannot be reduced any further.
In the next example, GHCi reduces the expression 1 + 2to
3, then prints the number 3. The reduction terminates with
the value 3 because there are no more terms to evaluate:
Prelude&gt; 1 + 2
3</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 42
Expressions can be nested in numbers limited only by our
willingness to take the time to write them down, much like in
arithmetic:
Prelude&gt; (1 + 2) * 3
9
Prelude&gt; ((1 + 2) * 3) + 100
109
You can keep expanding on this, nesting as many expres-
sions as you‚Äôd like and evaluating them. But, we don‚Äôt have to
limit ourselves to expressions such as these.
Normal form We say that expressions are in normal form
when there are no more evaluation steps that can be taken,
or, put diÔ¨Äerently, when they‚Äôve reached an irreducible form.
The normal form of 1 + 1is2. Why? Because the expression 1</p>
<ul>
<li>1can be evaluated or reduced by applying the addition oper-
ator to the two arguments. In other words, 1 + 1is a reducible
expression, while 2is an expression but is no longer reducible
‚Äî it can‚Äôt evaluate into anything other than itself. Reducible ex-
pressions are also called redexes . While we will generally refer
to this process as evaluation or reduction, you may also hear
it called ‚Äúnormalizing‚Äù or ‚Äúexecuting‚Äù an expression, though
these are somewhat imprecise.</li>
</ul>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 43
2.4 Functions
Expressions are the most basic unit of a Haskell program, and
functions are a specific type of expression. Functions in Haskell
are related to functions in mathematics, which is to say they
map an input or set of inputs to an output. A function is an
expression that is applied to an argument and always returns a
result. Because they are built purely of expressions, they will
always evaluate to the same result when given the same values.
As in the lambda calculus, all functions in Haskell take one
argument and return one result. The way to think of this is that,
in Haskell, when it seems we are passing multiple arguments to
a function, we are actually applying a series of nested functions,
each to one argument. This is called currying .
You may have noticed that the expressions we‚Äôve looked
at so far use literal values with no variables or abstractions.
Functions allow us to abstract the parts of code we‚Äôd want to
reuse for diÔ¨Äerent literal values. Instead of nesting addition
expressions, for example, we could write a function that would
add the value we wanted wherever we called that function.
Forexample, sayyouhadabunchofexpressionsyouneeded
to multiply by 3. You could keep entering them as individual
expressions like this:
Prelude&gt; (1 + 2) * 3</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 44
9
Prelude&gt; (4 + 5) * 3
27
Prelude&gt; (10 + 5) * 3
45
But you don‚Äôt want to do that. Functions are how we factor
out the pattern into something we can reuse with diÔ¨Äerent in-
puts. You do that by naming the function and introducing an
independent variable as the argument to the function. Func-
tions can also appear in the expressions that form the bodies
of other functions or be used as arguments to functions, just
as any other value can be.
In this case, we have a series of expressions that we want to
multiply by 3. Let‚Äôs think in terms of a function: what part is
common to all the expressions? What part varies? We know we
have to give functions a name and apply them to an argument,
so what could we call this function and what sort of argument
might we apply it to?
The common pattern is the * 3bit. The part that varies
is the addition expression before it, so we will make that a
variable. Wewillnameourfunctionandapplyittothevariable.
When we input a value for the variable, our function will
evaluate that, multiply it by 3, and return a result. In the next
section, we will formalize this into a Haskell function.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 45
Defining functions
Function definitions all share a few things in common. First,
they start with the name of the function. This is followed by
the formal parameters3of the function, separated only by white
space. Next there is an equal sign, which expresses equality of
the terms. Finally there is an expression that is the body of
the function and can be evaluated to return a value.
Defining functions in a Haskell source code file and in GHCi
are a little diÔ¨Äerent. To introduce definitions of values or
functions in GHCi, you must use let,4which looks like this:
Prelude&gt; let triple x = x * 3
In a source file we would enter it like this:
triplex=x<em>3
Let‚Äôs examine each part of that:
triple x =x</em>3
-- [1] [2] [3] [ 4 ]
3In practice, the terms argument andparameter are often used interchangeably, but
there is a diÔ¨Äerence. Argument properly refers to the value(s) that are passed to the
function‚Äôs parameters when the function is applied, not to the variables that represent
them in the function definition (or those in the type signature). See the definitions at the
end of the chapter for more information.
4This has changed as of the release of GHC 8.0.1; using letin declarations in GHCi is
no longer necessary. As we assume most readers of this edition will be using an earlier
version of GHC, we have kept the letnotation throughout the book, and this shouldn‚Äôt
cause any errors or breakage.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 46
1.This is the name of the function we are defining; it is a
function declaration . Note that it begins with a lowercase
letter.
2.This is the parameter of the function. The parameters
of our function correspond to the head of a lambda and
bind variables that appear in the body expression.
3.The=is used to define (or declare ) values and functions.
This isnothow we test for equality between two values in
Haskell.
4.This is the body of the function, an expression that could
be evaluated if the function is applied to a value. If triple
is applied, the argument it‚Äôs applied to will be the value
to which the ùë•is bound. Here the expression x * 3consti-
tutes the body of the function. So, if you have an expres-
sion like triple 6 ,ùë•is bound to 6. Since you‚Äôve applied the
function, you can also replace the fully applied function
with its body and bound arguments.
Capitalization matters! Function names start with lowercase
letters. Sometimes for clarity in function names, you may
want camelCase style, and that is good style provided the first
letter remains lowercase.
Variables must also begin with lowercase letters. They need
not be single letters.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 47
Playing with the triple function First, try entering the triple
function directly into the REPL using let. Now call the func-
tion by name and introduce a numeric value for the ùë•argu-
ment:
Prelude&gt; triple 2
6
Next, enter the second version (the one without let) into a
source file and save the file. Load it into GHCi, using the :load
or:lcommand. Once it‚Äôs loaded, you can call the function
at the prompt using the function name, triple, followed by
a numeric value, just as you did in the REPL example above.
Try using diÔ¨Äerent values for ùë•‚Äî integer values or other arith-
metic expressions. Then try changing the function itself in
the source file and reloading it to see what changes. You can
use:reload , or:r, to reload the same file.
2.5 Evaluation
When we talk about evaluating an expression, we‚Äôre talking
about reducing the terms until the expression reaches its sim-
plest form. Once a term has reached its simplest form, we say
that it is irreducible or finished evaluating. Usually, we call this
a value. Haskell uses a nonstrict evaluation (sometimes called
‚Äúlazy evaluation‚Äù) strategy which defers evaluation of terms
until they‚Äôre forced by other terms referring to them.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 48
Values are irreducible, but applications of functions to ar-
guments are reducible. Reducing an expression means evalu-
ating the terms until you‚Äôre left with a value. As in the lambda
calculus, application is evaluation: applying a function to an
argument allows evaluation or reduction.
Values are expressions, but cannot be reduced further. Val-
ues are a terminal point of reduction:
1
&quot;Icarus&quot;
The following expressions can be reduced to a value:
1+1
2*3+1
Each can be evaluated in the REPL, which reduces the ex-
pressions and then prints what it reduced to.
Let‚Äôs get back to our triple function. Calling the function
by name and applying it to an argument makes it a reducible
expression. In a pure functional language like Haskell, we can
replace applications of functions with their definitions and get
the same result, like in math. As a result when we see:
triple2
We can know that, since triple is defined as x = x * 3 , the
expression is equivalent to:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 49
triple2
-- [triple x = x * 3; x:= 2]
2*3
6
We‚Äôve applied triple to the value 2 and then reduced the
expression to the final result 6. Our expression triple 2 is in
canonical or normalform when it reaches the number 6 because
the value 6 has no remaining reducible expressions.
Haskell doesn‚Äôt evaluate everything to canonical or normal
form by default. Instead, it only evaluates to weak head normal
form (WHNF) by default. What this means is that not every-
thing will get reduced to its irreducible form immediately, so
this:
(\f-&gt;(1,2+f))2
reduces to the following in WHNF:
(1,2+2)
This representation is an approximation, but the key point
here is that 2 + 2is not evaluated to 4 until the last possible
moment.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 50
Exercises: Comprehension Check
1.Given the following lines of code as they might appear
in a source file, how would you change them to use them
directly in the REPL?
halfx=x/2
squarex=x<em>x
2.Write one function that has one parameter and works
for all the following expressions. Be sure to name the
function.
3.14</em>(5<em>5)
3.14</em>(10<em>10)
3.14</em>(2<em>2)
3.14</em>(4*4)
3.There is a value in Prelude calledpi. Rewrite your function
to usepiinstead of 3.14.
2.6 Infix operators
Functions in Haskell default to prefix syntax, meaning that the
function being applied is at the beginning of the expression
rather than the middle. We saw that with our triple function,</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 51
and we see it with standard functions such as the identity, or
id, function. This function returns whatever value it is given
as an argument:
Prelude&gt; id 1
1
While this is the default syntax for functions, not all func-
tions are prefix. There are a group of operators, such as the
arithmetic operators we‚Äôve been using, that are indeed func-
tions (they apply to arguments to produce an output) but ap-
pear by default in an infix position.
Operators are functions which can be used in infix style.
All operators are functions; not all functions are operators.
Whiletriple andidare prefix functions ( notoperators), the +
function is an infix operator:
Prelude&gt; 1 + 1
2
Now we‚Äôll try a few other arithmetic operators:
Prelude&gt; 100 + 100
200
Prelude&gt; 768395 * 21356345
16410108716275
Prelude&gt; 123123 / 123</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 52
1001.0
Prelude&gt; 476 - 36
440
Prelude&gt; 10 / 4
2.5
You can sometimes use functions infix style, with a small
change in syntax:
Prelude&gt; 10 <code>div</code> 4
2
Prelude&gt; div 10 4
2
And you can use infix operators in prefix fashion by wrap-
ping them in parentheses:
Prelude&gt; (+) 100 100
200
Prelude&gt; (*) 768395 21356345
16410108716275
Prelude&gt; (/) 123123 123
1001.0
If the function name is alphanumeric, it is a prefix function
by default, and not all prefix functions can be made infix. If</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 53
the name is a symbol, it is infix by default but can be made
prefix by wrapping it in parentheses.5
Associativity and precedence
As you may remember from your math classes, there‚Äôs a de-
fault associativity and precedence to the infix operators (<em>),
(+),(-), and(/).
We can ask GHCi for information such as associativity and
precedence of operators and functions by using the :infocom-
mand. When you ask GHCi for the :infoabout an operator
or function, it provides the type information. It also tells you
whether it‚Äôs an infix operator, and, if it is, its associativity and
precedence. Let‚Äôs talk about that associativity and precedence
briefly. We will elide the type information and so forth for
now.
Here‚Äôs what the code in Prelude says for (</em>),(+), and(-)at
time of writing:
5For people who like nitpicky details: you cannot make a prefix function into an infix
function using backticks, then wrap that in parentheses and make it into a prefix function.
We‚Äôre not clear why you‚Äôd want to do that anyway. Cut it out.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 54
:info (<em>)
infixl 7</em>
-- [1] [2] [3]
:info (+) (-)
infixl6+
infixl6-
1.infixl means it‚Äôs an infix operator; the lmeans it‚Äôs left
associative.
2.7 is the precedence: higher is applied first, on a scale of
0-9.
3.Infix function name: in this case, multiplication.
The information about addition and subtraction tell us they
are both left-associative, infix operators with the same prece-
dence (6).
Let‚Äôs play with parentheses and see what it means that these
associate to the left. Continue to follow along with the code
via the REPL:
This:
2<em>3</em>4
is evaluated as if it were:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 55
(2*3)*4
because of left associativity.
Here‚Äôs an example of a right-associative infix operator:
Prelude&gt; :info (^)
infixr 8 ^
-- [1] [2] [3]
1.infixr means infix operator; the rmeans it‚Äôs rightassocia-
tive.
2.8 is the precedence. Higher precedence, indicated by
higher numbers, is applied first, so this is higher prece-
dence than multiplication (7), addition, or subtraction
(both 6).
3.Infix function name: in this case, exponentiation.
It was hard to tell with multiplication why associativity mat-
tered, because multiplication is commutative. So shifting the
parentheses around never changes the result. Exponentiation,
however, is not associative and thus makes a prime candidate
for demonstrating left vs. right associativity.
Prelude&gt; 2 ^ 3 ^ 4
2417851639229258349412352
Prelude&gt; 2 ^ (3 ^ 4)</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 56
2417851639229258349412352
Prelude&gt; (2 ^ 3) ^ 4
4096
As you can see, adding parentheses starting from the right-
handsideoftheexpressionwhentheoperatorisright-associative
doesn‚Äôt change anything. However, if we parenthesize from
theleft, we get a diÔ¨Äerent result when the expression is evalu-
ated.
Your intuitions about precedence, associativity, and paren-
thesization from math classes will generally hold in Haskell:
2+3*4
(2+3)*4
What‚Äôs the diÔ¨Äerence between these two? Why are they
diÔ¨Äerent?
Exercises: Parentheses and Association
Below are some pairs of functions that are alike except for
parenthesization. Read them carefully and decide if the paren-
theses change the results of the function. Check your work in
GHCi.
1.a)8 + 7 * 9</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 57
b)(8 + 7) * 9
2.a)perimeter x y = (x * 2) + (y * 2)
b)perimeter x y = x * 2 + y * 2
3.a)f x = x / 2 + 9
b)f x = x / (2 + 9)
2.7 Declaring values
The order of declarations in a source code file doesn‚Äôt matter
because GHCi loads the entire file at once, so it knows all the
values that have been defined. On the other hand, when you
enter them one by one into the REPL, the order does matter.
For example, we can declare a series of expressions in the
REPL like this:
Prelude&gt; let y = 10
Prelude&gt; let x = 10 * 5 + y
Prelude&gt; let myResult = x * 5
As we saw above with the triple function, we have to use
letto declare something in the REPL.
We can now type the names of the values and hit enter to
see their values:
Prelude&gt; x</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 58
60
Prelude&gt; y
10
Prelude&gt; myResult
300
Let‚Äôs see how to declare those values in a file called learn.hs .
First, we declare the name of our module so it can be imported
by name in a project (we won‚Äôt be doing a project of this size for
a while yet, but it‚Äôs good to get in the habit of having module
names):
-- learn.hs
moduleLearnwhere
x=10<em>5+y
myResult =x</em>5
y=10
Module names are capitalized. Also, in the variable name,
we‚Äôve used camelCase: the first letter is still lowercase, but we
use an uppercase to delineate a word boundary for readability.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 59
Troubleshooting
It is easy to make mistakes in the process of typing learn.hs
into your editor. We‚Äôll look at a few common mistakes in
this section. One thing to keep in mind is that indentation of
Haskell code is significant and can change the meaning of the
code. Incorrect indentation of code can also break your code.
Use spaces, nottabs, to indent your source code.
In general, whitespace is significant in Haskell. Efficient
use of whitespace makes the syntax more concise. This can
take some getting used to if you‚Äôve been working in another
programming language. Whitespace is often the only mark of
a function call, unless parentheses are necessary due to con-
flicting precedence. Trailing whitespace, that is, extraneous
whitespace at the end of lines of code, is considered bad style.
In source code files, indentation often replaces syntactic
markers like curly brackets, semicolons, and parentheses. The
basic rule is that code that is part of an expression should be
indented under the beginning of that expression, even when
the beginning of the expression is not at the leftmost margin.
Furthermore, parts of the expression that are grouped should
be indented to the same level. For example, in a block of code
introduced by letordo, you might see something like this:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 60
let
x=3
y=4
-- or
letx=3
y=4
This wouldn‚Äôt work in a source file unless they were embed-
ded in a top-level declaration.
Noticethatthetwodefinitionsthatarepartoftheexpression
line up in either case. It is incorrect to write:
letx=3
y=4
-- or
let
x=3
y=4
If you have an expression that has multiple parts, your
indentation will follow a pattern like this:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 61
foox=
lety=x<em>2
z=x^2
in2</em>y*z
Notice that the definitions of ùë¶andùëßline up, and the def-
initions of letandinare also aligned. As you work through
the book, pay attention to the indentation patterns as we have
them printed. There are many cases where improper inden-
tation will cause code not to work. Indentation can easily go
wrong in a copy-and-paste job as well.
If you make a mistake like breaking up the declaration of ùë•
such that the rest of the expression began at the beginning of
the next line:
moduleLearnwhere
-- module declaration at the top
x=10
<em>5+y
myResult =x</em>5
y=10
You might see an error like:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 62
Prelude&gt; :l code/learn.hs
[1 of 1] Compiling Learn
code/learn.hs:10:1:
parse error on input ‚Äò<em>‚Äô
Failed, modules loaded: none.
Note that the first line of the error message tells you where
the error occurred: code/learn.hs:10:1 indicates that the mis-
take is in line 10, column 1, of the named file. That can make it
easier to find the problem that needs to be fixed. Please note
that the exact line and column numbers in your own error
messages might be diÔ¨Äerent from ours, depending on how
you‚Äôve entered the code into the file.
The way to fix this is to either put it all on one line, like this:
x=10</em>5+y
or to make certain when you break up lines of code that the
second line begins at least one space from the beginning of
that line (either of the following should work):</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 63
x=10
<em>5+y
-- or
x=10
<em>5+y
The second one looks a little better. Generally, you should
reserve breaking up of lines for when you have code exceeding
100 columns in width.
Another possible error is not starting a declaration at the
beginning (left) column of the line:
-- learn.hs
moduleLearnwhere
x=10</em>5+y
myResult =x</em>5
y=10
See that space before ùë•? That will cause an error like:
Prelude&gt; :l code/learn.hs</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 64
[1 of 1] Compiling Learn
code/learn.hs:11:1:
parse error on input ‚ÄòmyResult‚Äô
Failed, modules loaded: none.
This may confuse you, as myResult is not where you need to
modify your code. The error is only an extraneous space, but
all declarations in the module must start at the same column.
The column that all declarations within a module must start
in is determined by the first declaration in the module. In this
case, the error message gives a location that is diÔ¨Äerent from
where you should fix the problem because all the compiler
knows is that the declaration of ùë•made a single space the ap-
propriate indentation for all declarations within that module,
and the declaration of myResult began a column too early.
It is possible to fix this error by indenting the myResult and
ùë¶declarations to the same level as the indented ùë•declaration:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 65
-- learn.hs
moduleLearnwhere
x=10<em>5+y
myResult =x</em>5
y=10
However, this is considered bad style and is not standard
Haskell practice. There is almost never a good reason to indent
all your declarations in this way, but noting this gives us some
idea of how the compiler is reading the code. It is better, when
confronted with an error message like this, to make sure that
your first declaration is at the leftmost margin and proceed
from there.
Another possible mistake is that you might‚Äôve missed the
second -in the--used to comment out source lines of code.
So this code:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 66
-learn.hs
moduleLearnwhere
x=10<em>5+y
myResult =x</em>5
y=10
will cause this error:
code/learn.hs:7:1:
parse error on input ‚Äòmodule‚Äô
Failed, modules loaded: none.
Note again that it says the parse error occurred at the be-
ginning of the module declaration, but the issue is that the
comment line, - learn.hs , had only one dash, when it needed
two to form a syntactically correct Haskell comment.
Now we can see how to work with code that is saved in a
source file from GHCi without manually copying and pasting
the definitions into our REPL. Assuming we open our REPL
in the same directory as we have learn.hs saved, we can do the
following:
Prelude&gt; :load learn.hs</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 67
[1 of 1] Compiling Learn
Ok, modules loaded: Learn.
Prelude&gt; x
60
Prelude&gt; y
10
Prelude&gt; myResult
300
Exercises: Heal the Sick
The following code samples are broken and won‚Äôt compile.
The first two are as you might enter into the REPL; the third
is from a source file. Find the mistakes and fix them so that
they will.
1.let area x = 3. 14 * (x * x)
2.let double x = b * 2
3.x=7
y=10
f=x+y
2.8 Arithmetic functions in Haskell
This section will explore some basic arithmetic using some
common operators and functions for arithmetic. We‚Äôll focus</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 68
on the following subset of them:
Operator Name Purpose/application</p>
<ul>
<li>plus addition</li>
</ul>
<ul>
<li>minus subtraction</li>
</ul>
<ul>
<li>asterisk multiplication
/ slash fractional division
div divide integral division, round down
mod modulo like ‚Äòrem‚Äô, but after modular division
quot quotient integral division, round towards zero
rem remainder remainder after division
At the risk of stating the obvious, ‚Äúintegral‚Äù division refers
to division of integers. Because it‚Äôs integral and not fractional,
it takes integers as arguments and returns integers as results.
That‚Äôs why the results are rounded.
Here‚Äôs an example of each in the REPL:
Prelude&gt; 1 + 1
2
Prelude&gt; 1 - 1
0
Prelude&gt; 1 * 1
1
Prelude&gt; 1 / 1
1.0</li>
</ul>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 69
Prelude&gt; div 1 1
1
Prelude&gt; mod 1 1
0
Prelude&gt; quot 1 1
1
Prelude&gt; rem 1 1
0
You will usually want divfor integral division, due to the
waydivandquotround:
-- rounds down
Prelude&gt; div 20 (-6)
-4
-- rounds toward zero
Prelude&gt; quot 20 (-6)
-3
Also,remandmodhave slightly diÔ¨Äerent use cases; we‚Äôll look
atmodin a little more detail in this chapter. We will cover (/)
in more detail in a later chapter, as that will require some
explanation of types and typeclasses.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 70
Laws for quotients and remainders
Programming often makes use of more division and remain-
der functions than standard arithmetic does, and it‚Äôs helpful
to be familiar with the laws about quotandrem, anddivand
mod.6We‚Äôll take a look at those here.
(quot x y)*y + (rem x y) == x
(div x y)<em>y + (mod x y) == x
We won‚Äôt walk through a proof exercise, but we can demon-
strate these laws a bit:
(quot x y)<em>y + (rem x y)
Given x is 10 and y is (-4)
(quot 10 (-4))</em>(-4) + (rem 10 (-4))
quot 10 (-4) == (-2) and rem 10 (-4) == 2
(-2)</em>(-4) + (2) == 10
10 == x
6From Lennart Augustsson‚Äôs blog http://augustss.blogspot.com or Stack Overflow an-
swer at http://stackoverflow.com/a/8111203</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 71
Yes, we got to the result we wanted.
Now for divandmod:
(div x y)<em>y + (mod x y)
Given x is 10 and y is (-4)
(div 10 (-4))</em>(-4) + (mod 10 (-4))
div 10 (-4) == (-3) and mod 10 (-4) == -2
(-3)*(-4) + (-2) == 10
10 == x
Our result indicates all is well in the world of integral divi-
sion.
Usingmod
This section is not a full discussion of modular arithmetic, but
we want to give more direction in how to use modin general,
for those who may be unfamiliar with it, and how it works in
Haskell specifically.
We‚Äôve already mentioned that modgives the remainder of
a modular division. If you‚Äôre not already familiar with mod-</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 72
ular division, you may not understand the useful diÔ¨Äerence
between modandrem.
Modular arithmetic is a system of arithmetic for integers
where numbers ‚Äúwrap around‚Äù upon reaching a certain value,
called the modulus . It is often explained in terms of a clock.
When we count time by a 12-hour clock, we have to wrap
the counting around the 12. For example, if the time is now
8:00 and you want to know what time it will be 8 hours from
now, you don‚Äôt simply add 8 + 8 and get a result of 16 o‚Äôclock.7
Instead, you wrap the count around every 12 hours. So,
adding 8 hours to 8:00 means that we add 4 hours to get to
the 12, and at the 12 we start over again as if it‚Äôs 0 and add the
remaining 4 hours of our 8, for an answer of 4:00. That is, 8
hours after 8:00 is 4:00.
This is arithmetic modulo 12. In our 12-hour clock, 12 is
equivalent to both itself and to 0, so the time at 12:00 is also,
in some sense 0:00. Arithmetic modulo 12 means that 12 is
both 12 and 0.
Often, this will give you the same answer that remdoes:
Prelude&gt; mod 15 12
3
Prelude&gt; rem 15 12
3
7Obviously, with a 24-hour clock, such a time is possible; however, if we were starting
from 8:00 p.m. and trying to find the time 8 hours later, the answer would not be 16:00
a.m. A 24-hour clock has a diÔ¨Äerent modulus than a 12-hour clock.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 73
Prelude&gt; mod 21 12
9
Prelude&gt; rem 21 12
9
Prelude&gt; mod 3 12
3
Prelude&gt; rem 3 12
3
If you‚Äôre wondering what the deal is with the last two ex-
amples, it‚Äôs because modandremcan only represent integral
division. If all you have to work with is integers, then dividing
a smaller number by a larger number results in an answer of
0 with a remainder of whatever the smaller number (the divi-
dend) is. If you want to divide a smaller number by a larger
number and return a fractional answer, then you need to use
(/), and you won‚Äôt have a remainder.
Let‚Äôs say we need to write a function that will determine
what day of the week it was or will be a certain number of
days before or after this one. For our purposes here, we will
assign a number to each day of the week, using 0 to represent
Sunday.8Then if today is Monday, and we want to know what
8Sure, you may naturally think of the days of week as being numbered 1-7. But
programmers like to index things from zero.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 74
day of the week it will be 23 days from now, we could do this:
Prelude&gt; mod (1 + 23) 7
3
The 1 represents Monday, the current day, while 23 is the
number of days we‚Äôre trying to add. Using modto wrap it around
the 7 means it will return a number that corresponds to a day
of the week in our numbering.
And 5 days from Saturday will be Thursday:
Prelude&gt; mod (6 + 5) 7
4
We can use remto do the same thing with apparently equiv-
alent accuracy:
Prelude&gt; rem (1 + 23) 7
3
However, if we want to subtract and find out what day of
the week it was some number of days ago, then we‚Äôll see a
diÔ¨Äerence. Let‚Äôs try asking, if today is Wednesday (3), what
day it was 12 days ago:
Prelude&gt; mod (3 - 12) 7
5
Prelude&gt; rem (3 - 12) 7
-2</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 75
The version with modgives us a correct answer, while the rem
version does not.
One key diÔ¨Äerence here is that, in Haskell (not in all lan-
guages), if one or both arguments are negative, the results of
modwill have the same sign as the divisor, while the result of
remwill have the same sign as the dividend:
Prelude&gt; (-5) <code>mod</code> 2
1
Prelude&gt; 5 <code>mod</code> (-2)
-1
Prelude&gt; (-5) <code>mod</code> (-2)
-1
But:
Prelude&gt; (-5) <code>rem</code> 2
-1
Prelude&gt; 5 <code>rem</code> (-2)
1
Prelude&gt; (-5) <code>rem</code> (-2)
-1
Figuring out when you need modtakes some experience.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 76
Negative numbers
Due to the interaction of parentheses, currying, and infix syn-
tax, negative numbers get special treatment in Haskell.
If you want a value that is a negative number by itself, this
will work fine:
Prelude&gt; -1000
-1000
However, this will not work in some cases:
Prelude&gt; 1000 + -9
<interactive>:3:1:
Precedence parsing error
cannot mix ‚Äò+‚Äô [infixl 6] and
prefix <code>-</code> [infixl 6]
in the same infix expression
Fortunately, we were told about our mistake before any
of our code was executed. Note how the error message tells
you the problem has to do with precedence. Addition and
subtraction have the same precedence (6), and GHCi thinks
we are trying to add and subtract, not add a negative number,
so it doesn‚Äôt know how to resolve the precedence and evaluate
the expression. We need to make a small change before we
can add a positive and a negative number together:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 77
Prelude&gt; 1000 + (-9)
991
The negation of numbers in Haskell by the use of a unary -
is a form of syntactic sugar . Syntax is the grammar and struc-
ture of the text we use to express programs, and syntactic
sugar is a means for us to make that text easier to read and
write. Syntactic sugar can make the typing or reading of code
nicer but changes nothing about the semantics, or meaning, of
programs and doesn‚Äôt change how we solve problems in code.
Typically when code with syntactic sugar is processed by our
REPL or compiler, a simple transformation from the shorter
(‚Äúsweeter‚Äù) form to a more verbose, truer representation is
performed after the code has been parsed.
In the specific case of -, the syntactic sugar means the oper-
ator now has two possible interpretations. The two possible
interpretations of the syntactic -are that -is being used as an
alias for negate or that it is the subtraction function. The fol-
lowing are semantically identical (that is, they have the same
meaning, despite diÔ¨Äerent syntax) because the -is translated
intonegate :
Prelude&gt; 2000 + (-1234)
766
Prelude&gt; 2000 + (negate 1234)
766</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 78
Whereas this is -being used for subtraction:
Prelude&gt; 2000 - 1234
766
Fortunately, syntactic overloading like this isn‚Äôt common
in Haskell.
2.9 Parenthesization
Here we‚Äôve listed the information that GHCi gives us for var-
ious infix operators. We have left the type signatures in, al-
though it is not directly relevant at this time. This will give
you a chance to look at the types if you‚Äôre curious and also
provide a more accurate picture of the :infocommand.
Prelude&gt; :info (^)
(^) :: (Num a, Integral b) =&gt; a -&gt; b -&gt; a
infixr 8 ^
Prelude&gt; :info (<em>)
class Num a where
(</em>) :: a -&gt; a -&gt; a
infixl 7 *
Prelude&gt; :info (+)
class Num a where</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 79
(+) :: a -&gt; a -&gt; a
infixl 6 +
Prelude&gt; :info (-)
class Num a where
(-) :: a -&gt; a -&gt; a
infixl 6 -
Prelude&gt; :info ($)
($) :: (a -&gt; b) -&gt; a -&gt; b
infixr 0 $
We should take a moment to explain and demonstrate the
($)operator as you will run into it fairly frequently in Haskell
code. The good news is it does almost nothing. The bad news
is this fact sometimes trips people up.
First, here‚Äôs the definition of ($):
f$a=f a
Immediately this seems a bit pointless until we remember
that it‚Äôs defined as an infix operator with the lowest possible
precedence. The ($)operator is a convenience for when you
want to express something with fewer pairs of parentheses:
Prelude&gt; (2^) (2 + 2)
16</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 80
-- can replace those parentheses
Prelude&gt; (2^) $ 2 + 2
16
-- without either parentheses or $
Prelude&gt; (2^) 2 + 2
6
The($)will allow everything to the right of it to be evalu-
ated first and can be used to delay function application. You‚Äôll
see what we mean about delaying function application in par-
ticular when we get to Chapter 7 and use it with function
composition.
Also note that you can stack up multiple uses of ($)in the
same expression. For example, this works:
Prelude&gt; (2^) $ (+2) $ 3*2
256
But this does not:
Prelude&gt; (2^) $ 2 + 2 $ (*30)
A rather long and ugly type error about trying to use num-
bers as if they were functions follows. We can see why this
code doesn‚Äôt make sense if we examine the reduction steps:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 81
-- Remember ($)'s definition
f$a=f a
(2^)$2+2$(*30)
Given the right-associativity ( infixr ) of$we must begin at
the right-most position:
2+2$(*30)
-- reduce ($)
(2+2) (*30)
Then we must evaluate (2 + 2) before we can apply it:
4(*30)
You might think that this could evaluate as (4 * 30), but it‚Äôs
trying to apply 4 as if it was a function to the argument (*30)!
Writing expressions like (*30)is called sectioning .
Now let‚Äôs flip that expression around a bit so it works and
then walk through a reduction:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 82
(2^)$(*30)$2+2
-- must evaluate right-side first
(2^)$(*30)$2+2
-- application of the function (*30) to the
-- expression (2 + 2) forces evaluation
(2^)$(*30)4
-- then we reduce (*30) 4
(2^)$120
-- reduce ($) again.
(2^)120
-- reduce (2^)
1329227995784915872903807060280344576
Some Haskellers find parentheses more readable than the
dollar sign, but it‚Äôs too common in idiomatic Haskell code for
you to not at least be familiar with it.
Parenthesizing infix operators
There are times when you want to refer to an infix function
without applying any arguments, and there are also times
when you want to use them as prefix operators instead of infix.
In both cases you must wrap the operator in parentheses. Let‚Äôs
look at how we use infix operators as prefixes.
If your infix function is &gt;&gt;then you must write (&gt;&gt;)to refer
to it as a value. (+)is the addition infix function without any</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 83
arguments applied yet and (+1)is the same addition function
but with one argument applied, making it return the next
argument it‚Äôs applied to plus one:
Prelude&gt; 1 + 2
3
Prelude&gt; (+) 1 2
3
Prelude&gt; (+1) 2
3
The last case is known as sectioning and allows you to pass
around partially applied functions. With commutative func-
tions, such as addition, it makes no diÔ¨Äerence if you use (+1)
or(1+)because the order of the arguments won‚Äôt change the
result.
If you use sectioning with a function that is not commuta-
tive, the order matters:
Prelude&gt; (1/) 2
0.5
Prelude&gt; (/1) 2
2.0
Subtraction, (-), is a special case. These will work:
Prelude&gt; 2 - 1</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 84
1
Prelude&gt; (-) 2 1
1
The following, however, won‚Äôt work:
Prelude&gt; (-2) 1
Enclosing a value inside the parentheses with the -indi-
cates to GHCi that it‚Äôs the argument of a function. Because
the-function represents negation, not subtraction, when it‚Äôs
applied to a single argument, GHCi does not know what to do
with that, and so it returns an error message. Here, -is a case
of syntactic overloading disambiguated by how it is used.
You can use sectioning for subtraction, but it must be the
first argument:
Prelude&gt; let x = 5
Prelude&gt; let y = (1 -)
Prelude&gt; y x
-4
Or instead of (- x), you can write (subtract x):
Prelude&gt; (subtract 2) 3
1</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 85
It may not be immediately obvious why you would ever
want to do this, but you will see this syntax used throughout the
book, for example, once we start wanting to apply functions
to each value inside a list or other data structure.
2.10 Let and where
You will often see letandwhereused to introduce components
of expressions, and they seem similar. It takes some practice
to get used to the appropriate times to use each.
The contrast here is that letintroduces an expression , so it
can be used wherever you can have an expression, but whereis
adeclaration and is bound to a surrounding syntactic construct.
We‚Äôll start with an example of where:
-- FunctionWithWhere.hs
moduleFunctionWithWhere where
printInc n=print plusTwo
whereplusTwo =n+2
And if we use this in the REPL:
Prelude&gt; :l FunctionWithWhere.hs
[1 of 1] Compiling FunctionWithWhere ...</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 86
Ok, modules loaded: FunctionWithWhere.
Prelude&gt; printInc 1
3
Prelude&gt;
Now we have the same function, but using letin the place
ofwhere:
-- FunctionWithLet.hs
moduleFunctionWithLet where
printInc2 n= letplusTwo =n+2
inprint plusTwo
When you see letfollowed by in, you‚Äôre looking at a let
expression . Here‚Äôs that function in the REPL:
Prelude&gt; :load FunctionWithLet.hs
[1 of 1] Compiling FunctionWithLet ...
Ok, modules loaded: FunctionWithLet.
Prelude&gt; printInc2 3
5
If you loaded FunctionWithLet in the same REPL session as
FunctionWithWhere , then it will have unloaded the first one be-
fore loading the new one:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 87
Prelude&gt; :load FunctionWithWhere.hs
[1 of 1] Compiling FunctionWithWhere ...
Ok, modules loaded: FunctionWithWhere.
Prelude&gt; printInc 1
3
Prelude&gt; :load FunctionWithLet.hs
[1 of 1] Compiling FunctionWithLet ...
Ok, modules loaded: FunctionWithLet.
Prelude&gt; printInc2 10
12
Prelude&gt; printInc 10
<interactive>:6:1:
Not in scope: ‚ÄòprintInc‚Äô
Perhaps you meant ‚ÄòprintInc2‚Äô (line 4)
printInc isn‚Äôt in scope anymore because GHCi unloaded
everything you‚Äôd defined or loaded after you used :loadto load
theFunctionWithLet.hs source file. Scopeis the area of source
code where a binding of a variable applies.
That is one limitation of the :loadcommand in GHCi. As
we build larger projects that require having multiple modules
in scope, we will use a project manager called Stack rather
than GHCi itself.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 88
Exercises: A Head Code
Now for some exercises. First, determine in your head what
the following expressions will return, then validate in the
REPL:
1.letx=5inx
2.letx=5inx<em>x
3.letx=5; y=6inx</em>y
4.letx=3; y=1000inx+3
Above, you entered some letexpressions into your REPL
to evaluate them. Now, we‚Äôre going to open a file and rewrite
someletexpressions using wheredeclarations. You will have
to give the value you‚Äôre binding a name, although the name
can be a single letter if you like. For example,
-- this should work in GHCi
letx=5; y=6inx<em>y
could be rewritten as
-- put this in a file
mult1 =x</em>y
wherex=5
y=6</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 89
Making the equals signs line up is a stylistic choice. As long
as things are nested in that way, the equals signs do not have
to line up. But notice we use a name that we will use to refer
to this value in the REPL:
Prelude&gt; :l practice.hs
[1 of 1] Compiling Main
Ok, modules loaded: Main.
Prelude&gt; mult1
30
The prompt changes to <em>Maininstead of Prelude to indicate
that you have a module called Mainloaded.
Rewrite with whereclauses:
1.letx=3; y=1000inx</em>3+y
2.lety=10; x=10<em>5+yinx</em>5
3.letx=7
y=negate x
z=y*10
inz/x+y
Note: the filename you choose is unimportant except for
the.hsextension.</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 90
2.11 Chapter Exercises
The goal for all the following exercises is to get you playing
with code and forming hypotheses about what it should do.
Read the code carefully, using what we‚Äôve learned so far. Gen-
erate a hypothesis about what you think the code will do. Play
with it in the REPL and find out where you were right or wrong.
Parenthesization
Given what we know about the precedence of (<em>),(+), and(^),
how can we parenthesize the following expressions more ex-
plicitly without changing their results? Put together an answer
you think is correct, then test in the GHCi REPL.
For example, we want to make this more explicit
2+2</em>3-3
This will produce the same result:
2+(2<em>3)-3
Attempt the above on the following expressions:
1.2+2</em>3-1
2.(^)10$1+1
3.2^2*4^5+1</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 91
Equivalent expressions
Which of the following pairs of expressions will return the
same result when evaluated? Try to reason them out by read-
ing the code and then enter them into the REPL to check your
work:
1.1+1
2
2.10^2
10+9<em>10
3.400-37
(-)37400
4.100<code>div</code>3
100/3
5.2</em>5+18
2*(5+18)</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 92
More fun with functions
Here is a bit of code as it might be entered into a source file.
Remember that when you write code in a source file, the order
is unimportant, but when writing code directly into the REPL
the order does matter. Given that, look at this code and rewrite
it such that it could be evaluated in the REPL (remember: you
may need letwhen entering it directly into the REPL). Be sure
to enter your code into the REPL to make sure it evaluates
correctly.
z=7
x=y^2
waxOn=x*5
y=z+8
1.Now you have a value called waxOnin your REPL. What do
you think will happen if you enter:</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 93
10+waxOn
-- or
(+10) waxOn
-- or
(-)15waxOn
-- or
(-) waxOn 15
2.Earlier we looked at a function called triple . While your
REPL has waxOnin session, re-enter the triple function at
the prompt:
lettriple x =x*3
3.Now, whatwillhappenifweenterthisatourGHCiprompt?
What do you think will happen first, considering what role
waxOnis playing in this function call? Then enter it, see
what does happen, and check your understanding:
triplewaxOn
4.Rewrite waxOnas an expression with a whereclause in your
source file. Load it into your REPL and make sure it still
works as expected.
5.To the same source file where you have waxOn, add the
triple function. Remember: You don‚Äôt need letand the</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 94
function name should be at the left margin (that is, not
nested as one of the waxOnexpressions). Make sure it works
by loading it into your REPL and then entering triple
waxOnagain at the REPL prompt. You should have the
same answer as you did above.
6.Now, without changing what you‚Äôve done so far in that
file, add a new function called waxOff that looks like this:
waxOffx=triple x
7.Load the source file into your REPL and enter waxOff waxOn
at the prompt.
You now have a function, waxOff that can be applied to a
variety of arguments ‚Äî not just waxOnbut any (numeric)
value you want to put in for ùë•. Play with that a bit. What
is the result of waxOff 10 orwaxOff (-50) ? Try modifying
yourwaxOff function to do something new ‚Äî perhaps
you want to first triple the ùë•value and then square it or
divide it by 10. Spend some time getting comfortable with
modifying the source file code, reloading it, and checking
your modification in the REPL.
2.12 Definitions
1.The terms argument andparameter are often used inter-
changeably. However, it is worthwhile to understand the</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 95
distinction. A parameter , or formal parameter, represents a
value that will be passed to the function when the func-
tion is called. Thus, parameters are usually variables. An
argument is an input value the function is applied to. A
function‚Äôs parameter is bound to the value of an argument
when the function is applied to that argument. For exam-
ple, inf x = x + 2 which takes an argument and returns
that value added to 2, ùë•is the one parameter of our func-
tion. We run the code by applying ùëìto some argument.
If the argument we passed to the parameter ùë•were 2, our
result would be 4. However, arguments can themselves
be variables or be expressions that include variables, thus
the distinction is not always clear. When we use ‚Äúparam-
eter‚Äù in this book, it will always be referring to formal
parameters, usually in a type signature, but we‚Äôve taken
the liberty of using ‚Äúargument‚Äù somewhat more loosely.
2.Anexpression is a combination of symbols that conforms
to syntactic rules and can be evaluated to some result. In
Haskell, an expression is a well-structured combination
of constants, variables, and functions. While irreducible
constants are technically expressions, we usually refer to
those as ‚Äúvalues‚Äù, so we usually mean ‚Äúreducible expres-
sion‚Äù when we use the term expression .
3.Avalueis an expression that cannot be reduced or evalu-
ated any further. 2 * 2is an expression, but not a value,</p>
<p>CHAPTER 2. BASIC EXPRESSIONS AND FUNCTIONS 96
whereas what it evaluates to, 4, is a value.
4.Afunction is a mathematical object whose capabilities are
limited to being applied to an argument and returning a
result. Functions can be described as a list of ordered pairs
of their inputs and the resulting outputs, like a mapping.
Given the function f x = x + 2 applied to the argument
2, we would have the ordered pair (2, 4) of its input and
output.
5.Infixnotation is the style used in arithmetic and logic. Infix
means that the operator is placed between the operands
orarguments . An example would be the plus sign in an
expression like 2 + 2.
6.Operators are functions that are infix by default. In Haskell,
operators must use symbols and not alphanumeric char-
acters.
7.Syntactic sugar is syntax within a programming language
designed to make expressions easier to write or read.
2.13 Follow-up resources
1.Haskell wiki article on Let vs. Where
https://wiki.haskell.org/Let_vs._Where
2.How to desugar Haskell code; Gabriel Gonzalez</p>
<p>Chapter 3
Strings
Like punning,
programming is a play on
words
Alan Perlis
97</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 98
3.1 Printing strings
So far we‚Äôve been doing arithmetic using simple expressions.
In this chapter, we will turn our attention to a diÔ¨Äerent type
of data called String .
Most programming languages refer to the data structures
used to contain text as ‚Äústrings,‚Äù usually represented as se-
quences, or lists, of characters. In this section, we will
‚Ä¢take an introductory look at types to understand the data
structure called String ;
‚Ä¢talk about the special syntax, or syntactic sugar, used for
strings;
‚Ä¢print strings in the REPL environment;
‚Ä¢work with some standard functions that operate on this
datatype.
3.2 A first look at types
First, since we will be working with strings, we want to start by
understanding what these data structures are in Haskell as well
as a bit of special syntax we use for them. We haven‚Äôt talked
much about types yet, although you saw some examples of
them in the last chapter. Types are important in Haskell, and
the next two chapters are entirely devoted to them.</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 99
Types are a way of categorizing values. There are sev-
eral types for numbers, for example, depending on whether
they are integers, fractional numbers, etc. There is a type
for boolean values, specifically the values TrueandFalse. The
types we are primarily concerned with in this chapter are Char
‚Äòcharacter‚Äô and String .String s are lists of characters.
It is easy to find out the type of a value, expression, or
function in GHCi. We do this with the :typecommand.
Open up your REPL, enter :type 'a' at the prompt, and
you should see something like this:
Prelude&gt; :type 'a'
'a' :: Char
We‚Äôll highlight a few things here. First, we‚Äôve enclosed
our character in single quotes. This lets GHCi know that the
character is not a variable. If you enter :type a instead, it will
think it‚Äôs a variable and give you an error message that the ùëéis
not in scope. That is, the variable ùëéhasn‚Äôt been defined (is not
in scope), so it has no way to know what the type of it is.
Second, the ::symbol is read as ‚Äúhas the type.‚Äù You‚Äôll see
this often in Haskell. Whenever you see that double colon,
you know you‚Äôre looking at a type signature. A type signature
is a line of code that defines the types for a value, expression,
or function.
And, finally, there is Char, the type. Charis the type that
includes alphabetic characters, Unicode characters, symbols,</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 100
etc. So, asking GHCi :type 'a' , that is, ‚Äúwhat is the type of ‚Äòa‚Äô?‚Äù,
gives us the information, 'a' :: Char , that is, ‚Äú‚Äòa‚Äô has the type
of Char.‚Äù
Now, let‚Äôs try a string of text. This time we have to use
double quotation marks, not single, to tell GHCi we have a
string, not a single character:
Prelude&gt; :type &quot;Hello!&quot;
&quot;Hello!&quot; :: [Char]
We have something new in the type information. The
square brackets around Charhere are the syntactic sugar for a
list.String is atype alias , or type synonym, for a list of Char. A
type alias is what it sounds like: we use one name for a type,
usually for convenience, that has a diÔ¨Äerent type name under-
neath. Here String is another name for a list of characters. By
using the name String we are able to visually diÔ¨Äerentiate it
from other types of lists. When we talk about lists in more
detail later, we‚Äôll see why the square brackets are considered
syntactic sugar; for now, we only need to understand that
GHCi says ‚ÄúHello!‚Äù has the type list of Char.
3.3 Printing simple strings
Now, let‚Äôs see how to print strings of text in the REPL:
Prelude&gt; print &quot;hello world!&quot;</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 101
&quot;hello world!&quot;
We used printto tell GHCi to print the string to the display,
so it does, with the quotation marks still around it. The print
function is not specific to strings of text, though; it can be used
to print diÔ¨Äerent types of data to the screen.
The following also tell GHCi to print to the screen but are
specific to String :
Prelude&gt; putStrLn &quot;hello world!&quot;
hello world!
Prelude&gt;
Prelude&gt; putStr &quot;hello world!&quot;
hello world!Prelude&gt;
You can probably see that putStr andputStrLn are similar,
with one key diÔ¨Äerence. We also notice that both of these print
the string to the display without the quotation marks. This is
because, while they are superficially similar to print, they have
a diÔ¨Äerent type than printdoes. Functions that are similar on
the surface can behave diÔ¨Äerently depending on the type or
category they belong to.
Next, let‚Äôs take a look at how to do these things from source
files. Type the following into a file named print1.hs :</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 102
-- print1.hs
modulePrint1where
main::IO()
main=putStrLn &quot;hello world!&quot;
Here‚Äôs what you should see when you load it in GHCi and
runmain:
Prelude&gt; :l print1.hs
[1 of 1] Compiling Print1
Ok, modules loaded: Print1.
*Print1&gt; main
hello world!
*Print1&gt;
First, note that your Prelude&gt; prompt may have changed
to reflect the name of the module you loaded. You can use
:module or:mto unload the module and return to Prelude if
you wish. You can also set your prompt to something specific,
which means it won‚Äôt change every time you load or unload a
module1:
Prelude&gt; :set prompt &quot;Œª&gt; &quot;
Œª&gt; :r
1You can set it permanently if you prefer by setting the configuration in your ~/.ghci
file. You may have to create that file yourself in order to do so.</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 103
Ok, modules loaded: Print1.
Œª&gt; main
hello world!
Œª&gt;
Looking at the code, mainis the default action when you
build an executable or run it in a REPL. It is not a function but
is often a series of instructions to execute, which can include
applying functions and producing side-eÔ¨Äects. When building
a project with Stack, having a mainexecutable in a Main.hs file
is obligatory, but you can have source files and load them in
GHCi without necessarily having a mainblock.
As you can see, mainhas the type IO (). IO, or I/O, stands
for input/output. In Haskell, it is a special type, called IO,
used when the result of running the program involves eÔ¨Äects
beyond evaluating a function or expression. Printing to the
screen is an eÔ¨Äect, so printing the output of a module must be
wrapped in this IOtype. When you enter functions directly
into the REPL, GHCi implicitly understands and implements
IOwithout you having to specify that. Since the mainaction is
the default executable, you will see it in a lot of source files
that we build from here on out. We will explain its meaning
in more detail in a later chapter.
Let‚Äôs start another file:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 104
-- print2.hs
modulePrint2where
main::IO()
main= do
putStrLn &quot;Count to four for me:&quot;
putStr &quot;one, two&quot;
putStr &quot;, three, and&quot;
putStrLn &quot; four!&quot;
Thisdosyntax is a special syntax that allows for sequencing
actions. It is most commonly used to sequence the actions
that constitute your program, some of which will necessarily
perform eÔ¨Äects such as printing to the screen (that‚Äôs why the
obligatory type of mainisIO ()).donotation isn‚Äôt strictly neces-
sary, but since it often makes for more readable code than the
alternatives, you‚Äôll see it a lot.
Here‚Äôs what you should see when you run this one:
Prelude&gt; :l print2.hs
[1 of 1] Compiling Print2
Ok, modules loaded: Print2.
Prelude&gt; main
Count to four for me:
one, two, three, and four!
Prelude&gt;</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 105
For a bit of fun, change the invocations of putStr toputStrLn
and vice versa. Rerun the program and see what happens. The
LninputStrLn indicates that it starts a new line.
String concatenation
Toconcatenate something means to link together . Usually when
we talk about concatenation in programming we‚Äôre talking
about linear sequences such as lists or strings of text. If we
concatenate two strings &quot;Curry&quot; and&quot; Rocks!&quot; we will get the
string&quot;Curry Rocks!&quot; . Note the space at the beginning of &quot;
Rocks!&quot; . Without that, we‚Äôd get &quot;CurryRocks!&quot; .
Let‚Äôs start a new text file and type the following:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 106
-- print3.hs
modulePrint3where
myGreeting ::String
myGreeting =&quot;hello&quot; ++&quot; world!&quot;
hello::String
hello=&quot;hello&quot;
world::String
world=&quot;world!&quot;
main::IO()
main= do
putStrLn myGreeting
putStrLn secondGreeting
wheresecondGreeting =
concat [hello, &quot; &quot;, world]
We used ::to declare the types of each top-level expression.
It isn‚Äôt strictly necessary, as the compiler can infer these types,
but it is a good habit to be in as you write longer programs.
Remember, String is a type synonym for [Char]. You can
try changing the type signatures to reflect that and see if it
changes anything in the program execution.</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 107
If you execute this, you should see something like:
Prelude&gt; :load print3.hs
[1 of 1] Compiling Print3
Ok, modules loaded: Print3.
*Print3&gt; main
hello world!
hello world!
*Print3&gt;
This little exercise demonstrates a few things:
1.We defined values at the top level of a module: ( myGreeting ,
hello,world, andmain). That is, they were declared at the
top level so that they are available throughout the module.
2.We specify explicit types for top-level definitions.
3.We concatenate strings with (++)andconcat .
3.4 Top-level versus local definitions
What does it mean for something to be at the top level of a
module? It doesn‚Äôt necessarily mean it‚Äôs defined at the top of
the file. When the compiler reads the file, it will see all the
top-level declarations, no matter what order they come in the</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 108
file (with some limitations which we‚Äôll see later). Top-level
declarations are not nested within anything else and they are
in scope throughout the whole module.
We can contrast a top-level definition with a local definition.
To be locally defined would mean the declaration is nested
within some other expression and is not visible outside that
expression. We practiced this in the previous chapter with let
andwhere. Here‚Äôs an example for review:
moduleTopOrLocal where
topLevelFunction ::Integer -&gt;Integer
topLevelFunction x=
x+woot+topLevelValue
wherewoot::Integer
woot=10
topLevelValue ::Integer
topLevelValue =5
In the above, you could import and use topLevelFunction
ortopLevelValue from another module, and they are accessi-
ble to everything else in the module. However, wootis eÔ¨Äec-
tively invisible outside of topLevelFunction . Thewhereandlet
clauses in Haskell introduce local bindings or declarations.
To bind or declare something means to give an expression a</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 109
name. You could pass around and use an anonymous version
oftopLevelFunction manually, but giving it a name and reusing
it by that name is less repetitious.
Also note we explicitly declared the type of wootin thewhere
clause, using the ::syntax. This wasn‚Äôt necessary (Haskell‚Äôs
type inference would‚Äôve figured it out), but it was done here
to show you how. Be sure to load and run this code in your
REPL:
Prelude&gt; :l TopOrLocal.hs
[1 of 1] Compiling TopOrLocal
Ok, modules loaded: TopOrLocal.
*TopOrLocal&gt; topLevelFunction 5
20
Experiment with diÔ¨Äerent arguments and make sure you
understand the results you‚Äôre getting by walking through the
arithmetic in your head (or on paper).
Exercises: Scope
1.These lines of code are from a REPL session. Is ùë¶in scope
forùëß?
Prelude&gt; let x = 5
Prelude&gt; let y = 7
Prelude&gt; let z = x * y</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 110
2.These lines of code are from a REPL session. Is ‚Ñéin scope
forùëî? Go with your gut here.
Prelude&gt; let f = 3
Prelude&gt; let g = 6 * f + h
3.This code sample is from a source file. Is everything we
need to execute areain scope?
aread=pi*(r<em>r)
r=d/2
4.This code is also from a source file. Now are ùëüandùëëin
scope for area?
aread=pi</em>(r*r)
wherer=d/2
3.5 Types of concatenation functions
Let‚Äôs look at the types of (++)andconcat. The++function is
an infix operator. When we need to refer to an infix operator
in a position that is not infix ‚Äî such as when we are using it
in a prefix position or having it stand alone in order to query
its type ‚Äî we must put parentheses around it. On the other
hand,concat is a normal (not infix) function, so parentheses
aren‚Äôt necessary:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 111
++ has the type [a] -&gt; [a] -&gt; [a]
concat has the type [[a]] -&gt; [a]
Here‚Äôs how we query that in GHCi:
Prelude&gt; :t (++)
(++) :: [a] -&gt; [a] -&gt; [a]
Prelude&gt; :t concat
concat :: [[a]] -&gt; [a]
The type of concat says that we have a list of lists as input
and we will return a list. It will have the same values inside it
as the list of lists did; it just flattens it into one list structure, in
a manner of speaking. A String is a list, a list of Charspecifically,
andconcat can work on lists of strings or lists of lists of other
things:
Prelude&gt; concat [[1, 2], [3, 4, 5], [6, 7]]
[1,2,3,4,5,6,7]
Prelude&gt; concat [&quot;Iowa&quot;, &quot;Melman&quot;, &quot;Django&quot;]
&quot;IowaMelmanDjango&quot;
(n.b., Assuming you are using GHC 7.10 or higher, if you
check this type signature in your REPL, you will see a dif-
ference. We‚Äôll explain it in detail later; for now, please read
Foldable t =&gt; t [a] as being [[a]]. TheFoldable t , for our cur-
rent purposes, can be thought of as another list. In truth, list is</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 112
only one of the possible types here ‚Äî types that have instances
of theFoldable typeclass ‚Äî but right now, lists are the only one
we care about.)
But what do these types mean? Here‚Äôs how we can break it
down:
(++)::[a]-&gt;[a]-&gt;[a]
-- [1] [2] [3]
Everything after the ::is about our types, not our values.
The ‚Äòa‚Äô inside the list type constructor []is a type variable.
1.Take an argument of type [a]. This type is a list of ele-
ments of some type ùëé. This function does not know what
typeùëéis. It doesn‚Äôt need to know. In the context of the
program, the type of ùëéwill be known and made concrete
at some point.
2.Take another argument of type [a], a list of elements
whose type we don‚Äôt know. Because the variables are the
same, they must be the same type throughout (a == a).
3.Return a result of type [a].
As we‚Äôll see, because String is a type of list, the operators
we use with strings can also be used on lists of other types,
such as lists of numbers. The type [a]means that we have
a list with elements of a type ùëéwe do not yet know. If we</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 113
use the operators to concatenate lists of numbers, then the
ùëéin[a]will be some type of number (for example, integers).
If we are concatenating lists of characters, then ùëérepresents
aCharbecause String is[Char]. The type variable ùëéin[a]is
polymorphic. Polymorphism is an important feature of Haskell.
For concatenation, every list must be the same type of list; we
cannot concatenate a list of numbers with a list of characters,
for example. However, since the ùëéis a variable at the type level,
the literal values in each list we concatenate need not be the
same, only the same type. In other words, ùëémust equal ùëé(a ==
a).
Prelude&gt; &quot;hello&quot; ++ &quot; Chris&quot;
&quot;hello Chris&quot;
But:
Prelude&gt; &quot;hello&quot; ++ [1, 2, 3]
<interactive>:14:13:
No instance for (Num Char) arising
from the literal ‚Äò1‚Äô
In the expression: 1
In the second argument of ‚Äò(++)‚Äô,
namely ‚Äò[1, 2, 3]‚Äô
In the expression: &quot;hello&quot; ++ [1, 2, 3]</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 114
In the first example, we have two strings, so the type of ùëé
matches ‚Äî they‚Äôre both Charin[Char] , even though the literal
values are diÔ¨Äerent. Since the type matches, no type error
occurs and we see the concatenated result.
In the second example, we have two lists (a String and a
list of numbers) whose types do not match, so we get the
error message. GHCi asks for an instance of the numeric
typeclass Numfor the type Char.Typeclasses provide definitions
of operations, or functions, that can be shared across sets of
types. For now, you can understand this message as telling
you the types don‚Äôt match so it can‚Äôt concatenate the two lists.
Exercises: Syntax Errors
Read the syntax of the following functions and decide whether
it will compile. Test them in your REPL and try to fix the
syntax errors where they occur.
1.++ [1, 2, 3] [4, 5, 6]
2.'&lt;3' ++ ' Haskell'
3.concat [&quot;&lt;3&quot;, &quot; Haskell&quot;]</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 115
3.6 Concatenation and scoping
We will use parentheses to call ++as a prefix (not infix) function:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 116
-- print3flipped.hs
modulePrint3Flipped where
myGreeting ::String
myGreeting =(++)&quot;hello&quot; &quot; world!&quot;
hello::String
hello=&quot;hello&quot;
world::String
world=&quot;world!&quot;
main::IO()
main= do
putStrLn myGreeting
putStrLn secondGreeting
wheresecondGreeting =
(++) hello (( ++)&quot; &quot;world)
-- could've been:
-- secondGreeting =
-- hello ++ &quot; &quot; ++ world
InsecondGreeting , using++as a prefix function forces us to
shift some things around. Parenthesizing it that way empha-
sizes the right associativity of the ++function. Since it‚Äôs an infix</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 117
operator, you can check for yourself that it‚Äôs right associative:
Prelude&gt; :i (++)
(++) :: [a] -&gt; [a] -&gt; [a] -- Defined in ‚ÄòGHC.Base‚Äô
infixr 5 ++
Thewhereclause creates local bindings for expressions that
are not visible at the top level. In other words, the whereclause
inmainintroduces a definition visible only within the expres-
sion or function it‚Äôs attached to, rather than making it visible to
theentiremodule. Somethingvisibleatthetoplevelisinscope
for all parts of the module and may be exported by the module
or imported by a diÔ¨Äerent module. Local definitions, on the
other hand, are only visible to that one function. You cannot
import into a diÔ¨Äerent module and reuse secondGreeting .
To illustrate:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 118
-- print3broken.hs
modulePrint3Broken where
printSecond ::IO()
printSecond = do
putStrLn greeting
main::IO()
main= do
putStrLn greeting
printSecond
wheregreeting =&quot;Yarrrrr&quot;
You should get an error like this:
Prelude&gt; :l print3broken.hs
[1 of 1] Compiling Print3Broken
( print3broken.hs, interpreted )
print3broken.hs:6:12: Not in scope: ‚Äògreeting‚Äô
Failed, modules loaded: none.
Let‚Äôs take a closer look at this error:
print3broken.hs:6:12: Not in scope: ‚Äògreeting‚Äô</p>
<h1 id="12-3-4"><a class="header" href="#12-3-4">[1][2] [3] [4]</a></h1>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 119
1.The line the error occurred on: in this case, line 6.
2.The column the error occurred on: column 12. Text
on computers is often described in terms of lines and
columns. These line and column numbers are about lines
and columns in your text file containing the source code.
3.The actual problem: we refer to something not in scope,
that is, not visible to theprintSecond function.
4.The thing we referred to that isn‚Äôt visible or in scope.
Now make the Print3Broken code compile. It should print
‚ÄúYarrrrr‚Äù twice on two diÔ¨Äerent lines and then exit.
3.7 More list functions
Since a String is a specialized type of list, you can use standard
list operations on strings as well.
Here are some examples:
Prelude&gt; :t 'c'
'c' :: Char
Prelude&gt; :t &quot;c&quot;
&quot;c&quot; :: [Char]
-- [Char] is String
The(:)operator, called cons, builds a list:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 120
Prelude&gt; 'c' : &quot;hris&quot;
&quot;chris&quot;
Prelude&gt; 'P' : &quot;&quot;
&quot;P&quot;
Next up, headreturns the head or first element of a list:
Prelude&gt; head &quot;Papuchon&quot;
'P'
The complementary function tailreturns the list with the
head chopped oÔ¨Ä:
Prelude&gt; tail &quot;Papuchon&quot;
&quot;apuchon&quot;
takereturns the specified number of elements from the list,
starting from the left:
Prelude&gt; take 1 &quot;Papuchon&quot;
&quot;P&quot;
Prelude&gt; take 0 &quot;Papuchon&quot;
&quot;&quot;
Prelude&gt; take 6 &quot;Papuchon&quot;
&quot;Papuch&quot;
Anddropreturns the remainder of the list after the specified
number of elements has been dropped:</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 121
Prelude&gt; drop 4 &quot;Papuchon&quot;
&quot;chon&quot;
Prelude&gt; drop 9001 &quot;Papuchon&quot;
&quot;&quot;
Prelude&gt; drop 1 &quot;Papuchon&quot;
&quot;apuchon&quot;
We‚Äôve already seen the (++)operator:
Prelude&gt; &quot;Papu&quot; ++ &quot;chon&quot;
&quot;Papuchon&quot;
Prelude&gt; &quot;Papu&quot; ++ &quot;&quot;
&quot;Papu&quot;
The infix operator, (!!), returns the element that is in the
specified position in the list. Note that this is an indexing func-
tion, and indices start from 0. That means the first element of
your list is 0, not 1, when using this function:
Prelude&gt; &quot;Papuchon&quot; !! 0
'P'
Prelude&gt; &quot;Papuchon&quot; !! 4
'c'
Note that while all these functions are standard Prelude func-
tions, many of them are considered unsafe. They are unsafe
because they do not cover the case where they are given an</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 122
empty list as input. Instead they throw out an error message,
orexception :
Prelude&gt; head &quot;&quot;
*** Exception: Prelude.head: empty list
Prelude&gt; &quot;&quot; !! 4
*** Exception: Prelude.!!: index too large
This isn‚Äôt ideal behavior, so the use of these functions is
considered unwise for programs of any real size or complexity,
although we will use them in these first few chapters. We will
address how to cover all cases and make safer versions of such
functions in a later chapter.
3.8 Chapter Exercises
Reading syntax
1.For the following lines of code, read the syntax carefully
and decide if they are written correctly. Test them in your
REPL after you‚Äôve decided to check your work. Correct
as many as you can.
a)concat[[1,2,3], [4,5,6]]
b)++[1,2,3] [4,5,6]
c)(++)&quot;hello&quot; &quot; world&quot;</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 123
d)[&quot;hello&quot; ++&quot; world]
e)4!!&quot;hello&quot;
f)(!!)&quot;hello&quot; 4
g)take&quot;4 lovely&quot;
h)take3&quot;awesome&quot;
2.Next we have two sets: the first set is lines of code and
the other is a set of results. Read the code and figure out
which results came from which lines of code. Be sure to
test them in the REPL.
a)concat[[1<em>6], [2</em>6], [3<em>6]]
b)&quot;rain&quot;++drop2&quot;elbow&quot;
c)10</em>head [1,2,3]
d)(take3&quot;Julie&quot;)++(tail&quot;yes&quot;)
e)concat[tail [1,2,3],
tail [4,5,6],
tail [7,8,9]]
Can you match each of the previous expressions to one
of these results presented in a scrambled order?
a)&quot;Jules&quot;
b)[2,3,5,6,8,9]</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 124
c)&quot;rainbow&quot;
d)[6,12,18]
e)10
Building functions
1.Given the list-manipulation functions mentioned in this
chapter, write functions that take the following inputs and
return the expected outputs. Do them directly in your
REPL and use the takeanddropfunctions you‚Äôve already
seen.
Example
-- If you apply your function
-- to this value:
&quot;Hello World&quot;
-- Your function should return:
&quot;ello World&quot;
The following would be a fine solution:
Prelude&gt; drop 1 &quot;Hello World&quot;
&quot;ello World&quot;</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 125
Now write expressions to perform the following trans-
formations, just with the functions you‚Äôve seen in this
chapter. You do not need to do anything clever here.
a)-- Given
&quot;Curry is awesome&quot;
-- Return
&quot;Curry is awesome!&quot;
b)-- Given
&quot;Curry is awesome!&quot;
-- Return
&quot;y&quot;
c)-- Given
&quot;Curry is awesome!&quot;
-- Return
&quot;awesome!&quot;
2.Now take each of the above and rewrite it in a source
file as a general function that could take diÔ¨Äerent string
inputs as arguments but retain the same behavior. Use
a variable as the argument to your (named) functions. If
you‚Äôre unsure how to do this, refresh your memory by
looking at the waxOff exercise from the previous chapter
and the TopOrLocal module from this chapter.</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 126
3.Write a function of type String -&gt; Char which returns the
third character in a String . Remember to give the function
a name and apply it to a variable, not a specific String,
so that it could be reused for diÔ¨Äerent String inputs, as
demonstrated (feel free to name the function something
else. Be sure to fill in the type signature and fill in the
function definition after the equals sign):
thirdLetter ::
thirdLetter x=
-- If you apply your function
-- to this value:
&quot;Curry is awesome&quot;
-- Your function should return
`r'
Note that programming languages conventionally start
indexing things by zero, so getting the zeroth index of a
string will get you the first letter. Accordingly, indexing
with 3 will get you the fourth. Keep this in mind as you
write this function.
4.Now change that function so the string operated on is
always the same and the variable represents the number
of the letter you want to return (you can use ‚ÄúCurry is</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 127
awesome!‚Äù as your string input or a diÔ¨Äerent string if you
prefer).
letterIndex ::Int-&gt;Char
letterIndex x=
5.Using the takeanddropfunctions we looked at above, see
if you can write a function called rvrs(an abbreviation of
‚Äòreverse‚Äô used because there is a function called ‚Äòreverse‚Äô
already in Prelude, so if you call your function the same
name, you‚Äôll get an error message). rvrsshould take the
string ‚ÄúCurry is awesome‚Äù and return the result ‚Äúawesome
is Curry.‚Äù This may not be the most lovely Haskell code
you will ever write, but it is quite possible using only what
we‚Äôve learned so far. First write it as a single function in
a source file. This doesn‚Äôt need to, and shouldn‚Äôt, work
for reversing the words of anysentence. You‚Äôre expected
only to slice and dice this particular string with takeand
drop.
6.Let‚Äôs see if we can expand that function into a module.
Why would we want to? By expanding it into a module,
we can add more functions later that can interact with
each other. We can also then export it to other modules
if we want to and use this code in those other modules.
There are diÔ¨Äerent ways you could lay it out, but for the</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 128
sake of convenience, we‚Äôll show you a sample layout so
that you can fill in the blanks:
moduleReverse where
rvrs::String-&gt;String
rvrsx=
main::IO()
main=print()
Into the parentheses after printyou‚Äôll need to fill in your
function name rvrsplus the argument you‚Äôre applying
rvrsto, in this case ‚ÄúCurry is awesome.‚Äù That rvrsfunction
plus its argument are now the argument to print. It‚Äôs
important to put them inside the parentheses so that that
function gets applied and evaluated first, and then that
result is printed.
Of course, we have also mentioned that you can use the $
symbol to avoid using parentheses, too. Try modifying
your main function to use that instead of the parentheses.
3.9 Definitions
1.AString is a sequence of characters. In Haskell, String is
represented by a linked-list of Charvalues, aka [Char] .</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 129
2.Atypeor datatype is a classification of values or data.
Types in Haskell determine what values are members
of the type or that inhabit the type. Unlike in other lan-
guages, datatypes in Haskell by default do not delimit the
operations that can be performed on that data.
3.Concatenation is the joining together of sequences of val-
ues. Often in Haskell this is meant with respect to the
[], or list, datatype, which also applies to String which is
[Char] . Theconcatenation function in Haskell is (++)which
has type [a] -&gt; [a] -&gt; [a] . For example:
Prelude&gt; &quot;tacos&quot; ++ &quot; &quot; ++ &quot;rock&quot;
&quot;tacos rock&quot;
4.Scope is where a variable referred to by name is valid.
Another word used with the same meaning is visibility ,
because if a variable isn‚Äôt visible it‚Äôs not in scope.
5.Local bindings are bindings local to particular expressions.
The primary delineation here from top level bindings is
thatlocalbindings cannot be imported by other programs
or modules.
6.Toplevelbindings in Haskell are bindings that stand outside
of any other declaration. The main feature of top-level</p>
<p>CHAPTER 3. SIMPLE OPERATIONS WITH TEXT 130
bindings is that they can be made available to other mod-
ules within your programs or to other people‚Äôs programs.
7.Data structures are a way of organizing data so that the
data can be accessed conveniently or efficiently.</p>
<p>Chapter 4
Basic datatypes
There are many ways of
trying to understand
programs. People often
rely too much on one
way, which is called
‚Äúdebugging‚Äù and consists
of running a
partly-understood
program to see if it does
what you expected.
Another way, which ML
advocates, is to install
some means of
understanding in the very
programs themselves.
Robin Milner
131</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 132
4.1 Basic Datatypes
Haskell has a robust and expressive type system. Types play an
important role in the readability, safety, and maintainability of
Haskell code as they allow us to classify and delimit data, thus
restricting the forms of data our programs can process. Types,
also called datatypes , provide the means to build programs
more quickly and also allow for greater ease of maintenance.
As we learn more Haskell, we‚Äôll learn how to leverage types
in a way that lets us accomplish the same things but with less
code.
So far, we‚Äôve looked at expressions involving numbers, char-
acters, and lists of characters, also called strings. These are
some of the standard datatypes and are built into the standard
library. While those are useful datatypes and cover a lot of
types of values, they don‚Äôt cover every type of data. In this
chapter, we will
‚Ä¢review types we have seen in previous chapters;
‚Ä¢learn about datatypes, type constructors, and data con-
structors;
‚Ä¢work with predefined datatypes;
‚Ä¢learn more about type signatures and a bit about type-
classes.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 133
4.2 What are types?
Expressions, when evaluated, reduce to values. Every value
has a type. Types are how we group a set of values together
that share something in common. Sometimes that common-
ality is abstract; sometimes it‚Äôs a specific model of a particular
concept or domain. If you‚Äôve taken a mathematics course that
covered sets, thinking about types as being like sets will help
guide your intuition on what types are and how they work in
a mathematical1sense.
4.3 Anatomy of a data declaration
Data declarations are how datatypes are defined.
The type constructor is the name of the type and is capi-
talized. When you are reading or writing type signatures (the
type level of your code), the type names or type constructors
are what you use.
Data constructors are the values that inhabit the type they
are defined in. They are the values that show up in your code,
at the term level instead of the type level. By term level , we
mean they are the values as they appear in your code or the
values that your code evaluates to.
1Set theory is the study of mathematical collections of objects. Set theory was a
precursor to type theory, the latter being used prolifically in the design of programming
languages like Haskell. Logical operations like disjunction (or) and conjunction (and) used
in the manipulation of sets have equivalents in Haskell‚Äôs type system.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 134
We will start with a basic datatype to see how datatypes are
structured and get acquainted with the vocabulary. Boolisn‚Äôt a
datatype we‚Äôve seen yet in the book, but it provides for truth
values. It is named after the great logician George Boole and
the system of logic named for him. Because there are only
two truth values, there are only two data constructors:
-- the definition of Bool
dataBool=False|True
-- [1] [2] [3] [4]
1.Type constructor for datatype Bool. This is the name of
the type and shows up in type signatures.
2.Data constructor for the value False.
3.Pipe|indicates a sum type or logical disjunction: or. So, a
Boolvalue is TrueorFalse.
4.Data constructor for the value True.
The whole thing is called a data declaration. Data declara-
tions do not always follow precisely the same pattern ‚Äî there
are datatypes that use logical conjunction ( and) instead of dis-
junction, and some type constructors and data constructors
may have arguments. The thing they have in common is the
keyword datafollowed by the type constructor (or name of
the type that will appear in type signatures), the equals sign to</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 135
denote a definition, and then data constructors (or names of
values that inhabit your term-level code).
You can find the datatype definition for built-in datatypes
by using :infoin GHCi:
Prelude&gt; :info Bool
data Bool = False | True
Let‚Äôs look at where diÔ¨Äerent parts of datatypes show up
in our code. If we query the type information for a function
callednotwe see that it takes one Boolvalue and returns another
Boolvalue, so the type signature makes reference to the type
constructor, or datatype name:
Prelude&gt; :t not
not :: Bool -&gt; Bool
But when we use the notfunction, we use the data construc-
tors, or values:
Prelude&gt; not True
False
And our expression evaluates to another data constructor,
or value ‚Äî in this case, the other data constructor for the same
datatype.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 136
Exercises: Mood Swing
Given the following datatype, answer the following questions:
dataMood=Blah|Wootderiving Show
Thederiving Show part is not something we‚Äôve explained
yet. For now, all we‚Äôll say is that when you make your own
datatypes, deriving Showallows the values of that type to be
printed to the screen. We‚Äôll talk about it more when we talk
about typeclasses in detail.
1.What is the type constructor, or name of this type?
2.If the function requires a Moodvalue, what are the values
you could possibly use?
3.We are trying to write a function changeMood to change
Chris‚Äôs mood instantaneously. It should act like notin
that, given one value, it returns the othervalue of the same
type. So far, we‚Äôve written a type signature changeMood ::
Mood -&gt; Woot . What‚Äôs wrong with that?
4.Now we want to write the function that changes his mood.
Given an input mood, it gives us the other one. Fix any
mistakes and complete the function:
changeMood Mood=Woot
changeMood _ =Blah</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 137
We‚Äôre doing something here called pattern matching . We
can define a function by matching on a data constructor,
or value, and describing the behavior that the function
should have based on which value it matches. The un-
derscore in the second line denotes a catch-all, otherwise
case. So, in the first line of the function, we‚Äôre telling it
what to do in the case of a specific input. In the second
one, we‚Äôre telling it what to do regardless of all potential
inputs. It‚Äôs trivial when there are only two potential values
of a given type, but as we deal with more complex cases,
it can be convenient.
5.Enter all of the above ‚Äî datatype (including the deriving
Showbit), your corrected type signature, and the corrected
function into a source file. Load it and run it in GHCi to
make sure you got it right.
4.4 Numeric types
Let‚Äôs look next at numeric types, because we‚Äôve already seen
these types in previous chapters, and numbers are familiar
territory. It‚Äôs important to understand that Haskell does not
use only one type of number. For most purposes, the types of
numbers we need to be concerned with are:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 138
Integral numbers These are whole numbers, positive and
negative.
1.Int: This type is a fixed-precision integer. By ‚Äúfixed pre-
cision,‚Äù we mean it has a range, with a maximum and a
minimum, and so it cannot be arbitrarily large or small
‚Äî more about this in a moment.
2.Integer : This type is also for integers, but this one supports
arbitrarily large (or small) numbers.
Fractional These are not integers. Fractional values include
the following four types:
1.Float: This is the type used for single-precision float-
ing point numbers. Fixed-point number representations
have immutable numbers of digits assigned for the parts
of the number before and after the decimal point. In
contrast, floating point can shift how many bits it uses to
represent numbers before or after the decimal point. This
flexibility does, however, mean that floating point arith-
metic violates some common assumptions and should
only be used with great care. Generally, floating point
numbers should not be used at all in business applications.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 139
2.Double : This is a double-precision floating point number
type. It has twice as many bits with which to describe
numbers as the Floattype.
3.Rational : This is a fractional number that represents a
ratio of two integers. The value 1 / 2 :: Rational will be a
value carrying two Integer values, the numerator 1and the
denominator 2, and represents a ratio of 1 to 2. Rational is
arbitrarily precise but not as efficient as Scientific .
4.Scientific : This is a space efficient and almost arbitrary
precision scientific number type. Scientific numbers are
represented using scientific notation. It stores the coef-
ficient as an Integer and the exponent as an Int. Since
Intisn‚Äôt arbitrarily large, there is technically a limit to
the size of number you can express with Scientific , but
hitting that limit is quite unlikely. Scientific is available
in a library2and can be installed using cabal install or
stack install .
These numeric datatypes all have instances of a typeclass
calledNum. We will talk about typeclasses in the upcoming
chapters, but as we look at the types in this section, you will
seeNumlisted in some of the type information.
Typeclasses are a way of adding functionality to types that
is reusable across all the types that have instances of that type-
2Hackage page for scientific :https://hackage.haskell.org/package/scientific</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 140
class.Numis a typeclass for which most numeric types will
have an instance because there are standard functions that are
convenient to have available for all types of numbers. The Num
typeclass is what provides your standard (+),(-), and(*)oper-
ators along with a few others. Any type that has an instance of
Numcan be used with those functions. An instance defines how
the functions work for that specific type. We will talk about
typeclasses in much more detail soon.
Integral numbers
As we noted above, there are two main types of integral num-
bers:IntandInteger .
Integral numbers are whole numbers with no fractional
component. The following are integral numbers:
1219932442353464675685678
The following are not integral numbers:
1.31/2
Integer
The numbers of type Integer are the sorts of numbers we‚Äôre
used to working with in arithmetic equations that involve
whole numbers. They can be positive or negative, and Integer
extends as far in either direction as one needs them to go.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 141
TheBooldatatype only has two possible values, so we can list
them explicitly as data constructors. In the case of Integer , and
most numeric datatypes, these data constructors are not writ-
ten out because they include an infinite series of whole num-
bers. We‚Äôd need infinite data constructors stretching up and
down from zero. Hypothetically we could represent Integer as
a sum of three cases, recursive constructors headed towards
negative infinity, zero, and recursive constructors headed to-
wards positive infinity. This representation would be terribly
inefficient so there‚Äôs some GHC magic sprinkled on it.
Why do we have Int?
TheIntnumeric types are artifacts of what computer hardware
has supported natively over the years. Most programs should
useInteger , notInt, unless the limitations of the type are un-
derstood and the additional performance makes a diÔ¨Äerence.
The danger of Intand the related types Int8,Int16, et al. is
that they cannot express arbitrarily large quantities of infor-
mation. Since they are integral, this means they cannot be
arbitrarily large in the positive or negative sense.
Here‚Äôs what happens if we try to represent a number too
large for Int8:
Prelude&gt; import GHC.Int
Prelude&gt; 127 :: Int8</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 142
127
Prelude&gt; 128 :: Int8
<interactive>:11:1: Warning:
Literal 128 is out of the
Int8 range -128..127
If you are trying to write a large
negative literal,
use NegativeLiterals
-128
Prelude&gt; (127 + 1) :: Int8
-128
The syntax you see there, :: Int8 is us assigning the Int8
type to these numbers. As we will explain in more detail in
the next chapter, numbers are polymorphic under the surface,
and the compiler doesn‚Äôt assign them a concrete type until it
is forced to. It would be weird and unexpected if the compiler
defaulted all numbers to Int8, so in order to reproduce the
situation of having a number too large for an Inttype, we had
to assign that concrete type to it.
As you can see, 127 is fine because it is within the range of
valid values of type Int8, but 128 gives you a warning about
the impending overflow, and 127 + 1 overflows the bounds
and resets back to its smallest numeric value. Because the
memory the value is allowed to occupy is fixed for Int8, it</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 143
cannot grow to accommodate the value 128 the way Integer
can. Here the 8 represents how many bits the type uses to
represent integral numbers.3Being of a fixed size can be
useful in some applications, but most of the time, Integer is
preferred.
You can find out the minimum and maximum bounds of
numeric types using maxBound andminBound from the Bounded
typeclass. Here‚Äôs an example using our Int8andInt16example:
Prelude&gt; import GHC.Int
Prelude&gt; :t minBound
minBound :: Bounded a =&gt; a
Prelude&gt; :t maxBound
maxBound :: Bounded a =&gt; a
Prelude&gt; minBound :: Int8
-128
Prelude&gt; minBound :: Int16
-32768
Prelude&gt; minBound :: Int32
-2147483648
Prelude&gt; minBound :: Int64
-9223372036854775808
3The representation used for the fixed-size Inttypes is two‚Äôs complement .</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 144
Prelude&gt; maxBound :: Int8
127
Prelude&gt; maxBound :: Int16
32767
Prelude&gt; maxBound :: Int32
2147483647
Prelude&gt; maxBound :: Int64
9223372036854775807
Thus you can find the limitations of possible values for
any type that has an instance of that particular typeclass. In
this case, we are able to find out the range of values we can
represent with an Int8is -128 to 127.
You can find out if a type has an instance of Bounded , or any
other typeclass, by asking GHCi for the :infofor that type.
Doing this will also give you the datatype representation for
the type you queried:
Prelude&gt; :i Int
data Int = GHC.Types.I# GHC.Prim.Int#
-- Defined in ‚ÄòGHC.Enum‚Äô
instance Bounded Int
Intof course has many more typeclass instances, but Bounded
is the one we cared about at this time.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 145
Fractional numbers
The four common Fractional types in use in Haskell are Float,
Double ,Rational , andScientific .Rational ,Double , andFloatcome
with your install of GHC. Scientific comes from a library, as
we mentioned previously. Rational andScientific are arbi-
trary precision, with the latter being more efficient. Arbitrary
precision means that these can be used to do calculations re-
quiring a high degree of precision rather than being limited
to a specific degree of precision, the way FloatandDouble are.
You almost never want a Floatunless you‚Äôre doing graphics
programming such as with OpenGL.
Some computations involving numbers will be fractional
rather than integral. A good example of this is the division
function (/)which has the type:
Prelude&gt; :t (/)
(/) :: Fractional a =&gt; a -&gt; a -&gt; a
The notation Fractional a =&gt; denotes a typeclass constraint .
It tells us the type variable ùëémust implement the Fractional
typeclass. Whatever type of number ùëéturns out to be, it must
be a type that has an instance of the Fractional typeclass; that
is, there must be a declaration of how the operations from
that typeclass will work for the type. The /function will take
one number that implements Fractional , divide it by another</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 146
of the same type, and return a value of the same type as the
result.
Fractional is a typeclass that requires types to already have
an instance of the Numtypeclass. We describe this relation-
ship between typeclasses by saying that Numis a superclass of
Fractional . So(+)and other functions from the Numtypeclass
can be used with Fractional numbers, but functions from the
Fractional typeclass cannot be used with all types that have a
Numinstance:
Here‚Äôs what happens when we use (/)in the REPL:
Prelude&gt; 1 / 2
0.5
Prelude&gt; 4 / 2
2.0
Note that even when we had a whole number as a result,
the result was fractional. This is because values of Fractional
a =&gt; a default to the floating point type Double. In most cases,
you won‚Äôt want to explicitly use Double. You may be better
oÔ¨Ä using the arbitrary precision sibling to Integer ,Scientific .
Most people do not find it easy to reason about floating point
arithmetic and find it difficult to code around the quirks (those
quirks exist by design, but that‚Äôs another story), so in order
to avoid making mistakes, use arbitrary-precision types as a
matter of course.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 147
4.5 Comparing values
Up to this point, most of our operations with numbers have
involved doing simple arithmetic. We can also compare num-
bers to determine whether they are equal, greater than, or less
than:
Prelude&gt; let x = 5
Prelude&gt; x == 5
True
Prelude&gt; x == 6
False
Prelude&gt; x &lt; 7
True
Prelude&gt; x &gt; 3
True
Prelude&gt; x /= 5
False
Notice here that we first declared a value for ùë•using the
standard equals sign. Now we know that for the remainder of
our REPL session, all instances of ùë•will be the value 5. Because
the equals sign in Haskell is already used to define variables
and functions, we must use a double equals sign, ==, to have
the specific meaning is equal to . The/=symbol means is not
equal to . The other symbols should already be familiar to you.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 148
Having done this, we see that GHCi is returning a result of
eitherTrueorFalse, depending on whether the expression is
true or false. TrueandFalseare the data constructors for the
Booldatatype we saw above. If you look at the type information
for any of these infix operators, you‚Äôll find the result type listed
asBool:
Prelude&gt; :t (==)
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool
Prelude&gt; :t (&lt;)
(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool
Notice that we get some typeclass constraints again. Eqis a
typeclass that includes everything that can be compared and
determined to be equal in value; Ordis a typeclass that includes
all things that can be ordered. Note that neither of these is
limited to numbers. Numbers can be compared and ordered,
of course, but so can letters, so this typeclass constraint allows
for flexibility. These equality and comparison functions can
take any values that can be said to have equal value or can be
ordered. The rest of the type information tells us that it takes
one of these values, compares it to another value of the same
type, and returns a Boolvalue. As we‚Äôve already seen, the Bool
values are TrueorFalse.
With this information, let‚Äôs try playing with some other
values:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 149
Prelude&gt; 'a' == 'a'
True
Prelude&gt; 'a' == 'b'
False
Prelude&gt; 'a' &lt; 'b'
True
Prelude&gt; 'a' &gt; 'b'
False
Prelude&gt; 'a' == 'A'
False
Prelude&gt; &quot;Julie&quot; == &quot;Chris&quot;
False
We know that alphabetical characters can be ordered, al-
though we do not normally think of ‚Äòa‚Äô as being ‚Äúless than‚Äù ‚Äòb.‚Äô
But we can understand that here it means ‚Äòa‚Äô comes before ‚Äòb‚Äô in
alphabetical order. Further, we see this also works with strings
such as ‚ÄúJulie‚Äù or ‚ÄúChris.‚Äù GHCi has faithfully determined that
those two strings are not equal in value.
Now use your REPL to determine whether ‚Äòa‚Äô or ‚ÄòA‚Äô is greater.
Next, take a look at this sample and see if you can figure out
why GHCi returns the given results:
Prelude&gt; &quot;Julie&quot; &gt; &quot;Chris&quot;
True
Prelude&gt; &quot;Chris&quot; &gt; &quot;Julie&quot;
False</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 150
Good to see Haskell code that reflects reality. ‚ÄúJulie‚Äù is
greater than ‚ÄúChris‚Äù because J &gt;C, if the words had been ‚ÄúBack‚Äù
and ‚ÄúBrack‚Äù then it would‚Äôve skipped the first letter to deter-
mine which was greater because B == B, then ‚ÄúBrack‚Äù would
have been greater because ‚Äòr‚Äô &gt;‚Äòa‚Äô in the lexicographic ordering.
Note that this is leaning on the Ordtypeclass instances for the
list type andChar. You can only compare lists of items where
the items themselves also have an instance of Ord. Accordingly,
the following will work because CharandInteger have instances
ofOrd:
Prelude&gt; ['a', 'b'] &gt; ['b', 'a']
False
Prelude&gt; 1 &gt; 2
False
Prelude&gt; [1, 2] &gt; [2, 1]
False
A datatype that has no instance of Ordwill not work with
these functions:
Prelude&gt; data Mood = G | B deriving Show
Prelude&gt; [G, B]
[G,B]
Prelude&gt; [G, B] &gt; [B, G]
<interactive>:28:14:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 151
No instance for (Ord Mood) arising
from a use of ‚Äò&gt;‚Äô
In the expression: [G, B] &gt; [B, G]
In an equation for ‚Äòit‚Äô:
it = [G, B] &gt; [B, G]
‚ÄúNo instance for (Ord Mood) ‚Äù means it doesn‚Äôt have an Ord
instance to know how to order these values.
Here is another thing that doesn‚Äôt work with these functions:
Prelude&gt; &quot;Julie&quot; == 8
<interactive>:38:12:
No instance for (Num [Char]) arising from
the literal ‚Äò8‚Äô
In the second argument of ‚Äò(==)‚Äô,
namely ‚Äò8‚Äô
In the expression: &quot;Julie&quot; == 8
In an equation for ‚Äòit‚Äô: it = &quot;Julie&quot; == 8
We said above that comparison functions are polymorphic
and can work with a lot of diÔ¨Äerent types. But we also noted
that the type information only admitted values of matching
types. Once you‚Äôve given a term-level value that is a String
such as ‚ÄúJulie,‚Äù the type is determined and the other argument
must have the same type. The error message we see above is</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 152
telling us that the type of the literal value 8 doesn‚Äôt match the
type of the first value, and for this function, it must.
4.6 Go on and Bool me
TheBooldatatype comes standard in the Prelude . As we saw
earlier, Boolis a sum type with two constructors:
dataBool=False|True
This declaration creates a datatype with the type construc-
torBool, and we refer to specific types by their type construc-
tors. We use type constructors in type signatures, not in the
expressions that make up our term-level code. The type con-
structor Booltakes no arguments (some type constructors do
take arguments). The definition of Boolabove also creates two
data constructors, TrueandFalse. Both of these values are of
typeBool. Any function that accepts values of type Bool must
allow for the possibility of TrueorFalse; you cannot specify
in the type that it should only accept one specific value. An
English language formulation of this datatype would be some-
thing like: ‚ÄúThe datatype Boolis represented by the values True
orFalse.‚Äù
Remember, you can find the type of any value by asking
for it in GHCi, just as you can with functions:
Prelude&gt; :t True</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 153
True :: Bool
Prelude&gt; :t &quot;Julie&quot;
&quot;Julie&quot; :: [Char]
Now let‚Äôs have some fun with Bool. We‚Äôll start by reviewing
thenotfunction:
Prelude&gt; :t not
not :: Bool -&gt; Bool
Prelude&gt; not True
False
Note that we capitalize TrueandFalsebecause they are our
data constructors. What happens if you try to use notwithout
capitalizing them?
Let‚Äôs try something slightly more complex:
Prelude&gt; let x = 5
Prelude&gt; not (x == 5)
False
Prelude&gt; not (x &gt; 7)
True
We know that comparison functions evaluate to a Boolvalue,
so we can use them with not.
Let‚Äôsplaywithinfixoperatorsthatdealdirectlywithboolean
logic. How do we use Booland these associated functions?</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 154
First,(&amp;&amp;)is the infix operator for boolean conjunction. The
first example reads, colloquially, ‚Äútrue and true:‚Äù
Prelude&gt; True &amp;&amp; True
True
Prelude&gt; (8 &gt; 4) &amp;&amp; (4 &gt; 5)
False
Prelude&gt; not (True &amp;&amp; True)
False
The infix operator for boolean disjunction is (||), so the
first example here reads ‚Äúfalse or true:‚Äù
Prelude&gt; False || True
True
Prelude&gt; (8 &gt; 4) || (4 &gt; 5)
True
Prelude&gt; not ((8 &gt; 4) || (4 &gt; 5))
False
We can look up info about datatypes that are in scope (if
they‚Äôre not in scope, we have to import the module they live
in to bring them into scope) using the :infocommand GHCi
provides. Scope is a way to refer to where a named binding to
an expression is valid. When we say something is in scope , it
means you can use that expression by its bound name, either
because it was defined in the same function or module, or</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 155
because you imported it. So, it‚Äôs visible to the program we‚Äôre
trying to run right now. What is built into Haskell‚Äôs Prelude
module is significant because everything in it is automatically
imported and in scope. For now, this is what we want so we
don‚Äôt have to write every function from scratch.
Exercises: Find the Mistakes
The following lines of code may have mistakes ‚Äî some of
them won‚Äôt compile! You know what you need to do.
1.not True &amp;&amp; true
2.not (x = 6)
3.(1 * 2) &gt; 5
4.[Merry] &gt; [Happy]
5.[1, 2, 3] ++ &quot;look at me!&quot;
Conditionals with if-then-else
Haskell doesn‚Äôt have ‚Äòif‚Äô statements, but it does have if ex-
pressions . It‚Äôs a built-in bit of syntax that works with the Bool
datatype.
Prelude&gt; let t = &quot;Truthin'&quot;
Prelude&gt; let f = &quot;Falsin'&quot;</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 156
Prelude&gt; if True then t else f
&quot;Truthin'&quot;
The expression if True evaluates to True, hence we return ùë°.
Prelude&gt; if False then t else f
&quot;Falsin'&quot;
Prelude&gt; :t if True then t else f
if True then &quot;Truthin'&quot; else &quot;Falsin'&quot;
:: [Char]
Andif False evaluates to False, so we return the elsevalue.
The type of the whole expression is String (aka[Char] ) because
that‚Äôs the type of the value that is returned as a result.
The structure here is:
if CONDITION
then EXPRESSION_A
else EXPRESSION_B
If the condition (which must evaluate to Bool) reduces to the
valueTrue, thenEXPRESSION_A istheresult, otherwise EXPRESSION_B .
If-expressions can be thought of as a way to choose between
two values. You can embed a variety of expressions within
theifof an if-then-else, as long as it evaluates to Bool. The
types of the expressions in the thenandelseclauses must be
the same, as in the following:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 157
Prelude&gt; let x = 0
Prelude&gt; let a = &quot;AWESOME&quot;
Prelude&gt; let w = &quot;wut&quot;
Prelude&gt; if (x + 1 == 1) then a else w
&quot;AWESOME&quot;
Here‚Äôs how it reduces:
-- Given:
x=0
if(x+1==1)then&quot;AWESOME&quot; else&quot;wut&quot;
-- x is zero
if(0+1==1)then&quot;AWESOME&quot; else&quot;wut&quot;
-- reduce 0 + 1 so we can see
-- if it's equal to 1
if(1==1)then&quot;AWESOME&quot; else&quot;wut&quot;
-- Does 1 equal 1?
ifTruethen&quot;AWESOME&quot; else&quot;wut&quot;
-- pick the branch based on the Bool value
&quot;AWESOME&quot;
-- dunzo</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 158
But this does not work:
Prelude&gt; let dog = &quot;adopt a dog&quot;
Prelude&gt; let cat = &quot;or a cat&quot;
Prelude&gt; let x = 0
Prelude&gt; if x * 100 then dog else cat
<interactive>:15:7:
No instance for (Num Bool) arising
from a use of ‚Äò*‚Äô
In the expression: (x * 100)
In the expression:
if (x * 100)
then &quot;adopt a dog&quot;
else &quot;or a cat&quot;
In an equation for ‚Äòit‚Äô:
it = if (x * 100)
then &quot;adopt a dog&quot;
else &quot;or a cat&quot;
We got this type error because the condition passed to the
if-expression is of type Num a =&gt; a , notBoolandBooldoesn‚Äôt
implement the Numtypeclass. To oversimplify, (x * 100) evalu-
ates to a numeric result, and numbers aren‚Äôt truth values. It
would have typechecked had the condition been x * 100 == 0</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 159
orx * 100 == 9001 . In those cases, it would‚Äôve been an equality
check of two numbers which reduces to a Boolvalue.
Here‚Äôs an example of a function that uses a Boolvalue in an
if-expression:
-- greetIfCool1.hs
moduleGreetIfCool1 where
greetIfCool ::String-&gt;IO()
greetIfCool coolness =
ifcool
thenputStrLn &quot;eyyyyy. What's shakin'?&quot;
else
putStrLn &quot;pshhhh.&quot;
wherecool=
coolness ==&quot;downright frosty yo&quot;
When you test this in the REPL, it should play out like this:
Prelude&gt; :l greetIfCool1.hs
[1 of 1] Compiling GreetIfCool1
Ok, modules loaded: GreetIfCool1.
Prelude&gt; greetIfCool &quot;downright frosty yo&quot;
eyyyyy. What's shakin'?
Prelude&gt; greetIfCool &quot;please love me&quot;
pshhhh.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 160
Also note that greetIfCool could‚Äôve been written with cool
being a function rather than a value defined against the argu-
ment directly like so:
-- greetIfCool2.hs
moduleGreetIfCool2 where
greetIfCool ::String-&gt;IO()
greetIfCool coolness =
ifcool coolness
thenputStrLn &quot;eyyyyy. What's shakin'?&quot;
else
putStrLn &quot;pshhhh.&quot;
wherecool v=
v==&quot;downright frosty yo&quot;
4.7 Tuples
Tupleis a type that allows you to store and pass around multiple
values within a single value. Tuples have a distinctive, built-
in syntax that is used at both type and term levels, and each
tuple has a fixed number of constituents. We refer to tuples
by the number of values in each tuple: the two-tuple or pair,
for example, has two values inside it, (x, y); the three-tuple
or triple has three, (x, y, z) , and so on. This number is also</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 161
known as the tuple‚Äôs arity. As we will see, the values within a
tuple do not have to be of the same type.
We will start by looking at the two-tuple, a tuple with two
elements. The two-tuple is expressed at both the type level and
term level with the constructor (,). The datatype declaration
looks like this:
Prelude&gt;:info (,)
data(,) a b =(,) a b
This is diÔ¨Äerent from the Booltype we looked at earlier in a
couple of important ways, even apart from that special type
constructor syntax. The first is that it has two parameters,
represented by the type variables ùëéandùëè. Those have to be
applied to concrete types, much as variables at the term level
have to be applied to values to evaluate a function. The second
major diÔ¨Äerence is that this is a product type , not a sum type.
A product type represents a logical conjunction: you must
supplybotharguments to construct a value.
Notice that the two type variables are diÔ¨Äerent, so that al-
lows for tuples that contain values of two diÔ¨Äerent types. The
types are not, however, required to be diÔ¨Äerent:
Œª&gt; (,) 8 10
(8,10)
Œª&gt; (,) 8 &quot;Julie&quot;
(8,&quot;Julie&quot;)</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 162
Œª&gt; (,) True 'c'
(True,'c')
But if we try to apply it to only one argument:
Œª&gt; (,) 9
<interactive>:34:1:
No instance for (Show (b0 -&gt; (a0, b0)))
(maybe you haven't applied enough
arguments to a function?)
arising from a use of ‚Äòprint‚Äô
In the first argument of ‚Äòprint‚Äô,
namely ‚Äòit‚Äô
In a stmt of an interactive
GHCi command: print it
Well, look at that error. This is one we will explore in detail
soon, but for now the important part is the part in parenthe-
ses: we haven‚Äôt applied the function ‚Äî in this case, the data
constructor ‚Äî to enough arguments.
The two-tuple in Haskell has some default convenience
functions for getting the first or second value. They‚Äôre named
fstandsnd:
fst::(a, b)-&gt;a
snd::(a, b)-&gt;b</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 163
The type signature tells us there‚Äôs nothing those functions
could do other than return the first or second value, respec-
tively.
Here are some examples of manipulating tuples, specifically
the two-tuple:
Prelude&gt; let myTup = (1 :: Integer, &quot;blah&quot;)
Prelude&gt; :t myTup
myTup :: (Integer, [Char])
Prelude&gt; fst myTup
1
Prelude&gt; snd myTup
&quot;blah&quot;
Prelude&gt; import Data.Tuple
Prelude&gt; swap myTup
(&quot;blah&quot;,1)
We had to import Data.Tuple because swapisn‚Äôt included in
thePrelude .
We can also combine tuples with other expressions:
Prelude&gt; 2 + fst (1, 2)
3
Prelude&gt; 2 + snd (1, 2)
4
The(x, y) syntax of the tuple is special. The constructors
you use in the type signatures and in your code (terms) are</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 164
syntactically identical even though they‚Äôre diÔ¨Äerent things.
Sometimes that type constructor is referred to without the
type variables explicitly inside of it such as (,). Other times,
you‚Äôll see (a, b) ‚Äî particularly in type signatures.
You can use that syntax to pattern match when you write
functions, too. One nice thing about that is that the func-
tion definition can look very much like the type signature
sometimes. For example, we can implement fstandsndfor
ourselves like this:
fst'::(a, b)-&gt;a
fst'(a, b)=a
snd'::(a, b)-&gt;b
snd'(a, b)=b
Let‚Äôs look at another example of pattern matching on tuples:
tupFunc ::(Int, [a])
-&gt;(Int, [a])
-&gt;(Int, [a])
tupFunc (a, b) (c, d) =
((a+c), (b++d))
It‚Äôs generally unwise to use tuples of an overly large size,
both for efficiency and sanity reasons. Most tuples you see will
be( , , , , ) (5-tuple) or smaller.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 165
4.8 Lists
Lists are another type used to contain multiple values within
a single value. However, they diÔ¨Äer from tuples in three im-
portant ways: First, all elements of a list must be of the same
type. Second, lists have their own distinct []syntax. Like the
tuple syntax, it is used for both the type constructor in type
signatures and at the term level to express list values. Third,
the number of values that will be in the list isn‚Äôt specified in
the type ‚Äî unlike tuples where the arity is set in the type and
immutable.
Here‚Äôs an example for your REPL:
Prelude&gt; let p = &quot;Papuchon&quot;
Prelude&gt; let awesome = [p, &quot;curry&quot;, &quot;:)&quot;]
Prelude&gt; awesome
[&quot;Papuchon&quot;,&quot;curry&quot;,&quot;:)&quot;]
Prelude&gt; :t awesome
awesome :: [[Char]]
First thing to note is that awesome is a list of lists of Charvalues
because it is a list of strings, and String is a type alias for [Char] .
This means all the functions and operations valid for lists of
any value, usually expressed as [a], are valid for String because
[Char] is more specific than [a].</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 166
Prelude&gt; let s = &quot;The Simons&quot;
Prelude&gt; let also = [&quot;Quake&quot;, s]
Prelude&gt; :t (++)
(++) :: [a] -&gt; [a] -&gt; [a]
Prelude&gt; awesome ++ also
[&quot;Papuchon&quot;,
&quot;curry&quot;,
&quot;:)&quot;,
&quot;Quake&quot;,
&quot;The Simons&quot;]
Prelude&gt; let allAwesome = [awesome, also]
Prelude&gt; allAwesome
[[&quot;Papuchon&quot;,&quot;curry&quot;,&quot;:)&quot;],
[&quot;Quake&quot;,&quot;The Simons&quot;]]
Prelude&gt; :t allAwesome
allAwesome :: [[[Char]]]
Prelude&gt; :t concat
concat :: [[a]] -&gt; [a]
Prelude&gt; concat allAwesome
[&quot;Papuchon&quot;,
&quot;curry&quot;,
&quot;:)&quot;,
&quot;Quake&quot;,
&quot;The Simons&quot;]
We‚Äôll save a full exploration of the list datatype until we</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 167
get to the chapter on lists. The list data structure gets a whole
chapter because lists have some interesting complexity, we‚Äôre
going to use them to demonstrate some things about Haskell‚Äôs
nonstrict evaluation, and there are manystandard functions
and constructs that can be used with lists.
4.9 Chapter Exercises
As in previous chapters, you will gain more by working out the
answer before you check what GHCi tells you, but be sure
to use your REPL to check your answers to the following
exercises. Also, you will need to have the awesome ,also, and
allAwesome code from above in scope for this REPL session. For
convenience of reference, here are those values again:
awesome =[&quot;Papuchon&quot; ,&quot;curry&quot;,&quot;:)&quot;]
also=[&quot;Quake&quot;,&quot;The Simons&quot; ]
allAwesome =[awesome, also]
length is a function that takes a list and returns a result that
tells how many items are in the list.
1.Given the definition of length above, what would the type
signature be? How many arguments, of what type does it
take? What is the type of the result it evaluates to?
2.What are the results of the following expressions?</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 168
a)length [1, 2, 3, 4, 5]
b)length [(1, 2), (2, 3), (3, 4)]
c)length allAwesome
d)length (concat allAwesome)
3.Given what we know about numeric types and the type
signature of length, look at these two expressions. One
works and one returns an error. Determine which will
return an error and why.
(n.b., you will find Foldable t =&gt; t a representing [a], as
withconcat inthepreviouschapter. Again, consider Foldable
tto represent a list here, even though list is only one of
the possible types.)
Prelude&gt; 6 / 3
-- and
Prelude&gt; 6 / length [1, 2, 3]
4.How can you fix the broken code from the preceding
exercise using a diÔ¨Äerent division function/operator?
5.What is the type of the expression 2 + 3 == 5 ? What would
we expect as a result?
6.What is the type and expected result value of the follow-
ing:</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 169
Prelude&gt; let x = 5
Prelude&gt; x + 3 == 5
7.Below are some bits of code. Which will work? Why or
why not? If they will work, what value would these reduce
to?
Prelude&gt; length allAwesome == 2
Prelude&gt; length [1, 'a', 3, 'b']
Prelude&gt; length allAwesome + length awesome
Prelude&gt; (8 == 8) &amp;&amp; ('b' &lt; 'a')
Prelude&gt; (8 == 8) &amp;&amp; 9
8.Write a function that tells you whether or not a given
String (or list) is a palindrome. Here you‚Äôll want to use
a function called reverse a predefined function that does
what it sounds like.
reverse :: [a] -&gt; [a]
reverse &quot;blah&quot;
&quot;halb&quot;
isPalindrome ::(Eqa)=&gt;[a]-&gt;Bool
isPalindrome x=undefined
9.Write a function to return the absolute value of a number
using if-then-else</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 170
myAbs::Integer -&gt;Integer
myAbs=undefined
10.Fill in the definition of the following function, using fst
andsnd:
f::(a, b)-&gt;(c, d)-&gt;((b, d), (a, c))
f=undefined
Correcting syntax
In the following examples, you‚Äôll be shown syntactically incor-
rect code. Type it in and try to correct it in your text editor,
validating it with GHC or GHCi.
1.Here, we want a function that adds 1 to the length of a
string argument and returns that result.
x=(+)
Fxs=w'x'1
wherew=length xs
2.This is supposed to be the identity function, id.
\X=x
3.When fixed, this function will return 1 from the value (1,
2).</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 171
f(a b)=A
Match the function names to their types
1.Which of the following types is the type of show?
a)showa=&gt;a-&gt;String
b)Showa-&gt;a-&gt;String
c)Showa=&gt;a-&gt;String
2.Which of the following types is the type of (==)?
a)a-&gt;a-&gt;Bool
b)Eqa=&gt;a-&gt;a-&gt;Bool
c)Eqa-&gt;a-&gt;a-&gt;Bool
d)Eqa=&gt;A-&gt;Bool
3.Which of the following types is the type of fst?
a)(a, b)-&gt;a
b)b-&gt;a
c)(a, b)-&gt;b
4.Which of the following types is the type of (+)?
a)(+)::Numa-&gt;a-&gt;a-&gt;Bool
b)(+)::Numa=&gt;a-&gt;a-&gt;Bool</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 172
c)(+)::num a=&gt;a-&gt;a-&gt;a
d)(+)::Numa=&gt;a-&gt;a-&gt;a
e)(+)::a-&gt;a-&gt;a
4.10 Definitions
1.Atupleis an ordered grouping of values. In Haskell, you
cannot have a tuple with only one element, but there is a
zero tuple also called unitor(). The types of the elements
of tuples are allowed to vary, so you can have both (String,
String) or (Integer, String). Tuples in Haskell are the usual
means of briefly carrying around multiple values without
giving that combination its own name.
2.Atypeclass is a set of operations defined with respect to
a polymorphic type. When a type has an instance of a
typeclass, values of that type can be used in the standard
operations defined for that typeclass. In Haskell, type-
classes are unique pairings of class and concrete instance.
This means that if a given type ùëéhas an instance of Eq, it
hasonlyone instance of Eq.
3.Data constructors in Haskell provide a means of creating
values that inhabit a given type. Data constructors in
Haskell have a type and can either be constant values
(nullary) or take one or more arguments, like functions.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 173
In the following example, Catis a nullary data constructor
forPetandDogis a data constructor that takes an argument:
-- Why name a cat?
-- They don't answer anyway.
typeName=String
dataPet=Cat|DogName
The data constructors have the following types:
Prelude&gt; :t Cat
Cat :: Pet
Prelude&gt; :t Dog
Dog :: Name -&gt; Pet
4.Type constructors in Haskell are notvalues and can only be
used in type signatures. Just as data declarations generate
data constructors to create values that inhabit that type,
data declarations generate type constructors which can be
used to denote that type. In the above example, Petis the
type constructor. A guideline for diÔ¨Äerentiating the two
kinds of constructors is that type constructors always go
to the left of the =in a data declaration.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 174
5.Data declarations define new datatypes in Haskell. Data
declarations always create a new type constructor, but may
ormaynot create new data constructors. Data declarations
are how we refer to the entire definition that begins with
thedatakeyword.
6.Atype alias is a way to refer to a type constructor or type
constant by an alternate name, usually to communicate
something more specific or for brevity.
typeName=String
-- creates a new type alias Name of the
-- type String <em>not</em> a data declaration,
-- just a type alias declaration
7.Arityis the number of arguments a function accepts. This
notion is a little slippery in Haskell as, due to currying, all
functions are 1-arity and we handle accepting multiple
arguments by nesting functions.
8.Polymorphism in Haskell means being able to write code
in terms of values which may be one of several, or any,
type. Polymorphism in Haskell is either parametric or
constrained . The identity function, id, is an example of a
parametrically polymorphic function:
id::a-&gt;a
idx=x</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 175
Hereidworks for a value of anytype because it doesn‚Äôt
use any information specific to a given type or set of types.
Whereas, the following function isEqual :
isEqual ::Eqa=&gt;a-&gt;a-&gt;Bool
isEqual x y=x==y
Is polymorphic, but constrained orbounded to the set of
types which have an instance of the Eqtypeclass. The dif-
ferent kinds of polymorphism will be discussed in greater
detail in a later chapter.
4.11 Names and variables
Names
In Haskell there are seven categories of entities that have
names: functions, term-level variables, data constructors, type
variables, type constructors, typeclasses, and modules. Term-
level variables and data constructors exist in your terms. Term
levelis where your values live and is the code that executes
when your program is running. At the type level , which is used
during the static analysis &amp; verification of your program, we
have type variables, type constructors, and typeclasses. Lastly,
for the purpose of organizing our code into coherent group-
ings across diÔ¨Äerent files, we have modules.</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 176
Conventions for variables
Haskell uses a lot of variables, and some conventions have
developed. It‚Äôs not critical that you memorize this, because for
the most part, these are merely conventions, but familiarizing
yourself with them will help you read Haskell code.
Type variables (that is, variables in type signatures) gener-
ally start at ùëéand go from there: ùëé,ùëè,ùëê, and so forth. You may
sometimes see them with numbers appended to them, e.g., ùëé1.
Functions can be used as arguments and in that case are
typically labeled with variables starting at ùëì(followed by ùëîand
so on). They may sometimes have numbers appended (e.g., ùëì1)
and may also sometimes be decorated with the‚Ä≤character as
inùëì‚Ä≤. This would be pronounced ‚ÄúeÔ¨Ä-prime,‚Äù should you have
need to say it aloud. Usually this denotes a function that is
closely related to or a helper function to function ùëì. Functions
may also be given variable names that are not on this spectrum
as a mnemonic. For example, a function that results in a list
of prime numbers might be called ùëù, or a function that fetches
some text might be called ùë°ùë•ùë°.
Variables do not have to be a single letter. In small programs,
they often are; in larger programs, they usually should not
be a single letter. If there are many variables in a function
or program, as is common, it is helpful to have descriptive
variable names. It is often advisable in domain-specific code</p>
<p>CHAPTER 4. BECAUSE PIGS CAN‚ÄôT FLY 177
to use domain-specific variable names.
Arguments to functions are most often given names start-
ing atùë•, again occasionally seen numbered as in ùë•1. Other
single-letter variable names may be chosen when they serve a
mnemonic role, such as choosing ùëüto represent a value that is
the radius of a circle.
If you have a list of things you have named ùë•, by convention
that will usually be called ùë•ùë†, that is, the plural of ùë•. You will
see this convention often in the form (x:xs) , which means you
have a list in which the head of the list is ùë•and the rest of the
list isùë•ùë†.
All of these, though, are conventions, not definite rules.
While we will generally adhere to the conventions in this book,
any Haskell code you see out in the wild may not. Calling a
type variable ùë•instead of ùëéis not going to break anything. As
in the lambda calculus, the names don‚Äôt have any inherent
meaning. We oÔ¨Äer this information as a descriptive guide of
Haskell conventions, not as rules you must follow in your own
code.</p>
<p>Chapter 5
Types
She was the single
artificer of the world
In which she sang. And
when she sang, the sea,
Whatever self it had,
became the self
That was her song, for she
was the maker.
Wallace Stevens, ‚ÄúThe
Idea of Order at Key
West‚Äù
178</p>
<p>CHAPTER 5. TYPES 179
5.1 Types
In the last chapter, we looked at some built-in datatypes, such
asBooland tuples and had a brief run-in with the typeclasses
NumandEq. However, a deep understanding of types and how to
read and interpret them is fundamental to reading and writing
Haskell.
As we have seen, a datatype declaration defines a type con-
structor and data constructors. Data constructors are the val-
ues of a particular type; they are also functions that let us
create data, or values, of a particular type, although it will
take some time before the full import of this becomes clear.
In Haskell, you cannot create untyped data, so except for a
sprinkling of syntactic sugar for things like numbers or func-
tions, everything originates in a data constructor from some
definition of a type.
In this chapter, we‚Äôre going to take a deeper look at the type
system and
‚Ä¢learn more about querying and reading type signatures;
‚Ä¢see that currying has, unfortunately, nothing to do with
food;
‚Ä¢take a closer look at diÔ¨Äerent kinds of polymorphism;
‚Ä¢look at type inference and how to declare types for our
functions.</p>
<p>CHAPTER 5. TYPES 180
5.2 What are types for?
Haskell is an implementation of a pure lambda calculus, in
the sense that it isn‚Äôt much more than syntactic sugar over the
basic system of variables, abstractions, and applications that
constitute the rules of the lambda calculus ‚Äî at least, of a typed
lambda calculus. Developments in logic, mathematics, and
computer science led to the discovery (or invention, take your
pick) of a typed lambda calculus called System F in the 1970s.
Haskell has improved on System F in some key ways, such as
by allowing general recursion (more on that in a later chapter)
and the Hindley-Milnersystemto permit type inference (more
on that later in this chapter), but the core logic is the same.
So, why do we want types? Type systems in logic and math-
ematics have been designed to impose constraints that enforce
correctness. For our purposes, we can say that well-designed
type systems help eliminate some classes of errors as well as
concerns such as what the eÔ¨Äect of a conditional over a non-
Boolean value might be. A type system defines the associations
between diÔ¨Äerent parts of a program and checks that all the
parts fit together in a logically consistent, provably correct
way.
Let‚Äôs consider a short, somewhat oversimplified example.
TheBooltype is a set with two inhabitants, TrueandFalse, as
we saw in the last chapter. Anytime the value TrueorFalse
occurs in a Haskell program, the typechecker will know they‚Äôre</p>
<p>CHAPTER 5. TYPES 181
members of the Booltype. The inverse is that whenever the
typeBoolis declared in a type signature, the compiler will
expect one of those two values and only one of those two
values; you get a type error if you try to pass a number where
aBoolis expected.
In Haskell, where typing is static, typechecking occurs at
compile time . That means many errors will be caught before
you try to execute, or run, your program. The diÔ¨Äerence isn‚Äôt
always obvious because GHCi allows you to typecheck things
interactively, as you‚Äôre writing them, as well as execute them if
they typecheck. No type system can eliminate all possibilities
for error, so the possibility of runtime errors and exceptions
still exists, and testing of programs is necessary, but the type
system reduces the number and kinds of tests you must write.
Good type systems can also enable compiler optimizations,
because the compiler can know and predict certain things
about the execution of a program based on the types. Types
can also serve as documentation of your program, which is
one reason we encourage you to declare types (that is, write
the type signatures) for your functions. It won‚Äôt matter too
much when you‚Äôre writing small programs, but as programs
get longer, type signatures can help you read your program
and remember what you were doing, and help anyone else
who might be trying to use your code as well.
You may feel that Haskell‚Äôs type system requires a lot of up-</p>
<p>CHAPTER 5. TYPES 182
front work. This upfront cost comes with a later payoÔ¨Ä: code
that is safer and, down the line, easier to maintain. Working
with a good type system can eliminate those tests that only
check that you‚Äôre passing the right sort of data around, and
since tests are more code that you have to write (correctly) and
maintain, it will eventually save you time and eÔ¨Äort.
Many, perhaps most, programming languages have type
systems that feel like haggling with a petty merchant. However,
we believe Haskell provides a type system that more closely
resembles a quiet, pleasant conversation with a colleague than
an argument in the bazaar. Much of what we suggest with
regards to putting code in a file, loading it in a REPL, querying
types in the REPL, and so forth, is about creating habits con-
ducive to having this pleasant back and forth with your type
system.
5.3 How to read type signatures
In previous chapters, we‚Äôve seen that we can query types in
the REPL with the :typeor:tcommand. You can query types
for functions, partially applied functions, and values, which
are, in a way, fully applied functions.
When we query the types of values, we see something like
this:
Prelude&gt; :type 't'</p>
<p>CHAPTER 5. TYPES 183
't' :: Char -- 't' has the type Char
Prelude&gt; :type &quot;julie&quot;
&quot;julie&quot; :: [Char] -- &quot;julie&quot; has the type String
Prelude&gt; :type True
True :: Bool -- True has the type Bool
When we query the types of numeric values, we see type-
class information instead of a concrete type, because the com-
piler doesn‚Äôt know which specific numeric type a value is until
the type is either declared or the compiler is forced to infer
a specific type based on the function. For example, 13may
look like an integer to us, but that would only allow us to use it
in computations that take integers (and not, say, in fractional
division). For that reason, the compiler gives it the type with
the broadest applicability (most polymorphic) and says it‚Äôs a
constrained polymorphic Num a =&gt; a value:
Prelude&gt; :type 13
13 :: Num a =&gt; a
-- we can give it a concrete type
-- by declaring it
Prelude&gt; let x = 13 :: Integer
Prelude&gt; :t x
x :: Integer</p>
<p>CHAPTER 5. TYPES 184
You can also query the type signatures of functions, as we‚Äôve
seen:
Prelude&gt; :type not
not :: Bool -&gt; Bool
This takes one input of a Boolvalue and returns one Bool
value. Given that type, there aren‚Äôt too many things it even
coulddo.1
Understanding the function type
The arrow, (-&gt;), is the type constructor for functions in Haskell.
It‚Äôs baked into the language, but syntactically it works in very
much the same way as all the other types you‚Äôve seen so far. It‚Äôs
a type constructor, like Bool, except the (-&gt;)type constructor
takes arguments and has no data constructors:
Prelude&gt; :info (-&gt;)
data (-&gt;) a b
-- some further information is elided
If you compare this to the type constructor for the two-
tuple, you see the similarity:
Prelude&gt; :info (,)
data (,) a b = (,) a b
1Four, to be precise. But if we assume that the standard Prelude functions are generally
useful functions, it helps narrow it down considerably.</p>
<p>CHAPTER 5. TYPES 185
We saw earlier that the tuple constructor needs to be applied
to two values in order to construct a tuple. A function must
similarly have two arguments ‚Äî one input and one result ‚Äî
in order to be a function. Unlike the tuple constructor, though,
the function type has no data constructors. The value that
shows up at term level is the function. Functions are values .
As we‚Äôve said, the hallmark of a function is that it can be
applied , and the structure of the type demonstrates this. The
arrow is an infixoperator that has two parameters and associates
to the right (although function application is left associative).
The parameterization suggests that we will apply the function
to some argument that will be bound to the first parameter,
with the second parameter, ùëè, representing the return or result
type. We will cover these things in more detail throughout
this chapter.
Let‚Äôs return to reading type signatures. The function fstis
a value of type (a, b) -&gt; a where-&gt;is an infix type constructor
that takes two arguments:
fst::(a, b) -&gt;a
-- [1] [2] [3]
1.The first parameter of fsthas the type (a, b). Note that
the tuple type itself (,)takes two arguments ùëéandùëè.
2.The function type, (-&gt;), has two parameters. One is (a,
b)and one is the result ùëé.</p>
<p>CHAPTER 5. TYPES 186
3.The result of the function, which has type ùëé. It‚Äôs the same
ùëéthat was in the tuple (a, b) .
How do we know it‚Äôs the same ùëé? We can say that we know
the input type ùëéand the output type ùëémust be the same type,
and we can see that nothing happens between the input and the
output; that is, there is no operation that comes between them
that could transform that ùëéinto some other value of that type.
Let‚Äôs look at another function:
Prelude&gt; :type length
length :: [a] -&gt; Int
Thelength function takes one argument that is a list ‚Äî note
the square brackets ‚Äî and returns an Intresult. The Intresult
in this case will be the number of items in the list. The type
of the inhabitants of the list is left unspecified; this function
does not care ‚Äî in fact, cannot care ‚Äî what types of values
are inside the list.
Typeclass-constrained type variables
Next, let‚Äôs look at the types of some arithmetic functions. You
may recall that the act of wrapping an infix operator in paren-
theses allows us to use the function just like a normal prefix
function, including being able to query the type:
Prelude&gt; :type (+)</p>
<p>CHAPTER 5. TYPES 187
(+) :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; :type (/)
(/) :: Fractional a =&gt; a -&gt; a -&gt; a
To describe these casually, we could say addition takes one
numeric argument, adds it to a second numeric argument of
the same type, and returns a numeric value of the same type
as a result. Similarly, the fractional division function takes a
fractional value, divides it by a second fractional value, and
returns a third fractional value as a result. This isn‚Äôt precise,
but it will do for now.
The compiler gives the least specific and most general type
it can. Instead of limiting this function to a concrete type, we
get a typeclass-constrained polymorphic type variable. We‚Äôll
save a fuller explanation of typeclasses for the next chapter.
What we need to know here is that each typeclass oÔ¨Äers a stan-
dard set of functions that can be used across several concrete
types. When a typeclass is constraining a type variable in this
way, the variable could represent any of the concrete types
that have instances of that typeclass so that specific operations
on which the function depends are defined for that type. We
say it‚Äôs constrained because we still don‚Äôt know the concrete
type of ùëé, but we do know it can onlybe one of the types that
has the required typeclass instance.
This generalization of numberhood is what lets us use the
same numerical literals to represent numeric values of dif-</p>
<p>CHAPTER 5. TYPES 188
ferent types. We can start with a Num a =&gt; a value and then
create specific versions of it with a concrete type using the ::
to assign a type to the value:
Prelude&gt; let fifteen = 15
Prelude&gt; :t fifteen
fifteen :: Num a =&gt; a
Prelude&gt; let fifteenInt = fifteen :: Int
Prelude&gt; let fifteenDouble = fifteen :: Double
Prelude&gt; :t fifteenInt
fifteenInt :: Int
Prelude&gt; :t fifteenDouble
fifteenDouble :: Double
We went from Num a =&gt; a toIntandDouble. This works be-
causeIntandDouble each have an instance of the Numtypeclass:
Prelude&gt; :info Num
[...irrelevant bits elided...]
instance Num Int -- Defined in ‚ÄòGHC.Num‚Äô
instance Num Double -- Defined in ‚ÄòGHC.Float‚Äô
Since they both have instances of Num, the operations from
Num, such as addition, are defined for both of them:
Prelude&gt; fifteenInt + fifteenInt
30</p>
<p>CHAPTER 5. TYPES 189
Prelude&gt; fifteenDouble + fifteenDouble
30.0
We can also make more specific versions of our Num a =&gt; a
value named fifteen by using it in a way that requires it to
become something more specific:
Prelude&gt; fifteenDouble + fifteen
30.0
Prelude&gt; fifteenInt + fifteen
30
What we cannot do is this:
Prelude&gt; fifteenDouble + fifteenInt
Couldn't match expected type ‚ÄòDouble‚Äô
with actual type ‚ÄòInt‚Äô
In the second argument of ‚Äò(+)‚Äô,
namely ‚ÄòfifteenInt‚Äô
In the expression: fifteenDouble + fifteenInt
We can‚Äôt add those two values because their types are no
longer polymorphic, and their concrete types are diÔ¨Äerent so
they have diÔ¨Äerent definitions of how to implement addition.
The type error message contrasts the actual type with the ex-
pected type . The actual type is what we provided; the expected</p>
<p>CHAPTER 5. TYPES 190
type is what the compiler expected. Since we had fifteenDouble
as our first argument, it expected the second value to also have
the type Double but itactually has the type Int.
A type signature might have multiple typeclass constraints
on one or more of the variables. You will sometimes see (or
write) type signatures such as:
(Numa,Numb)=&gt;a-&gt;b-&gt;b
-- or
(Orda,Numa)=&gt;a-&gt;a-&gt;Ordering
Here, the constraints look like a tuple, although they don‚Äôt
add another function argument that you must provide, and
they don‚Äôt appear as a tuple at the value or term level. Nothing
to the left of the typeclass arrow, =&gt;, shows up at term level. The
tuple of constraints doesrepresent a product, or conjunction,
of constraints.
In the first example above, there are two constraints, one
for each variable. Both ùëéandùëèmust have instances of the
Numtypeclass. In the second example, both of the constraints
are on the one variable ùëé‚Äî that is, ùëémust be a type that
implements bothOrdandNum.</p>
<p>CHAPTER 5. TYPES 191
Exercises: Type Matching
Below you‚Äôll find a list of several standard functions we‚Äôve
talked about previously. Under that is a list of their type sig-
natures. Match the function to its type signature. Try to do
it without peeking at the type signatures (either in the text or
in GHCi) and then check your work. You may find it easier to
start from the types and work out what you think a function
of that type would do.
1.Functions:
a)not
b)length
c)concat
d)head
e)(&lt;)
2.Type signatures:
a)_ ::[a]-&gt;a
b)_ ::[[a]]-&gt;[a]
c)_ ::Bool-&gt;Bool
d)_ ::[a]-&gt;Int
e)_ ::Orda=&gt;a-&gt;a-&gt;Bool</p>
<p>CHAPTER 5. TYPES 192
5.4 Currying
As in the lambda calculus, arguments ( plural) is a shorthand
for the truth in Haskell: all functions in Haskell take one argu-
ment and return one result. Other programming languages,
if you have any experience with them, typically allow you to
define functions that can take multiple arguments. There is
no support for this built into Haskell. Instead there are syn-
tactic conveniences that construct curried functions by default.
Currying refers to the nesting of multiple functions, each ac-
cepting one argument and returning one result, to allow the
illusion of multiple-parameter functions.
The arrows we‚Äôve seen in type signatures denote the func-
tion type. We looked at the datatype definition earlier, but
let‚Äôs review:
data(-&gt;) a b
In order to have a function, you must have one input, the ùëé,
to apply the function to, and you‚Äôll get one result, the ùëè, back.
Each arrow in a type signature represents one argument and
one result, with the final type being the final result. If you
are constructing a function that requires multiple parameters,
then the ùëècan be another function (the ùëécan be another func-
tion as well). In that case, just like in lambda abstractions that
have multiple heads, they are nested.</p>
<p>CHAPTER 5. TYPES 193
Let‚Äôs break this down by looking at the type signature for
addition, a function that needs multiple inputs:
(+)::Numa=&gt;a-&gt;a-&gt;a
-- | 1 |
(+)::Numa=&gt;a-&gt;a-&gt;a
-- | 2 |
(+)::Numa=&gt;a-&gt;a-&gt;a
-- [3]
1.Here is the typeclass constraint saying that ùëémust have
an instance of Num. Addition is defined in the Numtypeclass.
2.The boundaries of 2 demarcate what you might call the
two parameters to the function (+), but all functions in
Haskell take one argument and return one result. This is
because functions in Haskell are nested like Matryoshka
dolls in order to accept ‚Äúmultiple‚Äù arguments. The way
the(-&gt;)type constructor for functions works means a -&gt;
a -&gt; a represents successive function applications, each
taking one argument and returning one result. The dif-
ference is that the function at the outermost layer is re-
turning another function that accepts the next argument.
This is called currying.</p>
<p>CHAPTER 5. TYPES 194
3.This is the result type for this function. It will be a number
of the same type as the two inputs.
The way the type constructor for functions, (-&gt;), is defined
makes currying the default in Haskell. This is because it is an
infix operator and right associative. Because it associates to
the right, types are implicitly parenthesized like so:
f::a-&gt;a-&gt;a
-- associates to
f::a-&gt;(a-&gt;a)
and
map::(a-&gt;b)-&gt;[a]-&gt;[b]
-- associates into
map::(a-&gt;b)-&gt;([a]-&gt;[b])
Let‚Äôs see if we can unpack the notion of a right-associating
infix operator giving us curried functions. The association
here, or grouping into parentheses, is not to control prece-
dence or order of evaluation; it only serves to group the pa-
rameters into argument and result, since there can only be</p>
<p>CHAPTER 5. TYPES 195
one argument and one result per arrow. Since all the arrows
have the same precedence, the associativity does not change
the precedence or order of evaluation.
Remember, when we have a lambda expression that appears
to have two parameters, they are nested lambdas. Applying the
expression to one argument returns a function that awaits ap-
plication to a second argument. After you apply it to a second
argument, you have a final result. You can nest more lambdas
than two, of course, but the process is the same: one argument,
one result, even though that result may be a function awaiting
application to another argument.
The type constructor for functions and the types we see
above are the same thing, but written in Haskell. When there
are ‚Äútwo arguments‚Äù in Haskell, we apply our function to an
argument, just like when we apply a lambda expression to an
argument, and then return a result that is a function and needs
to be applied to a second argument.
Explicit parenthesization, as when an input parameter is
itself a function (such as in map, above), may be used to indicate
order of evaluation, but the implicit associativity of the func-
tion type does not mean the inner or final set of parentheses,
i.e., the result type, evaluates first. Application is evaluation;
in other words, the only way to evaluate anything is by apply-
ing functions, and function application is leftassociative. So,
the leftmost, or outermost, arguments will be evaluated first,
assuming anything gets evaluated (since Haskell is nonstrict,</p>
<p>CHAPTER 5. TYPES 196
you can‚Äôt assume that anything will be evaluated, but this will
be more clear later).
Partial application
Currying may be interesting, but many people wonder what
the practical eÔ¨Äect or value of currying is. We‚Äôll look now at
a strategy called partial application to see what currying does
for us. It‚Äôs something we‚Äôll explore more as we go through the
book as well.
We use the double colon to assign a type. Making the type
concrete will eliminate the typeclass constraint:
addStuff ::Integer -&gt;Integer -&gt;Integer
addStuff a b=a+b+5
So,addStuff appears to take two Integer arguments and re-
turn an Integer result. But after loading that in GHCi we see
that it is taking one argument and returning a function that
takes one argument and returns one result:
Prelude&gt; :t addStuff
addStuff :: Integer -&gt; Integer -&gt; Integer
Prelude&gt; let addTen = addStuff 5
Prelude&gt; :t addTen
addTen :: Integer -&gt; Integer
Prelude&gt; let fifteen = addTen 5</p>
<p>CHAPTER 5. TYPES 197
Prelude&gt; fifteen
15
Prelude&gt; addTen 15
25
Prelude&gt; addStuff 5 5
15
Herefifteen is equal to addStuff 5 5 , because addTen is equal
toaddStuff 5 . The ability to apply only some of a function‚Äôs ar-
guments is called partial application. This lets us reuse addStuff
and create a new function from it with one of the arguments
applied.
If we recall that (-&gt;)is a type constructor and associates to
the right, this becomes more clear:
addStuff ::Integer -&gt;Integer -&gt;Integer
-- with explicit parenthesization
addStuff ::Integer -&gt;(Integer -&gt;Integer)
Applying addStuff to oneInteger argument gave us the func-
tionaddTen , which is the return function of addStuff . Applying
addTen to anInteger argument gives us a return value, so the
type of fifteen isInteger ‚Äî no more function arrows.
Let‚Äôs check our understanding with a function that isn‚Äôt
commutative:</p>
<p>CHAPTER 5. TYPES 198
subtractStuff ::Integer
-&gt;Integer
-&gt;Integer
subtractStuff x y=x-y-10
subtractOne =subtractStuff 1
Prelude&gt; :t subtractOne
subtractOne :: Integer -&gt; Integer
Prelude&gt; let result = subtractOne 11
Prelude&gt; result
-20
Why did we get this result? Because of the order in which
we applied arguments, result is equal to 1 - 11 - 10 .
Manual currying and uncurrying
Haskell is curried by default, but you can uncurry functions.
Uncurrying means un-nesting the functions and replacing the
two functions with a tuple of two values (these would be the two
values you want to use as arguments). If you uncurry (+), the
type changes from Num a =&gt; a -&gt; a -&gt; a toNum a =&gt; (a, a) -&gt; a
which better fits the description ‚Äútakes two arguments, returns
one result‚Äù than curried functions. Some older functional
languages default to using a product type like tuples to express
multiple arguments.</p>
<p>CHAPTER 5. TYPES 199
‚Ä¢Uncurried functions: One function, many arguments
‚Ä¢Curried functions: Many functions, one argument apiece
You can also desugar the automatic currying yourself, by
nesting the arguments with lambdas, though there‚Äôs rarely a
reason to do so.
We‚Äôll use anonymous lambda syntax here to show you some
examples of uncurrying. You may want to review anonymous
lambda syntax or try comparing these functions directly and
thinking of the backslash as a lambda:
indexanonymous function ! syntax
nonsense ::Bool-&gt;Integer
nonsense True=805
nonsense False=31337
curriedFunction ::Integer
-&gt;Bool
-&gt;Integer
curriedFunction i b=
i+(nonsense b)
uncurriedFunction ::(Integer,Bool)
-&gt;Integer
uncurriedFunction (i, b)=
i+(nonsense b)</p>
<p>CHAPTER 5. TYPES 200
anonymous ::Integer -&gt;Bool-&gt;Integer
anonymous =\i b-&gt;i+(nonsense b)
anonNested ::Integer
-&gt;Bool
-&gt;Integer
anonNested =
\i-&gt;\b-&gt;i+(nonsense b)
Then when we test the functions from the REPL:
Prelude&gt; curriedFunction 10 False
31347
Prelude&gt; anonymous 10 False
31347
Prelude&gt; anonNested 10 False
31347
They are all the same function, all giving the same results.
InanonNested , we manually nested the anonymous lambdas to
get a function that was semantically identical to curriedFunction
but didn‚Äôt leverage the automatic currying. This means func-
tions that seemto accept multiple arguments such as with a -&gt;
a -&gt; a -&gt; a arehigher-order functions : they yield more function
values as each argument is applied until there are no more (-&gt;)
type constructors and it terminates in a non-function value.</p>
<p>CHAPTER 5. TYPES 201
Currying and uncurrying existing functions
It turns out, we can curry and uncurry functions with multiple
parameters generically without writing new code for each one.
Consider the following example for currying:
Prelude&gt; let curry f a b = f (a, b)
Prelude&gt; :t curry
curry :: ((t1, t2) -&gt; t) -&gt; t1 -&gt; t2 -&gt; t
Prelude&gt; :t fst
fst :: (a, b) -&gt; a
Prelude&gt; :t curry fst
curry fst :: t -&gt; b -&gt; t
Prelude&gt; fst (1, 2)
1
Prelude&gt; curry fst 1 2
1
Then for uncurrying:
Prelude&gt; let uncurry f (a, b) = f a b
Prelude&gt; :t uncurry
uncurry :: (t1 -&gt; t2 -&gt; t) -&gt; (t1, t2) -&gt; t
Prelude&gt; :t (+)
(+) :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; (+) 1 2
3</p>
<p>CHAPTER 5. TYPES 202
Prelude&gt; uncurry (+) (1, 2)
3
Currying and uncurrying functions of three or more argu-
ments automatically is quite possible, but trickier. We‚Äôll leave
that be, but investigate on your own if you like.
Sectioning
We mentioned sectioning in Chapter 2, and now that we‚Äôve
talked a bit more about currying and partial application, it
may be more clear what‚Äôs happening there. The term section-
ingspecifically refers to partial application of infix operators,
which has a special syntax and allows you to choose whether
the argument you‚Äôre partially applying the operator to is the
first or second argument:
Prelude&gt; let x = 5
Prelude&gt; let y = (2^)
Prelude&gt; let z = (^2)
Prelude&gt; y x
32
Prelude&gt; z x
25
With commutative functions such as addition, the argu-
ment order does not matter. We will usually section addition</p>
<p>CHAPTER 5. TYPES 203
as, for example, (+3), but when we start using partially applied
functions a lot with maps and folds and so forth, you‚Äôll be able
to see the diÔ¨Äerence that the argument order can make with
noncommutative operators.
This does not only work with arithmetic, though:
Prelude&gt; let celebrate = (++ &quot; woot!&quot;)
Prelude&gt; celebrate &quot;naptime&quot;
&quot;naptime woot!&quot;
Prelude&gt; celebrate &quot;dogs&quot;
&quot;dogs woot!&quot;
You can also use the syntax with functions that are normally
prefix if you use the backticks to make them infix (note the
..is a shorthand for constructing a list of all the elements
between the first and last values given ‚Äî go ahead and play
with this in your REPL):
Prelude&gt; elem 9 [1..10]
True
Prelude&gt; 9 <code>elem</code> [1..10]
True
Prelude&gt; let c = (<code>elem</code> [1..10])
Prelude&gt; c 9
True
Prelude&gt; c 25
False</p>
<p>CHAPTER 5. TYPES 204
If you partially applied elemin its usual prefix form, then
the argument you apply it to would necessarily be the first
argument:
Prelude&gt; let hasTen = elem 10
Prelude&gt; hasTen [1..9]
False
Prelude&gt; hasTen [5..15]
True
Partial application is common enough in Haskell that, over
time, you‚Äôll develop an intuition for it. The sectioning syntax
exists to allow some freedom in which argument of a binary
operator you apply the function to.
Exercises: Type Arguments
Given a function and its type, tell us what type results from
applying some or all of the arguments.
You can check your work in the REPL like this (using the
first question as an example):
Prelude&gt; let f :: a -&gt; a -&gt; a -&gt; a; f = undefined
Prelude&gt; let x :: Char; x = undefined
Prelude&gt; :t f x</p>
<p>CHAPTER 5. TYPES 205
It turns out that you can check the types of things that aren‚Äôt
implemented yet, so long as you give GHCi an undefined to
bind the signature to.
1.If the type of fisa -&gt; a -&gt; a -&gt; a , and the type of ùë•isChar
then the type of f xis
a)Char -&gt; Char -&gt; Char
b)x -&gt; x -&gt; x -&gt; x
c)a -&gt; a -&gt; a
d)a -&gt; a -&gt; a -&gt; Char
2.If the type of gisa -&gt; b -&gt; c -&gt; b , then the type of
g 0 'c' &quot;woot&quot; is
a)String
b)Char -&gt; String
c)Int
d)Char
3.If the type of his(Num a, Num b) =&gt; a -&gt; b -&gt; b , then the
type of
h 1.0 2 is:
a)Double
b)Integer</p>
<p>CHAPTER 5. TYPES 206
c)Integral b =&gt; b
d)Num b =&gt; b
Note that because the type variables ùëéandùëèare diÔ¨Äerent,
the compiler mustassume that the types could be diÔ¨Äerent.
4.If the type of his(Num a, Num b) =&gt; a -&gt; b -&gt; b , then the
type of
h 1 (5.5 :: Double) is
a)Integer
b)Fractional b =&gt; b
c)Double
d)Num b =&gt; b
5.If the type of jackal is(Ord a, Eq b) =&gt; a -&gt; b -&gt; a , then
the type of
jackal &quot;keyboard&quot; &quot;has the word jackal in it&quot;
a)[Char]
b)Eq b =&gt; b
c)b -&gt; [Char]
d)b
e)Eq b =&gt; b -&gt; [Char]</p>
<p>CHAPTER 5. TYPES 207
6.If the type of jackal is(Ord a, Eq b) =&gt; a -&gt; b -&gt; a , then
the type of
jackal &quot;keyboard&quot;
a)b
b)Eq b =&gt; b
c)[Char]
d)b -&gt; [Char]
e)Eq b =&gt; b -&gt; [Char]
7.If the type of kessel is(Ord a, Num b) =&gt; a -&gt; b -&gt; a , then
the type of
kessel 1 2 is
a)Integer
b)Int
c)a
d)(Num a, Ord a) =&gt; a
e)Ord a =&gt; a
f)Num a =&gt; a
8.If the type of kessel is(Ord a, Num b) =&gt; a -&gt; b -&gt; a , then
the type of
kessel 1 (2 :: Integer) is
a)(Num a, Ord a) =&gt; a</p>
<p>CHAPTER 5. TYPES 208
b)Int
c)a
d)Num a =&gt; a
e)Ord a =&gt; a
f)Integer
9.If the type of kessel is(Ord a, Num b) =&gt; a -&gt; b -&gt; a , then
the type of
kessel (1 :: Integer) 2 is
a)Num a =&gt; a
b)Ord a =&gt; a
c)Integer
d)(Num a, Ord a) =&gt; a
e)a
5.5 Polymorphism
Polymorph is a word of relatively recent provenance. It was
invented in the early 19th century from the Greek words poly
for ‚Äúmany‚Äù and morph for ‚Äúform‚Äù. The -icsuffix in polymorphic
means ‚Äúmade of.‚Äù So, ‚Äòpolymorphic‚Äô means ‚Äúmade of many
forms.‚Äù In programming, this is understood to be in contrast
withmonomorphic , ‚Äúmade of one form.‚Äù</p>
<p>CHAPTER 5. TYPES 209
Polymorphic type variables give us the ability to implement
expressions that can accept arguments and return results of
diÔ¨Äerent types without having to write variations on the same
expression for each type. It would be inefficient if you were
doing arithmetic and had to write the same code over and
over for diÔ¨Äerent numeric types. The good news is the nu-
merical functions that come with your GHC installation and
thePrelude are polymorphic by default. Broadly speaking,
type signatures may have three kinds of types: concrete, con-
strained polymorphic, or parametrically polymorphic.
In Haskell, polymorphism divides into two categories: para-
metric polymorphism andconstrained polymorphism . If you‚Äôve
encountered polymorphism before, it was probably a form
of constrained, often called ad-hoc, polymorphism. Ad-hoc
polymorphism2in Haskell is implemented with typeclasses.
Parametric polymorphism is broader than ad-hoc polymor-
phism. Parametric polymorphism refers to type variables, or
parameters , that are fully polymorphic. When unconstrained
by a typeclass, their final, concrete type could be anything.
Constrained polymorphism, on the other hand, puts typeclass
constraints on the variable, decreasing the number of concrete
types it could be, but increasing what you can do with it by
defining and bringing into scope a set of operations.
2Wadler‚Äôs paper on making Ad-hoc polymorphism less ad-hoc http://people.csail.
mit.edu/dnj/teaching/6898/papers/wadler88.pdf</p>
<p>CHAPTER 5. TYPES 210
Recall that when you see a lowercase name in a type sig-
nature, it is a type variable and polymorphic (like ùëé,ùë°, etc). If
the type is capitalized, it is a specific, concrete type such as Int,
Bool, etc.
Let‚Äôs consider a parametrically polymorphic function: iden-
tity. Theidfunction comes with the Prelude and is called the
identity function because it is the identity for any value in
our language. In the next example, the type variable ùëéis para-
metrically polymorphic and not constrained by a typeclass.
Passing any value to idwill return the same value:
id::a-&gt;a
This type says: for all ùëé, get an argument of some type ùëé
and return a value of the same type ùëé.
This is the maximally polymorphic signature for id. It
allows this function to work with any type of data:
Prelude&gt; id 1
1
Prelude&gt; id &quot;blah&quot;
&quot;blah&quot;
Prelude&gt; let inc = (+1)
Prelude&gt; inc 2
3
Prelude&gt; (id inc) 2
3</p>
<p>CHAPTER 5. TYPES 211
Based on the type of id, we are guaranteed this behavior ‚Äî
it cannot do anything else! The ùëéin the type signature cannot
change because the type variable gets fixed to a concrete type
throughout the entire type signature (a == a). If one applies
idto a value of type Int, theùëéis fixed to type Int. By default,
type variables are resolved at the left-most part of the type
signature and are fixed once sufficient information to bind
them to a concrete type is available.
The arguments in parametrically polymorphic functions,
likeid, could be anything, any type or typeclass, so the terms
of the function are more restricted because there are no meth-
ods or information attached to them. With the type id :: a
-&gt; a, it can do nothing other than return ùëébecause there is
no information or method attached to its parameter at all ‚Äî
nothing can be done withùëé. On the other hand, a function like
negate, with a similar-appearing type signature of Num a =&gt; a
-&gt; aconstrains the ùëévariable as an instance of the Numtypeclass.
Nowùëéhas fewer concrete types it could be, but there is a set of
methods you can use, a set of things that can be done with ùëé.
If a variable represents a set of possible values, then a type
variable represents a set of possible types. When there is no
typeclass constraint, the set of possible types a variable could
represent is eÔ¨Äectively unlimited. Typeclass constraints limit
the set of potential types (and, thus, potential values) while
also passing along the common functions that can be used
with those values.</p>
<p>CHAPTER 5. TYPES 212
Concrete types have even more flexibility in terms of com-
putation. This has to do with the additive nature of typeclasses.
For example, an Intis only an Int, but it can make use of the
methods of the NumandIntegral typeclasses because it has in-
stances of both. We can describe Numas asuperclass of several
other numeric typeclasses that all inherit operations from Num.
In sum, if a variable could be anything , then there‚Äôs little
that can be done to it because it has no methods. If it can
besometypes (say, a type that has an instance of Num), then
it has some methods. If it is a concrete type, you lose the
type flexibility but, due to the additive nature of typeclass
inheritance, gain more potential methods. It‚Äôs important to
note that this inheritance extends downward from a superclass,
such as Num, to subclasses, such as Integral and then Int, but not
the other way around. That is, if something has an instance
ofNumbut not an instance of Integral , it can‚Äôt implement the
methods of the Integral typeclass. A subclass cannot override
the methods of its superclass.
A function is polymorphic when its type signature has vari-
ables that can represent more than one type. That is, its param-
eters are polymorphic. Parametric polymorphism refers to
fully polymorphic (unconstrained by a typeclass) parameters.
Parametricity is the property we get from having parametric
polymorphism. Parametricity means that the behavior of a
function with respect to the types of its (parametrically poly-</p>
<p>CHAPTER 5. TYPES 213
morphic) arguments is uniform. The behavior can notchange
just because it was applied to an argument of a diÔ¨Äerent type.
Exercises: Parametricity
All you can do with a parametrically polymorphic value is pass
or not pass it to some other expression. Prove that to yourself
with these small demonstrations.
1.Given the type a -&gt; a, which is the type for id, attempt
to make a function that terminates successfully that does
something other than returning the same value. This is
impossible, but you should try it anyway.
2.We can get a more comfortable appreciation of para-
metricity by looking at a -&gt; a -&gt; a . This hypothetical
function a -&gt; a -&gt; a has two‚Äìand only two‚Äìimplementa-
tions. Write both possible versions of a -&gt; a -&gt; a . After
doing so, try to violate the constraints of parametrically
polymorphic values we outlined above.
3.Implement a -&gt; b -&gt; b . How many implementations can
it have? Does the behavior change when the types of ùëé
andùëèchange?</p>
<p>CHAPTER 5. TYPES 214
Polymorphic constants
We‚Äôve seen that there are several types of numbers in Haskell
and that there are restrictions on using diÔ¨Äerent types of num-
bers in diÔ¨Äerent functions. But intuitively we see it would be
odd if we could not do arithmetic along the lines of -10 + 6.3 .
Well, let‚Äôs try it:
Prelude&gt; (-10) + 6.3
-3.7
That works just fine. Why? Let‚Äôs look at the types and see if
we can find out:
Prelude&gt; :t (-10) + 6.3
(-10) + 6.3 :: Fractional a =&gt; a
Prelude&gt; :t (-10)
(-10) :: Num a =&gt; a
Numeric literals like (-10) and 6.3 are polymorphic and stay
so until given a more specific type. The Num a =&gt; orFractional
a =&gt;is a typeclass constraint and the ùëéis the type variable
in scope. In the type for the entire equation, we see that the
compiler inferred that it was working with Fractional numbers.
It had to, to accommodate the fractional number 6.3. Fine,
but what about (-10)? We see that the type of (-10) is given
maximum polymorphism by only being an instance of the</p>
<p>CHAPTER 5. TYPES 215
Numtypeclass, which could be any type of number. We call
this a polymorphic constant; (-10) is not a variable, of course,
but the type that it instantiates could be any numeric type, so
its underlying representation is polymorphic. It will have to
resolve into a concrete type at some point in order to evaluate.
We can force the compiler to be more specific about the
types of numbers by declaring the type:
Prelude&gt; let x = 5 + 5
Prelude&gt; :t x
x :: Num a =&gt; a
Prelude&gt; let x = 5 + 5 :: Int
Prelude&gt; :t x
x :: Int
In the first example, we did not specify a type for the num-
bers, so the type signature defaulted to the broadest interpre-
tation, but in the second version, we told the compiler to use
theInttype.
Working around constraints
Previously, we‚Äôve looked at a function called length that takes
a list and counts the number of members and returns that
number as an Intvalue. We saw in the last chapter that because
Intis not a Fractional number, this function won‚Äôt work:</p>
<p>CHAPTER 5. TYPES 216
Prelude&gt; 6 / length [1, 2, 3]
No instance for (Fractional Int) arising
from a use of ‚Äò/‚Äô
In the expression: 6 / length [1, 2, 3]
In an equation for ‚Äòit‚Äô: it = 6 / length [1, 2, 3]
Heretheproblemis length isn‚Äôtpolymorphicenough. Fractional
includes several types of numbers, but Intisn‚Äôt one of them,
and that‚Äôs all length can return. Haskell does oÔ¨Äer ways to
work around this type of conflict, though. In this case, we
will use a function called fromIntegral that takes an integral
value and forces it to implement the Numtypeclass, rendering
it polymorphic. Here‚Äôs what the type signature looks like:
Prelude&gt; :type fromIntegral
fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b
So, it takes a value, ùëé, of anIntegral type and returns it as
a value, ùëè, of any Numtype. Let‚Äôs see how that works with our
fractional division problem:
Prelude&gt; 6 / fromIntegral (length [1, 2, 3])
2.0
And now all is right with the world once again.</p>
<p>CHAPTER 5. TYPES 217
5.6 Type inference
Haskell does not obligate us to assert a type for every expres-
sion or value in our programs because it has type inference .
Type inference is an algorithm for determining the types of
expressions. Haskell‚Äôs type inference is built on an extended
version of the Damas-Hindley-Milner type system.
Haskell will infer the most generally applicable (polymor-
phic) type that is still correct. Essentially, the compiler starts
from the values whose types it knows and then works out the
types of the other values. As you mature as a Haskell pro-
grammer, you‚Äôll find this is principally useful for when you‚Äôre
still figuring out new code rather than for code that is ‚Äúdone‚Äù.
Once your program is ‚Äúdone,‚Äù you will certainly know the
types of all the functions, and it‚Äôs considered good practice
to explicitly declare them. Remember when we suggested
that a good type system was like a pleasant conversation with
a colleague? Think of type inference as a helpful colleague
working through a problem with you.
For example, we can write idourselves:
Prelude&gt; let ourId x = x
Prelude&gt; :t ourId
ourId :: t -&gt; t
Prelude&gt; ourId 1
1</p>
<p>CHAPTER 5. TYPES 218
Prelude&gt; ourId &quot;blah&quot;
&quot;blah&quot;
Here we let GHCi infer the type of ourIditself. Due to alpha
equivalence, the diÔ¨Äerence in letters ( ùë°here versus ùëéabove)
makes no diÔ¨Äerence. Type variables have no meaning outside
of the type signatures where they are bound.
For this function, we again ask the compiler to infer the
type:
Prelude&gt; let myGreet x = x ++ &quot; Julie&quot;
Prelude&gt; myGreet &quot;hello&quot;
&quot;hello Julie&quot;
Prelude&gt; :type myGreet
myGreet :: [Char] -&gt; [Char]
The compiler knows the function (++)and has one value to
work with already that it knows is a String. It doesn‚Äôt have to
work very hard to infer a type signature from that information.
If, however, we take out the string value and replace it with
another variable, see what happens:
Prelude&gt; let myGreet x y = x ++ y
Prelude&gt; :type myGreet
myGreet :: [a] -&gt; [a] -&gt; [a]
We‚Äôre back to a polymorphic type signature, the same sig-
nature for (++)itself, because the compiler has no information</p>
<p>CHAPTER 5. TYPES 219
by which to infer the types for any of those variables (other
than that they are lists of some sort).
Let‚Äôs see type inference at work. Open your editor of choice
and enter the following snippet:
-- typeInference1.hs
moduleTypeInference1 where
f::Numa=&gt;a-&gt;a-&gt;a
fx y=x+y+3
Then load the code into GHCi to experiment:
Prelude&gt; :l typeInference1.hs
[1 of 1] Compiling TypeInference1
Ok, modules loaded: TypeInference1.
Prelude&gt; f 1 2
6
Prelude&gt; :t f
f :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; :t f 1
f 1 :: Num a =&gt; a -&gt; a
Because the numeric literals in Haskell have the (typeclass
constrained) polymorphic type Num a =&gt; a , we don‚Äôt get a more
specific type when applying ùëìto 1.</p>
<p>CHAPTER 5. TYPES 220
Look at what happens when we elide the explicit type sig-
nature for ùëì:
-- typeInference2.hs
moduleTypeInference2 where
fx y=x+y+3
No type signature for ùëì, so does it compile? Does it work?
Prelude&gt; :l typeInference2.hs
[1 of 1] Compiling TypeInference2
Ok, modules loaded: TypeInference2.
Prelude&gt; :t f
f :: Num a =&gt; a -&gt; a -&gt; a
Prelude&gt; f 1 2
6
Nothing changes. In certain cases there might be a change,
usually when you are using typeclasses in a way that doesn‚Äôt
make it clear which type you mean unless you assert one.
Exercises: Apply Yourself
Look at these pairs of functions. One function is unapplied,
so the compiler will infer maximally polymorphic type. The
second function has been applied to a value, so the inferred</p>
<p>CHAPTER 5. TYPES 221
type signature may have become concrete, or at least less
polymorphic. Figure out how the type would change and why,
make a note of what you think the new inferred type would
be and then check your work in GHCi.
1.-- Type signature of general function
(++)::[a]-&gt;[a]-&gt;[a]
-- How might that change when we apply
-- it to the following value?
myConcat x=x++&quot; yo&quot;
2.-- General function
(*)::Numa=&gt;a-&gt;a-&gt;a
-- Applied to a value
myMultx=(x/3)*5
3.take::Int-&gt;[a]-&gt;[a]
myTakex=take x&quot;hey you&quot;
4.(&gt;)::Orda=&gt;a-&gt;a-&gt;Bool
myComx=x&gt;(length [ 1..10])</p>
<p>CHAPTER 5. TYPES 222
5.(&lt;)::Orda=&gt;a-&gt;a-&gt;Bool
myAlphx=x&lt;'z'
5.7 Asserting types for declarations
Most of the time, we want to declare our types, rather than
relying on type inference. Adding type signatures to your code
can provide guidance to you as you write your functions. It
can also help the compiler give you information about where
your code is going wrong. As programs become longer and
more complex, type signatures become even more important,
as they help you or other programmers trying to use your
code read it and figure out what it‚Äôs supposed to do. This
section will look at how to declare types. We will start with
some trivial examples.
You may remember the triple function we‚Äôve seen before.
If we allow the compiler to infer the type, we end up with this:
Prelude&gt; let triple x = x * 3
Prelude&gt; :type triple
triple :: Num a =&gt; a -&gt; a
Here the triple function was made from the (<em>)function
which has type (</em>) :: Num a =&gt; a -&gt; a -&gt; a , but we have al-
ready applied one of the arguments, which is the 3, so there is</p>
<p>CHAPTER 5. TYPES 223
one less parameter in this type signature. It is still polymor-
phic because it can‚Äôt tell what type 3 is yet. If, however, we
want to ensure that our inputs and result may only be integers,
this is how we declare that:
Prelude&gt; let triple x = x * 3 :: Integer
Prelude&gt; :t triple
triple :: Integer -&gt; Integer
Note the typeclass constraint is gone because Integer imple-
mentsNum, so that constraint is redundant.
Here‚Äôs another example of a type declaration for our triple
function; this one is more like what you would see in a source
file:
-- type declaration
triple::Integer -&gt;Integer
-- function declaration
triplex=x*3
This is how most Haskell code you look at will be laid out,
with separate top-level declarations for types and functions.
Such top-level declarations are in scope throughout the mod-
ule.</p>
<p>CHAPTER 5. TYPES 224
It is possible, though uncommon, to declare types locally
withletandwhere. Here‚Äôsanexampleofassigningatypewithin
awhereclause:
triplex=tripleItYo x
wheretripleItYo ::Integer -&gt;Integer
tripleItYo y =y*3
We don‚Äôt have to assert the type of triple :
Prelude&gt; :t triple
triple :: Integer -&gt; Integer
The assertion in the whereclause narrowed our type down
fromNum a =&gt; a -&gt; a toInteger -&gt; Integer . GHC will pick up
and propagate type information for inference from appli-
cations of functions, sub-expressions, definitions ‚Äî almost
anywhere. The type inference is strong with this one.
Thereareconstraints on our ability to declare types. For
example, if we try to make the (+)function return a String , we
get an error message:
Prelude&gt; let x = 5 + 5 :: String
No instance for (Num String) arising from a use of ‚Äò+‚Äô
In the expression: 5 + 5 :: String
In an equation for ‚Äòx‚Äô: x = 5 + 5 :: String</p>
<p>CHAPTER 5. TYPES 225
This function cannot accept arguments of type String. In
this case, it‚Äôs overdetermined, both because the (+)function
is limited to types implementing the Numtypeclass and also
because we‚Äôve already passed it two numeric literals as values.
The numeric literals could be any of several numeric types
under the hood, but they can‚Äôt be String because String does
not implement the Numtypeclass.
5.8 Chapter Exercises
Welcome to another round of ‚ÄúKnowing is not enough; we
must apply.‚Äù
Multiple choice
1.A value of type [a]is
a)a list of alphabetic characters
b)a list of lists
c)a list whose elements are all of some type ùëé
d)a list whose elements are all of diÔ¨Äerent types
2.A function of type [[a]] -&gt; [a] could
a)take a list of strings as an argument
b)transform a character into a string</p>
<p>CHAPTER 5. TYPES 226
c)transform a string into a list of strings
d)take two arguments
3.A function of type [a] -&gt; Int -&gt; a
a)takes one argument
b)returns one element of type ùëéfrom a list
c)must return an Intvalue
d)is completely fictional
4.A function of type (a, b) -&gt; a
a)takes a list argument and returns a Charvalue
b)has zero arguments
c)takes a tuple argument and returns the first value
d)requires that ùëéandùëèbe of diÔ¨Äerent types
Determine the type
For the following functions, determine the type of the spec-
ified value. We suggest you type them into a file and load
the contents of the file in GHCi. In all likelihood, it initially
will not have the polymorphic types you might expect due to
themonomorphism restriction . That means that top-level dec-
larations by default will have a concrete type if any can be
determined. You can fix this by setting up your file like so:</p>
<p>CHAPTER 5. TYPES 227
{-# LANGUAGE NoMonomorphismRestriction #-}
moduleDetermineTheType where
-- simple example
example =1
If you had not included the NoMonomorphismRestriction exten-
sion,example would have had the type Integer instead of Num a
=&gt; a. Do your best to determine the mostpolymorphic type
an expression could have in the following exercises.
1.All function applications return a value. Determine the
value returned by these function applications and the type
of that value.
a)(*9)6
b)head[(0,&quot;doge&quot;),(1,&quot;kitteh&quot; )]
c)head[(0::Integer ,&quot;doge&quot;),(1,&quot;kitteh&quot; )]
d)ifFalsethenTrueelseFalse
e)length[1,2,3,4,5]
f)(length [ 1,2,3,4])&gt;(length &quot;TACOCAT&quot; )
2.Given</p>
<p>CHAPTER 5. TYPES 228
x=5
y=x+5
w=y<em>10
What is the type of w?
3.Given
x=5
y=x+5
zy=y</em>10
What is the type of z?
4.Given
x=5
y=x+5
f=4/y
What is the type of f?
5.Given
x=&quot;Julie&quot;
y=&quot; &lt;3 &quot;
z=&quot;Haskell&quot;
f=x++y++z
What is the type of f?</p>
<p>CHAPTER 5. TYPES 229
Does it compile?
For each set of expressions, figure out which expression, if any,
causes the compiler to squawk at you (n.b. we do not mean
literal squawking) and why. Fix it if you can.
1.bigNum=(^)5$10
wahoo=bigNum$10
2.x=print
y=print&quot;woohoo!&quot;
z=x&quot;hello world&quot;
3.a=(+)
b=5
c=b10
d=c200
4.a=12+b
b=10000*c
Type variable or specific type constructor?
1.You will be shown a type declaration, and you should
categorize each type. The choices are a fully polymorphic
type variable, constrained polymorphic type variable, or
concrete type constructor.</p>
<p>CHAPTER 5. TYPES 230
f::Numa=&gt;a-&gt;b-&gt;Int-&gt;Int
-- [0] [1] [2] [3]
Here, the answer would be: constrained polymorphic
(Num) ([0]), fully polymorphic ([1]), and concrete ([2] and
[3]).
2.Categorize each component of the type signature as de-
scribed in the previous example.
f::zed-&gt;Zed-&gt;Blah
3.Categorize each component of the type signature
f::Enumb=&gt;a-&gt;b-&gt;C
4.Categorize each component of the type signature
f::f-&gt;g-&gt;C
Write a type signature
For the following expressions, please add a type signature. You
should be able to rely on GHCi type inference to check your
work, although you might not have precisely the same answer
as GHCi gives (due to polymorphism, etc).
1.While we haven‚Äôt fully explained this syntax yet, you‚Äôve
seen it in Chapter 2 and as a solution to an exercise in</p>
<p>CHAPTER 5. TYPES 231
Chapter 4. This syntax is a way of destructuring a single
element of a list by pattern matching.
functionH ::
functionH (x:_)=x
2.functionC ::
functionC x y=
if(x&gt;y)thenTrueelseFalse
3.functionS ::
functionS (x, y)=y
Given a type, write the function
You will be shown a type and a function that needs to be writ-
ten. Use the information the type provides to determine what
the function should do. We‚Äôll also tell you how many ways
there are to write the function. Syntactically diÔ¨Äerent but
semantically equivalent implementations are not counted as
being diÔ¨Äerent. For example, writing a function one way then
rewriting the semantically identical function but using anony-
mous lambda syntax does not count as two implementations.
To make things a little easier, we‚Äôll demonstrate how to solve
this kind of exercise. Given:</p>
<p>CHAPTER 5. TYPES 232
myFunc::(x-&gt;y)
-&gt;(y-&gt;z)
-&gt;c
-&gt;(a, x)
-&gt;(a, z)
myFuncxToY yToZ _(a, x)=undefined
Talking through the above, we have a function that takes
four arguments. The final result is a tuple with the type (a,
z). It turns out, the ùëêargument is nowhere in our results and
there‚Äôs nothing to do with it, so we use the underscore to ignore
that. We named the two function arguments by their types
and pattern matched on the tuple argument. The only way to
get the second value of the tuple from the type ùë•to the type ùëß
is to use bothof the functions furnished to us. If we tried the
following:
myFuncxToY yToZ _(a, x)=
(a, (xToY x))
We would get a type error that it expected the type ùëßbut
the actual type was ùë¶. That‚Äôs because we‚Äôre on the right path,
but not quite done yet! Accordingly, the following should
typecheck:</p>
<p>CHAPTER 5. TYPES 233
myFunc::(x-&gt;y)
-&gt;(y-&gt;z)
-&gt;c
-&gt;(a, x)
-&gt;(a, z)
myFuncxToY yToZ _(a, x)=
(a, (yToZ (xToY x)))
1.There is only one function definition that typechecks and
doesn‚Äôt go into an infinite loop when you run it.
i::a-&gt;a
i=undefined
2.There is only one version that works.
c::a-&gt;b-&gt;a
c=undefined
3.Given alpha equivalence are c''andc(see above) the same
thing?
c''::b-&gt;a-&gt;b
c''= ?
4.Only one version that works.
c'::a-&gt;b-&gt;b
c'=undefined</p>
<p>CHAPTER 5. TYPES 234
5.There are multiple possibilities, at least two of which
you‚Äôve seen in previous chapters.
r::[a]-&gt;[a]
r=undefined
6.Only one version that will typecheck.
co::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
co=undefined
7.One version will typecheck.
a::(a-&gt;c)-&gt;a-&gt;a
a=undefined
8.One version will typecheck.
a'::(a-&gt;b)-&gt;a-&gt;b
a'=undefined
Fix it
Won‚Äôt someone take pity on this poor broken code and fix it
up? Be sure to check carefully for things like capitalization,
parentheses, and indentation.
1.module sing where</p>
<p>CHAPTER 5. TYPES 235
fstString :: [Char] ++ [Char]
fstString x = x ++ &quot; in the rain&quot;
sndString :: [Char] -&gt; Char
sndString x = x ++ &quot; over the rainbow&quot;
sing = if (x &gt; y) then fstString x or sndString y
where x = &quot;Singin&quot;
x = &quot;Somewhere&quot;
2.Now that it‚Äôs fixed, make a minor change and make it sing
the other song. If you‚Äôre lucky, you‚Äôll end up with both
songs stuck in your head!
3.-- arith3broken.hs
moduleArith3Broken where
main::IO()
Main= do
print1+2
putStrLn 10
print (negate -1)
print (( +)0blah)
whereblah=negate1</p>
<p>CHAPTER 5. TYPES 236
Type-Kwon-Do
The name is courtesy of Phillip Wright.3Thank you for the
idea!
The focus here is on manipulating terms in order to get the
types to fit. This sortof exercise is something you‚Äôll encounter
in writing real Haskell code, so the practice will make it easier
to deal with when you get there. Practicing this will make you
better at writing ordinary code as well.
Weprovidethetypesandbottomedout(declaredas undefined )
terms.Bottom andundefined will be explained in more detail
later. The contents of the terms are irrelevant here. You‚Äôll use
only the declarations provided and what the Prelude provides
by default unless otherwise specified. Your goal is to make the
???‚Äôd declaration pass the typechecker by modifying it alone.
Here‚Äôs a worked example for how we present these exercises
and how you are expected to solve them. Given the following:
3https://twitter.com/SixBitProxyWax</p>
<p>CHAPTER 5. TYPES 237
dataWoot
dataBlah
f::Woot-&gt;Blah
f=undefined
g::(Blah,Woot)-&gt;(Blah,Blah)
g= ???
Here it‚Äôs ùëîthat you‚Äôre supposed to implement; however,
you can‚Äôt evaluate anything. You‚Äôre to only use type-checking
and type-inference to validate your answers. Also note that
we‚Äôre using a trick for defining datatypes which can be named
in a type signature, but have no values. Here‚Äôs an example of
a valid solution:
g::(Blah,Woot)-&gt;(Blah,Blah)
g(b, w)=(b, f w)
The idea is to only fill in what we‚Äôve marked with ???.
Not all terms will always be used in the intended solution for a
problem.</p>
<p>CHAPTER 5. TYPES 238
1.f::Int-&gt;String
f=undefined
g::String-&gt;Char
g=undefined
h::Int-&gt;Char
h= ???
2.dataA
dataB
dataC
q::A-&gt;B
q=undefined
w::B-&gt;C
w=undefined
e::A-&gt;C
e= ???</p>
<p>CHAPTER 5. TYPES 239
3.dataX
dataY
dataZ
xz::X-&gt;Z
xz=undefined
yz::Y-&gt;Z
yz=undefined
xform::(X,Y)-&gt;(Z,Z)
xform= ???
4.munge::(x-&gt;y)
-&gt;(y-&gt;(w, z))
-&gt;x
-&gt;w
munge= ???
5.9 Definitions
1.Polymorphism refers to type variables which may refer to
more than one concrete type. In Haskell, this will usually
manifest as parametric orad-hoc polymorphism. By hav-
ing a larger set of types, we intersect the commonalities</p>
<p>CHAPTER 5. TYPES 240
of them all to produce a smaller set of correct terms. This
makes it less likely we‚Äôll write an incorrect program and
lets us reuse the code with other types.
2.Type inference is a faculty some programming languages,
most notably Haskell and ML, have to inferprincipal types
from terms without needing explicit type annotations.
There are, in some cases, terms in Haskell which can be
well-typed but which have no principal type. In those
cases, an explicit type annotation must be added.
With respect to Haskell, the principal type is the most
generic type which still typechecks. More generally, Prin-
cipal type is a property of the type system you‚Äôre interact-
ing with. Principal typing holds for that type system if a
type can be found for a term in an environment for which
all other types for that term are instances of the principal
type. Here are some examples:</p>
<p>CHAPTER 5. TYPES 241
-- Given the inferred types
a
Numa=&gt;a
Int
-- The principal type here is the
-- parametrically polymorphic 'a'.
-- Given these types
(Orda,Numa)=&gt;a
Integer
-- The principal type is
-- (Ord a, Num a) =&gt; a
3.Type variable is a way to refer to an unspecified type or
set of types in Haskell type signatures. Type variables
ordinarily will be equal to themselves throughout a type
signature. Let us consider some examples.
id::a-&gt;a
-- One type variable 'a' that occurs twice,
-- once as an argument, once as a result.
-- Parametrically polymorphic, could be
-- strictly anything</p>
<p>CHAPTER 5. TYPES 242
(+)::Numa=&gt;a-&gt;a-&gt;a
-- One type variable 'a', constrained
-- to needing an instance of Num. Two
-- arguments, one result.
-- All the same type.
4.Atypeclass is a means of expressing faculties or interfaces
that multiple datatypes may have in common. This en-
ables us to write code exclusively in terms of those com-
monalities without repeating yourself for each instance.
Just as one may sum values of type Int,Integer ,Float,
Double , andRational , we can avoid having diÔ¨Äerent (+),(*),
(-),negate , etc. functions for each by unifying them into
a single typeclass. Importantly, these can then be used
withalltypes that have a Numinstance. Thus, a typeclass
provides us a means to write code in terms of those oper-
ators and have our functions be compatible with all types
that have instances of that typeclass, whether they already
exist or are yet to be invented (by you, perhaps).
5.Parametricity is the property that holds in the presence of
parametric polymorphism. Parametricity states that the
behavior of a function will be uniform across all concrete
applications of the function. Parametricity4tells us that</p>
<p>CHAPTER 5. TYPES 243
the function:
id::a-&gt;a
Can be understood to have the same exact behavior for
every type in Haskell without us needing to see how it
was written. It is the same property that tells us:
const::a-&gt;b-&gt;a
constmustreturn the first value ‚Äî parametricity and the
definition of the type requires it!
f::a-&gt;a-&gt;a
Here,ùëìcan only return the first or second value, nothing
else, and it will always return one or the other consistently
without changing. If the function ùëìmade use of (+)or
(*), its type would necessarily be constrained by the type-
class Num and thus be an example of ad-hoc, rather than
parametric, polymorphism.
blahFunc ::b-&gt;String
blahFunc totally ignores its argument and is eÔ¨Äectively a
constant value of type String which requires a throw-away
argument for no reason.
4Examples are courtesy of the @parametricity twitter account.
https://twitter.com/parametricity</p>
<p>CHAPTER 5. TYPES 244
convList ::a-&gt;[a]
Unless the result is [], the resulting list has values that are
all the same value. The list will always be the same length.
6.Ad-hoc polymorphism (sometimes called ‚Äúconstrained poly-
morphism‚Äù) is polymorphism that applies one or more
typeclass constraints to what would‚Äôve otherwise been a
parametrically polymorphic type variable. Here, rather
than representing a uniformity of behavior across all con-
crete applications, the purpose of ad-hoc polymorphism
istoallowthefunctionstohavediÔ¨Äerentbehaviorforeach
instance. This ad-hoc-ness is constrained by the types
in the typeclass that defines the methods and Haskell‚Äôs
requirement that typeclass instances be unique for a given
type. For any given combination of typeclass and a type,
such as OrdandBool, there must only exist one unique
instance in scope. This makes it considerably easier to
reason about typeclasses. See the example for a disam-
biguation.</p>
<p>CHAPTER 5. TYPES 245
(+)::Numa=&gt;a-&gt;a-&gt;a
-- the above function is leveraging
-- ad-hoc polymorphism via the
-- Num typeclass
c'::a-&gt;a-&gt;a
-- This function is not,
-- it's parametrically polymorphic in 'a'.
7.Amodule is the unit of organization that the Haskell pro-
gramming language uses to collect together declarations
of values, functions, data types, typeclasses, and typeclass
instances. Any time you use ‚Äúimport‚Äù in Haskell, you are
importing declarations from a module . Let us look at an
example from the chapter exercises:
{-# LANGUAGE NoMonomorphismRestriction #-}
moduleDetermineTheType where
-- ^ name of our module
Here we made our Haskell source file have a module and
we named it DetermineTheType . We included a directive to
the compiler to disable the monomorphism restriction</p>
<p>CHAPTER 5. TYPES 246
before we declared the module. Also consider the follow-
ing example using import :
importData.Aeson (encode)
-- ^ the module Data.Aeson
importDatabase.Persist
-- ^ the module Database.Persist
In the above example, we are importing the function
encode declared in the module Data.Aeson along with any
typeclass instances. With the module Database.Persist we
are importing everything it makes available.
5.10 Follow-up resources
1.Luis Damas; Robin Milner. Principal type-schemes for
functional programs
2.Christopher Strachey. Fundamental Concepts in Pro-
gramming Languages
Popular origin of the parametric/ad-hoc polymorphism
distinction.</p>
<p>Chapter 6
Typeclasses
A blank cheque kills
creativity.
Mokokoma Mokhonoana
247</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 248
6.1 Typeclasses
You may have realized that it is very difficult to talk about or
understand Haskell‚Äôs type system without also talking about
typeclasses. So far we‚Äôve been focused on the way they interact
with type variables and numeric types, especially. This chapter
explains some important predefined typeclasses, only some
of which have to do with numbers, and provides more detail
about how typeclasses work more generally. In this chapter,
we will
‚Ä¢examine the typeclasses Eq,Num,Ord,Enum, andShow;
‚Ä¢learn about type-defaulting typeclasses and typeclass in-
heritance;
‚Ä¢look at some common but often implicit functions that
create side eÔ¨Äects.
6.2 What are typeclasses?
Typeclasses and types in Haskell are, in a sense, opposites.
Where a declaration of a type defines how that type in partic-
ular is created, a declaration of a typeclass defines how a set
of types are consumed or used in computations. This tension
is related to the expression problem which is about defining
code in terms of how data is created or processed. As Philip</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 249
Wadler put it, ‚ÄúThe goal is to define a datatype by cases, where
one can add new cases to the datatype and new functions over
the datatype, without recompiling existing code, and while
retaining static type safety (e.g., no casts).‚Äù1If you know other
programming languages with a similar concept, it may help to
think of typeclasses as being like interfaces to data that can work
across multiple datatypes. The latter facility is why typeclasses
are a means of ad hoc polymorphism ‚Äî ad hoc because type-
class code is dispatched by type, something we will explain
later in this chapter. We will continue calling it constrained
polymorphism, though, as we think that term is generally
more clear.
Typeclasses allow us to generalize over a set of types in
order to define and execute a standard set of features for those
types. For example, the ability to test values for equality is
useful, and we‚Äôd want to be able to use that function for data
of various types. In fact, we can test any data of a type that
implements the typeclass known as Eqfor equality. We do
not need separate equality functions for each diÔ¨Äerent type
of data; as long as our datatype implements, or instantiates,
theEqtypeclass, we can use the standard functions. Similarly,
all the numeric literals and their various types implement a
typeclass called Num, which defines a standard set of operators
that can be used with any type of numbers.
1Philip Wadler, ‚ÄúThe Expression Problem‚Äù http://homepages.inf.ed.ac.uk/wadler/
papers/expression/expression.txt</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 250
We‚Äôll get into more detail about what it means for a type
to have an ‚Äúinstance‚Äù of a typeclass in this chapter, but briefly
stated, it means that there is code that defines how the values
and functions from that typeclass work for that type. When
you use a typeclass method with one of the types that has such
an instance, the compiler looks up the code that dictates how
the function works for that type. We‚Äôll see this more as we
write our own instances.
6.3 Back to Bool
Let‚Äôs return briefly to the Booltype to get a feel for what type-
class information looks like. As you may recall, we can use
the GHCi command :infoto query information, including
typeclass information about any function or type (and some
values):
Prelude&gt; :info Bool
data Bool = False | True
instance Bounded Bool
instance Enum Bool
instance Eq Bool
instance Ord Bool
instance Read Bool
instance Show Bool</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 251
The information includes the data declaration for Booland
which typeclasses it already has instances of. It also tells you
where the datatype and its instances are defined for the com-
piler, if you want to look at the source code, but we‚Äôve left that
information out.
Let‚Äôs look at that list of instances. Each of these instances
is a typeclass that Boolimplements, and the instances are the
unique specifications of how Boolmakes use of the methods
from that typeclass. In this chapter, we‚Äôre only going to exam-
ine a few of these, namely Eq,Ord, andShow. Briefly, however,
they mean the following:
1.instance Bounded Bool ‚ÄìBounded for types that have an up-
per and lower bound
2.instance Enum Bool ‚ÄìEnumfor things that can be enumer-
ated
3.instance Eq Bool ‚ÄìEqfor things that can be tested for equal-
ity
4.instance Ord Bool ‚ÄìOrdfor things that can be put into a
sequential order
5.instance Read Bool ‚ÄìReadparses strings into things. Don‚Äôt
use it. No seriously, don‚Äôt.
6.instance Show Bool ‚ÄìShowrenders things into strings.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 252
Typeclasses have a hierarchy of sorts,2as you might recall
from our discussion of numeric types. All Fractional numbers
implement the Numtypeclass, but not all NumareFractional . All
members of Ordmust be members of Eq, and all members of
Enummust be members of Ord. To be able to put something
in an enumerated list, they must be able to be ordered; to be
able to order something, they must be able to be compared
for equality.
6.4 Eq
In Haskell, equality is implemented with a typeclass called Eq.
Some programming languages bake equality into every object
in the language, but some datatypes do not have a sensible
notion of equality3, so Haskell does not encode equality into
every type. Eqallows us to use standard measures of equality
for quite a few datatypes, though.
Eqis defined this way:
Prelude&gt; :info Eq
class Eq a where
(==) :: a -&gt; a -&gt; Bool
2You can use a search engine like Hoogle at http://haskell.org/hoogle to find informa-
tion on Haskell datatypes and typeclasses. Hoogle is a Haskell API search engine, which
allows you to search many standard Haskell libraries by function name or type signature.
As you become fluent in Haskell types, you will be able to input the type of the function
you want and find the functions that match.
3Most importantly, the function type does not have an Eqinstance for reasons we will
not get into here.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 253
(/=) :: a -&gt; a -&gt; Bool
First, it tells us we have a typeclass called Eqwhere there are
two basic functions, equality and nonequality, and gives their
type signatures. Next it lists the instances of Eq:
-- partial list
instance Eq a =&gt; Eq [a]
instance Eq Ordering
instance Eq Int
instance Eq Float
instance Eq Double
instance Eq Char
instance Eq Bool
instance (Eq a, Eq b) =&gt; Eq (a, b)
instance Eq ()
instance Eq a =&gt; Eq (Maybe a)
instance Eq Integer
We see several numeric types, our old friend Bool,Char(un-
surprising, as we‚Äôve seen that we can compare characters for
equality), and tuples. We know from this that any time we are
using data of these types, we are implementing the Eqtypeclass
and therefore have generic functions we can use to compare
their equality. Any type that has an instance of this typeclass
implements the methods of the typeclass.
Here are some examples using this typeclass:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 254
Prelude&gt; 132 == 132
True
Prelude&gt; 132 /= 132
False
Prelude&gt; (1, 2) == (1, 1)
False
Prelude&gt; (1, 1) == (1, 2)
False
Prelude&gt; &quot;doge&quot; == &quot;doge&quot;
True
Prelude&gt; &quot;doge&quot; == &quot;doggie&quot;
False
The types of (==)and(/=)inEqtell us something important
about these functions:
(==)::Eqa=&gt;a-&gt;a-&gt;Bool
(/=)::Eqa=&gt;a-&gt;a-&gt;Bool
Given these types, we know that they can be used for any
typeùëéwhich implements the Eqtypeclass. We also know that
both functions will take two arguments of the same type ùëéand
returnBool. We know they have to be the same because ùëémust
equalùëéin the same type signature.
When we apply (==)to a single argument, we can see how
it specializes the arguments:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 255
(==) ::Eqa=&gt;a-&gt;a-&gt;Bool
-- if we specialized (==)
-- for [Char] aka String
(==)
::[Char]-&gt;[Char]-&gt;Bool
(==)&quot;cat&quot;
:: [Char]-&gt;Bool
(==)&quot;cat&quot;&quot;cat&quot;
:: Bool
You can experiment with this further in the REPL to see
how applying types to arguments makes the type variables
more specific.
What happens if the first two arguments ùëéandùëéaren‚Äôt the
same type?
Prelude F M&gt; (1, 2) == &quot;puppies!&quot;
Couldn't match expected type ‚Äò(t0, t1)‚Äô
with actual type ‚Äò[Char]‚Äô
In the second argument of ‚Äò(==)‚Äô, namely ‚Äò&quot;puppies!&quot;‚Äô
In the expression: (1, 2) == &quot;puppies!&quot;
In an equation for ‚Äòit‚Äô: it = (1, 2) == &quot;puppies!&quot;
Let‚Äôs break down this type error:
Couldn't match expected type ‚Äò(t0, t1)‚Äô</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 256
with actual type ‚Äò[Char]‚Äô
This error means our [Char] wasn‚Äôt the tuple of types ùë°0and
ùë°1that was expected. (t0, t1) was expected for the second
argument (where we supplied &quot;puppies!&quot; ) because that‚Äôs the
type of the first argument. Remember: the type of ùëéis usually
setbytheleftmostoccurrenceandcan‚Äôtchangeinthesignature
Eq a =&gt; a -&gt; a -&gt; Bool .
Applying (==)toInteger will bind the ùëétype variable to
Integer . This is as if the signature changed to:
EqInteger =&gt;Integer -&gt;Integer -&gt;Bool
The typeclass constraint Eq Integer =&gt; gets dropped because
it‚Äôs redundant. We can see the issue more clearly if we look at
the typeclass instances on the 2-tuple (,):
data(,) a b =(,) a b
instance (Eqa,Eqb)=&gt;Eq(a, b)
instance (Orda,Ordb)=&gt;Ord(a, b)
instance (Reada,Readb)=&gt;Read(a, b)
instance (Showa,Showb)=&gt;Show(a, b)
We saw the Eqinstance of (,)getting used earlier when we
tested code like (1, 2) == (1, 2) . Critically, the Eqinstance of
(a, b) relies on the Eqinstances of ùëéandùëè. This tells us the
equality of two tuples (a, b) depends on the equality of their
constituent values ùëéandùëè. This is why this works:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 257
Prelude&gt; (1, 'a') == (2, 'b')
False
But neither of these will work:
Prelude&gt; (1, 2) == ('a', 'b')
Prelude&gt; (1, 'a') == ('a', 1)
Typeclass deriving Typeclass instances we can magically de-
rive are Eq,Ord,Enum,Bounded ,Read, andShow, though there are
some constraints on deriving some of these. Deriving means
you don‚Äôt have to manually write instances of these typeclasses
for each new datatype you create. We‚Äôll address this a bit more
in the chapter on Algebraic Datatypes.
6.5 Writing typeclass instances
We haven‚Äôt talked much about writing your own datatypes yet,
or about writing your own typeclass; however, you can and
will do both. In either case, you will sometimes find yourself
needing to write your own typeclass instances. While Eqis one
of the typeclasses you can simply derive, it‚Äôs also one of the
least complicated typeclasses to write instances for, so we‚Äôre
going to use it here, to demonstrate how to write your own
instances.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 258
Eq instances
As we‚Äôve seen, Eqprovides instances for determining equality
of values, so making an instance of it for a given datatype is
usually straightforward.
You can investigate a typeclass by referring to the Hack-
age documentation for that typeclass. Typeclasses like Eq
come with the core baselibrary that is located at http://hackage.
haskell.org/package/base .Eqspecifically is located at http://
hackage.haskell.org/package/base/docs/Data-Eq.html .
In that documentation, you‚Äôll want to note a particular bit
of wording:
Minimal complete definition: either == or /=.
This tells you what methods you need to define to have
a valid Eqinstance. In this case, either (==)(equal) or (/=)
(unequal) will suffice, as one can be defined as the negation
of the other. Why not only (==)? Although it‚Äôs rare, you may
have something clever to do for each case that could make
equality checking faster for a particular datatype, so you‚Äôre
allowed to specify both if you want to. We won‚Äôt do that here
because (/=)is the negation of (==), and we won‚Äôt be working
with any clever datatypes.
First, we‚Äôll work with a tiny, trivial datatype called... Trivial !</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 259
dataTrivial =
Trivial
With no deriving clause hanging oÔ¨Ä the butt of this datatype
declaration, we‚Äôll have no typeclass instances of any kind. If we
try to load this up and test equality without adding anything
further, GHC will throw a type error:
Prelude&gt; Trivial == Trivial
No instance for (Eq Trivial) arising
from a use of ‚Äò==‚Äô
In the expression: Trivial == Trivial
In an equation for ‚Äòit‚Äô: it = Trivial == Trivial
GHC can‚Äôt find an instance of Eqfor our datatype Trivial .
We could‚Äôve had GHC generate one for us using deriving Eq
or we could‚Äôve written one, but we did neither, so none exists
and it fails at compile time. In some languages, this sort of
mistake doesn‚Äôt become known until your code is already in
the middle of executing.
Unlike other languages, Haskell does not provide universal
stringification ( Show/ print) or equality ( Eq(value equality) or
pointer equality) as this is not always sound or safe, regardless
of what programming language you‚Äôre using.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 260
So we must write our own! Fortunately, with Trivial this
is...trivial. Keep your typeclass instances for a type in the same
file as that type (we‚Äôll explain why later):
dataTrivial =
Trivial'
instance EqTrivial where
Trivial' ==Trivial' =True
And that‚Äôs it! We wrote an instance that tells the compiler
how to test this datatype for equality. Data constructors and
type constructors often have the same name in Haskell, and
that can get confusing. We used the single quote at the end of
the data constructor here because they don‚Äôt have to have the
same name and it might make it easier to follow the examples.
If you load this up, you have only one possible expression
you can construct here:
Prelude&gt; Trivial' == Trivial'
True
Let‚Äôs drill down a bit into how this instance stuÔ¨Ä works:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 261
instance EqTrivial where
-- [1] [2] [3] [4]
Trivial' ==Trivial' =True
-- [5] [6] [7] [8]
instance EqTrivial where
(==)Trivial' Trivial' =True
-- [ 9 ]
1.The keyword instance here begins a declaration of a type-
classinstance. TypeclassinstancesarehowyoutellHaskell
how equality, stringification ( Show), orderability ( Ord), enu-
meration ( Enum) or other typeclasses should work for a
particular datatype. Without this instance, we can‚Äôt test
the values for equality even though the answer will never
vary in the case of this particular datatype.
2.The first name to follow the instance is the typeclass the
instance is providing. Here that is Eq.
3.The type the instance is being provided for. In this case,
we‚Äôreimplementingthe Eqtypeclass fortheTrivial datatype.
4.The keyword whereterminates the initial declaration and
beginning of the instance. What follows are the methods
(functions) being implemented.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 262
5.The data constructor (value) Trivial' is the first argument
to the==function we‚Äôre providing. Here we‚Äôre defining ==
using infix notation so the first argument is to the left.
6.The infix function ==, this is what we‚Äôre defining in this
declaration.
7.The second argument, which is the value Trivial' . Since
==is infix here, the second argument is to the right of ==.
8.The result of Trivial' == Trivial' , that is, True.
9.We could‚Äôve written the definition of (==)using prefix no-
tation instead of infix by wrapping the operator in paren-
theses. Note this is being shown as an alterative; you can‚Äôt
have two typeclass instances for the same type. Typeclass
instances are unique to a given type. You can try having
both in the same file, but you‚Äôll get an error.
Okay, let‚Äôs stretch our legs a bit and try something a bit less
Trivial ! We‚Äôll make our own datatypes ‚Äî one for the days of
the week and one for the date that makes use of the DayOfWeek
type:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 263
dataDayOfWeek =
Mon|Tue|Weds|Thu|Fri|Sat|Sun
-- day of week and numerical day of month
dataDate=
DateDayOfWeek Int
Since these are not prebaked datatypes in Haskell, they have
no typeclass instances at all. As they stand, there is nothing you
can do with them because no operations are defined for them.
Let‚Äôs fix that. The first Eqinstance we‚Äôll write is for DayOfWeek
and is a bit tedious to write out:
instance EqDayOfWeek where
(==)MonMon=True
(==)TueTue=True
(==)WedsWeds=True
(==)ThuThu=True
(==)FriFri=True
(==)SatSat=True
(==)SunSun=True
(==)_ _ = False
Now we‚Äôll write an Eqinstance for our Datetype. This one is
more interesting:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 264
instance EqDatewhere
(==) (Dateweekday dayOfMonth)
(Dateweekday' dayOfMonth') =
weekday ==weekday'
&amp;&amp;dayOfMonth ==dayOfMonth'
In theEqinstance for Date, we didn‚Äôt recapitulate how equal-
ity forDayOfWeek andIntvalues worked; we simply said that the
dates were equal if all of their constituent values were equal.
Note, also, that the compiler already expects the arguments
ofDateto be aDayOfWeek value and an Intso we do not need to
specify that. Based on what it knows about those three types,
this is enough information for us to test Datevalues for equality.
Does it work?
Prelude&gt; Date Thu 10 == Date Thu 10
True
Prelude&gt; Date Thu 10 == Date Thu 11
False
Prelude&gt; Date Thu 10 == Date Weds 10
False
It compiles, and it returns what we want after three cursory
checks ‚Äî ship it!
We‚Äôll point out one other thing about these types:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 265
Prelude&gt; Date Thu 10
<interactive>:26:1:
No instance for (Show Date) arising from a use of ‚Äòprint‚Äô
In a stmt of an interactive GHCi command: print it
We wrote an Eqinstance, so we can test the values for equal-
ity, but we can‚Äôt print them in the REPL because we provided
noShowinstance. If you‚Äôd like to fix that, you can stick a deriving
Showclause on the end of each of the datatypes above.
Partial functions ‚Äî not so strange danger
We‚Äôve mentioned partial application of functions previously,
but the term partial function refers to something diÔ¨Äerent. A
partial function is one that doesn‚Äôt handle all the possible cases,
so there are possible scenarios in which we haven‚Äôt defined
any way for the code to evaluate.
We need to take care to avoid partial functions in general
in Haskell, but this must be especially kept in mind when we
have a type with multiple cases such as DayOfWeek . What if we
had made a mistake in the Eqinstance?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 266
dataDayOfWeek =
Mon|Tue|Weds|Thu|Fri|Sat|Sun
instance EqDayOfWeek where
(==)MonMon=True
(==)TueTue=True
(==)WedsWeds=True
(==)ThuThu=True
(==)FriFri=True
(==)SatSat=True
(==)SunSun=True
What if the arguments are diÔ¨Äerent? We forgot our uncon-
ditional case. This will appear to be fine whenever the argu-
ments are the same, but blow up in our faces when they‚Äôre
not:
Prelude&gt; Mon == Mon
True
Prelude&gt; Mon == Tue
*** Exception: code/derivingInstances.hs:
(19,3)-(25,23):
Non-exhaustive patterns in function ==
Well, that stinks. We definitely didn‚Äôt start learning Haskell
because we wanted stuÔ¨Ä to blow up at runtime. So what gives?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 267
The good news is there issomething you can do to get more
help from GHC on this. If we turn all warnings on with the
-Wallflag in our REPL (or in our build configuration), then
GHC will let us know when we‚Äôre not handling all cases:
Prelude&gt; :set -Wall
Prelude&gt; :l code/derivingInstances.hs
[1 of 1] Compiling DerivingInstances
code/derivingInstances.hs:19:3: Warning:
Pattern match(es) are non-exhaustive
In an equation for ‚Äò==‚Äô:
Patterns not matched:
Mon Tue
Mon Weds
Mon Thu
Mon Fri
...
Ok, modules loaded: DerivingInstances.
You‚Äôll find that if you fix your instance and provide the
fallback case that returns False, it‚Äôll stop squawking about the
non-exhaustive patterns.
Partial functions are not only a concern with typeclass in-
stances, though. We will discuss this more in the next chapter,
but it‚Äôs also a concern with any function that doesn‚Äôt handle all</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 268
possible inputs, such as this, that blows up anytime the input
isn‚Äôt 2:
f::Int-&gt;Bool
f2=True
If you compile or load this, you‚Äôll get another warning (as-
suming you still have -Wallturned on). In this case, because
Intis ahugetype with many values, it‚Äôs using notation that says
you‚Äôre not handling all inputs that aren‚Äôt the number 2:
Pattern match(es) are non-exhaustive
In an equation for ‚Äòf‚Äô:
Patterns not matched:
GHC.Types.I# #x with #x <code>notElem</code> [2#]
If you add another case such that you‚Äôre handling one more
input, it will add that to the set of values you are handling:
f::Int-&gt;Bool
f1=True
f2=True
Pattern match(es) are non-exhaustive
In an equation for ‚Äòf‚Äô:
Patterns not matched:
GHC.Types.I# #x with #x <code>notElem</code> [1#, 2#]</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 269
f::Int-&gt;Bool
f1=True
f2=True
f3=True
Pattern match(es) are non-exhaustive
In an equation for ‚Äòf‚Äô:
Patterns not matched:
GHC.Types.I# #x with #x <code>notElem</code> [1#, 2#, 3#]
So on and so forth. The real answer here is to have an
unconditional case that matches everything. The following
will compile without complaint and is not partial:
f::Int-&gt;Bool
f1=True
f2=True
f3=True
f_ =False
Another solution is to use a datatype that isn‚Äôt hugelikeInt
if you only have a few cases you want to consider.
-- Seriously. It's huge.
Prelude&gt; minBound :: Int
-9223372036854775808</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 270
Prelude&gt; maxBound :: Int
9223372036854775807
If you want your data to describe only a handful of cases,
write them down in a sum type like the DayOfWeek datatype we
showed you earlier. Don‚Äôt use Intas an implicit sum type as C
programmers commonly do.
Sometimes we need to ask for more
When we‚Äôre writing an instance of a typeclass such as Eqfor
something with polymorphic parameters, such as Identity
below, we‚Äôll sometimes need to require our argument or argu-
ments to provide some typeclass instances for us in order to
write an instance for the datatype containing them:
dataIdentity a=
Identity a
instance Eq(Identity a)where
(==) (Identity v) (Identity v')=v==v'
What we want to do here is rely on whatever Eqinstances the
argument to Identity (written as ùëéin the datatype declaration
andùë£in the instance definition) has already. There is one
problem with this as it stands, though:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 271
No instance for (Eq a) arising from a use of ‚Äò==‚Äô
Possible fix: add (Eq a) to the
context of the instance declaration
In the expression: v == v'
In an equation for ‚Äò==‚Äô:
(==) (Identity v) (Identity v') = v == v'
In the instance declaration for ‚ÄòEq (Identity a)‚Äô
The problem here is that ùë£andùë£‚Ä≤are both of type ùëébut we
don‚Äôt know anything about ùëé. In this case, we can‚Äôt assume
it has an Eqinstance. However, we can use the same type-
class constraint syntax we saw with functions, in our instance
declaration:
instance Eqa=&gt;Eq(Identity a)where
(==) (Identity v) (Identity v')=v==v'
Now it‚Äôll work because we know ùëéhas to have an instance of
Eq. Additionally, Haskell will ensure we don‚Äôt attempt to check
equality with values that don‚Äôt have an Eqinstance at compile
time:
Prelude&gt; Identity NoEqInst == Identity NoEqInst
No instance for (Eq NoEqInst)
arising from a use of ‚Äò==‚Äô</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 272
In the expression:
Identity NoEqInst == Identity NoEqInst
In an equation for ‚Äòit‚Äô:
it = Identity NoEqInst == Identity NoEqInst
We could ask for more than we need in order to obtain an
answer, such as below where we ask for an Ordinstance for ùëé,
but there‚Äôs no reason to do so since Eqrequires less than Ord
and does enough for what we need here:
instance Orda=&gt;Eq(Identity a)where
(==) (Identity v) (Identity v')=
compare v v' ==EQ
That will compile, but it‚Äôs not clear why you‚Äôd do it. Maybe
you have your own secret reasons.
Exercises: Eq Instances
Write the Eqinstance for the datatype provided.
1.It‚Äôs not a typo, we‚Äôre just being cute with the name.
dataTisAnInteger =
TisAnInteger</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 273
2.dataTwoIntegers =
TwoInteger Integer
3.dataStringOrInt =
TisAnInt Int
|TisAString String
4.dataPaira=
Paira a
5.dataTuplea b=
Tuplea b
6.dataWhicha=
ThisOne a
|ThatOne a
7.dataEitherOr a b=
Helloa
|Goodbye b
6.6 Num
We have seen a lot of Numat this point, so we‚Äôll try not to go
on too long about it. It is a typeclass implemented by most
numeric types. As we did with Eqwe will query the information
and examine its set of predefined functions:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 274
classNumawhere
(+)::a-&gt;a-&gt;a
(*)::a-&gt;a-&gt;a
(-)::a-&gt;a-&gt;a
negate::a-&gt;a
abs::a-&gt;a
signum::a-&gt;a
fromInteger ::Integer -&gt;a
And its list of instances (not quite complete):
instance NumInteger
instance NumInt
instance NumFloat
instance NumDouble
We‚Äôve seen most of this information before, in one form
or another: common arithmetic functions with their type
signatures at the top ( fromInteger is similar to fromIntegral but
restricted to Integer rather than all integral numbers) plus a list
of types that implement this typeclass, numeric types we‚Äôve
looked at previously. No surprises here.
Integral
The typeclass called Integral has the following definition:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 275
class(Reala,Enuma)=&gt;Integral awhere
quot::a-&gt;a-&gt;a
rem::a-&gt;a-&gt;a
div::a-&gt;a-&gt;a
mod::a-&gt;a-&gt;a
quotRem ::a-&gt;a-&gt;(a, a)
divMod::a-&gt;a-&gt;(a, a)
toInteger ::a-&gt;Integer
The typeclass constraint (Real a, Enum a) =&gt; means that any
type that implements Integral must already have instances for
RealandEnumtypeclasses. In a very real sense the tuple syntax
here denotes the conjunction of typeclass constraints on your
type variables. An integral type must be both a real number
and enumerable and therefore may employ the methods of
each of those typeclasses. In turn, the Realtypeclass itself re-
quires an instance of Num. So, the Integral typeclass may put
the methods of RealandNuminto eÔ¨Äect (in addition to those
ofEnum). Since Realcannot override the methods of Num, this
typeclass inheritance is onlyadditive and the ambiguity prob-
lems caused by multiple inheritance in some programming
languages ‚Äî the so-called ‚Äúdeadly diamond of death‚Äù ‚Äî are
avoided.
Exercises: Tuple Experiment Look at the types given for
quotRem anddivMod . What do you think those functions do? Test</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 276
your hypotheses by playing with them in the REPL. We‚Äôve
given you a sample to start with below:
Prelude&gt; let ones x = snd (divMod x 10)
Fractional
Numis a superclass of Fractional . TheFractional typeclass is
defined as follows:
class(Numa)=&gt;Fractional awhere
(/) ::a-&gt;a-&gt;a
recip ::a-&gt;a
fromRational ::Rational -&gt;a
This typeclass declaration creates a class named Fractional
which requires its type argument ùëéto have an instance of Num
in order to create an instance of Fractional . This is another
example of typeclass inheritance. Fractional applies to fewer
numbers than Numdoes, and instances of the Fractional class
can use the functions defined in Num, but not all Numcan use
the functions defined in Fractional because nothing in Num‚Äôs
definition requires an instance of Fractional . There is a chart
at the end of the chapter to help you visualize this information.
We can see this with ordinary functions:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 277
First let‚Äôs consider this function, intentionally without a
type provided:
divideThenAdd x y=(x/y)+1
We‚Äôll load this with a type that asks only for a Numinstance:
divideThenAdd ::Numa=&gt;a-&gt;a-&gt;a
divideThenAdd x y=(x/y)+1
And you‚Äôll get the type error:
Could not deduce (Fractional a)
arising from a use of ‚Äò/‚Äô
from the context (Num a)
bound by the type signature for
divideThenAdd :: Num a =&gt; a -&gt; a -&gt; a
Now if we only cared about having the Numconstraint, we
couldmodifyourfunctiontonotuse (/)whichrequires Fractional :
-- This works fine.
-- (+) and (-) are both provided by Num
subtractThenAdd ::Numa=&gt;a-&gt;a-&gt;a
subtractThenAdd x y=(x-y)+1</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 278
Or we can change the type rather than modifying the func-
tion itself:
-- This works fine.
divideThenAdd ::Fractional a
=&gt;a-&gt;a-&gt;a
divideThenAdd x y=(x/y)+1
Put on your thinking cap Why didn‚Äôt we need to make the
type of the function we wrote require both typeclasses? Why
didn‚Äôt we have to do this:
f::(Numa,Fractional a)=&gt;a-&gt;a-&gt;a
Consider what it means for something to be a subset of a
larger set of objects.
6.7 Type-defaulting typeclasses
When you have a typeclass-constrained (ad hoc) polymorphic
value and need to evaluate it, the polymorphism must be re-
solved to a specific concrete type. The concrete type must
have an instance for all the required typeclass instances (that
is, if it is required to implement NumandFractional then the
concrete type can‚Äôt be an Int). Ordinarily the concrete type</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 279
would come from the type signature you‚Äôve specified or from
type inference, such as when a Num a =&gt; a is used in an expres-
sion that expects an Integer which forces the polymorphic
number value to concretize as an Integer . But in some cases,
particularly when you‚Äôre working in the GHCi REPL, you will
not have specified a concrete type for a polymorphic value. In
those situations, the typeclass will default to a concrete type,
and the default types are already set in the libraries.
When we do this in the REPL:
Prelude&gt; 1 / 2
0.5
Our result 0.5appears the way it does because it defaults to
Double . Using the type assignment operator ::we can assign a
more specific type and circumvent the default to Double :
Prelude&gt; 1 / 2 :: Float
0.5
Prelude&gt; 1 / 2 :: Double
0.5
Prelude&gt; 1 / 2 :: Rational
1 % 2
The Haskell Report4specifies the following defaults relevant
to numerical computations:
4The Haskell Report is the standard that specifies the language and standard libraries</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 280
default Num Integer
default Real Integer
default Enum Integer
default Integral Integer
default Fractional Double
default RealFrac Double
default Floating Double
default RealFloat Double
Num,Real, etc., are typeclasses, and Integer andDouble are
the types they default to. This type defaulting for Fractional
means that:
(/)::Fractional a=&gt;a-&gt;a-&gt;a
changes to
(/)::Double-&gt;Double-&gt;Double
if you don‚Äôt specify the concrete type desired for (/). A
similar example but for Integral would be
div::Integral a=&gt;a-&gt;a-&gt;a
defaulting to
div::Integer -&gt;Integer -&gt;Integer
for Haskell. The most recent version is Haskell Report 2010, which can be found at
https://www.haskell.org/onlinereport/haskell2010/ .</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 281
The typeclass constraint is superfluous when the types are
concrete. On the other hand, you must specify which type-
classes you want type variables to have implemented. The use
of polymorphic values without the ability to infer a specific
type and no default rule will cause GHC to complain about an
ambiguous type.
The following will work because all the types below imple-
ment the Numtypeclass:
Prelude&gt; let x = 5 + 5 :: Int
Prelude&gt; x
10
Prelude&gt; let x = 5 + 5 :: Integer
Prelude&gt; x
10
Prelude&gt; let x = 5 + 5 :: Float
Prelude&gt; x
10.0
Prelude&gt; let x = 5 + 5 :: Double
Prelude&gt; x
10.0
Now we can make this type more specific, and the process</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 282
will be similar. In this case, let‚Äôs use Integer which implements
Num:
let x = 10 :: Integer
let y = 5 :: Integer
-- These are the declared types for these
-- functions, because they're from Num.
(+) :: Num a =&gt; a -&gt; a -&gt; a
(*) :: Num a =&gt; a -&gt; a -&gt; a
(-) :: Num a =&gt; a -&gt; a -&gt; a
Now any functions from Numare going to automatically get
specialized to Integer when we apply them to the ùë•orùë¶values:
Prelude&gt; :t (x+)
(x+) :: Integer -&gt; Integer
-- For
(+) :: Num a =&gt; a -&gt; a -&gt; a
-- When 'a' is Integer
(+) :: Integer -&gt; Integer -&gt; Integer
-- Apply the first argument
(x+) :: Integer -&gt; Integer
-- Applying the second and last argument
(x+y) :: Integer</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 283
-- Final result was Integer.
We can declare more specific (monomorphic) functions
from more general (polymorphic) functions:
let add = (+) :: Integer -&gt; Integer -&gt; Integer
We cannot go in the other direction, because we lost the
generality of Numwhen we specialized to Integer :
Prelude&gt; :t id
id :: a -&gt; a
Prelude&gt; let numId = id :: Num a =&gt; a -&gt; a
Prelude&gt; let intId = numId :: Integer -&gt; Integer
Prelude&gt; let altNumId = intId :: Num a =&gt; a -&gt; a
Could not deduce (a1 ~ Integer)
from the context (Num a)
bound by the inferred type of
altNumId :: Num a =&gt; a -&gt; a
or from (Num a1)
bound by an expression type signature:
Num a1 =&gt; a1 -&gt; a1
‚Äòa1‚Äô is a rigid type variable bound by
an expression type signature:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 284
Num a1 =&gt; a1 -&gt; a1
Expected type: a1 -&gt; a1
Actual type: Integer -&gt; Integer
In the expression: intId :: Num a =&gt; a -&gt; a
In an equation for ‚ÄòaltNumId‚Äô:
altNumId = intId :: Num a =&gt; a -&gt; a
Theexpectedtype and the actualtype don‚Äôt match. Remember,
the actual type is the type we provided; the expected type
is what the compiler expects. Here, the actual type is more
concrete than the expected type. Types can be made more
specific, but not more general or polymorphic.
6.8 Ord
Next we‚Äôll take a look at a typeclass called Ord. We‚Äôve previously
noted that this typeclass covers the types of things that can be
put in order. If you use :infoforOrdin your REPL, you will
find a very large number of instances for this typeclass. We‚Äôre
going to pare it down a bit and focus on the essentials, but, as
always, we encourage you to explore this further on your own:
Prelude&gt; :info Ord</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 285
class Eq a =&gt; Ord a where
compare :: a -&gt; a -&gt; Ordering
(&lt;) :: a -&gt; a -&gt; Bool
(&gt;=) :: a -&gt; a -&gt; Bool
(&gt;) :: a -&gt; a -&gt; Bool
(&lt;=) :: a -&gt; a -&gt; Bool
max :: a -&gt; a -&gt; a
min :: a -&gt; a -&gt; a
instance Ord a =&gt; Ord (Maybe a)
instance (Ord a, Ord b) =&gt; Ord (Either a b)
instance Ord Integer
instance Ord a =&gt; Ord [a]
instance Ord Ordering
instance Ord Int
instance Ord Float
instance Ord Double
instance Ord Char
instance Ord Bool
Notably, at the top, we have another typeclass constraint.
Ordis constrained by Eqbecause if you‚Äôre going to compare
items in a list and put them in order, you need a way to de-
termine if they are equal. So, Ordrequires Eqand its methods.
The functions that come standard in this class have to do with
ordering. Some of them will give you a result of Bool, and</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 286
we‚Äôve played a bit with those functions. Let‚Äôs see what a few
others do:
Prelude&gt; compare 7 8
LT
Prelude&gt; compare 4 (-4)
GT
Prelude&gt; compare 4 4
EQ
Prelude&gt; compare &quot;Julie&quot; &quot;Chris&quot;
GT
Prelude&gt; compare True False
GT
Prelude&gt; compare True True
EQ
Thecompare function works for any of the types listed above
that implement the Ordtypeclass, including Bool, but unlike
the&lt;, &gt;, &gt;= and&lt;=operators, this returns an Ordering value
instead of a Boolvalue.
You may notice that Trueis greater than False. Proximally
this is due to how the Booldatatype is defined: False | True .
There may be a more interesting underlying reason if you
prefer to ponder the philosophical implications.
Themaxandminfunctions work in a similarly straightfor-
ward fashion for any type that implements this typeclass:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 287
Prelude&gt; max 7 8
8
Prelude&gt; min 10 (-10)
-10
Prelude&gt; max (3, 4) (2, 3)
(3,4)
Prelude&gt; min [2, 3, 4, 5] [3, 4, 5, 6]
[2,3,4,5]
Prelude&gt; max &quot;Julie&quot; &quot;Chris&quot;
&quot;Julie&quot;
By looking at the type signature, we can see that these func-
tions have two parameters. If you want to use these to deter-
mine the maximum or minimum of three values, you can nest
them:
Prelude&gt; max 7 (max 8 9)
9
If you try to give it too few arguments, you will get this
strange-seeming message:
Prelude&gt; max &quot;Julie&quot;
No instance for (Show ([Char] -&gt; [Char]))
-- [1] [2] [ 3 ]
arising from a use of ‚Äòprint‚Äô</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 288
-- [4]
In a stmt of an interactive GHCi command: print it
-- [ 5 ]
1.Haskell couldn‚Äôt find an instance of a typeclass for a value
of a given type.
2.The typeclass it couldn‚Äôt find an instance for was Show, the
typeclass that allows GHCi to print values in your terminal.
More on this in the following sections.
3.It couldn‚Äôt find an instance of Showfor the type String -&gt;
String . Nothing with type (-&gt;)should have a Showinstance
as a general rule because (-&gt;)denotes a function rather
than a constant value.
4.We wanted an instance of Showbecause we (indirectly)
invoked printwhich has type print :: Show a =&gt; a -&gt; IO
()‚Äî note the constraint for Show.
5.The interactive GHCi command print it invoked print
on our behalf.
Any time we ask GHCi to print a return value in our ter-
minal, we are indirectly invoking print, which has the type
Show a =&gt; a -&gt; IO () . The first argument to printmust have an
instance of Show. The error message is because maxapplied to</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 289
a single String argument needs another argument before it‚Äôll
return a String (aka[Char] ) value that is Show-able or printable.
Until we apply it to a second argument, it‚Äôs still a function,
and a function has no instance of Show. The request to print
a function, rather than a constant value, results in this error
message.
Ord instances
We‚Äôll see more examples of writing instances as we proceed
in the book and explain more thoroughly how to write your
own datatypes. We wrote some Eqinstances earlier. Now we‚Äôll
practice our instance-writing skills (this is one of the most
necessary skills in Haskell) by writing Ordinstances.
When you derive Ordinstances for a datatype, they rely on
the way the datatype is defined, but if you write your own
instance, you can define the behavior you want. We‚Äôll use the
days of the week again to demonstrate:
dataDayOfWeek =
Mon|Tue|Weds|Thu|Fri|Sat|Sun
deriving (Ord,Show)
We only derived OrdandShowthere because you should still
have the Eqinstance we wrote for this datatype in scope. If you
don‚Äôt, you have two options: bring it back into scope by putting
it into the file you‚Äôre currently using, or derive an Eqinstance</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 290
for the datatype now by adding it inside the parentheses. You
can‚Äôt have an Ordinstance unless you also have an Eqinstance,
so the compiler will complain if you don‚Äôt do one (not both)
of those two things.
Values to the left are less than values to the right, as if they
were placed on a number line:
Prelude&gt; Mon &gt; Tue
False
Prelude&gt; Sun &gt; Mon
True
Prelude&gt; compare Tue Weds
LT
But if we wanted to express that Friday is always the best
day, we can write our own Ordinstance to express that:
dataDayOfWeek =
Mon|Tue|Weds|Thu|Fri|Sat|Sun
deriving (Eq,Show)
instance OrdDayOfWeek where
compare FriFri=EQ
compare Fri_ =GT
compare _Fri=LT
compare _ _ = EQ</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 291
Now, if we compare Friday to any other day, Friday is always
greater. All other days, you notice, are equal in value:
Prelude&gt; compare Fri Sat
GT
Prelude&gt; compare Sat Mon
EQ
Prelude&gt; compare Fri Mon
GT
Prelude&gt; compare Sat Fri
LT
Prelude&gt; Mon &gt; Fri
False
Prelude&gt; Fri &gt; Sat
True
But we did derive an Eqinstance above, so we do get the
expected equality behavior:
Prelude&gt; Sat == Mon
False
Prelude&gt; Fri == Fri
True
A few things to keep in mind about writing Ordinstances:
First, it is wise to ensure that your Ordinstances agree with your
Eqinstances, whether the Eqinstances are derived or manually</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 292
written. If x == y , thencompare x y should return EQ. Also, you
want your Ordinstances to define a sensible total order. You
ensure this in part by covering all cases and not writing partial
instances, as we noted above with Eq. In general, your Ord
instance should be written such that, when compare x y returns
LT, thencompare y x returns GT.
Ord implies Eq
The following isn‚Äôt going to typecheck for reasons we already
covered:
check'::a-&gt;a-&gt;Bool
check'a a'=a==a'
The error we get mentions that we need Eq, which makes
sense!
No instance for (Eq a) arising from a use of ‚Äò==‚Äô
Possible fix:
add (Eq a) to the context of
the type signature for check' :: a -&gt; a -&gt; Bool
In the expression: a == a'
In an equation for ‚Äòcheck'‚Äô: check' a a' = a == a'
But what if we add Ordinstead of Eqas it asks?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 293
check'::Orda=&gt;a-&gt;a-&gt;Bool
check'a a'=a==a'
It should compile. Now, Ordisn‚Äôt what GHC asked for, so
why did it work? It worked because anything that provides an
instance of Ordmustby definition also already have an instance
ofEq. How do we know? As we said above, logically it makes
sense that you can‚Äôt order things without the ability to check
for equality, but we can also check :info Ord in GHCi:
Prelude&gt; :info Ord
class Eq a =&gt; Ord a where
... buncha noise we don't care about...
The class definition of Ordsays that any ùëéwhich wants to
define an Ordinstance must already provide an Eqinstance. We
can say that Eqis asuperclass ofOrd.
Usually, you want the minimally sufficient set of constraints
on all your functions ‚Äî so we would use Eqinstead of Ordif the
above example was ‚Äúreal‚Äù code ‚Äî but we did this so you could
get an idea of how constraints and superclassing in Haskell
work.
Exercises: Will They Work?
Next, take a look at the following code examples and try to
decide if they will work, what result they will return if they do,</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 294
and why or why not (be sure, as always, to test them in your
REPL once you have decided on your answer):
1.max(length [ 1,2,3])
(length [ 8,9,10,11,12])
2.compare (3<em>4) (3</em>5)
3.compare &quot;Julie&quot; True
4.(5+3)&gt;(3+6)
6.9 Enum
A typeclass known as Enumthat we have mentioned previously
seems similar to Ordbut is slightly diÔ¨Äerent. This typeclass
covers types that are enumerable, therefore have known pre-
decessors and successors. We shall try not to belabor the point,
because you are probably developing a good idea of how to
query and make use of typeclass information:
Prelude&gt; :info Enum
class Enum a where
succ :: a -&gt; a
pred :: a -&gt; a
toEnum :: Int -&gt; a
fromEnum :: a -&gt; Int</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 295
enumFrom :: a -&gt; [a]
enumFromThen :: a -&gt; a -&gt; [a]
enumFromTo :: a -&gt; a -&gt; [a]
enumFromThenTo :: a -&gt; a -&gt; a -&gt; [a]
instance Enum Ordering
instance Enum Integer
instance Enum Int
instance Enum Char
instance Enum Bool
instance Enum ()
instance Enum Float
instance Enum Double
Numbers and characters are known to have predictable
successors and predecessors, so these are paradigmatic cases
of enumerability:
Prelude&gt; succ 4
5
Prelude&gt; pred 'd'
'c'
Prelude&gt; succ 4.5
5.5
You can also see that some of these functions return a result
of a list type. They take a starting value and build a list with</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 296
the succeeding items of the same type:
Prelude&gt; enumFromTo 3 8
[3,4,5,6,7,8]
Prelude&gt; enumFromTo 'a' 'f'
&quot;abcdef&quot;
Finally, let‚Äôs take a short look at enumFromThenTo :
Prelude&gt; enumFromThenTo 1 10 100
[1,10,19,28,37,46,55,64,73,82,91,100]
Take a look at the resulting list and see if you can find the
pattern: what does this function do? What happens if we give
it the values 0 10 100 instead? How about 'a' 'c' 'z' ?
6.10 Show
Showis a typeclass that provides for the creating of human-
readable string representations of structured data. GHCi uses
Showto create String values it can print in the terminal.
Showis not a serialization format. Serialization is how data
is rendered to a textual or binary format for persistence or
communicating with other computers over a network. An
example of persistence would be saving data to a file on disk.
Showis not suitable for any of these purposes; it‚Äôs expressly for
human readability.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 297
The typeclass information looks like this (truncated):
classShowawhere
showsPrec ::Int-&gt;a-&gt;ShowS
show::a-&gt;String
showList ::[a]-&gt;ShowS
instance Showa=&gt;Show[a]
instance ShowOrdering
instance Showa=&gt;Show(Maybea)
instance ShowInteger
instance ShowInt
instance ShowChar
instance ShowBool
instance Show()
instance ShowFloat
instance ShowDouble
Importantly, we see that various number types, Boolvalues,
tuples, and characters are all already instances of Show. That is,
they have a defined ability to be printed to the screen. There is
also a function showwhich takes a polymorphic ùëéand returns
it as aString , allowing it to be printed.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 298
Printing and side eÔ¨Äects
When you ask GHCi to return the result of an expression and
print it to the screen, you are indirectly invoking a function
calledprintthat we encountered briefly in the chapter about
printing and again in the section about Ordand the error mes-
sage that results from passing the maxfunction too few argu-
ments. As understanding printis important to understanding
this typeclass, we‚Äôre going to digress a bit and talk about it in
more detail.
Haskell is a pure functional programming language. The
functional part of that comes from the fact that programs are
written as functions, similar to mathematical equations, in
which an operation is applied to some arguments to produce
a result. The purepart of our description of Haskell means
expressions in Haskell can be expressed exclusively in terms
of a lambda calculus.
It may not seem obvious that printing results to the screen
could be a source of worry. The function is not just applied
to the arguments that are in its scope but also asked to aÔ¨Äect
the world outside its scope in some way, namely by showing
you its result on a screen. This is known as a side eÔ¨Äect , a po-
tentially observable result apart from the value the expression
evaluates to. Haskell manages eÔ¨Äects by separating eÔ¨Äectful
computations from pure computations in ways that preserve
the predictability and safety of function evaluation. Impor-</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 299
tantly, eÔ¨Äect-bearing computations themselves become more
composable and easier to reason about. The benefits of ex-
plicit eÔ¨Äects include the fact that it makes it relatively easy to
reason about and predict the results of our functions.
What sets Haskell apart from most other functional pro-
gramming languages is that it introduced and refined a means
of writing ordinary programs that talk to the outside world
without adding anything to the pure lambda calculus it is
founded on. This property ‚Äî being lambda calculus and
nothing more ‚Äî is what makes Haskell a purely functional
programming language.
TheprintfunctionissometimesinvokedindirectlybyGHCi,
but its type explicitly reveals that it is eÔ¨Äectful. Up to now,
we‚Äôve been covering over how this works, but it‚Äôs time to dive
a bit deeper.
printis defined in the Prelude standard as a function to out-
put ‚Äúa value of any printable type to the standard output device.
Printable types are those that are instances of class Show; print
converts values to strings for output using the show operation
and adds a newline.‚Äù Let‚Äôs look at the type of print:
Prelude&gt; :t print
print :: Show a =&gt; a -&gt; IO ()
As we see, printtakes an argument ùëéthat must be a type with
an instance of the Showtypeclass and returns an IO ()result.
This result is an IOaction that returns a value of the type ().</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 300
We saw this IO ()result previously when we talked about
printing strings. We also noted that it is the obligatory type
ofmainin a source code file. This is because running mainonly
produces side eÔ¨Äects. indexmain@ main
Statedassimplyaspossible, anI/O(input/output, frequently
written ‚ÄòIO‚Äô without a slash; when referring to the Haskell
datatype, there is no slash) action is an action that, when per-
formed, has side eÔ¨Äects, including reading from input and
printing to the screen and will contain a return value. The
()denotes an empty tuple, which we refer to as unit. Unit
is a value, and also a type that has only this one inhabitant,
that essentially represents nothing. Printing a string to the
terminal doesn‚Äôt have a meaningful return value. But an IO
action, like any expression in Haskell, can‚Äôt return nothing ; it
must return something. So we use this empty tuple to rep-
resent the return value at the end of our I/O action. That is,
theprintfunction will first do the I/O action of printing the
string to the terminal and then complete the action, marking
an end to the execution of the function and a delimitation of
the side eÔ¨Äects, by returning this empty nothing tuple. It does
not print the empty tuple to the screen, but it is implicitly
there. The simplest way to think about the diÔ¨Äerence between
a value with a typical type like String and the same type but
fromIOsuch as with IO String is thatIOactions are formulas.
When you have a value of type IO String it‚Äôs more of a meansof
producing aString , which may require performing side eÔ¨Äects</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 301
along the way before you get your String value.
This is a String value:
myVal::String
This value is a method or means of obtaining a value, by
performing eÔ¨Äects or I/O, of type String :
ioString ::IOString
AnIOactionisperformedwhenwecall mainforourprogram,
as we have seen. But we also perform an IOaction when we
invokeprintimplicitly or explicitly. indexmain@ main
Working with Show
Up to now, we have only been deriving typeclass instances
forShowbecause deriving usually gives us the result we want
without a lot of fuss. Having a Showinstance is crucial to being
able to print anything to the terminal, so we‚Äôre going to look at
some examples of why Showis important and how it is imple-
mented. Invoking the Showtypeclass also invokes its methods,
specifically a method of taking your values and turning them
into values that can be printed to the screen.
A minimal implementation of an instance of Showonly re-
quires that showorshowsPrec be implemented, as in the follow-
ing example:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 302
dataMood=Blah
instance ShowMoodwhere
show_ =&quot;Blah&quot;
Prelude&gt; Blah
Blah
Here‚Äôs what happens in GHCi when you define a datatype
and ask GHCi to show it without the instance for the Show
typeclass:
Prelude&gt; data Mood = Blah
Prelude&gt; Blah
No instance for (Show Mood) arising
from a use of ‚Äòprint‚Äô
In a stmt of an interactive GHCi command: print it
Next let‚Äôs look at how you define a datatype to have an in-
stance of Show. We can derive the Showinstance for Moodbecause
it‚Äôs one of the typeclasses GHC supports deriving instances for
by default:
Prelude&gt; data Mood = Blah deriving Show
Prelude&gt; Blah
Blah</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 303
And, in fact, most of the time that‚Äôs what you‚Äôll do for your
own datatypes. In the chapter on building projects, we will
need to write a custom instance for Show, though, so that should
give you something exciting to look forward to.
6.11 Read
TheReadtypeclass...well, it‚Äôs... there. You‚Äôll notice that, like Show,
a lot of types have instances of Read. This typeclass is essentially
the opposite of Show. Where Showtakes things and turns them
into human-readable strings, Readtakes strings and turns them
into things. Like Show, it‚Äôs not a serialization format. So, what‚Äôs
the problem? We gave that dire warning against using Read
earlier in the chapter, but this doesn‚Äôt seem like a big deal,
right?
The problem is in the String type. A String is a list, which
could be empty in some cases, or stretch on to infinity in other
cases.
We can begin to understand this by examining the types:
Prelude&gt; :t read
read :: Read a =&gt; String -&gt; a
There‚Äôs no way Read a =&gt; String -&gt; a will always work. Let‚Äôs
consider a type like Integer which has a Readinstance. We are in
no way guaranteed that the String will be a valid representation</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 304
of anInteger value. A String value can be anytext. That‚Äôs way
too big of a type for things we want to parse into numbers!
We can prove this for ourselves in the REPL:
Prelude&gt; read &quot;1234567&quot; :: Integer
1234567
Prelude&gt; read &quot;BLAH&quot; :: Integer
*** Exception: Prelude.read: no parse
That exception is a runtime error and means that readis a
partial function , a function that doesn‚Äôt return a proper value
as a result for all possible inputs. We have ways of cleaning
this up we‚Äôll explain and demonstrate later. We should strive
to avoid writing or using such functions in Haskell because
Haskell gives us the tools necessary to avoid senseless sources
of errors in our code.
6.12 Instances are dispatched by type
We‚Äôve said a few times, without explaining it, that typeclasses
are dispatched by type, but it‚Äôs an important thing to under-
stand. Typeclasses are defined by the set of operations and
values all instances will provide. Typeclass instances are unique
pairings of the typeclass and a type. They define the ways to
implement the typeclass methods for that type.
We‚Äôre going to walk through some code to illustrate what
this all means. The first thing you will see is that we‚Äôve written</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 305
our own typeclass and instances for demonstration purposes.
Those details aren‚Äôt important for understanding this code.
Just remember:
‚Ä¢a typeclass defines a set of functions and/or values;
‚Ä¢types have instances of that typeclass;
‚Ä¢the instances specify the ways that type uses the functions
of the typeclass.
This is vacuous and silly. This is only to make a point. Please
do not write typeclasses like this:
classNumberish awhere
fromNumber ::Integer -&gt;a
toNumber ::a-&gt;Integer
-- pretend newtype is data for now
newtype Age=
AgeInteger
deriving (Eq,Show)
instance Numberish Agewhere
fromNumber n =Agen
toNumber ( Agen)=n</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 306
newtype Year=
YearInteger
deriving (Eq,Show)
instance Numberish Yearwhere
fromNumber n =Yearn
toNumber ( Yearn)=n
Then suppose we write a function using this typeclass and
the two types and instances:
sumNumberish ::Numberish a=&gt;a-&gt;a-&gt;a
sumNumberish a a'=fromNumber summed
whereintegerOfA =toNumber a
integerOfAPrime =toNumber a'
summed=
integerOfA +integerOfAPrime
Now let us think about this for a moment. The class def-
inition of Numberish doesn‚Äôt define any termsor code we can
compile and execute, only types. The code lives in the in-
stances for AgeandYear. So how does Haskell know where to
find code?
Prelude&gt; sumNumberish (Age 10) (Age 10)
Age 20</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 307
In the above, it knew to use the instance of Numberish forAge
because it could see that our arguments to sumNumberish were
of type Age. We can see this with the type inference, too:
Prelude&gt; :t sumNumberish
sumNumberish :: Numberish a =&gt; a -&gt; a -&gt; a
Prelude&gt; :t sumNumberish (Age 10)
sumNumberish (Age 10) :: Age -&gt; Age
After the first parameter is applied to a value of type Age, it
knows that all other occurrences of type Numberish a =&gt; a must
beAge.
To see a case where we‚Äôre notproviding enough information
to Haskell for it to identify a concrete type with which to get
the appropriate instance, we‚Äôre going to change our typeclass
and associated instances:
(This is even worse than the last one. Don‚Äôt use typeclasses
to define default values. Seriously. Haskell ninjas will find you
and replace your toothpaste with muddy chalk.)
classNumberish awhere
fromNumber ::Integer -&gt;a
toNumber ::a-&gt;Integer
defaultNumber ::a</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 308
instance Numberish Agewhere
fromNumber n =Agen
toNumber ( Agen)=n
defaultNumber =Age65
instance Numberish Yearwhere
fromNumber n =Yearn
toNumber ( Yearn)=n
defaultNumber =Year1988
Then in the REPL, we can see that in some cases, there‚Äôs no
way for Haskell to know what we want!
Prelude&gt; defaultNumber
No instance for (Show a0) arising
from a use of ‚Äòprint‚Äô
The type variable ‚Äòa0‚Äô is ambiguous
Note: there are several potential instances:
instance Show a =&gt; Show (Maybe a)
instance Show Ordering
instance Show Integer
...plus 24 others
This fails because it has no idea what type defaultNumber is
other than that it‚Äôs provided for by Numberish ‚Äôs instances. But</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 309
the good news is, even if it‚Äôs a value and doesn‚Äôt take any argu-
ments, we have a means of telling Haskell what we want:
Prelude&gt; defaultNumber :: Age
Age 65
Prelude&gt; defaultNumber :: Year
Year 1988
Just assign the type you expect and it works fine! Here,
Haskell is using the type assertion to dispatch , or specify, what
typeclass instance we want to get our defaultNumber from.
Why not write a typeclass like this? For reasons we‚Äôll explain
when we talk about Monoid , it‚Äôs important that your typeclasses
have laws and rules about how they work. Numberish is a bit...
arbitrary. There are better ways to express what it does in
Haskell than a typeclass. Functions and values alone suffice
here.
6.13 Gimme more operations
We talked about the diÔ¨Äerent kinds of polymorphism in type
signatures ‚Äî constrained versus parametric. Having no con-
straint on our term-level values means they could be any type,
but there isn‚Äôt much we can do with them. The methods and
operations are in the typeclasses, and so we get more utility</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 310
by specifying typeclass constraints. If your types are more
general than your terms are, then you need to constrain your
types with the typeclasses that provide the operations you
want to use. We looked at some examples of this in the sec-
tions above about Integral andFractional , but in this section,
we‚Äôll be more specific about how to modify type signatures to
fit the terms.
We‚Äôll start by looking at some examples of times when we
need to change our types because they‚Äôre more general than
our terms allow:
add::a-&gt;a-&gt;a
addx y=x+y
If you load it up, you‚Äôll get the following error:
No instance for (Num a) arising from a use of ‚Äò+‚Äô
Possible fix:
add (Num a) to the context of
the type signature for add :: a -&gt; a -&gt; a
Fortunately, this is one of those cases where GHC knows
precisely what the problem is and how to remedy it. We need
to add a Numconstraint to the type ùëé. But why? Because our
function can‚Äôt accept a value of strictly anytype. We need
something that has an instance of Numbecause the (+)function
comes from Num:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 311
add::Numa=&gt;a-&gt;a-&gt;a
addx y=x+y
With the constraint added to the type, it works fine! What
if we use a method from another operation?
addWeird ::Numa=&gt;a-&gt;a-&gt;a
addWeird x y=
ifx&gt;1
thenx+y
elsex
We get another error, but once again GHC helps us out, so
long as we resist the pull of tunnel vision5and look at what it‚Äôs
telling us:
Could not deduce (Ord a) arising from a use of ‚Äò&gt;‚Äô
from the context (Num a)
bound by the type signature for
addWeird :: Num a =&gt; a -&gt; a -&gt; a
Possible fix:
add (Ord a) to the context of
the type signature for
addWeird :: Num a =&gt; a -&gt; a -&gt; a
5All programmers experience this. Just slow down and you‚Äôll be okay.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 312
The problem is that having a Numconstraint on our type ùëé
isn‚Äôt enough. Numdoesn‚Äôt imply Ord. Given that, we have to add
another constraint which is what GHC told us to do:
addWeird ::(Orda,Numa)=&gt;a-&gt;a-&gt;a
addWeird x y=
ifx&gt;1
thenx+y
elsex
Now this should typecheck because our constraints are ask-
ing that ùëéhave instances of NumandOrd.
Concrete types imply all the typeclasses they
provide
We‚Äôll be repurposing some examples from earlier in the chap-
ter, modifying them to all have a concrete type in the place of
ùëé:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 313
add::Int-&gt;Int-&gt;Int
addx y=x+y
addWeird ::Int-&gt;Int-&gt;Int
addWeird x y=
ifx&gt;1
thenx+y
elsex
check'::Int-&gt;Int-&gt;Bool
check'a a'=a==a'
These will all typecheck! This is because the Inttype has
the typeclasses Num,Eq, andOrdall implemented. We don‚Äôt need
to sayOrd Int =&gt; Int -&gt; Int -&gt; Int because it doesn‚Äôt add any
information. A concrete type either has a typeclass instance or
it doesn‚Äôt ‚Äî adding the constraint means nothing. A concrete
type always implies the typeclasses that are provided for it.
There are some caveats to keep in mind here when it comes
to using concrete types. One of the nice things about para-
metricity and typeclasses is that you are being explicit about
what you mean to do withyour data which means you are
less likely to make a mistake. Intis a big datatype with many
inhabitants and many typeclasses and operations defined for
it ‚Äî it could be easy to make a function that does something
unintended. Whereas if we were to write a function, even if we</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 314
hadIntvalues in mind for it, which used a polymorphic type
constrained by the typeclass instances we wanted, we could
ensure we only used the operations we intended. This isn‚Äôt a
panacea, but it can be worth avoiding concrete types for these
(and other) reasons sometimes.
6.14 Chapter Exercises
Multiple choice
1.The Eq class
a)includes all types in Haskell
b)is the same as the Ord class
c)makes equality tests possible
d)only includes numeric types
2.The typeclass Ord
a)allows any two values to be compared
b)is a subclass of Eq
c)is a superclass of Eq
d)has no instance for Bool
3.Suppose the typeclass Ord has an operator &gt;. What is the
type of &gt;?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 315
a)Ord a =&gt; a -&gt; a -&gt; Bool
b)Ord a =&gt; Int -&gt; Bool
c)Ord a =&gt; a -&gt; Char
d)Ord a =&gt; Char -&gt; [Char]
4.Inx = divMod 16 12
a)the type of ùë•is Integer
b)the value of ùë•is undecidable
c)the type of ùë•is a tuple
d)ùë•is equal to 12 / 16
5.The typeclass Integral includes
a)Int and Integer numbers
b)integral, real, and fractional numbers
c)Schrodinger‚Äôs cat
d)only positive numbers
Does it typecheck?
For this section of exercises, you‚Äôll be practicing looking for
type and typeclass errors.
For example, printIt will not work because functions like
ùë•have no instance of Show, the typeclass that lets you convert
things to Strings (usually for printing):</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 316
x::Int-&gt;Int
xblah=blah+20
printIt ::IO()
printIt =putStrLn (show x)
Here‚Äôs the type error you get if you try to load the code:
No instance for (Show (Int -&gt; Int)) arising
from a use of ‚Äòshow‚Äô
In the first argument of ‚ÄòputStrLn‚Äô, namely ‚Äò(show x)‚Äô
In the expression: putStrLn (show x)
In an equation for ‚ÄòprintIt‚Äô: printIt = putStrLn (show x)
It‚Äôs saying it can‚Äôt find an implementation of the typeclass
Showfor the type Int -&gt; Int , which makes sense. Nothing with
the function type constructor (-&gt;)has an instance of Show6by
default in Haskell.
Examine the following code and decide whether it will type-
check. Then load it in GHCi and see if you were correct. If
it doesn‚Äôt typecheck, try to match the type error against your
understanding of why it didn‚Äôt work. If you can, fix the error
and re-run the code.
6For an explanation and justification of why functions in Haskell cannot have a
Showinstance, see the wiki page on this topic. https://wiki.haskell.org/Show_instance_for_
functions</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 317
1.Does the following code typecheck? If not, why not?
dataPerson=PersonBool
printPerson ::Person-&gt;IO()
printPerson person=putStrLn (show person)
2.Does the following typecheck? If not, why not?
dataMood=Blah
|Wootderiving Show
settleDown x= ifx==Woot
thenBlah
elsex
3.If you were able to get settleDown to typecheck:
a)What values are acceptable inputs to that function?
b)What will happen if you try to run settleDown 9 ? Why?
c)What will happen if you try to run Blah &gt; Woot ? Why?
4.Does the following typecheck? If not, why not?</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 318
typeSubject =String
typeVerb=String
typeObject=String
dataSentence =
Sentence Subject VerbObject
deriving (Eq,Show)
s1=Sentence &quot;dogs&quot;&quot;drool&quot;
s2=Sentence &quot;Julie&quot; &quot;loves&quot; &quot;dogs&quot;
Given a datatype declaration, what can we do?
Given the following datatype definitions:
dataRocks=
RocksStringderiving (Eq,Show)
dataYeah=
YeahBoolderiving (Eq,Show)
dataPapu=
PapuRocksYeah
deriving (Eq,Show)</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 319
Which of the following will typecheck? For the ones that
don‚Äôt typecheck, why don‚Äôt they?
1.phew=Papu&quot;chases&quot; True
2.truth=Papu(Rocks&quot;chomskydoz&quot; )
(YeahTrue)
3.equalityForall ::Papu-&gt;Papu-&gt;Bool
equalityForall p p'=p==p'
4.comparePapus ::Papu-&gt;Papu-&gt;Bool
comparePapus p p'=p&gt;p'
Match the types
We‚Äôre going to give you two types and their implementations.
Then we‚Äôre going to ask you if you can substitute the second
typeforthefirst. Youcantestthisbytypingthefirstdeclaration
and its type into a file and editing in the new one, loading to
see if it fails. Don‚Äôtguess, test all your answers!
1.For the following definition.
a)i::Numa=&gt;a
i=1
b)Try replacing the type signature with the following:</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 320
i::a
After you‚Äôve formulated your own answer, then tested
that answer and believe you understand why you were
right or wrong, make sure to use GHCi to check what
type GHC infersfor the definitions we provide without
a type assigned. For example, for this one, you‚Äôd type
in:
Prelude&gt; let i = 1
Prelude&gt; :t i
-- Result elided intentionally.
2.a)f::Float
f=1.0
b)f::Numa=&gt;a
3.a)f::Float
f=1.0
b)f::Fractional a=&gt;a
4.Hint for the following: type :info RealFrac in your REPL.
a)f::Float
f=1.0
b)f::RealFrac a=&gt;a</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 321
5.a)freud::a-&gt;a
freudx=x
b)freud::Orda=&gt;a-&gt;a
6.a)freud'::a-&gt;a
freud'x=x
b)freud'::Int-&gt;Int
7.a)myX=1::Int
sigmund ::Int-&gt;Int
sigmund x=myX
b)sigmund ::a-&gt;a
8.a)myX=1::Int
sigmund' ::Int-&gt;Int
sigmund' x=myX
b)sigmund' ::Numa=&gt;a-&gt;a
9.a)You‚Äôll need to import sortfromData.List .
jung::Orda=&gt;[a]-&gt;a
jungxs=head (sort xs)
b)jung::[Int]-&gt;Int
10.a)young::[Char]-&gt;Char
youngxs=head (sort xs)</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 322
b)young::Orda=&gt;[a]-&gt;a
11.a)mySort::[Char]-&gt;[Char]
mySort=sort
signifier ::[Char]-&gt;Char
signifier xs=head (mySort xs)
b)signifier ::Orda=&gt;[a]-&gt;a
Type-Kwon-Do Two: Electric Typealoo
Round Two! Same rules apply ‚Äî you‚Äôre trying to fill in terms
(code) which‚Äôll fit the type. The idea with these exercises is that
you‚Äôll derive the implementation from the type information.
You‚Äôll probably need to use stuÔ¨Ä from Prelude.
1.chk::Eqb=&gt;(a-&gt;b)-&gt;a-&gt;b-&gt;Bool
chk= ???
2.-- Hint: use some arithmetic operation to
-- combine values of type 'b'. Pick one.
arith::Numb
=&gt;(a-&gt;b)
-&gt;Integer
-&gt;a
-&gt;b
arith= ???</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 323
6.15 Chapter Definitions
1.Typeclass inheritance is when a typeclass has a superclass.
This is a way of expressing that a typeclass requires another
typeclass to be available for a given type before you can
write an instance.
classNuma=&gt;Fractional awhere
(/)::a-&gt;a-&gt;a
recip::a-&gt;a
fromRational ::Rational -&gt;a
Here the typeclass Fractional inherits fromNum. We could
also say that Numis asuperclass ofFractional . The long
and short of it is that if you want to write an instance of
Fractional for some ùëé, that type ùëé, must already have an
instance of Numbefore you may do so.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 324
-- Even though in principle
-- this could work, it will fail because
-- Nada doesn't have a Num instance
newtype Nada=
NadaDoublederiving (Eq,Show)
instance Fractional Nadawhere
(Nadax)/(Naday)=Nada(x/y)
recip (Nadan)=Nada(recip n)
fromRational r =Nada(fromRational r)
Then if you try to load it:
No instance for (Num Nada)
arising from the superclasses
of an instance declaration
In the instance declaration for
‚ÄòFractional Nada‚Äô
You need a Numinstance first. Can‚Äôt write one that makes
sense? Then you‚Äôre not allowed to have a Fractional in-
stance either. Them‚Äôs the rules.
2.EÔ¨Äects are how we refer to observable actions programs may
take other than compute a value. If a function modifies</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 325
some state or interacts with the outside world in a manner
that can be observed, then we say it has an eÔ¨Äecton the
world.
3.IOis the type for values whose evaluation bears the possi-
bility of causing side eÔ¨Äects, such as printing text, reading
text input from the user, reading or writing files, or con-
necting to remote computers. This will be explained in
muchmore depth in the chapter on IO.
4.Aninstance is the definition of how a typeclass should
work for a given type. Instances are unique for a given
combination of typeclass and type.
5.In Haskell we have derivedinstances so that obvious or com-
mon typeclasses, such as Eq,Enum,Ord, andShowcan have
the instances generated based only on how the datatype
is defined. This is so programmers can make use of these
conveniences without writing the code themselves, over
and over.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 326
6.16 Typeclass inheritance, partial
This is not a complete chart of typeclass inheritance. It illus-
trates the relationship between a few of the typeclasses we‚Äôve
talked about in this chapter. You can see, for example, that
the subclass Fractional inherits from the superclass Numbut not
vice versa. While many types have instances of ShowandRead,
they aren‚Äôt superclasses, so we‚Äôve left them out of the chart for
clarity.
Figure 6.1: Chart of some typeclasses and their parentage.
Only the typeclasses seen so far are included.
6.17 Follow-up resources
1.P. Wadler and S. Blott. How to make ad-hoc polymor-
phism less ad hoc.</p>
<p>CHAPTER 6. LESS AD-HOC POLYMORPHISM 327
http://www.cse.iitk.ac.in/users/karkare/courses/2010/cs653/
Papers/ad-hoc-polymorphism.pdf
2.Cordelia V. Hall, Kevin Hammond, Simon L. Peyton Jones,
and Philip L. Wadler. Typeclasses in Haskell.
http://ropas.snu.ac.kr/lib/dock/HaHaJoWa1996.pdf</p>
<p>Chapter 7
More functional patterns
I would like to be able to
always‚Ä¶divide the things
up into as many pieces as
I can, each of which I
understand separately. I
would like to understand
the way of adding things
up, independently of
what it is I‚Äôm adding up.
Gerald Sussman
328</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 329
7.1 Make it func-y
You might be asking yourself what this chapter is all about:
haven‚Äôt we been talking about functions all along? We have,
but as you might guess from the fact that Haskell is a functional
programming language, there is more to say ‚Äî so much more!
A function is an instruction for producing an output from
an input, or argument. Functions are applied to arguments
which binds their parameters to values. The fully applied
function with its arguments is then evaluated to produce the
output or result. In this chapter we will demonstrate
‚Ä¢Haskell functions are first-class entities that
‚Ä¢can be values in expressions, lists, or tuples;
‚Ä¢can be passed as arguments to a function;
‚Ä¢can be returned from a function as a result;
‚Ä¢make use of syntactic patterns.
7.2 Arguments and parameters
As you know from our discussion of currying, functions in
Haskell may appear to have multiple parameters but this is
only the surface appearance; in fact, all functions take one
argument and return one result. We construct functions in</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 330
Haskell through various syntactic means of denoting that an
expression takes arguments. Functions are defined by the fact
that they can be applied to an argument and return a result.
All Haskell values can be arguments to functions. A value
that can be used as an argument to a function is a first-class
value. In Haskell, this includes functions, which can be argu-
ments to more functions still. Not all programming languages
allow this, but hopefully the earlier discussion of the function
type and currying have given an idea of how and why this
works.
Setting parameters
You name parameters to functions in Haskell by declaring
them between the name of the function, which is always at
the left margin, and the equals sign, separating the name from
both the function name and the equals sign with white space.
The name is a variable, and when we apply the function to
an argument, the value of the argument is bound, or unified,
with the named parameter in our function definition.
First we‚Äôll define a value with no parameters:
myNum::Integer
myNum=1
myVal=myNum</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 331
If we query the type of myVal:
Prelude&gt; :t myVal
myVal :: Integer
The value myValhas the same type as myNumbecause it is equal
to it. We can see from the type that it‚Äôs a value without any
parameters, so we can‚Äôt apply it to anything.
Now let‚Äôs introduce a parameter named ùëì:
myNum::Integer
myNum=1
myValf=myNum
And let‚Äôs see how that changed the type:
Prelude&gt; :t myVal
myVal :: t -&gt; Integer
Bywriting ùëìaftermyValweparameterized myVal, whichchanges
the type from Integer tot -&gt; Integer . The type ùë°is polymor-
phic because we don‚Äôt do anything with it ‚Äî it could be any-
thing. We didn‚Äôt do anything with ùëìso the maximally poly-
morphic type was inferred. If we do something with ùëì, the
type will change:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 332
Prelude&gt; let myNum = 1 :: Integer
Prelude&gt; let myVal f = f + myNum
Prelude&gt; :t myVal
myVal :: Integer -&gt; Integer
Now it knows ùëìhas to be of type Integer because we added
it tomyNum.
We can tell a simple value from a function in part because
a value is not applied to any arguments, while functions nec-
essarily have parameters that can be applied to arguments.
Although Haskell functions only take one argument per
function, we can declare multiple parameters in a term-level
function definition:
myNum::Numa=&gt;a
myNum=1
-- [1]
myVal::Numa=&gt;a-&gt;a
myValf=f+myNum
-- [2]
stillAFunction ::[a]-&gt;[a]-&gt;[a]-&gt;[a]
stillAFunction a b c=a++b++c
-- [ 3 ]</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 333
1.Declaration of a value of type Num a =&gt; a . We can tell it‚Äôs
not a function because no parameters are named between
the name of the declared value and the =, so it accepts no
arguments, and the value 1 is not a function.
2.Hereùëìis a name for a parameter to the function myVal. It
represents the possibility of being applied to, or bound
to, an input value. The function type is Num a =&gt; a -&gt; a .
If you assign the type Integer tomyNum, as we had above,
myNumandmyValwould have the types Integer andInteger
-&gt; Integer , respectively.
3.Hereùëé,ùëè, andùëêrepresent parameters for the function.
The underlying logic is of nested functions each applied
to one argument, rather than one function taking several
arguments, but this is how it appears at term level.
Notice what happens to the types as we name more param-
eters:
Prelude&gt; let myVal f g = myNum
Prelude&gt; :t myVal
myVal :: t -&gt; t1 -&gt; Integer
Prelude&gt; let myVal f g h = myNum
Prelude&gt; :t myVal
myVal :: t -&gt; t1 -&gt; t2 -&gt; Integer</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 334
Here the types are t,t1, andt2which could be diÔ¨Äerent
types. They are allowed but notrequired to be diÔ¨Äerent types.
They‚Äôre all polymorphic because we gave the type inference
nothing to go on with respect to what type they could be. The
type variables are diÔ¨Äerent because nothing in our code is
preventing them from varying, so they are potentially dif-
ferent types. The inference infers the most polymorphic type
that works.
Binding variables to values
Let‚Äôs consider how the binding of variables works. Applying
a function binds its parameters to values. Type parameters
become bound to a type, and function variables are bound
to a value. The binding of variables concerns not only the
application of function arguments, but also things like let
expressions and whereclauses. Consider the following function:
addOne::Integer -&gt;Integer
addOnex=x+1
We don‚Äôt know the result until the addOne function is applied
to anInteger value argument. When addOne is applied to a
value, we say that ùë•is nowbound to the value the function was
applied to. Until a function‚Äôs arguments have been applied,</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 335
thereby binding the parameters to values, we cannot make use
of the result of the function.
addOne1-- x is now bound to 1
addOne1=1+1
=2
addOne10-- x is bound to 10
addOne10=10+1
=11
In addition to binding variables through function applica-
tion, we can use letexpressions to declare and bind variables
as well:
bindExp ::Integer -&gt;String
bindExp x=
lety=5in
&quot;the integer was: &quot; ++show x
++&quot; and y was: &quot; ++show y
Inshow y ,ùë¶is in scope because the letexpression binds the
variable ùë¶to 5.ùë¶is only in scope insidetheletexpression. Let‚Äôs
see something that won‚Äôt work:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 336
bindExp ::Integer -&gt;String
bindExp x=
letz=y+xin
lety=5in
&quot;the integer was: &quot;
++show x++&quot; and y was: &quot;
++show y++&quot; and z was: &quot;
++show z
You should see an error, ‚ÄúNot in scope: ‚Äòy‚Äô‚Äù. We are trying
to make ùëßequal a value constructed from ùë•andùë¶.ùë•is in
scope because the function argument is visible anywhere in
the function. However, ùë¶is bound in the expression that let z
= ‚Ä¶wraps, so it‚Äôs not in scope yet ‚Äî that is, it‚Äôs not visible to
the main function.
In some cases, function arguments are not visible in the
function if they have been shadowed. Let‚Äôs look at a case of
shadowing :
bindExp ::Integer -&gt;String
bindExp x=
letx=10; y=5in
&quot;the integer was: &quot; ++show x
++&quot; and y was: &quot; ++show y
If you apply this to an argument, you‚Äôll notice the result
never changes:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 337
Prelude&gt; bindExp 9001
&quot;the integer was: 10 and y was: 5&quot;
This is because the reference to ùë•arising from the argument
ùë•was shadowed by the ùë•from the letbinding. The definition
ofùë•that is innermost in the code (where the function name at
the left margin is the outside ) takes precedence because Haskell
islexically scoped . Lexical scoping means that resolving the
value for a named entity depends on the location in the code
and the lexical context, for example in letandwhereclauses.
Among other things, this makes it easier to know what values
referred to by name are and where they come from. Let‚Äôs
annotate the previous example and we‚Äôll see what is meant
here:
bindExp ::Integer -&gt;String
bindExp x= letx=10
-- [1] [2]
y=5
in&quot;x: &quot;++show x
-- [3]
++&quot; y: &quot;++show y
1.The parameter ùë•introduced in the definition of bindExp .
This gets shadowed by the ùë•in[2].</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 338
2.This is a let-binding of ùë•and shadows the definition of ùë•
introduced as an argument at [1].
3.A use of the ùë•bound by [2]. Given Haskell‚Äôs static (lexical)
scoping it will always refer to the ùë•defined as x = 10 in the
letbinding!
You can also see the eÔ¨Äect of shadowing a name in scope in
GHCi using the letstatements you‚Äôve been kicking around all
along:
Prelude&gt; let x = 5
Prelude&gt; let y = x + 5
Prelude&gt; y
10
Prelude&gt; y * 10
100
Prelude&gt; let z y = y * 10
Prelude&gt; x
5
Prelude&gt; y
10
Prelude&gt; z 9
90
-- but
Prelude&gt; z y</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 339
100
Note that while ùë¶is bound in GHCi‚Äôs scope to x + 5, the
introduction of z y = y * 10 creates a new inner scope which
shadowed the nameùë¶. Now, when we call ùëß, GHCi will use the
value we pass as ùë¶to evaluate the expression, not necessarily
the value 10from the letstatement y = x + 5 . Using ùë¶as an ar-
gument to ùëß, as in the last example, means the value of ùë¶from
the outer scope is passed to ùëßas an argument. The lexically
innermost binding for a variable of a particular name always
takes precedence. It does not matter that the ùë¶inùëß‚Äôs parame-
ters has the same name as the ùë¶from earlier in GHCi: ùë¶will
always be bound to the value that ùëßis applied to. (Incidentally,
the seeming-sequentiality of defining things in GHCi is, under
the hood, a never-ending series of nested lambda expressions,
similar to the way functions can seem to accept multiple argu-
ments but are, at root, a series of nested functions).
7.3 Anonymous functions
We have already seen how to write anonymous functions using
the lambda syntax represented by a backslash. Anonymous
means ‚Äúwithout a name‚Äù and that gives us a clue to why we have
this syntax ‚Äî to construct functions and use them without
giving them a name.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 340
Forexample, earlierwelookedatthisnamed, i.e., not anony-
mous, function:
triple::Integer -&gt;Integer
triplex=x<em>3
And here is the same function but with anonymous function
syntax:
(\x-&gt;x</em>3)::Integer -&gt;Integer
You need the parentheses for the type assertion :: Integer
-&gt; Integer to apply to the entire anonymous function and not
just the Num a =&gt; a value 3. You can give this function a name,
making it not anonymous anymore, in GHCi like this:
Prelude&gt; :{
*Main| let trip :: Integer -&gt; Integer
<em>Main| trip = \x -&gt; x</em>3
*Main| :}
Prelude&gt;
Similarly, to apply an anonymous function we‚Äôll often need
to wrap it in parentheses so that our intent is clear:
Prelude&gt; (\x -&gt; x * 3) 5
15
Prelude&gt; \x -&gt; x * 3 1</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 341
Could not deduce (Num (a0 -&gt; a))</p>
<div style="break-before: page; page-break-before: always;"></div><p>arising from the ambiguity check for ‚Äòit‚Äô
from the context
(Num (a1 -&gt; a), Num a1, Num a)
bound by the inferred type for ‚Äòit‚Äô:
(Num (a1 -&gt; a), Num a1, Num a) =&gt; a -&gt; a
at <interactive>:9:1-13
The type variable ‚Äòa0‚Äô is ambiguous
When checking that ‚Äòit‚Äô
has the inferred type ‚Äòforall a a1.
(Num (a1 -&gt; a), Num a1, Num a) =&gt;
a -&gt; a‚Äô
Probable cause:
the inferred type is ambiguous
The type error Could not deduce (Num (a0 -&gt; a)) is because
you can‚Äôt use Num a =&gt; a values as if they were functions. To
the computer, it looks like you‚Äôre trying to use 3 as a function
and apply 3 to 1. Here the itreferred to is 3 1which it thinks
is3applied to 1as if3were a function.1
1In GHCi error messages, itrefers to the last expression you entered.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 342
Exercises: Grab Bag
Note the following exercises are from source code files, not
written for use directly in the REPL. Of course, you can change
them to test directly in the REPL if you prefer.
1.Which (two or more) of the following are equivalent?
a)mThx y z=x<em>y</em>z
b)mThx y=\z-&gt;x<em>y</em>z
c)mThx=\y-&gt;\z-&gt;x<em>y</em>z
d)mTh=\x-&gt;\y-&gt;\z-&gt;x<em>y</em>z
2.The type of mTh(above) is Num a =&gt; a -&gt; a -&gt; a -&gt; a .
Which is the type of mTh 3?
a)Integer -&gt; Integer -&gt; Integer
b)Num a =&gt; a -&gt; a -&gt; a -&gt; a
c)Num a =&gt; a -&gt; a
d)Num a =&gt; a -&gt; a -&gt; a
3.Next, we‚Äôll practice writing anonymous lambda syntax.
For example, one could rewrite:
addOnex=x+1
Into:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 343
addOne=\x-&gt;x+1
Try to make it so it can still be loaded as a top-level def-
inition by GHCi. This will make it easier to validate your
answers.
a)Rewrite the ffunction in the where clause.
addOneIfOdd n= caseodd nof
True-&gt;f n
False-&gt;n
wheref n=n+1
b)Rewrite the following to use anonymous lambda syn-
tax:
addFive x y=(ifx&gt;ythenyelsex)+5
c)Rewrite the following so that it doesn‚Äôt use anony-
mous lambda syntax:
mflipf=\x-&gt;\y-&gt;f y x
The utility of lambda syntax
You‚Äôre going to see this anonymous syntax a lot as we proceed
through the book, but right now it may not seem to be that
useful ‚Äî it‚Äôs just another way to write functions.
You most often use this syntax when you‚Äôre passing a func-
tion in as an argument to a higher-order function (more on
this soon!) and that‚Äôs the only place in your program where</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 344
that particular function will be used. If you‚Äôre never going to
call it, then it doesn‚Äôt need to be given a name.
We won‚Äôt go into a lot of detail about this yet, but named
entities and anonymous entities evaluate a bit diÔ¨Äerently in
Haskell, and that can be one reason to use an anonymous
function in some cases.
7.4 Pattern matching
Pattern matching is an integral and ubiquitous feature of
Haskell ‚Äî so integral and ubiquitous that we‚Äôve been using it
throughout the book without saying anything about it. Once
you start, you can‚Äôt stop.
Pattern matching is a way of matching values against pat-
terns and, where appropriate, binding variables to successful
matches. It is worth noting here that patterns can include things
as diverse as undefined variables, numeric literals, and list syn-
tax. As we will see, pattern matching matches on any and all
data constructors.
Pattern matching allows you to expose data and dispatch
diÔ¨Äerent behaviors based on that data in your function defini-
tions by deconstructing values to expose their inner workings.
There is a reason we describe values as ‚Äúdata constructors ‚Äù, al-
though we haven‚Äôt explored that much yet. Pattern matching
also allows us to write functions that can decide between two
or more possibilities based on which value it matches.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 345
Patterns are matched against values, or data constructors,
nottypes. Matching a pattern may fail, proceeding to the next
available pattern to match or succeed. When a match suc-
ceeds, the variables exposed in the pattern are bound. Pattern
matching proceeds from left to right and outside to inside.
We can pattern match on numbers. In the following exam-
ple, when the Integer argument to the function equals 2, this
returns True, otherwise, False:
isItTwo ::Integer -&gt;Bool
isItTwo 2=True
isItTwo _ =False
You can enter the same function directly into GHCi using
the:{and:}block syntax, enter :}and ‚Äúreturn‚Äù to end the
block.
Prelude&gt; :{
*Main| let isItTwo :: Integer -&gt; Bool
*Main| isItTwo 2 = True
*Main| isItTwo _ = False
*Main| :}
Note the use of the underscore _after the match against the
value2. This is a means of defining a universal pattern that
never fails to match, a sort of ‚Äúanything else‚Äù case.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 346
Prelude&gt; isItTwo 2
True
Prelude&gt; isItTwo 3
False
Handling all the cases
The order of pattern matches matters! The following version
of the function will always return Falsebecause it will match
the ‚Äúanything else‚Äù case first ‚Äî and match it to everything ‚Äî
so nothing will get through that to match with the pattern you
do want to match:
isItTwo ::Integer -&gt;Bool
isItTwo _ =False
isItTwo 2=True
<interactive>:9:33: Warning:
Pattern match(es) are overlapped
In an equation for ‚ÄòisItTwo‚Äô:
isItTwo 2 = ...
Prelude&gt; isItTwo 2
False
Prelude&gt; isItTwo 3
False</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 347
Try to order your patterns from most specific to least spe-
cific, particularly as it concerns the use of _to unconditionally
match any value. Unless you get fancy, you should be able
to trust GHC‚Äôs pattern match overlap warning and should
triple-check your code when it complains.
What happens if we forget to match a case in our pattern?
isItTwo ::Integer -&gt;Bool
isItTwo 2=True
Notice that now our function can only pattern match on the
value 2. This is an incomplete pattern match because it can‚Äôt
match any other data. Incomplete pattern matches applied to
data they don‚Äôt handle will return bottom , a non-value used to
denote that the program cannot return a value or result. This
will throw an exception, which if unhandled, will make your
program fail:
Prelude&gt; isItTwo 2
True
Prelude&gt; isItTwo 3
*** Exception: :50:33-48:
Non-exhaustive patterns
in function isItTwo
We‚Äôre going to get well acquainted with the idea of bottom
in upcoming chapters. For now, it‚Äôs enough to know that this
is what you get when you don‚Äôt handle all the possible data.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 348
Fortunately, there‚Äôs a way to know at compile time when
your pattern matches are non-exhaustive and don‚Äôt handle
every case:
Prelude&gt; :set -Wall
Prelude&gt; :{
*Main| let isItTwo :: Integer -&gt; Bool
*Main| isItTwo 2 = True
*Main| :}
<interactive>:28:5: Warning:
This binding for ‚ÄòisItTwo‚Äô shadows
the existing binding
defined at <interactive>:20:5
<interactive>:28:5: Warning:
Pattern match(es) are non-exhaustive
In an equation for ‚ÄòisItTwo‚Äô:
Patterns not matched:
#x with #x <code>notElem</code> [2#]
By turning on all warnings with -Wall, we‚Äôre now told ahead
of time that we‚Äôve made a mistake. Do notignore the warnings
GHC provides for you!</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 349
Pattern matching against data constructors
Pattern matching serves a couple of purposes. It enables us to
vary what our functions do given diÔ¨Äerent inputs. It also allows
us to unpack and expose the contents of our data. The values
TrueandFalsedon‚Äôt have any other data to expose, but some
data constructors have parameters, and pattern matching can
let us expose and make use of the data in their arguments.
The next example uses newtype which is a special case of data
declarations. newtype is diÔ¨Äerent in that it permits only one
constructor and only one field. We will talk about newtype more
later. For now, we want to focus on how pattern matching can
be used to expose the contents of data and specify behavior
based on that data:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 350
-- registeredUser1.hs
moduleRegisteredUser where
newtype Username =
Username String
newtype AccountNumber =
AccountNumber Integer
dataUser=
UnregisteredUser
|RegisteredUser Username AccountNumber
With the type User, we can use pattern matching to ac-
complish two things. First, Useris a sum with two construc-
tors,UnregisteredUser andRegisteredUser . We can use pattern
matching to dispatch our function diÔ¨Äerently depending on
which value we get. Then with the RegisteredUser construc-
tor we see that it is a product of two newtype s,Username and
AccountNumber . We can use pattern matching to break down
not only RegisteredUser ‚Äôs contents, but also that of the newtype s
if all the constructors are in scope. Let‚Äôs write a function to
pretty-print Uservalues:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 351
-- registeredUser2.hs
moduleRegisteredUser where
newtype Username =
Username String
newtype AccountNumber =
AccountNumber Integer
dataUser=
UnregisteredUser
|RegisteredUser Username AccountNumber
printUser ::User-&gt;IO()
printUser UnregisteredUser =
putStrLn &quot;UnregisteredUser&quot;
printUser (RegisteredUser
(Username name)
(AccountNumber acctNum)) =
putStrLn $name++&quot; &quot;++show acctNum
Note that you can continue the pattern on the next line if it
gets too long. Next, let‚Äôs load this into the REPL and look at
the types:
Prelude&gt; :l code/registeredUser2.hs</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 352
...
Prelude&gt; :t RegisteredUser
RegisteredUser :: Username
-&gt; AccountNumber
-&gt; User
Prelude&gt; :t Username
Username :: String -&gt; Username
Prelude&gt; :t AccountNumber
AccountNumber :: Integer -&gt; AccountNumber
Notice how the type of RegisteredUser is a function that con-
structs a Userout of two arguments: Username andAccountNumber .
This is what we mean when we refer to a value as a ‚Äúdata con-
structor.‚Äù
Now, let‚Äôs use our functions. The argument names are te-
dious to type in, but they were chosen to ensure clarity. Passing
the function an UnregisteredUser returns the expected value:
Prelude&gt; printUser UnregisteredUser
UnregisteredUser
The following, though, asks it to match on data constructor
RegisteredUser and allows us to construct a Userout of the String
‚Äúcallen‚Äù and the Integer 10456:
Prelude&gt; let myUser = Username &quot;callen&quot;
Prelude&gt; let myAcct = AccountNumber 10456</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 353
Prelude&gt; :{
*Main| let rUser =
*Main| RegisteredUser myUser myAcct
*Main| :}
Prelude&gt; printUser rUser
callen 10456
Through the use of pattern matching, we were able to un-
pack the RegisteredUser value of the Usertype and vary behav-
ior over the diÔ¨Äerent constructors of types.
This idea of unpacking and dispatching on data is impor-
tant, so let us examine another example. First, we‚Äôre going to
write a couple of new datatypes. Writing your own datatypes
won‚Äôt be fully explained until a later chapter, but most of the
structure here should be familiar already. We have a sum type
calledWherePenguinsLive :
dataWherePenguinsLive =
Galapagos
|Antarctica
|Australia
|SouthAfrica
|SouthAmerica
deriving (Eq,Show)
And a product type called Penguin . We haven‚Äôt given product
types much attention yet, but for now you can think of Penguin</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 354
as a type with only one value, Peng, and that value is a sort of
box that contains a WherePenguinsLive value:
dataPenguin =
PengWherePenguinsLive
deriving (Eq,Show)
Given these datatypes, we will write a couple functions for
processing the data:
-- is it South Africa? If so, return True
isSouthAfrica ::WherePenguinsLive -&gt;Bool
isSouthAfrica SouthAfrica =True
isSouthAfrica Galapagos =False
isSouthAfrica Antarctica =False
isSouthAfrica Australia =False
isSouthAfrica SouthAmerica =False
But that is redundant. We can use _to indicate an uncondi-
tional match on a value we don‚Äôt care about. The following is
better (more concise, easier to read) and does the same thing:
isSouthAfrica' ::WherePenguinsLive -&gt;Bool
isSouthAfrica' SouthAfrica =True
isSouthAfrica' _ = False
We can also use pattern matching to unpack Penguin values
to get at the WherePenguinsLive value it contains:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 355
gimmeWhereTheyLive ::Penguin
-&gt;WherePenguinsLive
gimmeWhereTheyLive (Pengwhereitlives) =
whereitlives
Try using the gimmeWhereTheyLive function on some test data.
When you enter the name of the penguin (note the lowercase),
it will unpack the Pengvalue to return the WherePenguinsLive
that‚Äôs inside:
humboldt =PengSouthAmerica
gentoo=PengAntarctica
macaroni =PengAntarctica
little=PengAustralia
galapagos =PengGalapagos
Now a more elaborate example. We‚Äôll expose the contents
ofPengand match on what WherePenguinLives value we care
about in one pattern match:
galapagosPenguin ::Penguin -&gt;Bool
galapagosPenguin (PengGalapagos )=True
galapagosPenguin _ = False
antarcticPenguin ::Penguin -&gt;Bool
antarcticPenguin (PengAntarctica )=True
antarcticPenguin _ = False</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 356
In this final function, the (||)operator is an orfunction that
will return Trueif either value is True:
antarcticOrGalapagos ::Penguin -&gt;Bool
antarcticOrGalapagos p=
(galapagosPenguin p)
||(antarcticPenguin p)
Note that we‚Äôre using pattern matching to accomplish two
things here. We‚Äôre using it to unpack the Penguin datatype.
We‚Äôre also specifying which WherePenguinsLive value we want
to match on.
Pattern matching tuples
You can also use pattern matching rather than functions for
operating on the contents of tuples. Remember this example
from Chapter 4?
f::(a, b)-&gt;(c, d)-&gt;((b, d), (a, c))
f=undefined
When you did that exercise, you may have written it like
this:
f::(a, b)-&gt;(c, d)-&gt;((b, d), (a, c))
fx y=((snd x, snd y), (fst x, fst y))</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 357
But we can use pattern matching on tuples to make a some-
what cleaner version of it:
f::(a, b)-&gt;(c, d)-&gt;((b, d), (a, c))
f(a, b) (c, d) =((b, d), (a, c))
One nice thing about this is that the tuple syntax allows the
function to look a great deal like its type. Let‚Äôs look at more
examples of pattern matching on tuples. Note that the second
example below is nota pattern match but the others are:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 358
-- matchingTuples1.hs
moduleTupleFunctions where
-- These have to be the same type because
-- (+) is a -&gt; a -&gt; a
addEmUp2 ::Numa=&gt;(a, a)-&gt;a
addEmUp2 (x, y)=x+y
-- addEmUp2 could also be written like so
addEmUp2Alt ::Numa=&gt;(a, a)-&gt;a
addEmUp2Alt tup=(fst tup) +(snd tup)
fst3::(a, b, c) -&gt;a
fst3(x,<em>,</em>)=x
third3::(a, b, c) -&gt;c
third3(<em>,</em>, x)=x
Prelude&gt; :l code/matchingTuples1.hs
[1 of 1] Compiling TupleFunctions
Ok, modules loaded: TupleFunctions.
Now we‚Äôre going to use GHCi‚Äôs :browse to see a list of the
type signatures and functions we loaded from the module
TupleFunctions :</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 359
Prelude&gt; :browse TupleFunctions
addEmUp2 :: Num a =&gt; (a, a) -&gt; a
addEmUp2Alt :: Num a =&gt; (a, a) -&gt; a
fst3 :: (a, b, c) -&gt; a
third3 :: (a, b, c) -&gt; c
Prelude&gt; addEmUp2 (10, 20)
30
Prelude&gt; addEmUp2Alt (10, 20)
30
Prelude&gt; fst3 (&quot;blah&quot;, 2, [])
&quot;blah&quot;
Prelude&gt; third3 (&quot;blah&quot;, 2, [])
[]
Sweet. Let‚Äôs do some exercises. Pausing to exercise keeps
the muscles flexible, even the mental ones.
Exercises: Variety Pack
1.Given the following declarations
k(x, y)=x
k1=k ((4-1),10)
k2=k (&quot;three&quot;, (1+2))
k3=k (3,True)</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 360
a)What is the type of k?
b)What is the type of k2? Is it the same type as k1ork3?
c)Ofk1, k2, k3 , which will return the number 3 as the
result?
2.Fill in the definition of the following function:
-- Remember: Tuples have the
same syntax for their
-- type constructors and
-- their data constructors.
f::(a, b, c)
-&gt;(d, e, f)
-&gt;((a, d), (c, f))
f=undefined
7.5 Case expressions
Caseexpressionsareaway, similarinsomerespectsto if-then-else ,
of making a function return a diÔ¨Äerent result based on diÔ¨Äer-
ent inputs. You can use case expressions with any datatype that
has visible data constructors. When we consider the datatype
Bool:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 361
dataBool=False|True
-- [1] [2] [3]
1.Type constructor, we only use this in type signatures, not
in term-level code like case expressions.
2.Data constructor for the value of Boolnamed False‚Äî we
can match on this.
3.Data constructor for the value of Boolnamed True‚Äî we
can match on this as well.
Any time we case match or pattern match on a sum type
likeBool, we should define how we handle each constructor
or provide a default that matches all of them. In fact, we must
handle both cases or use a function that handles both or we
will have written a partial function that can throw an error
at runtime. There is rarely a good reason to do this: write
functions that handle all possible inputs!
Let‚Äôs start by looking at an if-then-else expression that we
saw in a previous chapter:
ifx+1==1then&quot;AWESOME&quot; else&quot;wut&quot;
We can rewrite this as a case expression, matching on the
constructors of Bool:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 362
funcZx=
casex+1==1of
True-&gt;&quot;AWESOME&quot;
False-&gt;&quot;wut&quot;
Note that while the syntax is considerably diÔ¨Äerent here,
the results will be the same. Be sure to load it in the REPL and
try it out.
We could also write a case expression to tell us whether or
not something is a palindrome:
palxs=
casexs==reverse xs of
True-&gt;&quot;yes&quot;
False-&gt;&quot;no&quot;
The above can also be written with a whereclause in cases
where you might need to reuse the ùë¶:
pal'xs=
caseyof
True-&gt;&quot;yes&quot;
False-&gt;&quot;no&quot;
wherey=xs==reverse xs
In either case, the function will first check if the input string
is equal to the reverse of it. If that returns True, then the string</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 363
is a palindrome, so your function says, ‚Äúyes.‚Äù If not, then it‚Äôs
not.
Here is one more example, also matching on the data con-
structors from Bool, and you can compare its syntax to the
if-then-else version we‚Äôve seen before:
-- greetIfCool3.hs
moduleGreetIfCool3 where
greetIfCool ::String-&gt;IO()
greetIfCool coolness =
casecoolof
True-&gt;
putStrLn &quot;eyyyyy. What's shakin'?&quot;
False-&gt;
putStrLn &quot;pshhhh.&quot;
wherecool=
coolness ==&quot;downright frosty yo&quot;
So far, the case expressions we‚Äôve looked at rely on a straight-
forward pattern match with TrueandFalseexplicitly. In an
upcoming section, we‚Äôll look at another way to write a case
expression.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 364
Exercises: Case Practice
We‚Äôre going to practice using case expressions by rewriting
functions. Some of these functions you‚Äôve seen in previous
chapters (and some you‚Äôll see later using diÔ¨Äerent syntax yet
again!), but you‚Äôll be writing new versions now. Please note
these are all written as they would be in source code files, and
we recommend you write your answers in source files and
then load into GHCi to check, rather than trying to do them
directly into the REPL.
First, rewrite if-then-else expressions into case expressions.
1.The following should return xwhenxis greater than y.
functionC x y= if(x&gt;y)thenxelsey
2.The following will add 2 to even numbers and otherwise
simply return the input value.
ifEvenAdd2 n= ifeven nthen(n+2)elsen
The next exercise doesn‚Äôt have all the cases covered. See
if you can fix it.
3.The following compares a value, x, to zero and returns an
indicator for whether xis a postive number or negative
number. But what if xis 0? You may need to play with
thecompare function a bit to find what to do.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 365
numsx=
casecompare x 0of
LT-&gt; -1
GT-&gt;1
7.6 Higher-order functions
Higher-order functions (HOFs) are functions that accept func-
tions as arguments. Functions are values ‚Äî why couldn‚Äôt they
be passed around like any other values? This is an important
component of functional programming and gives us a way to
combine functions efficiently.
Let‚Äôs examine a standard higher-order function, flip:
Prelude&gt; :t flip
flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
-- using (-) as our (a -&gt; b -&gt; c)
Prelude&gt; (-) 10 1
9
Prelude&gt; let fSub = flip (-)
Prelude&gt; fSub 10 1
-9
Prelude&gt; fSub 5 10
5</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 366
The first parameter of flipis a function, such as (-), that
itself has two parameters. flipflips the order of the arguments.
We can implement fliplike this, using the variable ùëìto
represent the function (a -&gt; b -&gt; c) :
flip::(a-&gt;b-&gt;c)-&gt;b-&gt;a-&gt;c
flipf x y=f y x
Alternately, it could‚Äôve been written as:
myFlip::(a-&gt;b-&gt;c)-&gt;b-&gt;a-&gt;c
myFlipf=\x y-&gt;f y x
There‚Äôs no diÔ¨Äerence in what flipandmyFlip do: one de-
clares parameters in the function definition, and the other
declares them instead in the anonymous function value being
returned. But what makes flip a higher-order function? Well,
it‚Äôs this:
flip::(a-&gt;b-&gt;c)-&gt;b-&gt;a-&gt;c
[1]
flipf x y=f y x
[2] [3]
1.When we want to express a function argument within a
function type, we must use parentheses to nest it.
2.The argument ùëìis the function a -&gt; b -&gt; c .</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 367
3.We apply ùëìtoùë•andùë¶butflipwill flip the order of ap-
plication and apply ùëìtoùë¶and then ùë•instead of the usual
order.
To better understand how HOFs work syntactically, it‚Äôs
worth remembering how parentheses associate in type signa-
tures.
Let‚Äôs look at the type of the following function:
returnLast ::a-&gt;b-&gt;c-&gt;d-&gt;d
returnLast _ _ _d=d
If we explicitly parenthesize returnLast , it must match the
associativity of -&gt;, which is right-associative. The following
parenthesization works fine. Note that this makes the default
currying explicit:
returnLast' ::a-&gt;(b-&gt;(c-&gt;(d-&gt;d)))
returnLast' _ _ _d=d
However, this will not work. This is not how -&gt;associates:
returnBroke ::(((a-&gt;b)-&gt;c)-&gt;d)-&gt;d
returnBroke _ _ _d=d
If you attempt to load returnBroke , you‚Äôll get a type error.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 368
Couldn't match expected type
‚Äòt0 -&gt; t1 -&gt; t2 -&gt; t2‚Äô
with actual type ‚Äòd‚Äô
‚Äòd‚Äô is a rigid type variable bound by
the type signature for
returnBroke :: (((a -&gt; b) -&gt; c) -&gt; d) -&gt; d
Relevant bindings include
returnBroke :: (((a -&gt; b) -&gt; c) -&gt; d) -&gt; d
The equation(s) for ‚ÄòreturnBroke‚Äô
have four arguments,
but its type ‚Äò(((a -&gt; b) -&gt; c) -&gt; d) -&gt; d‚Äô
has only one
This type error is telling us that the type of returnBroke only
specifies one argument that has the type ((a -&gt; b) -&gt; c) -&gt; d ,
yet our function definition seems to expect fourarguments.
The type signature of returnBroke specifies a single function as
the sole argument to returnBroke .2
Wecanhave a type that is parenthesized in that fashion as
long as we want to do something diÔ¨Äerent than what returnLast
does:
2Fun fact: returnBroke is an impossible function.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 369
returnAfterApply ::(a-&gt;b)-&gt;a-&gt;c-&gt;b
returnAfterApply f a c=f a
What we‚Äôre doing here is parenthesizing to the leftso that
we can refer to a separate function, with its own parameters
and result, as an argument to our top level function. Here the
(a -&gt; b) is theùëìargument we use to produce a value of type ùëè
from a value of type ùëé.
One reason we want HOFs is to manipulate how functions
are applied to arguments. To understand another reason, let‚Äôs
revisit the compare function from the Ordtypeclass:
Prelude&gt; :t compare
compare :: Ord a =&gt; a -&gt; a -&gt; Ordering
Prelude&gt; :info Ordering
data Ordering = LT | EQ | GT
Prelude&gt; compare 10 9
GT
Prelude&gt; compare 9 9
EQ
Prelude&gt; compare 9 10
LT
Now we‚Äôll write a function that makes use of this:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 370
dataEmployee =Coder
|Manager
|Veep
|CEO
deriving (Eq,Ord,Show)
reportBoss ::Employee -&gt;Employee -&gt;IO()
reportBoss e e'=
putStrLn $show e++
&quot; is the boss of &quot; ++
show e'
employeeRank ::Employee
-&gt;Employee
-&gt;IO()
employeeRank e e'=
casecompare e e' of
GT-&gt;reportBoss e e'
-- [ 1 ]
EQ-&gt;putStrLn &quot;Neither employee <br />
\is the boss&quot;
-- [ 2 ]
LT-&gt;(flip reportBoss) e e'
-- [ 3 ]</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 371
Thecasein theemployeeRank function is a case expression.
This function says: case expression
1.In the case of comparing ùëíandùëí‚Ä≤and finding ùëíis greater
thanùëí‚Ä≤, return reportBoss e e' .
2.In the case of finding them equal, return the string ‚ÄúNei-
ther employee is the boss.‚Äù
3.Inthecaseoffinding ùëílessthan ùëí‚Ä≤, flipthefunction reportBoss .
This could also have been written reportBoss e' e .
Thecompare function uses the behavior of the Ordinstance
defined for a given type in order to compare them. In this
case, our data declaration lists them in order from Coderin
the lowest rank and CEOin the top rank, so compare will use that
ordering to evaluate the result of the function.
If we load this up and try it out:
Prelude&gt; employeeRank Veep CEO
CEO is the boss of Veep
That‚Äôs probably true in most companies! Being industrious
programmers, we naturally want to refactor this a bit to be
more flexible ‚Äî notice how we change the type of employeeRank :</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 372
dataEmployee =Coder
|Manager
|Veep
|CEO
deriving (Eq,Ord,Show)
reportBoss ::Employee -&gt;Employee -&gt;IO()
reportBoss e e'=
putStrLn $show e++
&quot; is the boss of &quot; ++
show e'
employeeRank ::(Employee
-&gt;Employee
-&gt;Ordering )
-&gt;Employee
-&gt;Employee
-&gt;IO()
employeeRank f e e'=
casef e e'of
GT-&gt;reportBoss e e'
EQ-&gt;putStrLn &quot;Neither employee <br />
\is the boss&quot;
LT-&gt;(flip reportBoss) e e'</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 373
Now our employeeRank function will accept a function argu-
ment with the type Employee -&gt; Employee -&gt; Ordering , which we
named ùëì, in the place where we had compare before. You‚Äôll no-
tice we have the same case expressions here again. We can get
the same behavior we had last time by passing it compare as the
function argument:
Prelude&gt; employeeRank compare Veep CEO
CEO is the boss of Veep
Prelude&gt; employeeRank compare CEO Veep
CEO is the boss of Veep
But since we‚Äôre clever hackers, we can subvert the hierarchy
with a comparison function that does something a bit diÔ¨Äerent
with the following code:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 374
dataEmployee =Coder
|Manager
|Veep
|CEO
deriving (Eq,Ord,Show)
reportBoss ::Employee -&gt;Employee -&gt;IO()
reportBoss e e'=
putStrLn $show e++
&quot; is the boss of &quot; ++
show e'
codersRuleCEOsDrool ::Employee
-&gt;Employee
-&gt;Ordering
codersRuleCEOsDrool CoderCoder=EQ
codersRuleCEOsDrool Coder_ =GT
codersRuleCEOsDrool _Coder=LT
codersRuleCEOsDrool e e'=
compare e e'
employeeRank ::(Employee
-&gt;Employee
-&gt;Ordering )
-&gt;Employee
-&gt;Employee
-&gt;IO()
employeeRank f e e'=
casef e e'of
GT-&gt;reportBoss e e'
EQ-&gt;putStrLn &quot;Neither employee <br />
\is the boss&quot;
LT-&gt;(flip reportBoss) e e'</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 375
Herewe‚Äôvecreateda newfunction that changesthe behavior
of the normal compare function by pattern matching on our
data constructor, Coder. In a case where Coderis the first value
(and the second value is anything ‚Äî note the underscore used
as a catchall), the result will be GTor greater than. In a case
whereCoderis the second value passed, this function will return
LT, orless than . In any case where Coderis not one of the values,
compare will exhibit its normal behavior. The case expression
in theemployeeRank function is otherwise unchanged.
And here‚Äôs how that works:
Prelude&gt; employeeRank compare Coder CEO
CEO is the boss of Coder
Prelude&gt; let cs = codersRuleCEOsDrool
Prelude&gt; employeeRank cs Coder CEO
Coder is the boss of CEO
Prelude&gt; employeeRank cs CEO Coder
Coder is the boss of CEO
If we use compare as our ùëìargument, then the behavior
is unchanged. If, on the other hand, we use our new func-
tion,codersRuleCEOsDrool as theùëìargument, then the behavior
changes and we unleash anarchy in the cubicle farm.
We were able to rely on the behavior of compare but make
changes in the part we wanted to change. This is the value of
HOFs. They give us the beginnings of a powerful method for
reusing and composing code.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 376
Exercises: Artful Dodgy
Given the following definitions tell us what value results from
further applications. When you‚Äôve written down at least some
of the answers and think you know what‚Äôs what, type the def-
initions into a file and load them in GHCi to test your answers.
-- Types not provided,
-- try filling them in yourself.
dodgyx y=x+y*10
oneIsOne =dodgy1
oneIsTwo =(flip dodgy) 2
1.For example, given the expression dodgy 1 0 , what do you
think will happen if we evaluate it? If you put the def-
initions in a file and load them in GHCi, you can do the
following to see the result.
Prelude&gt; dodgy 1 0
1
Now attempt to determine what the following expressions
reduce to. Do it in your head, verify in your REPL after
you think you have an answer.
2.dodgy 1 1</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 377
3.dodgy 2 2
4.dodgy 1 2
5.dodgy 2 1
6.oneIsOne 1
7.oneIsOne 2
8.oneIsTwo 1
9.oneIsTwo 2
10.oneIsOne 3
11.oneIsTwo 3
7.7 Guards
We have played around with booleans and expressions that
evaluate to their truth value including if-then-else expressions
which rely on boolean evaluation to decide between two out-
comes. In this section, we will look at another syntactic pattern
called guards that relies on truth values to decide between two
or more possible results.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 378
if-then-else
Let‚Äôs begin with a quick review of what we learned about
if-then-else expressions in the Basic Datatypes chapter. Note,
if-then-else isnotguards! This is review, before moving on to
guards themselves. The pattern is this:
if <condition>
then <result if True>
else <result if False>
where the ifcondition is an expression that results in a Bool
value. We saw how this allows us to write functions like this:
Prelude&gt; let x = 0
Prelude&gt; let a = &quot;AWESOME&quot;
Prelude&gt; let w = &quot;wut&quot;
Prelude&gt; if (x + 1 == 1) then a else w
&quot;AWESOME&quot;
The next couple of examples will demonstrate how to use
the multiline block syntax for an ifexpression:
-- alternately
Prelude&gt; let x = 0
Prelude&gt; :{
Prelude| if (x + 1 == 1)
Prelude| then &quot;AWESOME&quot;</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 379
Prelude| else &quot;wut&quot;
Prelude| :}
&quot;AWESOME&quot;
The indentation isn‚Äôt required:
Prelude&gt; let x = 0
Prelude&gt; :{
Prelude| if (x + 1 == 1)
Prelude| then &quot;AWESOME&quot;
Prelude| else &quot;wut&quot;
Prelude| :}
&quot;AWESOME&quot;
In the exercises at the end of Chapter 4, you were asked to
write a function called myAbsthat returns the absolute value of
a real number. You would have implemented that function
with an if-then-else expression similar to the following:
myAbs::Integer -&gt;Integer
myAbsx= ifx&lt;0then(-x)elsex
We‚Äôre going to look at another way to write this using guards.
Writing guard blocks
Guard syntax allows us to write compact functions that allow
for two or more possible outcomes depending on the truth of</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 380
the conditions. Let‚Äôs start by looking at how we would write
myAbswith a guard block instead of with an if-then-else :
myAbs::Integer -&gt;Integer
myAbsx
|x&lt;0=(-x)
|otherwise =x
Notice that each guard has its own equals sign. We didn‚Äôt
put one after the argument in the first line of the function def-
inition because each case needs its own expression to return
if its branch succeeds. Now we‚Äôll enumerate the components
for clarity:
myAbs::Integer -&gt;Integer
myAbs x
-- [1] [2]
|x&lt;0=(-x)
-- [3] [4] [5] [6]
|otherwise =x
-- [7] [8] [9] [10]
1.The name of our function, myAbsstill comes first.
2.There is one parameter named ùë•.
3.Here‚Äôs where it gets diÔ¨Äerent. Rather than an =imme-
diately after the introduction of any parameter(s), we‚Äôre</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 381
starting a new line and using the pipe|to begin a guard
case.
4.This is the expression we‚Äôre using to test to see if this
branch should be evaluated or not. The guard case ex-
pression between the |and=must evaluate to Bool.
5.The=denotes that we‚Äôre declaring what expression to
return should our x &lt; 0beTrue.
6.Then after the =we have the expression (-x)which will
be returned if x &lt; 0.
7.Another new line and a |to begin a new guard case.
8.otherwise is another name for True, used here as a fallback
case in case x &lt; 0wasFalse.
9.Another =to begin declaring the expression to return if
we hit the otherwise case.
10.We kick ùë•back out if it wasn‚Äôt less than 0.
Let‚Äôs see how this evaluates:
Prelude&gt; myAbs (-10)
10
Prelude&gt; myAbs 10
10</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 382
In the first example, when it is passed a negative number
as an argument, it looks at the first guard and sees that (-10)
is indeed less than 0, evaluates that as True, and so returns
the result of (-x), in this case, (-(-10)) or 10. In the second
example, it looks at the first guard, sees that 10 does not meet
that condition, so it is False, and goes to the next guard. The
otherwise is always True, so it returns ùë•, in this case, 10. Guards
always evaluate sequentially, so your guards should be ordered
from the case that is most restrictive to the case that is least
restrictive.
Let‚Äôs look next at a function that will have more than two
possible outcomes, in this case the results of a test of sodium
(Na) levels in the blood. We want a function that looks at the
numbers (the numbers represent mEq/L or milliequivalents
per liter) and tells us if the blood sodium levels are normal or
not:
bloodNa ::Integer -&gt;String
bloodNa x
|x&lt;135=&quot;too low&quot;
|x&gt;145=&quot;too high&quot;
|otherwise =&quot;just right&quot;
We can incorporate diÔ¨Äerent types of expressions into the
guard block, as long as each guard can be evaluated to a Bool
value. For example, the following takes 3 numbers and tells</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 383
you if the triangle whose sides they measure is a right triangle
or not (using the Pythagorean theorem):
-- c is the hypotenuse of
-- the triangle.
isRight ::(Numa,Eqa)
=&gt;a-&gt;a-&gt;a-&gt;String
isRight a b c
|a^2+b^2==c^2=&quot;RIGHT ON&quot;
|otherwise =&quot;not right&quot;
And the following function will take your dog‚Äôs age and tell
you how old your dog is in human years:
dogYrs::Integer -&gt;Integer
dogYrsx
|x&lt;=0=0
|x&lt;=1=x<em>15
|x&lt;=2=x</em>12
|x&lt;=4=x<em>8
|otherwise =x</em>6
Why the diÔ¨Äerent numbers? Because puppies reach matu-
rity much faster than human babies do, so a year-old puppy
isn‚Äôt equivalent to a 6- or 7-year-old child (there is more com-
plexity to this conversion than this function uses, because</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 384
other factors such as the size of the dog play a role as well. You
can certainly experiment with that if you like).
We can also use wheredeclarations within guard blocks. Let‚Äôs
say you gave a test that had 100 questions and you wanted a
simple function for translating the number of questions the
student got right into a letter grade:
avgGrade ::(Fractional a,Orda)
=&gt;a-&gt;Char
avgGrade x
|y&gt;=0.9='A'
|y&gt;=0.8='B'
|y&gt;=0.7='C'
|y&gt;=0.59='D'
|y&lt;0.59='F'
wherey=x/100
No surprises there. Notice the variable ùë¶is introduced, not
as an argument to the named function but in the guard block
and is defined in the whereclause. By defining it there, it is in
scope for all the guards above it. There were 100 problems on
the hypothetical test, so any ùë•we give it will be divided by 100
to return the letter grade.
Also notice we left out the otherwise ; we could have used it
for the final case but chose instead to use less than . That is fine
because in our guards we‚Äôve handled all possible values. It is</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 385
important to note that GHCi cannot always tell you when you
haven‚Äôt accounted for all possible cases, and it can be difficult
to reason about it, so it is wise to use otherwise in your final
guard.
Remember: You can use :set -Wall in GHCi to turn on
warnings, and then it will tell you if you have non-exhaustive
patterns.
Exercises: Guard Duty
1.Itisprobablycleartoyouwhyyouwouldn‚Äôtputan otherwise
in your top-most guard, but try it with avgGrade anyway
and see what happens. It‚Äôll be more clear if you rewrite
it as anotherwise match: | otherwise = 'F' . What happens
now if you pass a 90 as an argument? 75? 60?
2.What happens if you take avgGrade as it is written and
reorder the guards? Does it still typecheck and work the
same? Try moving | y &gt;= 0.7 = 'C' and passing it the
argument 90, which should be an ‚ÄòA.‚Äô Does it return an ‚ÄòA‚Äô?
3.The following function returns
palxs
|xs==reverse xs =True
|otherwise =False
a)xswritten backwards when it‚Äôs True</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 386
b)Truewhenxsis a palindrome
c)Falsewhenxsis a palindrome
d)Falsewhenxsis reversed
4.What types of arguments can paltake?
5.What is the type of the function pal?
6.The following function returns
numbers x
|x&lt;0= -1
|x==0=0
|x&gt;0=1
a)the value of its argument plus or minus 1
b)the negation of its argument
c)an indication of whether its argument is a positive or
negative number or zero
d)binary machine language
7.What types of arguments can numbers take?
8.What is the type of the function numbers ?</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 387
7.8 Function composition
Function composition is a type of higher-order function that
allows us to combine functions such that the result of applying
one function gets passed to the next function as an argument.
It is a very concise style, in keeping with the terse functional
style Haskell is known for. At first, it seems complicated and
difficult to unpack, but once you get the hang of it, it‚Äôs fun!
Let‚Äôs begin by looking at the type signature and what it means:
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
-- [1] [2] [3] [4]
1.is a function from ùëètoùëê, passed as an argument (thus the
parentheses).
2.is a function from ùëétoùëè.
3.is a value of type ùëé, the same as [2]expects as an argument.
4.is a value of type ùëê, the same as [1]returns as a result.
Then with the addition of one set of parentheses:
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
-- [1] [2] [3]
In English:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 388
1.given a function ùëètoùëê
2.given a function ùëétoùëè
3.return a function ùëétoùëê.
The result of (a -&gt; b) is the argument of (b -&gt; c) so this is
how we get from an ùëéargument to a ùëêresult. We‚Äôve stitched
the result of one function into being the argument of another.
Next let‚Äôs start looking at composed functions and how
to read and work with them. The basic syntax of function
composition looks like this:
(f.g) x=f (g x)
This composition operator, (.), takes two functions here,
named ùëìandùëî. Theùëìfunction corresponds to the (b -&gt; c) in
the type signature, while the ùëîfunction corresponds to the
(a -&gt; b) . Theùëîfunction is applied to the (polymorphic) ùë•
argument. The result of that application then passes to the ùëì
function as its argument. The ùëìfunction is in turn applied to
that argument and evaluated to reach the final result.
Let‚Äôs go step by step through this transformation. We can
think of the (.)or composition operator as being a way of
pipelining data through multiple functions. The following
composed functions will first add the values in the list together
and then negate the result of that:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 389
Prelude&gt; negate . sum $ [1, 2, 3, 4, 5]
-15
-- which is evaluated like this
negate . sum $ [1, 2, 3, 4, 5]
-- note: this code works as well
negate (sum [1, 2, 3, 4, 5])
negate (15)
-15
Notice that we did this directly in our REPL, because the
composition operator is already in scope in Prelude . The sum
of the list is 15. That result gets passed to the negate function
and returns a result of (-15).
You may be wondering why we need the $operator. You
might remember way back when we talked about the prece-
dence of various operators that we said that operator has a
lower precedence than an ordinary function call (white space,
usually). Ordinary function application has a precedence of
10 (out of 10). The composition operator has a precedence of
9. If we left white space as our function application, this would
be evaluated like this:
negate . sum [1, 2, 3, 4, 5]
negate . 15</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 390
Because function application has a higher precedence than
the composition operator, that function application would
happen before the two functions composed. We‚Äôd be trying to
pass a numeric value where our composition operator needs a
function. By using the $we signal that application to the argu-
ments should happen afterthe functions are already composed.
We can also parenthesize it instead of using the $operator.
In that case, it looks like this:
Prelude&gt; (negate . sum) [1, 2, 3, 4, 5]
-15
The choice of whether to use parentheses or the dollar sign
isn‚Äôt important; it is a question of style and ease of writing and
reading.
The next example uses two functions, takeandreverse , and
is applied to an argument that is a list of numbers from 1 to 10.
What we expect to happen is that the list will first be reversed
(from 10 to 1) and then the first 5 elements of the new list will
be returned as the result.
Prelude&gt; take 5 . reverse $ [1..10]
[10,9,8,7,6]
Given the next bit of code, how could we rewrite it to use
function composition instead of parentheses?</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 391
Prelude&gt; take 5 (enumFrom 3)
[3,4,5,6,7]
We know that we will have to eliminate the parentheses,
add the composition operator, and add the $operator. It will
then look like this:
Prelude&gt; take 5 . enumFrom $ 3
[3,4,5,6,7]
You may also define it this way, which is more similar to
how composition is written in source files:
Prelude&gt; let f x = take 5 . enumFrom $ x
Prelude&gt; f 3
[3,4,5,6,7]
You may be wondering why bother with this if it simply
does the same thing as nesting functions in parentheses. One
reason is that it is quite easy to compose more than two func-
tions this way.
Thefilter odd function is new for us, but it simply filters the
odd numbers (you can change it to filter even if you wish) out
of the list that enumFrom builds for us. Finally, takewill return
as the result only the number of elements we have specified
as the argument of take. Feel free to experiment with varying
any of the arguments.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 392
Prelude&gt; take 5 . filter odd . enumFrom $ 3
[3,5,7,9,11]
As you compose more functions, you can see that nesting
all the parentheses would become tiresome. This operator
allows us to do away with that. It also allows us to write in an
even more terse style known as ‚Äúpointfree.‚Äù
7.9 Pointfree style
Pointfree refers to a style of composing functions without
specifying their arguments. The ‚Äúpoint‚Äù in ‚Äúpointfree‚Äù refers
to the arguments, not (as it may seem) to the function compo-
sition operator. In some sense, we add ‚Äúpoints‚Äù (the operator)
to be able to drop points (arguments). Quite often, pointfree
code is tidier on the page and easier to read as it helps the
reader focus on the functions rather than the data that is being
shuffled around.
We said above that function composition looks like this:
(f . g) x = f (g x)
As you put more functions together, composition can make
them easier to read. For example, (f. g. h) x can be easier
to read than f (g (h x)) and it also brings the focus to the
functions rather than the arguments. Pointfree is an extension
of that idea but now we drop the argument altogether:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 393
f . g = \x -&gt; f (g x)
f . g . h = \x -&gt; f (g (h x))
To see what this looks like in practice, we‚Äôll start by rewriting
in pointfree style some of the functions we used in the section
above:
Prelude&gt; let f = negate . sum
Prelude&gt; f [1, 2, 3, 4, 5]
-15
Notice that when we define our function ùëìwe don‚Äôt spec-
ify that there will be any arguments. Yet when we apply the
function to an argument, the same thing happens as before.
How would we rewrite:
f::Int-&gt;[Int]-&gt;Int
fz xs=foldr (+) z xs
as a pointfree function?
Prelude&gt; let f = foldr (+)
Prelude&gt; f 0 [1..5]
15
And now because we named the function, it can be reused
with diÔ¨Äerent arguments.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 394
Here is another example of a short pointfree function and
its result. It involves a new use of filter that uses the Bool
operator ==. Look at it carefully and, on paper or in your head,
walk through the evaluation process involved:
Prelude&gt; let f = length . filter (== 'a')
Prelude&gt; f &quot;abracadabra&quot;
5
Next, we‚Äôll look at a set of functions that work together, in a
single module, and rely on both composition and pointfree
style:
-- arith2.hs
moduleArith2where
add::Int-&gt;Int-&gt;Int
addx y=x+y
addPF::Int-&gt;Int-&gt;Int
addPF=(+)
addOne::Int-&gt;Int
addOne=\x-&gt;x+1
addOnePF ::Int-&gt;Int
addOnePF =(+1)</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 395
main::IO()
main= do
print (0::Int)
print (add 10)
print (addOne 0)
print (addOnePF 0)
print ((addOne .addOne) 0)
print ((addOnePF .addOne) 0)
print ((addOne .addOnePF) 0)
print ((addOnePF .addOnePF) 0)
print (negate (addOne 0))
print ((negate .addOne) 0)
print ((addOne .addOne.addOne
.negate.addOne) 0)
Take your time and work through what each function is
doing, whether on paper or in your head. Then load this code
as a source file and run it in GHCi and see if your results were
accurate.
You should now have a good understanding of how you
can use (.)tocompose functions. It‚Äôs important to remember
that the functions in composition are applied from right to
left, like a Pacman munching from the right side, reducing the
expressions as he goes.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 396
7.10 Demonstrating composition
You may recall back in Chapter 3 we mentioned that the func-
tionsprintandputStr seem similar on the surface but behave
diÔ¨Äerently because they have diÔ¨Äerent underlying types. Let‚Äôs
take a closer look at that now.
First,putStrLn andputStr have the same type:
putStr :: String -&gt; IO ()
putStrLn :: String -&gt; IO ()
But the type of printis diÔ¨Äerent:
print :: Show a =&gt; a -&gt; IO ()
They all return a result of IO ()for reasons we discussed
in the previous chapter. But the parameters here are quite
diÔ¨Äerent. The first two take String s as arguments, while print
has a constrained polymorphic parameter, Show a =&gt; a . The
first two work fine if we need to display values that are already
of type String . But how do we display numbers (or other non-
string values)? First we have to convert those numbers to
strings, then we can print the strings.
You may also recall a function from our discussion of the
Showtypeclass called show. Here‚Äôs the type of showagain:
show::Showa=&gt;a-&gt;String</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 397
Fortunately, it was understood that combining putStrLn and
showwould be a common pattern, so the function named print
is the composition of showandputStrLn . We do it this way
because it‚Äôs simpler . The printing function concerns itself only
with printing, while the stringification function concerns itself
only with that.
Here are two ways to implement printwithputStrLn and
show:
print::Showa=&gt;a-&gt;IO()
printa=putStrLn (show a)
-- using the . operator for
-- composing functions.
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
-- we can write print as:
print::Showa=&gt;a-&gt;IO()
printa=(putStrLn .show) a
Now let‚Äôs go step by step through this use of (.),putStrLn ,
andshow:</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 398
(.) ::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
putStrLn ::String-&gt;IO()
-- [1] [2]
show ::Showa=&gt;a-&gt;String
-- [3] [4]
putStrLn .show::Showa=&gt;a-&gt;IO()
-- [5] [6]
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
-- [1] [2] [3] [4] [5] [6]
-- If we replace the variables with
-- the specific types they take on
-- in this application of (.)
(.)::Showa=&gt;(String-&gt;IO())
-&gt;(a-&gt;String)
-&gt;a-&gt;IO()</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 399
(.)::(b -&gt;c)
-- (String -&gt; IO ())
-&gt;(a-&gt;b)
-- (a -&gt; String)
-&gt;a-&gt;c
-- a -&gt; IO ()
1.is the string that putStrLn accepts as an argument.
2.is theIO ()thatputStrLn returns, that is, performing the
side eÔ¨Äect of printing and returning unit.
3.isùëéthat must implement the Showtypeclass; this is the Show
a =&gt; a from the showfunction which is a method on the
Showtypeclass.
4.is the string that showreturns. This is what the Show a =&gt; a
value got stringified into.
5.is theShow a =&gt; a the final composed function expects.
6.is theIO ()the final composed function returns.
We can now make it pointfree. When we are working with
functions primarily in terms of composition rather than appli-
cation, the pointfree version can sometimes (not always) be
more elegant.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 400
Here‚Äôs the previous version of the function:
print::Showa=&gt;a-&gt;IO()
printa=(putStrLn .show) a
And here‚Äôs the pointfree version of print:
print::Showa=&gt;a-&gt;IO()
print=putStrLn .show
The point of printis to compose putStrLn andshowso that
we don‚Äôt have to call showon its argument ourselves. That is,
printis principally about the composition of two functions,
so it comes out nicely as a pointfree function. Saying that
we could apply putStrLn . show to an argument in this case is
redundant.
7.11 Chapter Exercises
Multiple choice
1.A polymorphic function
a)changes things into sheep when invoked
b)has multiple arguments
c)has a concrete type</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 401
d)may resolve to values of diÔ¨Äerent types, depending
on inputs
2.Two functions named fandghave types Char -&gt; String
andString -&gt; [String] respectively. The composed func-
tiong . fhas the type
a)Char -&gt; String
b)Char -&gt; [String]
c)[[String]]
d)Char -&gt; String -&gt; [String]
3.A function fhas the type Ord a =&gt; a -&gt; a -&gt; Bool and we
apply it to one numeric value. What is the type now?
a)Ord a =&gt; a -&gt; Bool
b)Num -&gt; Num -&gt; Bool
c)Ord a =&gt; a -&gt; a -&gt; Integer
d)(Ord a, Num a) =&gt; a -&gt; Bool
4.A function with the type (a -&gt; b) -&gt; c
a)requires values of three diÔ¨Äerent types
b)is a higher-order function
c)must take a tuple as its first argument
d)has its parameters in alphabetical order</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 402
5.Given the following definition of f, what is the type of f
True?
f::a-&gt;a
fx=x
a)f True :: Bool
b)f True :: String
c)f True :: Bool -&gt; Bool
d)f True :: a
Let‚Äôs write code
1.The following function returns the tens digit of an integral
argument.
tensDigit ::Integral a=&gt;a-&gt;a
tensDigit x=d
wherexLast=x <code>div</code> 10
d=xLast <code>mod</code> 10
a)First, rewrite it using divMod .
b)Does the divMod version have the same type as the
original version?
c)Next, let‚Äôs change it so that we‚Äôre getting the hundreds
digit instead. You could start it like this (though that
may not be the only possibility):</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 403
hunsDx=d2
whered=undefined
...
2.Implement the function of the type a -&gt; a -&gt; Bool -&gt; a
once each using a case expression and once with a guard.
foldBool ::a-&gt;a-&gt;Bool-&gt;a
foldBool =
error
&quot;Error: Need to implement foldBool!&quot;
The result is semantically similar to if-then-else expres-
sions but syntactically quite diÔ¨Äerent. Here is the pattern
matching version to get you started:
foldBool3 ::a-&gt;a-&gt;Bool-&gt;a
foldBool3 x_False=x
foldBool3 _yTrue=y
3.Fill in the definition. Note that the first argument to our
function is alsoa function which can be applied to values.
Your second argument is a tuple, which can be used for
pattern matching:
g::(a-&gt;b)-&gt;(a, c)-&gt;(b, c)
g=undefined</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 404
4.For this next exercise, you‚Äôll experiment with writing
pointfree versions of existing code. This involves some
new information, so read the following explanation care-
fully.
Typeclasses are dispatched by type. Readis a typeclass like
Show, but it is the dual or ‚Äúopposite‚Äù of Show. In general, the
Readtypeclass isn‚Äôt something you should plan to use a
lot, but this exercise is structured to teach you something
about the interaction between typeclasses and types.
The function readin theReadtypeclass has the type:
read::Reada=&gt;String-&gt;a
Notice a pattern?
read::Reada=&gt;String-&gt;a
show::Showa=&gt;a-&gt;String
Write the following code into a source file. Then load it
and run it in GHCi to make sure you understand why the
evaluation results in the answers you see.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 405
-- arith4.hs
moduleArith4where
-- id :: a -&gt; a
-- id x = x
roundTrip ::(Showa,Reada)=&gt;a-&gt;a
roundTrip a=read (show a)
main= do
print (roundTrip 4)
print (id 4)
5.Next, write a pointfree version of roundTrip . (n.b., This
refers to the function definition, not to its application in
main.)
6.We will continue to use the code in module Arith4 for this
exercise as well.
When we apply showto a value such as (1 :: Int) , theùëéthat
implements Show is Int, so GHC will use the Int instance
of the Show typeclass to stringify our Int of 1.
However, readexpects a String argument in order to re-
turn an ùëé. TheString argument that is the first argument
toreadtells the function nothing about what type the de-
stringified result should be. In the type signature roundTrip</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 406
currently has, it knows because the type variables are the
same, so the type that is the input to showhas to be the
same type as the output of read.
Your task now is to change the type of roundTrip inArith4 to
(Show a, Read b) =&gt; a -&gt; b . How might we tell GHC which
instance of Readto dispatch against the String now? Make
the expression print (roundTrip 4) work. You will only
need the has the type syntax of ::and parentheses for
scoping.
7.12 Chapter Definitions
1.Binding orbound is a common word used to indicate con-
nection, linkage, or association between two objects. In
Haskell we‚Äôll use it to talk about what value a variable has,
e.g., a parameter variable is bound to an argument value,
meaning the value is passed into the parameter as input
and each occurrence of that named parameter will have
the same value. Bindings as a plurality will usually refer
to a collection of variables and functions which can be
referenced by name.
blah::Int
blah=10
Here the variable blahis bound to the value 10.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 407
2.Ananonymous function is a function which is not bound to
an identifier and is instead passed as an argument to an-
other function and/or used to construct another function.
See the following examples.
\x-&gt;x
-- anonymous version of id
idx=x
-- not anonymous, it's bound to 'id'
3.Currying is the process of transforming a function that
takes multiple arguments into a series of functions which
each take one argument and return one result. This is ac-
complished through the nesting. In Haskell, all functions
are curried by default. You don‚Äôt need to do anything
special yourself.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 408
-- curry and uncurry already
-- exist in Prelude
curry'::((a, b) -&gt;c)-&gt;a-&gt;b-&gt;c
curry'f a b=f (a, b)
uncurry' ::(a-&gt;b-&gt;c)-&gt;((a, b) -&gt;c)
uncurry' f (a, b) =f a b
-- uncurried function,
-- takes a tuple of its arguments
add::(Int,Int)-&gt;Int
add(x, y)=x+y
add'::Int-&gt;Int-&gt;Int
add'=curry' add
A function that appears to take two arguments is two func-
tions that each take one argument and return one result.
What makes this work is that a function can return another
function.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 409
fa b=a+b
-- is equivalent to
f=\a-&gt;(\b-&gt;a+b)
4.Pattern matching is a syntactic way of deconstructing prod-
uct and sum types to get at their inhabitants. With re-
spect to products, pattern matching gives you the means
for destructuring and exposing the contents of products,
binding one or more values contained therein to names.
With sums, pattern matching lets you discriminate which
inhabitant of a sum you mean to handle in that match.
It‚Äôs best to explain pattern matching in terms of how
datatypes work, so we‚Äôre going to use terminology that
you may not fully understand yet. We‚Äôll cover this more
deeply soon.
-- nullary data constructor,
-- not a sum or product.
-- Just a single value.
dataBlah=Blah
Pattern matching on Blahcan only do one thing.
blahFunc ::Blah-&gt;Bool
blahFunc Blah=True</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 410
dataIdentity a=
Identity a
deriving (Eq,Show)
Identity is a unary data constructor. Still not a product,
only contains one value.
-- when you pattern match on Identity
-- you can unpack and expose the 'a'
unpackIdentity ::Identity a-&gt;a
unpackIdentity (Identity x)=x
-- But you can choose to ignore
-- the contents of Identity
ignoreIdentity ::Identity a-&gt;Bool
ignoreIdentity (Identity _)=True
-- or ignore it completely since
-- matching on a non-sum data constructor
-- changes nothing.
ignoreIdentity' ::Identity a-&gt;Bool
ignoreIdentity' _ =True</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 411
dataProduct a b=
Product a b
deriving (Eq,Show)
Now we can choose to use none, one, or both of the values
in the product of ùëéandùëè:
productUnpackOnlyA ::Product a b-&gt;a
productUnpackOnlyA (Product x_)=x
productUnpackOnlyB ::Product a b-&gt;b
productUnpackOnlyB (Product _y)=y
Or we can bind them both to a diÔ¨Äerent name:
productUnpack ::Product a b-&gt;(a, b)
productUnpack (Product x y)=(x, y)
What happens if you try to bind the values in the product
to the same name?
dataSumOfThree a b c=
FirstPossible a
|SecondPossible b
|ThirdPossible c
deriving (Eq,Show)</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 412
Now we can discriminate by the inhabitants of the sum
and choose to do diÔ¨Äerent things based on which con-
structor in the sum they were.
sumToInt ::SumOfThree a b c-&gt;Integer
sumToInt (FirstPossible _)=0
sumToInt (SecondPossible _)=1
sumToInt (ThirdPossible _)=2
-- We can selectively ignore
-- inhabitants of the sum
sumToInt ::SumOfThree a b c-&gt;Integer
sumToInt (FirstPossible _)=0
sumToInt _ = 1
-- We still need to handle
-- every possible value
Pattern matching is about your data.
5.Bottom is a non-value used to denote that the program
cannot return a value or result. The most elemental
manifestation of this is a program that loops infinitely.
Other forms can involve things like writing a function</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 413
that doesn‚Äôt handle all of its inputs and fails on a pattern
match. The following are examples of bottom:
-- If you apply this to any values,
-- it'll recurse indefinitely.
fx=f x
-- It'll a'splode if you pass a False value
dontDoThis ::Bool-&gt;Int
dontDoThis True=1
-- morally equivalent to
definitelyDontDoThis ::Bool-&gt;Int
definitelyDontDoThis True=1
definitelyDontDoThis False=error&quot;oops&quot;
-- don't use error.
-- We'll show you a better way soon.
Bottom can be useful as a canary for signaling when code
paths arebeing evaluated. We usually do this to determine
how lazy a program is or isn‚Äôt. You‚Äôll see a lotof this in
our chapter on non-strictness later on.
6.Higher-orderfunctions are functions which themselves take</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 414
functions as arguments or return functions as results. Due
to currying, technically any function that appears to take
more than one argument is higher order in Haskell.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 415
-- Technically higher order
-- because of currying
Int-&gt;Int-&gt;Int
-- See? Returns another function
-- after applying the first argument
Int-&gt;(Int-&gt;Int)
-- The rest of the following examples are
-- types of higher order functions
(a-&gt;b)-&gt;a-&gt;b
(a-&gt;b)-&gt;[a]-&gt;[b]
(Int-&gt;Bool)-&gt;[Int]-&gt;[Bool]
-- also higher order, this one
-- takes a function argument which itself
-- is higher order as well.
((a-&gt;b)-&gt;c)-&gt;[a]-&gt;[c]
7.Composition is the application of a function to the result
of having applied another function. The composition op-</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 416
erator is a higher-order function as it takes the functions
it composes as arguments and then returns a function of
the composition:
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
-- is
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
-- or
(.)::(b-&gt;c)-&gt;((a-&gt;b)-&gt;(a-&gt;c))
-- can be implemented as
comp::(b-&gt;c)-&gt;((a-&gt;b)-&gt;(a-&gt;c))
compf g x=f (g x)
The function ùëîis applied to ùë•,ùëìis applied to the result of
g x.
8.Pointfree is programming tacitly, or without mentioning
arguments by name. This tends to look like ‚Äúplumby‚Äù
code where you‚Äôre routing data around implicitly or leav-
ing oÔ¨Ä unnecessary arguments thanks to currying. The
‚Äúpoint‚Äù referred to in the term pointfree is an argument.</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 417
-- not pointfree
blahx=x
addAndDrop x y=x+1
reverseMkTuple a b=(b, a)
reverseTuple (a, b)=(b, a)
-- pointfree versions of the above
blah=id
addAndDrop =const.(1+)
reverseMkTuple =flip (,)
reverseTuple =uncurry (flip (,))
To see more examples like this, check out the Haskell Wiki
page on Pointfree at https://wiki.haskell.org/Pointfree .
7.13 Follow-up resources
1.Paul Hudak; John Peterson; Joseph Fasel. A Gentle In-
troduction to Haskell, chapter on case expressions and
pattern matching.
https://www.haskell.org/tutorial/patterns.html
2.Simon Peyton Jones. The Implementation of Functional
Programming Languages, pages 53-103.
http://research.microsoft.com/en-us/um/people/simonpj/papers/
slpj-book-1987/index.htm</p>
<p>CHAPTER 7. MORE FUNCTIONAL PATTERNS 418
3.Christopher Strachey. Fundamental Concepts in Pro-
gramming Languages, page 11 for explanation of curry-
ing.
http://www.cs.cmu.edu/~crary/819-f09/Strachey67.pdf
4.J.N. Oliveira. An introduction to pointfree programming.
http://www.di.uminho.pt/~jno/ps/iscalc_1.ps.gz
5.Manuel Alcino Pereira da Cunha. Point-free Program
Calculation.
http://www4.di.uminho.pt/~mac/Publications/phd.pdf</p>
<p>Chapter 8
Recursion
Imagine a portion of the
territory of England has
been perfectly levelled,
and a cartographer traces
a map of England. The
work is perfect. There is
no particular of the
territory of England,
small as it can be, that has
not been recorded in the
map. Everything has its
own correspondence.
The map, then, must
contain a map of the map,
that must contain a map
of the map of the map,
and so on to infinity.
Jorge Luis Borges, citing
Josiah Royce
419</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 420
8.1 Recursion
Recursion is defining a function in terms of itself via self-
referential expressions. It means that the function will con-
tinue to call itself and repeat its behavior until some condition
is met to return a result. It‚Äôs an important concept in Haskell
and in mathematics because it gives us a means of express-
ingindefinite or incremental computation without forcing us
to explicitly repeat ourselves and allowing the data we are
processing to decide when we are done computing.
Recursion is a natural property of many logical and math-
ematical systems, including human language. That there is
no limit on the number of expressible, valid sentences in hu-
man language is due to recursion. A sentence in English can
have another sentence nested within it. Sentences can be
roughly described as structures which have a noun phrase, a
verb phrase, and optionally another sentence. This possibility
for unlimited nested sentences is recursive and enables the
limitless expressibility therein. Recursion is a means of ex-
pressing code that must take an indefinite number of steps to
return a result.
But the lambda calculus does not appear on the surface
to have any means of recursion, because of the anonymity
of expressions. How do you call something without a name?
Being able to write recursive functions, though, is essential to
Turing completeness. We use a combinator ‚Äî known as the Y</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 421
combinator or fixed-point combinator ‚Äî to write recursive
functions in the lambda calculus. Haskell has native recursion
ability based on the same principle as the Y combinator.
It is important to have a solid understanding of the behavior
of recursive functions. In later chapters, we will see that, in
fact, it is not often necessary to write our own recursive func-
tions, as many standard higher-order functions have built-in
recursion. But without understanding the systematic behav-
ior of recursion itself, it can be difficult to reason about those
HOFs. In this chapter, we will
‚Ä¢explore what recursion is and how recursive functions
evaluate;
‚Ä¢go step-by-step through the process of writing recursive
functions;
‚Ä¢have fun with bottom .
8.2 Factorial!
One of the classic introductory functions for demonstrating
recursion in functional languages is factorial. In arithmetic,
you might‚Äôve seen expressions like 4!. Thebangyou‚Äôre seeing
next to the number 4 is the notation for the factorial function.
Let‚Äôs evaluate 4!:</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 422
4! = 4 * 3 * 2 * 1
12 * 2 * 1
24 * 1
24
4! = 24
Now let‚Äôs do it the silly way in Haskell:
fourFactorial ::Integer
fourFactorial =4<em>3</em>2<em>1
This will return the correct result, but it only covers one
possible result for factorial . This is less than ideal. We want
to express the general idea of the function, not encode specific
inputs and outputs manually.
Now we‚Äôll look at some broken code to introduce the con-
cept of a base case :
-- This won't work. It never stops.
brokenFact1 ::Integer -&gt;Integer
brokenFact1 n=n</em>brokenFact1 (n -1)
Let‚Äôs apply this to 4 and see what happens:</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 423
brokenFact1 4=
4*(4-1)
<em>((4-1)-1)
<em>(((4-1)-1)-1)
...this series never stops
The way we can stop a recursive expression is by having a
base case that stops the self-application to further arguments.
Understanding this is critical for writing functions which are
correct and terminate properly. Here‚Äôs what this looks like for
factorial :
moduleFactorial where
factorial ::Integer -&gt;Integer
factorial 0=1
factorial n=n</em>factorial (n -1)
brokenFact1 4=
4</em>(4-1)
*((4-1)-1)
*(((4-1)-1)-1)
*((((4-1)-1)-1)-1)
*(((((4-1)-1)-1)-1)-1)
...never stops</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 424
But the base case factorial 0 = 1 in the fixed version gives
our function a stopping point, so the reduction changes:
-- Changes to
-- n = n * factorial (n - 1)
factorial 4=
4<em>factorial ( 4-1)
-- evaluate (-) applied to 4 and 1
4</em>factorial 3
-- evaluate factorial applied to 3
-- expands to 3 * factorial (3 - 1)
4<em>3</em>factorial ( 3-1)
-- beta reduce (-) applied to 3 and 1
4<em>3</em>factorial 2
-- evaluate factorial applied to 2
4<em>3</em>2<em>factorial ( 2-1)
-- evaluate (-) applied to 2 and 1
4</em>3<em>2</em>factorial 1
-- evaluate factorial applied to 1
4<em>3</em>2<em>1</em>factorial ( 1-1)</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 425
-- evaluate (-) applied to 1 and 1
-- we know factorial 0 = 1
-- so we evaluate that to 1
4<em>3</em>2<em>1</em>1
-- And when we evaluate
-- our multiplications
24
Making our base case an identity value for the function
(multiplication in this case) means that applying the function
to that case doesn‚Äôt change the result of previous applications.
Another way to look at recursion
In the last chapter, we looked at a higher-order function called
composition. Function composition is a way of tying two (or
more) functions together such that the result of applying the
first function gets passed as an argument to the next function.
This is the same thing recursive functions are doing ‚Äî taking
the result of the first application of the function and passing it
to the next function ‚Äî except in the case of recursive functions,
thefirstresultgetspassedbacktothesamefunctionratherthan
a diÔ¨Äerent one, until it reaches the base case and terminates.</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 426
Where function composition as we normally think of it is
static and definite, recursive compositions are indefinite. The
number of times the function may be applied depends on the
arguments to the function, and the applications can be infinite
if a stopping point is not clearly defined.
Let‚Äôs recall that function composition has the following
type:
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
And when we use it like this:
take5.filter odd .enumFrom $3
we know that the first result will be a list generated by
enumFrom which will be passed to filter odd , giving us a list of
only the odd results, and that list will be passed to take 5 and
our final result will be the first five members of that list. Thus,
results get piped through a series of functions.
Recursion is self-referential composition.1We apply a func-
tion to an argument, then pass that result on as an argument
to a second application of the same function and so on.
Now look again at how the compose function (.)is written:
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
(.) f g=\x-&gt;f (g x)
1Many thanks to George Makrydakis for discussing this with us.</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 427
A programming language, such as Haskell, that is built
purely on lambda calculus has one verb for expressing compu-
tations that can be evaluated: apply. We apply a function to an
argument. Applying a function to an argument and potentially
doing something with the result is all we can do, no matter
what syntactic conveniences we construct to make it seem that
we are doing more than that. While we give function compo-
sition a special name and operator to point up the pattern and
make it convenient to use, it‚Äôs only a way of saying:
‚Ä¢given two functions, ùëìandùëî, as arguments to (.),
‚Ä¢when we get an argument ùë•, applyùëîtoùë•,
‚Ä¢then apply ùëìto the result of (g x); or,
‚Ä¢to rephrase, in code:
(.) f g=\x-&gt;f (g x)
With function recursion, you might notice that it is func-
tion application in the same way that composition is. The
diÔ¨Äerence is that instead of a fixed number of applications,
recursive functions rely on inputs to determine when to stop
applying functions to successive results. Without a specified</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 428
stopping point, the result of (g x)will keep being passed back
toùëîindefinitely.2
Let‚Äôs look at some code to see the similarity in patterns:
inc::Numa=&gt;a-&gt;a
inc=(+1)
three=inc.inc.inc$0
-- different syntax, same thing
three'=(inc.inc.inc)0
Our composition of incbakes the number of applications
into the source code. We don‚Äôt presently have a means of
changing how many times we want it to apply incwithout
writing a new function.
So, we might want to make a general function that can apply
incan indefinite number of times and allow us to specify as
an argument how many times it should be applied:
incTimes ::(Eqa,Numa)=&gt;a-&gt;a-&gt;a
incTimes 0n=
n
incTimes times n =
1+(incTimes (times -1) n)
2Because Haskell is built on pure lambda calculus, recursion is implemented in the
language through the Y, or fixed-point combinator. You can read a very good explanation
of that at http://mvanier.livejournal.com/2897.html if you are interested in knowing how it
works.</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 429
Here,ùë°ùëñùëöùëíùë†is a variable representing the number of times
the incrementing function (not called inchere but written as
1 +in the function body) should be applied to the argument
ùëõ. If we want to apply it zero times, it will return our ùëõto us.
Otherwise, the incrementing function will be applied as many
times as we‚Äôve declared:
Prelude&gt; incTimes 10 0
10
Prelude&gt; incTimes 5 0
5
Prelude&gt; incTimes 5 5
10
--does this look familiar?
In a function such as this, the looming threat of unending
recursion is minimized because the number of times to apply
the function is an argument to the function itself, and we‚Äôve
defined a stopping point: when (times - 1) is equal to zero, it
returns ùëõand that‚Äôs all the applications we get.
We can abstract the recursion out of incTimes , too:</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 430
applyTimes ::(Eqa,Numa)=&gt;
a-&gt;(b-&gt;b)-&gt;b-&gt;b
applyTimes 0f b=b
applyTimes n f b=f (applyTimes (n -1) f b)
incTimes' ::(Eqa,Numa)=&gt;a-&gt;a-&gt;a
incTimes' times n =applyTimes times ( +1) n
When we do, we can make the composition more obvious
inapplyTimes :
applyTimes ::(Eqa,Numa)=&gt;
a-&gt;(b-&gt;b)-&gt;b-&gt;b
applyTimes 0f b=
b
applyTimes n f b=
f.applyTimes (n -1) f$b
We‚Äôre recursively composing our function ùëìwithapplyTimes
(n-1) f however many subtractions it takes to get nto 0!
Intermission: Exercise
Write out the evaluation of the following. It might be a little
less noisy if you do so with the form that didn‚Äôt use (.).
applyTimes 5(+1)5</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 431
8.3 Bottom
‚ä•orbottom is a term used in Haskell to refer to computations
that do not successfully result in a value. The two main vari-
eties of bottom are computations that failed with an error or
those that failed to terminate. In logic, ‚ä•corresponds to false.
Let us examine a few ways by which we can have bottom in
our programs:
Prelude&gt; let x = x in x
*** Exception: &lt;<loop>&gt;
Here GHCi detected that let x = x in x was never going
to return and short-circuited the never-ending computation.
This is an example of bottom because it was never going to
return a result. Note that if you‚Äôre using a Windows com-
puter, this example may freeze your GHCi and not throw an
exception.
Next let‚Äôs define a function that will return an exception:
f::Bool-&gt;Int
fTrue=error&quot;blah&quot;
fFalse=0
And let‚Äôs try that out in GHCi:
Prelude&gt; f False</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 432
0
Prelude&gt; f True
*** Exception: blah
In the first case, when we evaluated f False and got 0, that
didn‚Äôt result in a bottom value. But, when we evaluated f True ,
we got an exception which is a means of expressing that a
computation failed. We got an exception because we specified
that this value should return an error. But this, too, is an
example of bottom.
Another example of a bottom would be a partial function.
Let‚Äôs consider a rewrite of the previous function:
f::Bool-&gt;Int
fFalse=0
This has the same type and returns the same output. What
we‚Äôve done is elided the f True = error &quot;blah&quot; case from the
function definition. This is nota solution to the problem with
the previous function, but it will give us a diÔ¨Äerent exception.
We can observe this for ourselves in GHCi:
Prelude&gt; let f :: Bool -&gt; Int; f False = 0
Prelude&gt; f False
0
Prelude&gt; f True
*** Exception: 6:23-33:</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 433
Non-exhaustive patterns in function f
Theerrorvalue is still there, but our language implemen-
tation is making it the fallback case because we didn‚Äôt write
atotalfunction, that is, a function which handles all of its in-
puts. Because we failed to define ways to handle all potential
inputs, for example through an ‚Äúotherwise‚Äù case, the previous
function was really:
f::Bool-&gt;Int
fFalse=0
f_ =error$&quot;*** Exception: &quot;
++&quot;Non-exhaustive&quot;
++&quot;patterns in function f&quot;
A partial function is one which does not handle all of its
inputs. A total function is one that does. How do we make our
ùëìinto a total function? One way is with the use of the datatype
Maybe.
dataMaybea=Nothing |Justa
TheMaybedatatype can take an argument. In the first case,
Nothing , there is no argument; this is our way to say that there
is no result or data from the function without hitting bottom.
The second case, Just a takes an argument and allows us to
return the data we‚Äôre wanting. Maybemakes all uses of nilvalues</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 434
and most uses of bottom unnecessary. Here‚Äôs how we‚Äôd use it
withùëì:
f::Bool-&gt;MaybeInt
fFalse=Just0
f_ =Nothing
Note that the type and both cases all change. Not only do
we replace the errorwith the Nothing value from Maybe, but we
also have to wrap 0 in the Justconstructor from Maybe. If we
don‚Äôt do so, we‚Äôll get a type error when we try to load the code,
as you can see:
f::Bool-&gt;MaybeInt
fFalse=0
f_ =Nothing
Prelude&gt; :l code/brokenMaybe1.hs
[1 of 1] Compiling Main
code/brokenMaybe1.hs:3:11:
No instance for (Num (Maybe Int))
arising from the literal ‚Äò0‚Äô
In the expression: 0
In an equation for ‚Äòf‚Äô: f False = 0</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 435
This type error is because, as before, 0 has the type Num a
=&gt; a, so it‚Äôs trying to get an instance of NumforMaybe Int . We
can clarify our intent a bit:
f::Bool-&gt;MaybeInt
fFalse=0::Int
f_ =Nothing
And then get a better type error in the bargain:
Prelude&gt; :l code/brokenMaybe2.hs
[1 of 1] Compiling Main
code/brokenMaybe2.hs:3:11:
Couldn't match expected type
‚ÄòMaybe Int‚Äô with actual type ‚ÄòInt‚Äô
In the expression: 0 :: Int
In an equation for ‚Äòf‚Äô: f False = 0 :: Int
We‚Äôll explain Maybein more detail a bit later.
8.4 Fibonacci numbers
Another classic demonstration of recursion in functional pro-
gramming is a function that calculates the ùëõth number in a
Fibonacci sequence. The Fibonacci sequence is a sequence
of numbers in which each number is the sum of the previous</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 436
two: 1, 1, 2, 3, 5, 8, 13, 21, 34... and so on. It‚Äôs an indefinite
computation that relies on adding two of its own members, so
it‚Äôs a perfect candidate for a recursive function. We‚Äôre going to
walk through the steps of how we would write such a function
for ourselves to get a better understanding of the reasoning
process.
1.Consider the types
The first thing we‚Äôll consider is the possible type signature
for our function. The Fibonacci sequence only involves
positive whole numbers. The argument to our Fibonacci
function is going to be a positive whole number, because
we‚Äôre trying to return the value that is the ùëõth member of
the Fibonacci sequence. Our result will also be a positive
whole number, since that‚Äôs what Fibonacci numbers are.
We would be looking, then, for values that are of the Intor
Integer types. We could use one of those concrete types
or use a typeclass for constrained polymorphism. Specif-
ically, we want a type signature that takes one integral
argument and returns one integral result. So, our type
signature will look something like this:
fibonacci ::Integer -&gt;Integer
-- or
fibonacci ::Integral a=&gt;a-&gt;a
2.Consider the base case</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 437
It may sometimes be difficult to determine your base case
up front, but it‚Äôs worth thinking about. For one thing,
you do want to ensure that your function will terminate.
For another thing, giving serious consideration to your
base case is a valuable part of understanding how your
function works. Fibonacci numbers are positive integers,
so a reasonable base case is zero. When the recursive
process hits zero, it should terminate.
The Fibonacci sequence is a bit trickier than some, though,
because it needs two base cases. The sequence has to start
oÔ¨Ä with two numbers, since two numbers are involved in
computing the next. The next number after zero is 1, and
we add zero to 1 to start the sequence so those will be our
base cases:
fibonacci ::Integral a=&gt;a-&gt;a
fibonacci 0=0
fibonacci 1=1
3.Consider the arguments
We‚Äôve already determined that the argument to our func-
tion, the value to which the function is applied, is an inte-
gral number and represents the member of the sequence
we want to be evaluated. That is, we want to pass a value
such as 10 to this function and have it calculate the 10th</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 438
number in the Fibonacci sequence. We only need to have
one variable as a parameter to this function then.
But that argument will also be used as arguments within
the function due to the recursive process. Every Fibonacci
number is the result of adding the preceding two numbers.
So, in addition to a variable ùë•, we will need to use (x - 1)
and(x - 2) to get both the numbers before our argument.
fibonacci ::Integral a=&gt;a-&gt;a
fibonacci 0=0
fibonacci 1=1
fibonacci x=(x-1) (x-2)
-- note: this doesn't work yet.
4.Consider the recursion
All right, now we come to the heart of the matter. In what
way will this function refer to itself and call itself? Look at
what we‚Äôve worked out so far: what needs to happen next
to produce a Fibonacci number? One thing that needs
to happen is that (x - 1) and(x - 2) need to be added
together to produce a result. Try simply adding those two
together and running the function that way.</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 439
fibonacci ::Integral a=&gt;a-&gt;a
fibonacci 0=0
fibonacci 1=1
fibonacci x=(x-1)+(x-2)
If you pass the value 6 to that function, what will happen?
Prelude&gt; fibonacci 6
9
Why? Because ((6 - 1) + (6 - 2)) equals 9. But this isn‚Äôt how
we calculate Fibonacci numbers! The sixth member of the
Fibonacci sequence is not ((6 - 1) + (6 - 2)). What we want is
to add the fifth member of the Fibonacci sequence to the
fourth member. That result will be the sixth member of
the sequence. We do this by making the function refer to
itself. In this case, we have to specify that both (x - 1) and
(x - 2) are themselves Fibonacci numbers, so we have to
call the function to itself twice.
fibonacci ::Integral a=&gt;a-&gt;a
fibonacci 0=0
fibonacci 1=1
fibonacci x=
fibonacci (x -1)+fibonacci (x -2)</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 440
Now, if we apply this function to the value 6, we will get a
diÔ¨Äerent result:
Prelude&gt; fibonacci 6
8
Why? Because it evaluates this recursively:
fibonacci 6=fibonacci 5+fibonacci 4
fibonacci 5=fibonacci 4+fibonacci 3
fibonacci 4=fibonacci 3+fibonacci 2
fibonacci 3=fibonacci 2+fibonacci 1
fibonacci 2=fibonacci 1+fibonacci 0
Zero and 1 have been defined as being equal to zero and</p>
<ol>
<li>So here our recursion stops, and it starts adding the
result:
fibonacci 0 + 0
fibonacci 1 + 1
fibonacci 2 + (1 + 0 =) 1
fibonacci 3 + (1 + 1 =) 2</li>
</ol>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 441
fibonacci 4 + (1 + 2 =) 3
fibonacci 5 = (2 + 3 =) 5
fibonacci 6 = (3 + 5 =) 8
It can be daunting at first to think how you would write a
recursive function and what it means for a function to call
itself. But as you can see, it‚Äôs useful when the function will
make reference to its own results in a repeated fashion.
8.5 Integral division from scratch
Many people learned multiplication by memorizing multi-
plication tables, usually up to 10x10 or 12x12 (dozen). In fact,
one can perform multiplication in terms of addition, repeated
over and over. Similarly, one can define integral division in
terms of subtraction.
Let‚Äôs think through our recursive division function one step
at a time. First, let‚Äôs consider the types we would want to use for
such a function and see if we can construct a reasonable type
signature. When we divide numbers, we have a numerator
and a denominator. When we evaluate 10 / 5 to get the answer
2, 10 is the numerator, 5 the denominator, and 2 the quotient.
So we have at least three numbers here. So, perhaps a type
likeInteger -&gt; Integer -&gt; Integer would be suitable. You could</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 442
even add some type synonyms to make it more obvious if you
wished:
dividedBy ::Integer -&gt;Integer -&gt;Integer
dividedBy =div
-- changes to
typeNumerator =Integer
typeDenominator =Integer
typeQuotient =Integer
dividedBy ::Numerator
-&gt;Denominator
-&gt;Quotient
dividedBy =div
Thetypekeyword, instead of the more familiar dataor
newtype , declares a type synonym, or type alias. Those are all
Integer types, but we can give them diÔ¨Äerent names to make
them easier for human eyes to distinguish in type signatures.
For this example, we didn‚Äôt write out the recursive imple-
mentation of dividedBy we had in mind. As it turns out, when
we write the function, we will want to change the final type sig-
nature a bit, for reasons we‚Äôll see in a minute. Sometimes the</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 443
use of type synonyms can improve the clarity and purpose of
your type signatures, so this is something you‚Äôll see, especially
in more complex code. For our relatively simple function, it
may not be necessary.
Next, let‚Äôs think through our base case. The way we divide in
terms of subtraction is by stopping when our result of having
subtracted repeatedly is lower than the divisor. If it divides
evenly, it‚Äôll stop at 0:
Solve 20 divided by 4
-- [1] [2]
-- [1]: Dividend or numerator
-- [2]: Divisor or denominator
-- Result is quotient
20 divided by 4 == 20 - 4, 16</p>
<ul>
<li>4, 12</li>
<li>4, 8</li>
<li>4, 4</li>
<li>4, 0
-- 0 is less than 4, so we stopped.
-- We subtracted 5 times, so 20 / 4 == 5
Otherwise, we‚Äôll have a remainder. Let‚Äôs look at a case where
it doesn‚Äôt divide evenly:
Solve 25 divided by 4</li>
</ul>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 444
25 divided by 4 == 25 - 4, 21</p>
<ul>
<li>4, 17</li>
<li>4, 13</li>
<li>4, 9</li>
<li>4, 5</li>
<li>4, 1
-- we stop at 1, because it's less than 4
In the case of 25 divided by 4, we subtracted 4 six times and
had 1 as our remainder. We can generalize this process of di-
viding whole numbers, returning the quotient and remainder,
into a recursive function which does the repeated subtraction
and counting for us. Since we‚Äôd like to return the quotient
andthe remainder, we‚Äôre going to return the 2-tuple (,)as the
result of our recursive function.
dividedBy ::Integral a=&gt;a-&gt;a-&gt;(a, a)
dividedBy num denom =go num denom 0
wherego n d count
|n&lt;d=(count, n)
|otherwise =
go (n-d) d (count +1)
We‚Äôve changed the type signature from the one we had
originally worked out, both to make it more polymorphic</li>
</ul>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 445
(Integral a =&gt; a versusInteger ) and also to return the tuple
instead of just an integer.
Here we used a common Haskell idiom called a gofunction.
This allows us to define a function via a where-clause that can
accept more arguments than the top-level function dividedBy
does. In this case, the top-level function takes two arguments,
numanddenom, but we need a third argument in order to keep
trackofhowmanytimeswedothesubtraction. Thatargument
is called countand is defined with a starting value of zero and
is incremented by 1 every time the otherwise case is invoked.
There are two branches in our gofunction. The first case
is the most specific; when the numerator ùëõis less than the
denominator ùëë, the recursion stops and returns a result. It
is not significant that we changed the argument names from
ùëõùë¢ùëöandùëëùëíùëõùëúùëö toùëõandùëë. Thegofunction has already been
applied to those arguments in the definition of dividedBy so
theùëõùë¢ùëö,ùëëùëíùëõùëúùëö , and 0 are bound to ùëõ,ùëë, andùëêùëúùë¢ùëõùë°in thewhere
clause.
The result is a tuple of ùëêùëúùë¢ùëõùë°and the last value for ùëõ. This is
our base case that stops the recursion and gives a final result.
Here‚Äôs an example of how dividedBy expands but with the
code inlined:</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 446
dividedBy 102
-- first we'll do this the previous way,
-- but we'll keep track of how many
-- times we subtracted.
10divided by 2==
10-2,8(subtracted 1time)
-2,6(subtracted 2times)
-2,4(subtracted 3times)
-2,2(subtracted 4times)
-2,0(subtracted 5times)
Since the final number was 0, there‚Äôs no remainder. We
subtracted five times. So 10 / 2 == 5 .
Now we‚Äôll expand the code:
dividedBy 102=
go1020
|10&lt;2= ...
-- false, skip this branch
|otherwise =go (10-2)2(0+1)
-- otherwise is literally the value True
-- so if first branch fails,
-- this always succeeds</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 447
go821
-- 8 isn't &lt; 2, so the otherwise branch
go (8-2)2(1+1)
-- n == 6, d == 2, count == 2
go622
go (6-2)2(2+1)
-- 6 isn't &lt; 2, so the otherwise branch
-- n == 4, d == 2, count == 3
go423
go (4-2)2(3+1)
-- 4 isn't &lt; 2, so the otherwise branch
-- n == 2, d == 2, count == 4
go224
go (2-2)2(4+1)
-- 2 isn't &lt; 2, so the otherwise branch
-- n == 0, d == 2, count == 5</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 448
go025
-- the n &lt; d branch is finally evaluated
-- because 0 &lt; 2 is true
-- n == 0, d == 2, count == 5
|0&lt;2=(5,0)
(5,0)
The result of ùëêùëúùë¢ùëõùë°is the quotient, that is, how many times
you can subtract 2 from 10. In a case where there was a remain-
der, that number would be the final value for your numerator
and would be returned as the remainder.
8.6 Chapter Exercises
Review of types
1.What is the type of [[True, False], [True, True], [False,
True]] ?
a)Bool
b)mostly True
c)[a]
d)[[Bool]]
2.Whichofthefollowinghasthesametypeas [[True, False],
[True, True], [False, True]] ?</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 449
a)[(True, False), (True, True), (False, True)]
b)[[3 == 3], [6 &gt; 5], [3 &lt; 4]]
c)[3 == 3, 6 &gt; 5, 3 &lt; 4]
d)[&quot;Bool&quot;, &quot;more Bool&quot;, &quot;Booly Bool!&quot;]
3.For the following function
func ::[a]-&gt;[a]-&gt;[a]
funcx y=x++y
which of the following is true?
a)xandymust be of the same type
b)xandymust both be lists
c)ifxis aString thenymust be a String
d)all of the above
4.For the funccode above, which is a valid application of
functo both of its arguments?
a)func &quot;Hello World&quot;
b)func &quot;Hello&quot; &quot;World&quot;
c)func [1, 2, 3] &quot;a, b, c&quot;
d)func [&quot;Hello&quot;, &quot;World&quot;]</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 450
Reviewing currying
Given the following definitions, tell us what value results from
further applications.
cattyConny ::String-&gt;String-&gt;String
cattyConny x y=x++&quot; mrow &quot; ++y
-- fill in the types
flippy=flip cattyConny
appedCatty =cattyConny &quot;woops&quot;
frappe=flippy&quot;haha&quot;
1.What is the value of appedCatty &quot;woohoo!&quot; ? Try to deter-
mine the answer for yourself, then test in the REPL.
2.frappe &quot;1&quot;
3.frappe (appedCatty &quot;2&quot;)
4.appedCatty (frappe &quot;blue&quot;)
5.cattyConny (frappe &quot;pink&quot;)
(cattyConny &quot;green&quot; (appedCatty &quot;blue&quot;))
6.cattyConny (flippy &quot;Pugs&quot; &quot;are&quot;) &quot;awesome&quot;</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 451
Recursion
1.Write out the steps for reducing dividedBy 15 2 to its final
answer according to the Haskell code.
2.Write a function that recursively sums all numbers from
1 to n, n being the argument. So that if n was 5, you‚Äôd add
1 + 2 + 3 + 4 + 5 to get 15. The type should be (Eq a, Num a)
=&gt; a -&gt; a .
3.Write a function that multiplies two integral numbers
using recursive summation. The type should be (Integral
a) =&gt; a -&gt; a -&gt; a .
Fixing dividedBy
Our dividedBy function wasn‚Äôt quite ideal. For one thing. It
was a partial function and doesn‚Äôt return a result (bottom)
when given a divisor that is 0 or less.
Using the pre-existing divfunction we can see how negative
numbers should be handled:
Prelude&gt; div 10 2
5
Prelude&gt; div 10 (-2)
-5
Prelude&gt; div (-10) (-2)
5</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 452
Prelude&gt; div (-10) (2)
-5
The next issue is how to handle zero. Zero is undefined for
division in math, so we ought to use a datatype that lets us say
there was no sensible result when the user divides by zero. If
you need inspiration, consider using the following datatype
to handle this.
dataDividedResult =
ResultInteger
|DividedByZero
McCarthy 91 function
We‚Äôre going to describe a function in English, then in math
notation, then show you what your function should return for
some test inputs. Your task is to write the function in Haskell.
The McCarthy 91 function yields ùë•‚àí10 whenùë• &gt; 100 and91
otherwise. The function is recursive.
ùëÄùê∂(ùëõ) =‚éß{
‚é®{‚é©ùëõ‚àí10 ifùëõ &gt;100
ùëÄùê∂(ùëÄùê∂(ùëõ+11)) ifùëõ ‚â§100
mc91=undefined
You haven‚Äôt seen mapyet, but all you need to know right
now is that it applies a function to each member of a list and</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 453
returns the resulting list. It‚Äôll be explained in more detail in
the next chapter.
Prelude&gt; map mc91 [95..110]
[91,91,91,91,91,91,91,92,93,94,95,96,97,98,99,100]
Numbers into words
moduleWordNumber where
importData.List (intersperse )
digitToWord ::Int-&gt;String
digitToWord n=undefined
digits::Int-&gt;[Int]
digitsn=undefined
wordNumber ::Int-&gt;String
wordNumber n=undefined
Hereundefined is a placeholder to show you where you need
to fill in the functions. The nto the right of the function names
is the argument which will be an integer.
Fill in the implementations of the functions above so that
wordNumber returns the English word version of the Int value.</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 454
You will first write a function that turns integers from 0-9 into
their corresponding English words, ‚Äùone,‚Äù ‚Äùtwo,‚Äù and so on.
Then you will write a function that takes the integer, separates
the digits, and returns it as a list of integers. Finally you will
need to apply the first function to the list produced by the sec-
ond function and turn it into a single string with interspersed
hyphens.
We‚Äôve laid out multiple functions for you to consider as you
tackle the problem. You may not need all of them, depend-
ing on how you solve it ‚Äî these are suggestions. Play with
them and look up their documentation to understand them
in deeper detail.
You will probably find this difficult.
div ::Integral a=&gt;a-&gt;a-&gt;a
mod ::Integral a=&gt;a-&gt;a-&gt;a
map ::(a-&gt;b)-&gt;[a]-&gt;[b]
concat ::[[a]]-&gt;[a]
intersperse ::a-&gt;[a]-&gt;[a]
(++) ::[a]-&gt;[a]-&gt;[a]
(:[]) ::a-&gt;[a]
Also consider:
Prelude&gt; div 135 10
13</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 455
Prelude&gt; mod 135 10
5
Prelude&gt; div 13 10
1
Prelude&gt; mod 13 10
3
Here is what your output should look in the REPL when it‚Äôs
working:
Prelude&gt; wordNumber 12324546
&quot;one-two-three-two-four-five-four-six&quot;
Prelude&gt;
8.7 Definitions
1.Recursion is a means of computing results that may require
an indefinite amount of work to obtain through the use of
repeated function application. Most recursive functions
that terminate or otherwise do useful work will often have
a case that calls itself and a base case that acts as a backstop
of sorts for the recursion.</p>
<p>CHAPTER 8. FUNCTIONS THAT CALL THEMSELVES 456
-- not recursive
lessOne ::Int-&gt;Int
lessOne n=n-1
-- recursive
zero::Int-&gt;Int
zero0=0
zeron=zero (n -1)</p>
<p>Chapter 9
Lists
If the doors of perception
were cleansed, everything
would appear to man as it
is - infinite.
William Blake
457</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 458
9.1 Lists
Lists do double duty in Haskell. The first purpose lists serve
is as a way to refer to and process a collection or plurality of
values. The second is as an infinite series of values, usually
generated by a function, which allows them to act as a stream
datatype.
In this chapter, we will:
‚Ä¢explain list‚Äôs datatype and how to pattern match on lists;
‚Ä¢practice many standard library functions for operating
on lists;
‚Ä¢learn about the underlying representations of lists;
‚Ä¢see what that representation means for their evaluation;
‚Ä¢and do a whole bunch of exercises!
9.2 The list datatype
The list datatype in Haskell is defined like this:
data[]a=[]|a:[a]
Here[]is the type constructor for lists as well as the data
constructor for the empty list. The []data constructor is a</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 459
nullary constructor because it takes no arguments. The second
data constructor, in contrast, has arguments. (:)is an infix
operator usually called ‚Äòcons‚Äô (short for construct ). Here cons
takes a value of type ùëéand a list of type [a]and evaluates to
[a].
Whereas the list datatype as a whole is a sum type, as we can
tell from the |in the definition, the second data constructor (:)
<code>cons</code> is aproduct because it takes two arguments. Remember,
a sum type can be read as an ‚Äúor‚Äù as in the Booldatatype where
you get FalseorTrue. A product is like an ‚Äúand.‚Äù We‚Äôre going
to talk more about sum and product types in another chapter,
but for now it will suffice to recognize that a : [a] constructs
a value from two arguments, by adding the ùëéto the front of
the list [a]. The list datatype is a sum type, though, because
it iseitheran empty list ora single value with more list ‚Äî not
both.
In English, one can read this as:
data[]a=[]|a:[a]
-- [1] [2] [3] [4] [5] [6]
1.The datatype with the type constructor []
2.takes a single type constructor argument ‚Äòa‚Äô
3.at the term level can be constructed via
4.nullary constructor []</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 460
5.orit can be constructed by
6.data constructor (:)which is a product of a value of the
typeawe mentioned in the type constructor anda value
of type [a], that is, ‚Äúmore list.‚Äù
The cons constructor (:)is an infix data constructor and
goes between the two arguments ùëéand[a]that it accepts. Since
it takes two arguments, it is a product of those two arguments,
like the tuple type (a, b). Unlike a tuple, however, this con-
structor is recursive because it mentions its own type [a]as
one of the members of the product.
If you‚Äôre an experienced programmer or took a CS class at
some point, you may be familiar with singly-linked lists. This
is a fair description of the list datatype in Haskell, although
average case performance in some situations changes due
to nonstrict evaluation; however, it can contain infinite data
which makes it also work as a stream datatype, but one that has
the option of ending the stream with the []data constructor.
9.3 Pattern matching on lists
We know we can pattern match on data constructors, and the
data constructors for lists are no exceptions. Here we match
on the first argument to the infix (:)constructor, ignoring the
rest of the list, and return that value:</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 461
Prelude&gt; let myHead (x : <em>) = x
Prelude&gt; :t myHead
myHead :: [t] -&gt; t
Prelude&gt; myHead [1, 2, 3]
1
We can do the opposite as well:
Prelude&gt; let myTail (</em> : xs) = xs
Prelude&gt; :t myTail
myTail :: [t] -&gt; [t]
Prelude&gt; myTail [1, 2, 3]
[2,3]
We do need to be careful with functions like these. Neither
myHead normyTail has a case to handle an empty list ‚Äî if we try
to pass them an empty list as an argument, they can‚Äôt pattern
match:
Prelude&gt; myHead []
*** Exception:
Non-exhaustive patterns
in function myHead
Prelude&gt; myTail []
*** Exception:
Non-exhaustive patterns</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 462
in function myTail
The problem is that the type [a] -&gt; a ofmyHead is deceptive
because the [a]type doesn‚Äôt guarantee that it‚Äôll have an ùëévalue.
It‚Äôs not guaranteed that the list will have at least one value, so
myTail can fail as well. One possibility is putting in a base case:
myTail ::[a]-&gt;[a]
myTail[] =[]
myTail(_:xs)=xs
In that case, our function now evaluates like this:
Prelude&gt; myTail [1..5]
[2,3,4,5]
Prelude&gt; myTail []
[]
Using Maybe A better way to handle this situation is with a
datatype called Maybe. We‚Äôll save a full treatment of Maybefor
a later chapter, but this should give you some idea of how it
works. The idea here is that it makes your failure case explicit,
and as programs get longer and more complex that can be
quite useful.
Let‚Äôs try an example using MaybewithmyTail. Instead of
having a base case that returns an empty list, the function</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 463
written with Maybewould return a result of Nothing . As we can
see below, the Maybedatatype has two potential values, Nothing
orJust a :
Prelude&gt; :info Maybe
data Maybe a = Nothing | Just a
Rewriting myTail to useMaybeis fairly straightforward:
safeTail ::[a]-&gt;Maybe[a]
safeTail []=Nothing
safeTail (x:[])=Nothing
safeTail (_:xs)=Justxs
Notice that our function is still pattern matching on the list.
We‚Äôve made the second base case safeTail (x:[]) = Nothing to
reflect the fact that if your list has only one value inside it, its
tail is an empty list. If you leave this case out, then this function
will return Just [] for lists that have only a head value. Take
a few minutes to play around with this and see how it works.
Then see if you can rewrite the myHead function above using
Maybe.
Later in the book, we‚Äôll also cover a datatype called NonEmpty
which always has at least one value and avoids the empty list
problem.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 464
9.4 List‚Äôs syntactic sugar
Haskell has some syntactic sugar to accommodate the use of
lists, so that you can write:
Prelude&gt; [1, 2, 3] ++ [4]
[1, 2, 3, 4]
Rather than:
Prelude&gt; (1 : 2 : 3 : []) ++ 4 : []
[1,2,3,4]
The syntactic sugar is here to allow building lists in terms
of the successive applications of ‚Äòcons‚Äò (:)to a value without
having to tediously type it all out.
When we talk about lists, we often talk about them in terms
of ‚Äúcons cells‚Äù and spines. The syntactic sugar obscures this
underlying construction, but looking at the desugared ver-
sion above may make it more clear. The cons cells are the
list datatype‚Äôs second data constructor, a : [a] , the result of
recursively prepending a value to ‚Äúmore list.‚Äù The cons cell is
aconceptual space that values may inhabit.
The spine is the connective structure that holds the cons
cells together and in place. As we will soon see, this structure
nests the cons cells rather than ordering them in a right-to-
left row. Because diÔ¨Äerent functions may treat the spine and</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 465
the cons cells diÔ¨Äerently, it is important to understand this
underlying structure.
9.5 Using ranges to construct lists
There are several ways we can construct lists. One of the
simplest is with ranges. The basic syntax is to make a list that
has the element you want to start the list from followed by
two dots followed by the value you want as the final element
in the list. Here are some examples using the range syntax,
followed by the desugared equivalents using functions from
theEnumtypeclass:
Prelude&gt; [1..10]
[1,2,3,4,5,6,7,8,9,10]
Prelude&gt; enumFromTo 1 10
[1,2,3,4,5,6,7,8,9,10]
Prelude&gt; [1,2..10]
[1,2,3,4,5,6,7,8,9,10]
Prelude&gt; enumFromThenTo 1 2 10
[1,2,3,4,5,6,7,8,9,10]
Prelude&gt; [1,3..10]
[1,3,5,7,9]
Prelude&gt; enumFromThenTo 1 3 10</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 466
[1,3,5,7,9]
Prelude&gt; [2,4..10]
[2,4,6,8,10]
Prelude&gt; enumFromThenTo 2 4 10
[2,4,6,8,10]
Prelude&gt; ['t'..'z']
&quot;tuvwxyz&quot;
Prelude&gt; enumFromTo 't' 'z'
&quot;tuvwxyz&quot;
The types of the functions underlying the range syntax are:
enumFrom ::Enuma
=&gt;a-&gt;[a]
enumFromThen ::Enuma
=&gt;a-&gt;a-&gt;[a]
enumFromTo ::Enuma
=&gt;a-&gt;a-&gt;[a]
enumFromThenTo ::Enuma
=&gt;a-&gt;a-&gt;a-&gt;[a]
All of these functions require that the type being ‚Äúranged‚Äù
have an instance of the Enumtypeclass. The first two functions,</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 467
enumFrom andenumFromThen , generate lists of indefinite, possibly
infinite, length. For it to create an infinitely long list, you
must be ranging over a type that has no upper bound in its
enumeration. Integer is such a type. You can make Integer
values as large as you have memory to describe.
Be aware that enumFromTo must have its first argument be
lower than the second argument:
Prelude&gt; enumFromTo 3 1
[]
Prelude&gt; enumFromTo 1 3
[1,2,3]
Otherwise you‚Äôll get an empty list.
Exercise: EnumFromTo
Some things you‚Äôll want to know about the Enumtypeclass:
Prelude&gt; :info Enum
class Enum a where
succ :: a -&gt; a
pred :: a -&gt; a
toEnum :: Int -&gt; a
fromEnum :: a -&gt; Int
enumFrom :: a -&gt; [a]
enumFromThen :: a -&gt; a -&gt; [a]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 468
enumFromTo :: a -&gt; a -&gt; [a]
enumFromThenTo :: a -&gt; a -&gt; a -&gt; [a]
Prelude&gt; succ 0
1
Prelude&gt; succ 1
2
Prelude&gt; succ 'a'
'b'
Write your own enumFromTo definitions for the types pro-
vided. Do not use range syntax to do so. It should return the
same results as if you did [start..stop] . Replace the undefined ,
an value which results in an error when evaluated, with your
own definition.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 469
eftBool ::Bool-&gt;Bool-&gt;[Bool]
eftBool =undefined
eftOrd::Ordering
-&gt;Ordering
-&gt;[Ordering ]
eftOrd=undefined
eftInt::Int-&gt;Int-&gt;[Int]
eftInt=undefined
eftChar ::Char-&gt;Char-&gt;[Char]
eftChar =undefined
9.6 Extracting portions of lists
In this section, we‚Äôll take a look at some useful functions for
extracting portions of a list and dividing lists into parts. The
first three functions have similar type signatures, taking Int
arguments and applying them to a list argument:
take::Int-&gt;[a]-&gt;[a]
drop::Int-&gt;[a]-&gt;[a]
splitAt ::Int-&gt;[a]-&gt;([a], [a])</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 470
We have seen examples of some of the above functions in
previous chapters, but they are common and useful enough
they deserve review.
Thetakefunction takes the specified number of elements
out of a list and returns a list containing just those elements.
As you can see it takes one argument that is an Intand applies
that to a list argument. Here‚Äôs how it works:
Prelude&gt; take 7 ['a'..'z']
&quot;abcdefg&quot;
Prelude&gt; take 3 [1..10]
[1,2,3]
Prelude&gt; take 3 []
[]
Notice that when we pass it an empty list as an argument,
it returns an empty list. These lists use the syntactic sugar
for building lists with ranges. We can also use takewith a list-
building function, such as enumFrom . Reminder: enumFrom can
generate an infinite list if the type of list inhabitants is, such
asInteger , an infinite set. But as long as we‚Äôre only taking a
certain number of elements from that, it won‚Äôt generate an
infinite list:
Prelude&gt; take 10 (enumFrom 10)</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 471
[10,11,12,13,14,15,16,17,18,19]
Thedropfunction is similar to takebut drops the specified
number of elements oÔ¨Ä the beginning of the list. Again, we
can use it with ranges or list-building functions:
Prelude&gt; drop 5 [1..10]
[6,7,8,9,10]
Prelude&gt; drop 8 ['a'..'z']
&quot;ijklmnopqrstuvwxyz&quot;
Prelude&gt; drop 4 []
[]
Prelude&gt; drop 2 (enumFromTo 10 20)
[12,13,14,15,16,17,18,19,20]
ThesplitAt function cuts a list into two parts at the element
specified by the Intand makes a tuple of two lists:
Prelude&gt; splitAt 5 [1..10]
([1,2,3,4,5],[6,7,8,9,10])
Prelude&gt; splitAt 10 ['a'..'z']
(&quot;abcdefghij&quot;,&quot;klmnopqrstuvwxyz&quot;)</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 472
Prelude&gt; splitAt 5 []
([],[])
Prelude&gt; splitAt 3 (enumFromTo 5 15)
([5,6,7],[8,9,10,11,12,13,14,15])
The higher-order functions takeWhile anddropWhile are a bit
diÔ¨Äerent, as you can see from the type signatures:
takeWhile ::(a-&gt;Bool)-&gt;[a]-&gt;[a]
dropWhile ::(a-&gt;Bool)-&gt;[a]-&gt;[a]
So these take and drop items out of a list that meet some
condition, as we can see from the presence of Bool.takeWhile
will take elements out of a list that meet that condition and
then stop when it meets the first element that doesn‚Äôt satisfy
the condition:
Take the elements that are less than 3:
Prelude&gt; takeWhile (&lt;3) [1..10]
[1,2]
Take the elements that are less than 8:
Prelude&gt; takeWhile (&lt;8) (enumFromTo 5 15)
[5,6,7]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 473
The next example returns an empty list because it stops
taking as soon as the condition isn‚Äôt met, which in this case is
the first element:
Prelude&gt; takeWhile (&gt;6) [1..10]
[]
In the final example above, why does it only return a single
ùëé?
Prelude&gt; takeWhile (=='a') &quot;abracadabra&quot;
&quot;a&quot;
Now, we‚Äôll look at dropWhile whose behavior is probably
predictable based on the functions and type signatures we‚Äôve
already seen in this section. We will use the same arguments
as we used with takeWhile so the diÔ¨Äerence between them is
easy to see:
Prelude&gt; dropWhile (&lt;3) [1..10]
[3,4,5,6,7,8,9,10]
Prelude&gt; dropWhile (&lt;8) (enumFromTo 5 15)
[8,9,10,11,12,13,14,15]
Prelude&gt; dropWhile (&gt;6) [1..10]
[1,2,3,4,5,6,7,8,9,10]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 474
Prelude&gt; dropWhile (=='a') &quot;abracadabra&quot;
&quot;bracadabra&quot;
Exercises: Thy Fearful Symmetry
1.UsingtakeWhile anddropWhile , write a function that takes a
string and returns a list of strings, using spaces to separate
the elements of the string into words, as in the following
sample:
Prelude&gt; myWords &quot;sheryl wants fun&quot;
[&quot;wallfish&quot;, &quot;wants&quot;, &quot;fun&quot;]
2.Next, write a function that takes a string and returns a list
of strings, using newline separators to break up the string
as in the following (your job is to fill in the undefined
function):</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 475
modulePoemLines where
firstSen =&quot;Tyger Tyger, burning bright \n&quot;
secondSen =&quot;In the forests of the night \n&quot;
thirdSen =&quot;What immortal hand or eye \n&quot;
fourthSen =&quot;Could frame thy fearful <br />
\symmetry?&quot;
sentences =firstSen ++secondSen
++thirdSen ++fourthSen
-- putStrLn sentences -- should print
-- Tyger Tyger, burning bright
-- In the forests of the night
-- What immortal hand or eye
-- Could frame thy fearful symmetry?
-- Implement this
myLines ::String-&gt;[String]
myLines =undefined</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 476
-- What we want 'myLines sentences'
-- to equal
shouldEqual =
[&quot;Tyger Tyger, burning bright&quot;
,&quot;In the forests of the night&quot;
,&quot;What immortal hand or eye&quot;
,&quot;Could frame thy fearful symmetry?&quot;
]
-- The main function here is a small test
-- to ensure you've written your function
-- correctly.
main::IO()
main=
print$
&quot;Are they equal? &quot;
++show (myLines sentences
==shouldEqual)
3.Now let‚Äôs look at what those two functions have in com-
mon. Try writing a new function that parameterizes the
character you‚Äôre breaking the string argument on and
rewrite myWords andmyLines using it.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 477
9.7 List comprehensions
List comprehensions are a means of generating a new list
from a list or lists. They come directly from the concept of
set comprehensions in mathematics, including similar syntax.
They must have at least one list, called the generator, that gives
the input for the comprehension, that is, provides the set of
items from which the new list will be constructed. They may
have conditions to determine which elements are drawn from
the list and/or functions applied to those elements.
Let‚Äôs start by looking at a very simple example:
[ x^2|x&lt;-[1..10]]
-- [1] [2] [ 3 ]
1.This is the output function that will apply to the members
of the list we indicate.
2.The pipe here designates the separation between the out-
put function and the input.
3.This is the input set: a generator list and a variable that
represents the elements that will be drawn from that list.
This says, ‚Äúfrom a list of numbers from 1-10, take (&lt;-)
each element as an input to the output function.‚Äù
In plain English, that list comprehension will produce a
new list that includes the square of every number from 1 to 10:</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 478
Prelude&gt; [x^2 | x &lt;- [1..10]]
[1,4,9,16,25,36,49,64,81,100]
Now we‚Äôll look at some ways to vary what elements are
drawn from the generator list(s).
Adding predicates
List comprehensions can optionally take predicates that limit
the elements drawn from the generator list. The predicates
must evaluate to Boolvalues, as in other condition-placing
function types we‚Äôve looked at (for example, guards). Then the
items drawn from the list and passed to the output function
will only be those that met the Truecase in the predicate.
For example, let‚Äôs say we wanted a similar list comprehen-
sion as we used above, but this time we wanted our new list to
contain the squares of only the even numbers while ignoring
the odds. In that case, we put a comma after our generator list
and add the condition:
Prelude&gt; [x^2 | x &lt;- [1..10], rem x 2 == 0]
[4,16,36,64,100]
Here we‚Äôve specified that the only elements to take from
the generator list as ùë•are those that, when divided by 2, have
a remainder of zero ‚Äî that is, even numbers.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 479
We can also write list comprehensions that have multiple
generators. One thing to note is that the rightmost generator
will be exhausted first, then the second rightmost, and so on.
For example, let‚Äôs say you wanted to make a list of ùë•to
theùë¶power, instead of squaring all of them as we did above.
Separate the two inputs with a comma as below:
Prelude&gt; [x^y | x &lt;- [1..5], y &lt;- [2, 3]]
[1,1,4,8,9,27,16,64,25,125]
When we examine the resulting list, we see that it is each
ùë•value first to the second power and then to the third power,
followed by the next ùë•value to the second and then to the
third and so on, ending with the result of 5^2and5^3. We are
applying the function to each possible pairing of values from
the two lists we‚Äôre binding values out of. It begins by trying
to get a value out of the leftmost generator, from which we‚Äôre
getting ùë•.
We could put a condition on that, too. Let‚Äôs say we only
want to return the list of values that are less than 200. We add
another comma and write our predicate:
Prelude&gt; :{
Prelude| [x ^ y |
Prelude| x &lt;- [1..10],
Prelude| y &lt;- [2, 3],
Prelude| x ^ y &lt; 200]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 480
Prelude| :}
[1,1,4,8,9,27,16,64,25,125,36,49,64,81,100]
We can use multiple generators to turn two lists into a list
of tuples containing those elements as well. The generator
lists don‚Äôt even have to be of the same length or, due to the
nature of the tuple type, even the same type:
Prelude&gt; :{
Prelude| [(x, y) |
Prelude| x &lt;- [1, 2, 3],
Prelude| y &lt;- [6, 7]]
Prelude| :}
[(1,6),(1,7),(2,6),(2,7),(3,6),(3,7)]
Prelude&gt; :{
Prelude| [(x, y) |
Prelude| x &lt;- [1, 2, 3],
Prelude| y &lt;- ['a', 'b']]
Prelude| :}
[(1,'a'),(1,'b'),(2,'a'),
(2,'b'),(3,'a'),(3,'b')]
Again the pattern is that it generates every possible tuple
for the first ùë•value, then it moves to the next ùë•value and so
on.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 481
Recall that the first list comprehension we looked at gen-
erated a list of all the values of ùë•^2whenùë•is a number from
1-10. Let‚Äôs say you wanted to use that list in another list com-
prehension. First, you‚Äôd want to give that list a name. Let‚Äôs call
itmySqr:
Prelude&gt; let mySqr = [x^2 | x &lt;- [1..10]]
Now we can use that list as the generator for another list
comprehension. Here, we will limit our input values to those
that are less than 4 for the sake of brevity:
Prelude&gt; let mySqr = [x^2 | x &lt;- [1..10]]
Prelude&gt; :{
Prelude| [(x, y) |
Prelude| x &lt;- mySqr,
Prelude| y &lt;- [1..3], x &lt; 4]
Prelude| :}
[(1,1),(1,2),(1,3)]
Exercises: Comprehend Thy Lists
Take a look at the following functions, figure what you think
the output lists will be, and then run them in your REPL to
verify (note that you will need the mySqrlist from above in
scope to do this):
[x | x &lt;- mySqr, rem x 2 == 0]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 482
[(x, y) | x &lt;- mySqr,
y &lt;- mySqr,
x &lt; 50, y &gt; 50]
take 5 [ (x, y) | x &lt;- mySqr,
y &lt;- mySqr,
x &lt; 50, y &gt; 50 ]
List comprehensions with Strings
It‚Äôs worth remembering that strings are lists, so list comprehen-
sions can also be used with strings. We‚Äôre going to introduce
a standard function called elem1that tells you whether an el-
ement is in a list or not. It evaluates to a Boolvalue, so it is
useful as a predicate in list comprehensions:
Prelude&gt; :t elem
elem :: Eq a =&gt; a -&gt; [a] -&gt; Bool
Prelude&gt; elem 'a' &quot;abracadabra&quot;
True
Prelude&gt; elem 'a' &quot;Julie&quot;
False
In the first case, ‚Äòa‚Äô is an element of ‚Äúabracadabra‚Äù so that
evaluates to True, but in the second case, there is no ‚Äòa‚Äô in
1Reminder, pretend Foldable in the type of elemmeans it‚Äôs a list until we cover Foldable
later.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 483
‚ÄúJulie‚Äù so we get a Falseresult. As you can see from the type
signature, elemdoesn‚Äôt only work with characters and strings,
but that‚Äôs what we‚Äôll use it for here. Let‚Äôs see if we can write a
list comprehension to remove all the lowercase letters from
a string. Here our condition is that we only want to take ùë•
from our generator list when it meets the condition that it is
an element of the list of capital letters:
Prelude&gt; :{
Prelude| [x |
Prelude| x &lt;- &quot;Three Letter Acronym&quot;,
Prelude| elem x ['A'..'Z']]
Prelude| :}
&quot;TLA&quot;
Let‚Äôs see if we can now generalize this into an acronym
generator that will accept diÔ¨Äerent strings as inputs, instead of
forcing us to rewrite the whole list comprehension for every
string we might want to feed it. We will do this by naming
a function that will take one argument and use that as the
generator string for our list comprehension. So the function
argument and the generator string will need to be the same
thing:
Prelude&gt; :{
Prelude| let acro xs =
Prelude| [x | x &lt;- xs,</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 484
Prelude| elem x ['A'..'Z']]
Prelude| :}
We useùë•ùë†for our function argument to indicate to ourselves
that it‚Äôs a list, that the ùë•is plural. It doesn‚Äôt have to be; you
could use a diÔ¨Äerent variable there and obtain the same result.
It is idiomatic to use a ‚Äúplural‚Äù variable for list arguments, but
it is not necessary.
All right, so we have our acrofunction with which we can
generate acronyms from any string:
Prelude&gt; acro &quot;Self Contained Underwater Breathing Apparatus&quot;
&quot;SCUBA&quot;
Prelude&gt; acro &quot;National Aeronautics and Space Administration&quot;
&quot;NASA&quot;
Given the above, what do you think this function would do:
Prelude&gt; let myString xs = [x | x &lt;- xs, elem x &quot;aeiou&quot;]
Exercises: Square Cube
Given the following:
Prelude&gt; let mySqr = [x^2 | x &lt;- [1..5]]
Prelude&gt; let myCube = [y^3 | y &lt;- [1..5]]
1.First write an expression that will make tuples of the out-
puts of mySqrandmyCube .</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 485
2.Now alter that expression so that it only uses the x and y
values that are less than 50.
3.Apply another function to that list comprehension to
determine how many tuples inhabit your output list.
9.8 Spines and nonstrict evaluation
As we have seen, lists are a recursive series of cons cells a : [a]
terminated by the empty list [], but we want a way to visu-
alize this structure in order to understand the ways lists get
processed. When we talk about data structures in Haskell, par-
ticularly lists, sequences, and trees, we talk about them having
aspine. This is the connective structure that ties the collection
of values together. In the case of a list, the spine is usually tex-
tually represented by the recursive cons (:)operators. Given
the data: [1, 2, 3] , we get a list that looks like:
1 : 2 : 3 : []
or
1 : (2 : (3 : []))
:
/ <br />
1 :
/ </p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 486
2 :
/ <br />
3 []
The problem with the 1 : (2 : (3 : [])) representation we
used earlier is that it makes it seem like the value 1 exists
‚Äúbefore‚Äù the cons (:)cell that contains it, but actually, the cons
cells contain the values. Because of this and the way nonstrict
evaluation works, you can evaluate cons cells independently
of what they contain. It is possible to evaluate only the spine of
the list without evaluating individual values. It is also possible
to evaluate only part of the spine of a list and not the rest of it.
Evaluation of the list in this representation proceeds down
the spine. However, constructing the list (when that is neces-
sary) proceeds upthe spine. In the example above, then, we
start with an infix operator, evaluate the arguments 1 and a
new cons cell, and proceed downward to the 3 and empty list.
But when we need to build the list, to print it in the REPL for
example, it proceeds from the bottom of the list up the spine,
first putting the 3 into the empty list, then adding the 2 to
the front of that list, then, finally, putting the 1 in the front of
that. Because Haskell‚Äôs evaluation is nonstrict, the list isn‚Äôt con-
structed until it‚Äôs consumed ‚Äî indeed, nothing is evaluated
until it must be. Until it‚Äôs consumed or you force strictness
in some way, there are a series of placeholders as a blueprint</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 487
of the list that can be constructed when it‚Äôs needed. We‚Äôll talk
more about nonstrictness soon.
We‚Äôregoingtobring ‚ä•orbottom backintheformof undefined
in order to demonstrate some of the eÔ¨Äects of nonstrict evalu-
ation. Here we‚Äôre going to use _to syntactically signify values
we are ignoring and not evaluating. The underscores repre-
sent the values contained by the cons cells. The spine is the
recursive series of cons constructors signified by (:)as you
can see below:
: &lt;------|
/ \ |
_ : &lt;----| This is the &quot;spine&quot;
/ \ |
_ : &lt;--|
/ <br />
_ []
You‚Äôll see the term ‚Äòspine‚Äô used in reference to data struc-
tures, such as trees, that aren‚Äôt lists. In the case of a list, the
spine is a linear succession of one cons cell wrapping another
cons cell. With data structures like trees, which we will cover
later, you‚Äôll see that the spine can be nodes that contain 2 or
more nodes.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 488
Using GHCi‚Äôs :sprint command
We can use a special command in GHCi called sprint to print
variables and see what has been evaluated already, with the un-
derscore representing expressions that haven‚Äôt been evaluated
yet.
A warning : We always encourage you to experiment and
explore for yourself after seeing the examples in this book, but
:sprint has some behavioral quirks that can be a bit frustrating.
GHC Haskell has some opportunistic optimizations which
introduce strictness to make code faster when it won‚Äôt change
how your code evaluates. Additionally polymorphism means
values like Num a =&gt; a are really waiting for a sort of argument
which will make it concrete (this will be covered in more detail
in a later chapter). To avoid this, you have to assign a more
concrete type such as IntorDouble, otherwise it stays uneval-
uated,_, in:sprint ‚Äôs output. If you can keep these caveats to
:sprint ‚Äôs behavior in mind, it can be useful. Otherwise if you
find it confusing, don‚Äôt sweat it and wait for us to elaborate
more deeply in the chapter on nonstrictness.
Let‚Äôs define a list using enumFromTo , which is tantamount to
using syntax like ['a'..'z'] , then ask for the state of blahwith
respect to whether it has been evaluated:
Prelude&gt; let blah = enumFromTo 'a' 'z'
Prelude&gt; :sprint blah</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 489
blah = _
Theblah = _ indicates that blahis totally unevaluated.
Next we‚Äôll take one value from blahand then evaluate it by
forcing GHCi to print the expression:
Prelude&gt; take 1 blah
&quot;a&quot;
Prelude&gt; :sprint blah
blah = 'a' : _
So we‚Äôve evaluated a cons cell :and the first value 'a'.
Then we take two values and print them ‚Äî which forces
evaluation of the second cons cell and the second value:
Prelude&gt; take 2 blah
&quot;ab&quot;
Prelude&gt; :sprint blah
blah = 'a' : 'b' : _
Assuming this is a contiguous GHCi session, the first cons
cell and value were already forced.
We can keep going with this, evaluating the list one value
at a time:
Prelude&gt; take 3 blah
&quot;abc&quot;
Prelude&gt; :sprint blah</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 490
blah = 'a' : 'b' : 'c' : _
Thelength function is only strict in the spine, meaning it
only forces evaluation of the spine of a list, not the values,
something we can see if we try to find the length of a list of
undefined values. But when we use length onblah,:sprint will
behave as though we had forced evaluation of the values as
well:
Prelude&gt; length blah
26
Prelude&gt; :sprint blah
blah = &quot;abcdefghijklmnopqrstuvwxyz&quot;
That the individual characters were shown as evaluated
and not exclusively the spine after getting the length of blahis
one of the unfortunate aforementioned quirks of how GHCi
evaluates code.
Spines are evaluated independently of values
Values in Haskell get reduced to weak head normal form by
default. By ‚Äònormal form‚Äô we mean that the expression is fully
evaluated. ‚ÄòWeak head normal form‚Äô means the expression is
only evaluated as far as is necessary to reach a data constructor.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 491
Weak head normal form (WHNF) is a larger set and con-
tains both the possibility that the expression is fully evalu-
ated (normal form) and the possibility that the expression has
been evaluated to the point of arriving at a data constructor
or lambda awaiting an argument. For an expression in weak
head normal form, further evaluation may be possible once
another argument is provided. If no further inputs are pos-
sible, then it is still in WHNF but also in normal form (NF).
We‚Äôre going to explain this more fully later in the book in the
chapter on nonstrictness when we show you how call-by-need
works and the implications for Haskell. For now, we‚Äôll look at
a few examples to get a sense for what might be going on.
Below we list some expressions and whether they are in
WHNF, NF, both, or neither:
(1,2)-- WHNF &amp; NF
This first example is in normal form and is fully evaluated.
Anything in normal form is by definition also in weak head
normal form, because weak head is an expression which is
evaluated up to at least the first data constructor. Normal
form exceeds that by requiring that all subexpressions be fully
evaluated. Here the components of the value are the tuple
data constructor and the values 1 and 2.
(1,1+1)</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 492
This example is in WHNF, but not NF. The (+)applied to
its arguments could be evaluated but hasn‚Äôt been yet.
\x-&gt;x<em>10-- WHNF &amp; NF
This anonymous function is in normal form because while
(</em>)has been applied to two arguments of a sort, it cannot be
reduced further until the outer x -&gt; ... has been applied.
With nothing further to reduce, it is in normal form.
&quot;Papu&quot;++&quot;chon&quot;
This string concatenation is in neither WHNF nor NF, this
is because the outermost component of the expression is a
function, (++), whose arguments are fully applied but it hasn‚Äôt
been evaluated. Whereas, the following would be in WHNF
but not NF:
(1,&quot;Papu&quot;++&quot;chon&quot;)
When we define a list and define all its values, it is in NF
and all its values are known. There‚Äôs nothing left to evaluate
at that point, such as in the following example:
Prelude&gt; let num :: [Int]; num = [1, 2, 3]
Prelude&gt; :sprint num
num = [1,2,3]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 493
We can also construct a list through ranges or functions.
In this case, the list is in WHNF but not NF. The compiler
only evaluates the head or first node of the graph, but just the
cons constructor, not the value or rest of the list it contains.
We know there‚Äôs a value of type ùëéin the cons cell we haven‚Äôt
evaluated and a ‚Äúrest of list‚Äù which might either be the empty
list[]which ends the list or another cons cell ‚Äî we don‚Äôt know
which because we haven‚Äôt evaluated the next [a]value yet. We
saw that above in the :sprint section, and you can see that
evaluation of the first values does not force evaluation of the
rest of the list:
Prelude&gt; let myNum :: [Int]; myNum = [1..10]
Prelude&gt; :sprint myNum
myNum = _
Prelude&gt; take 2 myNum
[1,2]
Prelude&gt; :sprint myNum
myNum = 1 : 2 : _
This is an example of WHNF evaluation. It‚Äôs weak head
normal form because the list has to be constructed by the
range and it‚Äôs only going to evaluate as far as it has to. With
take 2, we only need to evaluate the first two cons cells and
the values they contain, which is why when we used :sprint
we only saw 1 : 2 : _ . Evaluating to normal form would‚Äôve</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 494
meant recursing through the entire list, forcing not only the
entire spine but also the values each cons cell contained.
In these tree representations, evaluation or consumption of
the list goes downthe spine. The following is a representation
of a list that isn‚Äôt spine strict and is awaiting something to force
the evaluation:
:
/ <br />
_ _
By default, it stops here and never evaluates even the first
cons cell unless it‚Äôs forced to, as we saw.
However, functions that are spine strict can force complete
evaluation of the spine of the list even if they don‚Äôt force eval-
uation of each value. Pattern matching is strict by default, so
pattern matching on cons cells can mean forcing spine strict-
ness if your function doesn‚Äôt stop recursing the list. It can
evaluate the spine only or the spine as well as the values that
inhabit each cons cell, depending on context.
On the other hand, length is strict in the spine but not the
values. If we defined a list such as [1, 2, 3] , usinglength on it
would force evaluation of the entire spine without accompa-
nying strictness in the values:
:
/ </p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 495
_ :
/ <br />
_ :
/ <br />
_ []
We can see this if we use length but make one of the values
bottom with the undefined value, and see what happens:
Prelude&gt; let x = [1, undefined, 3]
Prelude&gt; length x
3
The first and third values in the list were numbers, but the
second value was undefined andlength didn‚Äôt make it crash.
Why? Because length measures the length of a list, which only
requires recursing the spine and counting how many cons cells
there are. We could define our own length function ourselves
like so:
-- <em>Not</em> identical to the length
-- function in Prelude
length::[a]-&gt;Integer
length[]=0
length(_:xs)=1+length xs</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 496
One thing to note is that we use _to ignore the values in our
arguments or that are part of a pattern match. In this case, we
pattern-matched on the (:)data constructor, but wanted to
ignore the value which is the first argument. However, it‚Äôs not
a mere convention to bind references we don‚Äôt care about on
the left-hand side to <em>. You can‚Äôt bind arguments to the name
‚Äù</em>‚Äù; it‚Äôs part of the language. This is partly so the compiler
knows for a certainty you won‚Äôt ever evaluate something in
that particular case. Currently, if you try using _on the right-
hand side in the definition, it‚Äôll think you‚Äôre trying to refer to
a hole.
We‚Äôre only forcing the (:)constructors and the []at the
end in order to count the number of values contained by the
list:
: &lt;-|
/ \ |
|-&gt; _ : &lt;-|
| / \ | These got evaluated (forced)
|-&gt; _ : &lt;-|
| / \ |
|-&gt; _ [] &lt;-|
|
| These did not
However, length will throw an error on a bottom value if
part of the spine itself is bottom:</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 497
Prelude&gt; let x = [1] ++ undefined ++ [3]
Prelude&gt; x
[1*** Exception: Prelude.undefined
Prelude&gt; length x
*** Exception: Prelude.undefined
Printing the list fails, although it gets as far as printing the
first[and the first value, and attempting to get the length also
fails because it can‚Äôt count undefined spine values.
It‚Äôs possible to write functions which will force both the
spine and the values. sumis an example because in order to
return a result at all, it must return the sum of all values in the
list.
We‚Äôll write our own sumfunction for the sake of demonstra-
tion:
mySum::Numa=&gt;[a]-&gt;a
mySum[]=0
mySum(x:xs)=x+mySum xs
First, the +operator is strict in both of its arguments, so that
will force evaluation of the values and the mySum xs . Therefore
mySumwill keep recursing until it hits the empty list and must
stop. Then it will start going back up the spine of the list,
summing the inhabitants as it goes. It looks something like
this (the zero represents our empty list):</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 498
Prelude&gt; mySum [1..5]
1 + (2 + (3 + (4 + (5 + 0))))
1 + (2 + (3 + (4 + 5)))
1 + (2 + (3 + 9))
1 + (2 + 12)
1 + 14
15
We will be returning to this topic at various points in the
book because developing intuition for Haskell‚Äôs evaluation
strategies takes time and practice. If you don‚Äôt feel like you
fully understand it at this point, that‚Äôs OK. It‚Äôs a complex topic,
and it‚Äôs better to approach it in stages.
Exercises: Bottom Madness
Will it blow up?
Will the following expressions return a value or be ‚ä•?
1.[x^y|x&lt;-[1..5], y&lt;-[2, undefined]]
2.take1$
[x^y|x&lt;-[1..5], y&lt;-[2, undefined]]
3.sum[1, undefined, 3]
4.length[1,2, undefined]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 499
5.length$[1,2,3]++undefined
6.take1$filter even [ 1,2,3, undefined]
7.take1$filter even [ 1,3, undefined]
8.take1$filter odd [ 1,3, undefined]
9.take2$filter odd [ 1,3, undefined]
10.take3$filter odd [ 1,3, undefined]
Intermission: Is it in normal form?
For each expression below, determine whether it‚Äôs in:
1.normal form, which implies weak head normal form;
2.weak head normal form only; or,
3.neither.
Remember that an expression cannot be in normal form or
weak head normal form if the outermost part of the expression
isn‚Äôt a data constructor. It can‚Äôt be in normal form if any part
of the expression is unevaluated.
1.[1,2,3,4,5]
2.1:2:3:4:_</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 500
3.enumFromTo 110
4.length[1,2,3,4,5]
5.sum(enumFromTo 110)
6.['a'..'m']++['n'..'z']
7.(_,'b')
9.9 Transforming lists of values
We have already seen how we can make recursive functions
with self-referential expressions. It‚Äôs a useful tool and a core
part of the logic of Haskell. In truth, in part because Haskell
uses nonstrict evaluation, we tend to use higher-order func-
tions for transforming data rather than manually recursing
over and over.
For example, one common thing you would want to do is
return a list with a function applied uniformly to all values
within the list. To do so, you need a function that is inherently
recursive and can apply that function to each member of the
list. For this purpose we can use either the maporfmapfunctions.
mapcan only be used with [].fmapis defined in a typeclass
named Functor and can be applied to data other than lists. We
will learn more about Functor later; for now, we‚Äôll focus on the
list usage. Here are some examples using mapandfmap:</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 501
Prelude&gt; map (+1) [1, 2, 3, 4]
[2,3,4,5]
Prelude&gt; map (1-) [1, 2, 3, 4]
[0,-1,-2,-3]
Prelude&gt; fmap (+1) [1, 2, 3, 4]
[2,3,4,5]
Prelude&gt; fmap (2*) [1, 2, 3, 4]
[2,4,6,8]
Prelude&gt; fmap id [1, 2, 3]
[1,2,3]
Prelude&gt; map id [1, 2, 3]
[1,2,3]
The types of mapandfmaprespectively are:
map:: (a-&gt;b)-&gt;[a]-&gt;[b]
fmap::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
Let‚Äôs look at how the types line up with a program, starting
withmap:
map::(a-&gt;b)-&gt;[a]-&gt;[b]
map(+1)
The(a -&gt; b) becomes more specific and resolves to Num a
=&gt; a -&gt; a :</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 502
Prelude&gt;:t map (+1)
map(+1)::Numb=&gt;[b]-&gt;[b]
Now we see it will take one list of Numas an argument and
return a list of Numas a result.
The type of fmapwill behave similarly:
fmap::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
-- notice the Functor typeclass constraint
fmap(+1)
-- again, (a -&gt; b) is now more specific
It‚Äôs a bit diÔ¨Äerent from mapbecause the Functor typeclass
includes more than lists:
Prelude&gt; :t fmap (+1)
fmap (+1) :: (Num b, Functor f) =&gt; f b -&gt; f b
Here‚Äôs how mapis defined in base:
map::(a-&gt;b)-&gt;[a]-&gt;[b]
map_[]=[]
-- [1] [2] [3]
mapf (x:xs)=f x:map f xs
-- [4] [5] [6] [7] [8]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 503
1._is used here to ignore the function argument because
we don‚Äôt need it.
2.We are pattern matching on the []empty list case because
List is a sum type with two cases and we must handle both
every time we pattern match or case on a list value.
3.We return the []empty list value because when there are
no values, it‚Äôs the only correct thing we can do. If you
attempt to do anything else, the typechecker will swat
you.
4.We bind the function argument to the name ùëìas it merits
no name more specific than this. ùëìandùëîare common
names for nonspecific function values in Haskell. This is
the function we are mapping over the list value with map
5.We do not leave the entire list argument bound as a single
name. Since we‚Äôve already pattern-matched the []empty
list case, we know there must be at least one value in
the list. Here we pattern match into the (:)second data
constructor of the list, which is a product. ùë•is the single
value of the cons product. ùë•ùë†is the rest of the list.
6.We apply our function ùëìto the single value ùë•. This part
of themapfunction is what applies the function argument
to the contents of the list.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 504
7.We(:)cons the value returned by the expression f xonto
the head of the result of map‚Äôing the rest of the list. Data is
immutable in Haskell. When we map, we do not mutate
the existing list, but build a new list with the values that
result from applying the function.
8.We call mapitself applied to ùëìandùë•ùë†. This expression is the
rest of the list with the function ùëìapplied to each value.
How do we write out what map fdoes? Note, this order of
evaluation doesn‚Äôt represent the proper nonstrict evaluation
order, but does give an idea of what‚Äôs going on:
map(+1) [1,2,3]
-- desugared, (:) is infixr 5,
-- so it's right-associative
map(+1) (1:(2:(3:[])))
-- Not an empty list, so second
-- pattern-match in map fires.
-- Apply (+1) to value, then map
(+1)1:
map (+1)
(2:(3:[]))</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 505
-- Apply (+1) to the next value, cons onto
-- the result of mapping over the rest
(+1)1:
((+1)2:
(map (+1)
(3:[])))
-- Last time we'll trigger the
-- second-case of map
(+1)1:
((+1)2:
((+1)3:
(map (+1)[])))
-- Now we trigger the base-case that
-- handles empty list and return the
-- empty list.
(+1)1:
((+1)2:
((+1)3:[]))
-- Now we reduce
2:((+1)2:((+1)3:[]))
2:3:(+1)3:[]
2:3:4:[]==[2,3,4]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 506
Using the syntactic sugar of list, here‚Äôs an approximation of
whatmapis doing for us:
mapf [1,2,3]==[f1, f2, f3]
map(+1) [1,2,3]
[(+1)1, (+1)2, (+1)3]
[2,3,4]
Or using the spine syntax we introduced earlier:
:
/ <br />
1 :
/ <br />
2 :
/ <br />
3 []
map (+1) [1, 2, 3]
:
/ <br />
(+1) 1 :
/ <br />
(+1) 2 :
/ </p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 507
(+1) 3 []
As we mentioned above, these representations do not ac-
count for nonstrict evaluation. Crucially, mapdoesn‚Äôt traverse
the whole list and apply the function immediately. The func-
tion is applied to the values you force out of the list one by one.
We can see this by selectively leaving some values undefined:
Prelude&gt; map (+1) [1, 2, 3]
[2,3,4]
-- the whole list was forced because
-- GHCi printed the list that resulted
Prelude&gt; (+1) undefined
*** Exception: Prelude.undefined
Prelude&gt; (1, undefined)
(1,*** Exception: Prelude.undefined
Prelude&gt; fst (1, undefined)
1
Prelude&gt; map (+1) [1, 2, undefined]
[2,3,*** Exception: Prelude.undefined</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 508
Prelude&gt; take 2 $ map (+1) [1, 2, undefined]
[2,3]
In the final example, the undefined value was never forced
and there was no error because we used take 2 to request only
the first two elements. With map (+1) we only force as many
values as cons cells we forced. We‚Äôll only force the values if
we evaluate the result value in the list that the map function
returns.
The significant part here is that strictness doesn‚Äôt proceed
only outside-in. We can have lazily evaluated code (e.g., map)
wrapped around a strict core (e.g., +). In fact, we can choose to
apply laziness and strictness in how we evaluate the spine or
the leaves independently. A common mantra for performance
sensitive code in Haskell is, ‚Äúlazy in the spine, strict in the
leaves.‚Äù We‚Äôll cover this properly later when we talk about
nonstrictness and data structures, although many Haskell users
rarely worry about this.
You can use mapandfmapwith other functions and list types
as well. In this example, we use the fstfunction to return a
list of the first element of each tuple in a list of tuples:
Prelude&gt; map fst [(2, 3), (4, 5), (6, 7), (8, 9)]
[2,4,6,8]
Prelude&gt; fmap fst [(2, 3), (4, 5), (6, 7), (8, 9)]
[2,4,6,8]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 509
In this example we map a partially applied takefunction:
Prelude&gt; map (take 3) [[1..5], [1..5], [1..5]]
[[1,2,3],[1,2,3],[1,2,3]]
Next, we‚Äôll map an if-then-else over a list using an anony-
mous function. This list will find any value equal to 3, negate
it, and then return the list:
Prelude&gt; map (\x -&gt; if x == 3 then (-x) else (x)) [1..10]
[1,2,-3,4,5,6,7,8,9,10]
At this point, you can try your hand at mapping diÔ¨Äerent
functions using this as a model. We recommend getting com-
fortable with mapping before moving on to the Folds chapter.
Exercises: More Bottoms
As always, we encourage you to try figuring out the answers
before you enter them into your REPL.
1.Will the following expression return a value or be ‚ä•?
take1$map (+1) [undefined, 2,3]
2.Will the following expression return a value?
take1$map (+1) [1, undefined, 3]
3.Will the following expression return a value?</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 510
take2$map (+1) [1, undefined, 3]
4.What does the following mystery function do? What is its
type? Describe it (to yourself or a loved one) in standard
English and then test it out in the REPL to make sure you
were correct.
itIsMystery xs=
map (\x-&gt;elem x&quot;aeiou&quot;) xs
5.What will be the result of the following functions:
a)map(^2) [1..10]
b)mapminimum [[ 1..10], [10..20], [20..30]]
-- n.b. <code>minimum</code> is not the same function
-- as the <code>min</code> that we used before
c)mapsum [[1..5], [1..5], [1..5]]
6.Back in chapter 7, you wrote a function called foldBool .
That function exists in a module known as Data.Bool and
is called bool. Write a function that does the same (or
similar, if you wish) as the map (if-then-else) function you
saw above but uses boolinstead of the if-then-else syntax.
Your first step should be bringing the boolfunction into
scope by typing import Data.Bool at your Prelude prompt.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 511
9.10 Filtering lists of values
When we talked about function composition in Chapter 7,
we used a function called filter that takes a list as input and
returns a new list consisting solely of the values in the input
list that meet a certain condition, as in this example which
finds the even numbers of a list and returns a new list of those
values:
Prelude&gt; filter even [1..10]
[2,4,6,8,10]
Let‚Äôs now take a closer look at filter .filter has the follow-
ing definition:
filter::(a-&gt;Bool)-&gt;[a]-&gt;[a]
filter_[]=[]
filterpred (x:xs)
|pred x =x:filter pred xs
|otherwise =filter pred xs
Filtering takes a function that returns a Boolvalue, maps
that function over a list, and returns a new list of all the values
that met the condition. It‚Äôs important to remind ourselves that
this function, as we can see in the definition, builds a new list
including values that meet the condition and excluding the
ones that do not ‚Äî it does not mutate the existing list.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 512
We have seen how filter works with oddandevenalready.
We have also seen one example along the lines of this:
Prelude&gt; filter (== 'a') &quot;abracadabra&quot;
&quot;aaaaa&quot;
Asyoumightsuspectfromwhatwe‚ÄôveseenofHOFs, though,
filter can handle many types of arguments. The following ex-
ample does the same thing as filter even but with anonymous
function syntax:
Prelude&gt; filter (\x -&gt; (rem x 2) == 0) [1..20]
[2,4,6,8,10,12,14,16,18,20]
We covered list comprehensions earlier as a way of filtering
lists as well. Compare the following:
Prelude&gt; filter (\x -&gt; elem x &quot;aeiou&quot;) &quot;abracadabra&quot;
&quot;aaaaa&quot;
Prelude&gt; [x | x &lt;- &quot;abracadabra&quot;, elem x &quot;aeiou&quot;]
&quot;aaaaa&quot;
As they say, there‚Äôs more than one way to skin a cat.
Again, we recommend at this point you try writing some
filter functions of your own to get comfortable with the pat-
tern.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 513
Exercises: Filtering
1.Given the above, how might we write a filter function that
would give us all the multiples of 3 out of a list from 1-30?
2.Recalling what we learned about function composition,
how could we compose the above function with the length
function to tell us <em>how many</em> multiples of 3 there are
between 1 and 30?
3.Next we‚Äôre going to work on removing all articles (‚Äôthe‚Äô, ‚Äôa‚Äô,
and ‚Äôan‚Äô) from sentences. You want to get to something
that works like this:
Prelude&gt; myFilter &quot;the brown dog was a goof&quot;
[&quot;brown&quot;,&quot;dog&quot;,&quot;was&quot;,&quot;goof&quot;]
You may recall that earlier in this chapter we asked you
to write a function that separates a string into a list of
strings by separating them at spaces. That is a standard
library function called words. You may consider starting
this exercise by using words(or your version, of course).
9.11 Zipping lists
Zipping lists together is a means of combining values from
multiple lists into a single list. Related functions like zipWith</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 514
allow you to use a combining function to produce a list of
results from two lists.
First let‚Äôs look at zip:
Prelude&gt; :t zip
zip :: [a] -&gt; [b] -&gt; [(a, b)]
Prelude&gt; zip [1, 2, 3] [4, 5, 6]
[(1,4),(2,5),(3,6)]
One thing to note is that zipstops as soon as one of the lists
runs out of values:
Prelude&gt; zip [1, 2] [4, 5, 6]
[(1,4),(2,5)]
Prelude&gt; zip [1, 2, 3] [4]
[(1,4)]
And will return an empty list if either of the lists is empty:
Prelude&gt; zip [] [1..1000000000000000000]
[]
zipproceeds until the shortest list ends.
Prelude&gt; zip ['a'] [1..1000000000000000000]
[('a',1)]
Prelude&gt; zip [1..100] ['a'..'c']
[(1,'a'),(2,'b'),(3,'c')]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 515
We can use unzipto recover the lists as they were before
they were zipped:
Prelude&gt; zip [1, 2, 3] [4, 5, 6]
[(1,4),(2,5),(3,6)]
Prelude&gt; unzip $ zip [1, 2, 3] [4, 5, 6]
([1,2,3],[4,5,6])
Prelude&gt; fst $ unzip $ zip [1, 2, 3] [4, 5, 6]
[1,2,3]
Prelude&gt; snd $ unzip $ zip [1, 2, 3] [4, 5, 6]
[4,5,6]
Be aware that information can be lost in this process because
zipmust stop on the shortest list:
Prelude&gt; snd $ unzip $ zip [1, 2] [4, 5, 6]
[4,5]
We can also use zipWith to apply a function to the values of
two lists in parallel:
zipWith ::(a-&gt;b-&gt;c)
-- [1]
-&gt;[a]-&gt;[b]-&gt;[c]
-- [2] [3] [4]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 516
1.A function with two arguments. Notice how the type
variables of the arguments and result align with the type
variables in the lists.
2.The first input list.
3.The second input list.
4.The output list created from applying the function to the
values in the input lists.
A brief demonstration of how zipWith works:
Prelude&gt; zipWith (+) [1, 2, 3] [10, 11, 12]
[11,13,15]
Prelude&gt; zipWith (*) [1, 2, 3] [10, 11, 12]
[10,22,36]
Prelude&gt; zipWith (==) ['a'..'f'] ['a'..'m']
[True,True,True,True,True,True]
Prelude&gt; let xs = [10, 5, 34, 9]
Prelude&gt; let xs' = [6, 8, 12, 7]
Prelude&gt; zipWith max xs xs'
[10,8,34,9]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 517
Zipping exercises
1.Write your own version of zipand ensure it behaves the
same as the original.
zip::[a]-&gt;[b]-&gt;[(a, b)]
zip=undefined
2.Do what you did for zip, but now for zipWith :
zipWith ::(a-&gt;b-&gt;c)
-&gt;[a]-&gt;[b]-&gt;[c]
zipWith =undefined
3.Rewrite your zipin terms of the zipWith you wrote.
9.12 Chapter Exercises
The first set of exercises here will mostly be review but will
also introduce you to some new things. The second set is
more conceptually challenging but does not use any syntax or
concepts we haven‚Äôt already studied. If you get stuck, it may
help to flip back to a relevant section and review.
Data.Char
These first few exercises are straightforward but will introduce
you to some new library functions and review some of what</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 518
we‚Äôve learned so far. Some of the functions we will use here
are not standard in Prelude and so have to be imported from
a module called Data.Char . You may do so in a source file
(recommended) or at the Prelude prompt with the same phrase:
import Data.Char (write that at the top of your source file). This
brings into scope a bunch of new standard functions we can
play with that operate on CharandString types.
1.Query the types of isUpper andtoUpper .
2.Given the following behaviors, which would we use to
write a function that filters all the uppercase letters out
of aString ? Write that function such that, given the input
‚ÄúHbEfLrLxO,‚Äù your function will return ‚ÄúHELLO.‚Äù
Prelude Data.Char&gt; isUpper 'J'
True
Prelude Data.Char&gt; toUpper 'j'
'J'
3.Write a function that will capitalize the first letter of a
string and return the entire string. For example, if given
the argument ‚Äújulie,‚Äù it will return ‚ÄúJulie.‚Äù
4.Now make a new version of that function that is recursive
such that if you give it the input ‚Äúwoot‚Äù it will holler back
at you ‚ÄúWOOT.‚Äù The type signature won‚Äôt change, but
you will want to add a base case.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 519
5.To do the final exercise in this section, we‚Äôll need another
standard function for lists called head. Query the type of
headand experiment with it to see what it does. Now write
a function that will capitalize the first letter of a String
and return only that letter as the result.
6.Cool. Good work. Now rewrite it as a composed function.
Then, for fun, rewrite it pointfree.
Ciphers
We‚Äôll still be using Data.Char for this next exercise. You should
save these exercises in a module called Cipher because we‚Äôll
be coming back to them in later chapters. You‚Äôll be writing a
Caesar cipher for now, but we‚Äôll suggest some variations on
the basic program in later chapters.
A Caesar cipher is a simple substitution cipher, in which
each letter is replaced by the letter that is a fixed number of
places down the alphabet from it. You will find variations on
this all over the place ‚Äî you can shift leftward or rightward,
for any number of spaces. A rightward shift of 3 means that
‚ÄôA‚Äô will become ‚ÄôD‚Äô and ‚ÄôB‚Äô will become ‚ÄôE,‚Äô for example. If you
did a leftward shift of 5, then ‚Äôa‚Äô would become ‚Äôv‚Äô and so forth.
Your goal in this exercise is to write a basic Caesar cipher
that shifts rightward. You can start by having the number of
spaces to shift fixed, but it‚Äôs more challenging to write a cipher</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 520
that allows you to vary the number of shifts so that you can
encode your secret messages diÔ¨Äerently each time.
There are Caesar ciphers written in Haskell all over the
internet, but to maximize the likelihood that you can write
yours without peeking at those, we‚Äôll provide a couple of tips.
When yours is working the way you want it to, we would
encourage you to then look around and compare your solution
to others out there.
The first lines of your text file should look like this:
moduleCipherwhere
importData.Char
Data.Char includes two functions called ordandchrthat can
be used to associate a Charwith its Intrepresentation in the
Unicode system and vice versa:
*Cipher&gt;:t chr
chr::Int-&gt;Char
*Cipher&gt;:t ord
ord::Char-&gt;Int
Using these functions is optional; there are other ways you
can proceed with shifting, but using chrandordmight simplify
the process a bit.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 521
You want your shift to wrap back around to the beginning of
the alphabet, so that if you have a rightward shift of 3 from ‚Äôz,‚Äô
you end up back at ‚Äôc‚Äô and not somewhere in the vast Unicode
hinterlands. Depending on how you‚Äôve set things up, this
might be a bit tricky. Consider starting from a base character
(e.g., ‚Äôa‚Äô) and using modto ensure you‚Äôre only shifting over the
26 standard characters of the English alphabet.
You should include an unCaesar function that will decipher
your text as well. In a later chapter, we will test it.
Writing your own standard functions
Below are the outlines of some standard functions. The goal
here is to write your own versions of these to gain a deeper
understanding of recursion over lists and how to make func-
tions flexible enough to accept a variety of inputs. You could
figure out how to look up the answers, but you won‚Äôt do that
because you know you‚Äôd only be cheating yourself out of the
knowledge. Right?
Let‚Äôs look at an example of what we‚Äôre after here. The and2
function can take a list of Boolvalues and returns True if and
only if no values in the list are False. Here‚Äôs how you might
write your own version of it:
2Note that if you‚Äôre using GHC 7.10 or newer, the functions and,any, andallhave
been abstracted from being usable only with lists to being usable with any datatype that
has an instance of the typeclass Foldable . It still works with lists, the same as it did before.
Proceed assured that we‚Äôll cover this later.</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 522
-- direct recursion, not using (&amp;&amp;)
myAnd::[Bool]-&gt;Bool
myAnd[]=True
myAnd(x:xs)=
ifx==False
thenFalse
elsemyAnd xs
-- direct recursion, using (&amp;&amp;)
myAnd::[Bool]-&gt;Bool
myAnd[]=True
myAnd(x:xs)=x&amp;&amp;myAnd xs
And now the fun begins:
1.myOrreturns Trueif anyBoolin the list is True.
myOr::[Bool]-&gt;Bool
myOr=undefined
2.myAnyreturns Trueifa -&gt; Bool applied to any of the values
in the list returns True.
myAny::(a-&gt;Bool)-&gt;[a]-&gt;Bool
myAny=undefined
Example for validating myAny:</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 523
Prelude&gt; myAny even [1, 3, 5]
False
Prelude&gt; myAny odd [1, 3, 5]
True
3.After you write the recursive myElem , write another version
that uses any. The built-in version of elemin GHC 7.10 and
newer has a type that uses Foldable instead of the list type
specifically. You can ignore that and write the concrete
version that works only for list.
myElem::Eqa=&gt;a-&gt;[a]-&gt;Bool
Prelude&gt; myElem 1 [1..10]
True
Prelude&gt; myElem 1 [2..10]
False
4.Implement myReverse .
myReverse ::[a]-&gt;[a]
myReverse =undefined
Prelude&gt; myReverse &quot;blah&quot;
&quot;halb&quot;
Prelude&gt; myReverse [1..5]
[5,4,3,2,1]</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 524
5.squish flattens a list of lists into a list
squish::[[a]]-&gt;[a]
squish=undefined
6.squishMap maps a function over a list and concatenates the
results.
squishMap ::(a-&gt;[b])-&gt;[a]-&gt;[b]
squishMap =undefined
Prelude&gt; squishMap (\x -&gt; [1, x, 3]) [2]
[1,2,3]
Prelude&gt; squishMap (\x -&gt; &quot;WO &quot;++[x]++&quot; HOO &quot;) &quot;123&quot;
&quot;WO 1 HOO WO 2 HOO WO 3 HOO &quot;
7.squishAgain flattens a list of lists into a list. This time re-use
thesquishMap function.
squishAgain ::[[a]]-&gt;[a]
squishAgain =undefined
8.myMaximumBy takes a comparison function and a list and
returns the greatest element of the list based on the last
value that the comparison returned GTfor. If you import
maximumBy fromData.List , you‚Äôll see the type is:
Foldable t
=&gt;(a-&gt;a-&gt;Ordering )-&gt;t a-&gt;a</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 525
rather than
(a-&gt;a-&gt;Ordering )-&gt;[a]-&gt;a
myMaximumBy ::(a-&gt;a-&gt;Ordering )
-&gt;[a]-&gt;a
myMaximumBy =undefined
Prelude&gt; let xs = [1, 53, 9001, 10]
Prelude&gt; myMaximumBy compare xs
9001
9.myMinimumBy takes a comparison function and a list and
returns the least element of the list based on the last value
that the comparison returned LT for.
myMinimumBy ::(a-&gt;a-&gt;Ordering )
-&gt;[a]-&gt;a
myMinimumBy =undefined
Prelude&gt; let xs = [1, 53, 9001, 10]
Prelude&gt; myMinimumBy compare xs
1
10.Usingthe myMinimumBy andmyMaximumBy functions, writeyour
own versions of maximum andminimum . If you have GHC 7.10</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 526
ornewer, you‚Äôllseeatypeconstructorthatwantsa Foldable
instance instead of a list as has been the case for many
functions so far.
myMaximum ::(Orda)=&gt;[a]-&gt;a
myMaximum =undefined
myMinimum ::(Orda)=&gt;[a]-&gt;a
myMinimum =undefined
9.13 Definitions
1.In type theory, a producttype is a type made of a set of types
compounded over each other. In Haskell we represent
products using tuples or data constructors with more than
one argument. The ‚Äúcompounding‚Äù is from each type
argument to the data constructor representing a value that
coexists with all the other values simultaneously. Products
of types represent a conjunction, ‚Äúand,‚Äù of those types. If
you have a product of BoolandInt, your terms will each
contain a BoolandIntvalue.
2.In type theory, a sum type of two types is a type whose
terms are terms in either type, but not simultaneously. In
Haskell sum types are represented using the pipe, |, in a
datatype definition. Sums of types represent a disjunction,</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 527
‚Äúor,‚Äù of those types. If you have a sum of BoolandInt, your
terms will be eitheraBoolvalueoranIntvalue.
3.Consis ordinarily used as a verb to signify that a list value
has been created by cons‚Äôing a value onto the head of
another list value. In Haskell, (:)is the cons operator for
the list type. It is a data constructor defined in the list
datatype:
1:[2,3]
-- [a] [b]
[1,2,3]
-- [c]
(:)::a-&gt;[a]-&gt;[a]
-- [d] [e] [f]
a)The number 1, the value we are consing.
b)A list of the number 2 followed by the number 3.
c)The final result of consing 1onto[2, 3] .
d)The type variable ùëécorresponds to 1, the value we
consed onto the list value.
e)The first occurrence of the type [a]in the cons oper-
ator‚Äôs type corresponds to the second and final argu-
ment(:)accepts, which was [2, 3] .</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 528
f)The second and final occurrence of the type [a]in the
cons operator‚Äôs type corresponds to the final result
[1, 2, 3] .
4.Cons cell is a data constructor and a product of the types
aand[a]as defined in the list datatype. Because it refer-
ences the list type constructor itself in the second argu-
ment, it allows for nesting of multiple cons cells, possibly
indefinitely with the use of recursive functions, for repre-
senting an indefinite number of values in series:
data[]a=[]|a:[a]
-- ^ cons operator
-- Defining it ourselves
dataLista=Nil|Consa (Lista)
-- Creating a list using our list type
Cons1(Cons2(Cons3Nil))
Here(Cons 1 ...) ,(Cons 2 ...) and(Cons 3 Nil) are all
individual cons cells in the list [1, 2, 3] .
5.Thespineis a way to refer to the structure that glues a
collection of values together. In the list datatype it is</p>
<p>CHAPTER 9. THIS THING AND SOME MORE STUFF 529
formed by the recursive nesting of cons cells. The spine is,
in essence, the structure of collection that isn‚Äôtthe values
contained therein. Often spine will be used in reference
to lists, but it applies with tree data structures as well:
-- Given the list [1, 2, 3]
1:--------| The nested cons operators
(2:-----| here represent the spine.
(3:--|
[]))
-- Blanking the irrelevant values out
<em>:----------|
(</em>:-------|
(_:----&gt; Spine
[]))
9.14 Follow-up resources
1.Data.List documentation for the baselibrary.
http://hackage.haskell.org/package/base/docs/Data-List.html
2.Ninety-nine Haskell problems.
https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems</p>
<p>Chapter 10
Folding lists
The explicit teaching of
thinking is no trivial task,
but who said that the
teaching of programming
is? In our terminology,
the more explicitly
thinking is taught, the
more of a scientist the
programmer will
become.
Edsger Dijkstra
530</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 531
10.1 Folds
Folding is a concept that extends in usefulness and importance
beyond lists, but lists are often how they are introduced. Folds
as a general concept are called catamorphisms. You‚Äôre famil-
iar with the root, ‚Äúmorphism‚Äù from polymorphism. ‚ÄúCata-‚Äù
means ‚Äúdown‚Äù or ‚Äúagainst‚Äù, as in ‚Äúcatacombs.‚Äù Catamorphisms
are a means of deconstructing data. If the spine of a list is the
structure of a list, then a fold is what can reduce that structure.1
This chapter is a thorough look at the topic of folding lists
in Haskell. We will:
‚Ä¢explain what folds are and how they work;
‚Ä¢detail the evaluation processes of folds;
‚Ä¢walk through writing folding functions;
‚Ä¢introduce scans, functions that are related to folds.
10.2 Bringing you into the fold
Let‚Äôs start with a quick look at foldr, short for ‚Äúfold right.‚Äù This
is the fold you‚Äôll most often want to use with lists. The follow-
ing type signature may look a little hairy, but let‚Äôs compare it
1Note that a catamorphism canbreak down the structure but that structure might be
rebuilt, so to speak, during evaluation. That is, folds can return lists as results.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 532
to what we know about mapping. Note that the type of foldr
changed with GHC 7.10:
-- GHC 7.8 and older
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
-- GHC 7.10 and newer
foldr::Foldable t
=&gt;(a-&gt;b-&gt;b)
-&gt;b
-&gt;t a
-&gt;b
Lined up next to each other:
foldr::Foldable t=&gt;
(a-&gt;b-&gt;b)-&gt;b-&gt;t a-&gt;b
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[]a-&gt;b
For now, all you need to know is that GHC 7.10 abstracted
out the list-specific part of folding into a typeclass that lets you
reuse the same folding functions for any datatype that can be
folded ‚Äî not just lists. We can even recover the more concrete
type because we can always make a type more concrete, but
never more generic:
Prelude&gt; :{</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 533
Prelude| let listFoldr :: (a -&gt; b -&gt; b)
Prelude| -&gt; b
Prelude| -&gt; [] a
Prelude| -&gt; b
Prelude| listFoldr = foldr
Prelude| :}
Prelude&gt; :t listFoldr
listFoldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
Now let‚Äôs notice a parallel between mapandfoldr:
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
-- Remember how map worked?
map::(a-&gt;b)-&gt;[a]-&gt;[b]
map(+1)1: 2: 3:[]
(+1)1:(+1)2:(+1)3:[]
-- Given the list
foldr(+)0(1:2:3:[])
1+(2+(3+0))
Where mapapplies a function to each member of a list and
returns a list, a fold replaces the cons constructors with the
function and reduces the list.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 534
10.3 Recursive patterns
Let‚Äôs revisit sum:
Prelude&gt; sum [1, 5, 10]
16
As we‚Äôve seen, it takes a list, adds the elements together,
and returns a single result. You might think of it as similar
to themapfunctions we‚Äôve looked at, except that it‚Äôs mapping
(+)over the list, replacing the cons operators themselves, and
returning a single result, instead of mapping, for example, (+1)
into each cons cell and returning a whole list of results back
to us. This has the eÔ¨Äect of both mapping an operator over a
list and also reducing the list. In a previous section, we wrote
sumin terms of recursion:
sum::[Integer]-&gt;Integer
sum[]=0
sum(x:xs)=x+sum xs
And if we bring back our length function from earlier:
length::[a]-&gt;Integer
length[]=0
length(_:xs)=1+length xs</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 535
Do you see some structural similiarity? What if you look at
product andconcat as well?
product ::[Integer]-&gt;Integer
product []=1
product (x:xs)=x*product xs
concat::[[a]]-&gt;[a]
concat[]=[]
concat(x:xs)=x++concat xs
In each case, the base case is the identity for that function.
So the identity for sum,length ,product , andconcat respectively
are 0, 0, 1, and []. When we do addition, adding zero gives us
the same result as our initial value: 1 + 0 = 1 . But when we do
multiplication, it‚Äôs multiplying by 1 that gives us the identity:
2 * 1 = 2 . With list concatenation, the identity is the empty
list, such that [1, 2, 3] ++ [] == [1, 2, 3] .
Also, each of them has a main function with a recursive
pattern that associates to the right. The head of the list gets
evaluated, set aside, and then the function moves to the right,
evaluates the next head, and so on.
10.4 Fold right
We call foldrthe ‚Äúright fold‚Äù because the fold is right asso-
ciative; that is, it associates to the right. This is syntactically</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 536
reflected in a straightforward definition of foldras well:
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
foldrf z[]=z
foldrf z (x:xs)=f x (foldr f z xs)
The similarities between this and the recursive patterns we
saw above should be clear. The ‚Äúrest of the fold,‚Äù (foldr f z xs)
is an argument to the function ùëìwe‚Äôre folding with. The ùëßis
the zero of our fold. It provides a fallback value for the empty
list case and a second argument to begin our fold with. The
zero is often the identity for whatever function we‚Äôre folding
with, such as 0 for (+)and 1 for (*).
How foldr evaluates
We‚Äôre going to rejigger our definition of foldra little bit. It
won‚Äôt change the semantics, but it‚Äôll make it easier to write out
what‚Äôs happening:
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
foldrf z xs=
casexsof
[]-&gt;z
(x:xs)-&gt;f x (foldr f z xs)
Here we see how the right fold associates to the right. This
will reduce like the sumexample from earlier:</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 537
foldr(+)0[1,2,3]
When we reduce that fold, the first step is substituting ùë•ùë†in
our case expression:
foldr(+)0[1,2,3]=
case[1,2,3]of
...
Which case of the expression matches?
foldr(+)0[1,2,3]=
case[1,2,3]of
[]-&gt;0
(x:xs)-&gt;
f x (foldr f z xs) --&lt;---this one
What are f, x, xs, and z in that branch of the case?
foldr(+)0[1,2,3]=
case[1,2,3]of
[] -&gt;0
(1:[2,3])-&gt;
(+)1(foldr ( +)0[2,3])
Critically, we‚Äôre going to expand (foldr (+) 0 [2, 3]) only
because (+)is strict in both of its arguments, so it forces the</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 538
next iteration. We could have a function which doesn‚Äôt contin-
ually force the rest of the fold. If it were to stop on the first case
here, then it would‚Äôve returned the value 1. One such function
isconstwhich always returns the first argument. We‚Äôll show
you how that behaves in a bit. Our next recursion is the (foldr
(+) 0 [2, 3]) :
foldr(+)0[2,3]=
case[2,3]of
[] -&gt;
0-- this didn't match again
(2:[3])-&gt;(+)2(foldr ( +)0[3])
There is (+) 1implicitly wrapped around this continuation
of the recursive fold. (+)is not only strict in both of its argu-
ments, but it‚Äôs unconditionally so, so we‚Äôre going to proceed to
the next recursion of foldr. Note that the function calls bounce
between our folding function ùëìandfoldr. This bouncing back
and forth gives more control to the folding function. A hypo-
thetical folding function, such as const, which doesn‚Äôt need the
second argument has the opportunity to do less work by not
evaluating its second argument which is ‚Äúmore of the fold.‚Äù
There is (+) 1 ((+) 2 ...) implicitly wrapped around this
next step of the recursive fold:</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 539
foldr(+)0[3]=
case[3]of
[] -&gt;
0-- this didn't match again
(3:[])-&gt;(+)3(foldr ( +)0[])
We‚Äôre going to ask for more foldrone last time. There is,
again,(+) 1 ((+) 2 ((+) 3 ...)) implicitly wrapped around
this final step of the recursive fold. Now we hit our base case
and and hit our base case:
foldr(+)0[]=
case[]of
[] -&gt;
0--&lt;--Thisone finally matches
-- ignore the other case, didn't happen
So one way to think about the way Haskell evaluates is that
it‚Äôs like a text rewriting system. Our expression has thus far
rewritten itself from:
foldr(+)0[1,2,3]
Into:
(+)1((+)2((+)30))</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 540
If you wanted to clean it up a bit without changing how it
evaluates, you could make it the following:
1+(2+(3+0))
As in arithmetic, we evaluate innermost parentheses first:
1+(2+(3+0))
1+(2+3)
1+5
6
And now we‚Äôre done, with the result of 6.
We can also use a trick popularized by some helpful users
in the Haskell IRC community to see how the fold associates.2
xs=map show [ 1..5]
y=foldr (\x y-&gt;concat
[&quot;(&quot;,x,&quot;+&quot;,y,&quot;)&quot;])&quot;0&quot;xs
When we call ùë¶in the REPL, we can see how the foldreval-
uates:
2Idea borrowed from Cale Gibbard from the haskell Freenode IRC channel and on
the Haskell.org wiki https://wiki.haskell.org/Fold#Examples</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 541
Prelude&gt; y
&quot;(1+(2+(3+(4+(5+0)))))&quot;
One initially nonobvious aspect of folding is that it happens
in two stages, traversal and folding. Traversal is the stage
in which the fold recurses over the spine. Folding refers to
the evaluation or reduction of the folding function applied
to the values. All folds recurse over the spine in the same
direction; the diÔ¨Äerence between left folds and right folds is
in the association, or parenthesization, of the folding function
and, thus, which direction the folding or reduction proceeds.
Withfoldr, the rest of our fold is an argument to the func-
tion we‚Äôre folding with:
foldrf z (x:xs)=f x (foldr f z xs)
-- ^--------------^
-- rest of the fold
Given this two-stage process and nonstrict evaluation, if
ùëìdoesn‚Äôt evaluate its second argument (rest of the fold), no
more of the spine will be forced. One of the consequences of
this is that foldrcan avoid evaluating not only some or all of
the values in the list, but some or all of the list‚Äôs spineas well!
For this reason, foldrcan be used with lists that are potentially
infinite. For example, compare the following sets of results</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 542
(recall that (+)will unconditionally evaluate the entire spine
and all of the values):
Prelude&gt; foldr (+) 0 [1..5]
15
While you cannot use foldrwith addition on an infinite list,
you can use functions that are not strict in both arguments and
therefore do not require evaluation of every value in order to
return a result. The function myAny, for example, can return a
Trueresult as soon as it finds one True:
myAny::(a-&gt;Bool)-&gt;[a]-&gt;Bool
myAnyf xs=
foldr (\x b-&gt;f x||b)Falsexs
The following should work despite being an infinite list:
Prelude&gt; myAny even [1..]
True
The following will never finish evaluating because it‚Äôs always
an odd number:
Prelude&gt; myAny even (repeat 1)
Another term we use for this never-ending evaluation is
bottom orundefined . There‚Äôs no guarantee that a fold of an</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 543
infinite list will finish evaluating even if you used foldr, it of-
ten depends on the input data and the fold function. Let us
consider some more examples with a less inconvenient bottom :
Prelude&gt; let u = undefined
-- here, we give an undefined value
Prelude&gt; foldr (+) 0 [1, 2, 3, 4, u]
*** Exception: Prelude.undefined
Prelude&gt; let xs = take 4 [1, 2, 3, 4, u]
Prelude&gt; foldr (+) 0 xs
10
-- here, undefined is part of the spine
Prelude&gt; let xs = [1, 2, 3, 4] ++ u
Prelude&gt; foldr (+) 0 xs
*** Exception: Prelude.undefined
Prelude&gt; let xs = take 4 ([1, 2, 3, 4]++u)
Prelude&gt; foldr (+) 0 xs
10
By taking only the first four elements, we stop the recursive
folding process at the first four values so our addition function
does not run into bottom, and that works whether undefined is
one of the values or part of the spine.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 544
Thelength function behaves diÔ¨Äerently; it evaluates the
spine unconditionally, but not the values:
Prelude&gt; length [1, 2, 3, 4, undefined]
5
Prelude&gt; length ([1, 2, 3, 4] ++ undefined)
*** Exception: Prelude.undefined
However, if we drop the part of the spine that includes the
bottom before we use length, we can get an expression that
works:
Prelude&gt; let xs = [1, 2, 3, 4] ++ undefined
Prelude&gt; length (take 4 xs)
4
takeis nonstrict like everything else you‚Äôve seen so far, and
in this case, it only returns as much list as you ask for. The dif-
ference in what it does, is it stopsreturning elements of the list
it was given when it hits the length limit you gave it. Consider
this:
Prelude&gt; let xs = [1, 2] ++ undefined
Prelude&gt; length $ take 2 $ take 4 xs
2
It doesn‚Äôt matter that take 4 could‚Äôve hit the bottom! Noth-
ing forced it to because of the take 2 between it and length .</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 545
Now that we‚Äôve seen how the recursive second argument to
foldr‚Äôs folding function works, let‚Äôs consider the first argument:
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
foldrf z[]=z
foldrf z (x:xs)=f x (foldr f z xs)
-- [1]
The first argument, [1], involves a pattern match that is
strict by default ‚Äî the ùëìonly applies to ùë•if there is an ùë•value
and not just an empty list. This means that foldrmust force
an initial cons cell in order to discriminate between the []and
the(x : xs) cases, so the first cons cell cannot be undefined.
Now we‚Äôre going to try something unusual to demonstrate
that the first bit of the spine must be evaluated by foldr. We
have a somewhat silly anonymous function that will ignore
all its arguments and return a value of 9001. We‚Äôre using it
withfoldrbecause it will never force evaluation of any of its
arguments, so we can have a bottom as a value or as part of
the spine, and it will not force an evaluation:
Prelude&gt; foldr (_ _ -&gt; 9001) 0 [1..5]
9001
Prelude&gt; let xs = [1, 2, 3, undefined]
Prelude&gt; foldr (_ _ -&gt; 9001) 0 xs
9001</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 546
Prelude&gt; let xs = [1, 2, 3] ++ undefined
Prelude&gt; foldr (_ _ -&gt; 9001) 0 xs
9001
Everything is fine unless the first piece of the spine is bot-
tom:
Prelude&gt; foldr (_ _ -&gt; 9001) 0 undefined
*** Exception: Prelude.undefined
Prelude&gt; let xs = [1, undefined]
Prelude&gt; foldr (_ _ -&gt; 9001) 0 xs
9001
Prelude&gt; let xs = [undefined, undefined]
Prelude&gt; foldr (_ _ -&gt; 9001) 0 xs
9001
The final two examples work because it isn‚Äôt the first cons
cellthat is bottom ‚Äî the undefined values are inside the cons
cells, not in the spine itself. Put diÔ¨Äerently, the cons cells
contain bottom values but are not themselves bottom. We will
experiment later with nonstrictness and strictness to see how
it aÔ¨Äects the way our programs evaluate.
Traversing the rest of the spine doesn‚Äôt occur unless the
function asks for the results of having folded the rest of the
list. In the following examples, we don‚Äôt force traversal of the</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 547
spine because constthrows away its second argument, which
is the rest of the fold:
-- reminder:
-- const :: a -&gt; b -&gt; a
-- const x _ = x
Prelude&gt; const 1 2
1
Prelude&gt; const 2 1
2
Prelude&gt; foldr const 0 [1..5]
1
Prelude&gt; foldr const 0 [1,undefined]
1
Prelude&gt; foldr const 0 ([1,2] ++ undefined)
1
Prelude&gt; foldr const 0 [undefined,2]
*** Exception: Prelude.undefined
Now that we‚Äôve seen how foldrevaluates, we‚Äôre going to
look atfoldlbefore we move on to learning how to write and
use folds.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 548
10.5 Fold left
Because of the way lists work, folds must first recurse over
the spine of the list from the beginning to the end. Left folds
traverse the spine in the same direction as right folds, but their
folding process is left associative and proceeds in the opposite
direction as that of foldr.
Here‚Äôs a simple definition of foldl. Note that to see the same
type for foldlin your GHCi REPL you will need to import
Data.List for the same reasons as with foldr:
-- again, different type in
-- GHC 7.10 and newer.
foldl::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;b
foldlf acc[]=acc
foldlf acc (x :xs)=foldl f (f acc x) xs
foldl::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;b
-- Given the list
foldl(+)0(1:2:3:[])
-- foldl associates like this
((0+1)+2)+3</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 549
We can also use the same trick we used to see the associa-
tivity of foldrto see the associativity of foldl:
Prelude&gt; let conc = concat
Prelude&gt; let f x y = conc [&quot;(&quot;,x,&quot;+&quot;,y,&quot;)&quot;]
Prelude&gt; foldl f &quot;0&quot; (map show [1..5])
&quot;(((((0+1)+2)+3)+4)+5)&quot;
We can see from this that foldlbegins its reduction process
by adding the acc(accumulator) value to the head of the list,
whereas foldrhad added it to the final element of the list first.
We can also use functions called scansto see how folds eval-
uate. Scans are similar to folds but return a list of all the inter-
mediate stages of the fold. We can compare scanrandscanlto
their accompanying folds to see the diÔ¨Äerence in evaluation:
Prelude&gt; foldr (+) 0 [1..5]
15
Prelude&gt; scanr (+) 0 [1..5]
[15,14,12,9,5,0]
Prelude&gt; foldl (+) 0 [1..5]
15
Prelude&gt; scanl (+) 0 [1..5]
[0,1,3,6,10,15]</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 550
The relationship between the scans and folds are as follows:
last(scanl f z xs) =foldl f z xs
head(scanr f z xs) =foldr f z xs
Each fold will return the same result for this operation, but
we can see from the scans that they arrive at that result in a
diÔ¨Äerent order, due to the diÔ¨Äerent associativity. We‚Äôll talk
more about scans later.
Associativity and folding
Next we‚Äôll take a closer look at some of the eÔ¨Äects of the asso-
ciativity of foldl. As we‚Äôve said, both folds traverse the spine
in the same direction. What‚Äôs diÔ¨Äerent is the associativity of
the evaluation.
The fundamental way to think about evaluation in Haskell
is as substitution. When we use a right fold on a list with the
function ùëìand start value ùëß, we‚Äôre, in a sense, replacing the
cons constructors with our folding function and the empty list
constructor with our start value ùëß:</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 551
[1..3]==1:2:3:[]
foldrf z [1,2,3]
1<code>f</code> (foldr f z [ 2,3])
1<code>f</code> (2<code>f</code> (foldr f z [ 3]))
1<code>f</code> (2<code>f</code> (3<code>f</code> (foldr f z [])))
1<code>f</code> (2<code>f</code> (3<code>f</code> z))
Furthermore, lazy evaluation lets our functions, rather than
the ambient semantics of the language, dictate what order
things get evaluated in. Because of this, the parentheses are real .
In the above, the 3 <code>f</code> z pairing gets evaluated first because
it‚Äôs in the innermost parentheses. Right folds have to traverse
the list outside-in, but the folding itself starts from the end of
the list.
It‚Äôs hard to see this with arithmetic functions that are as-
sociative, such as addition, but it‚Äôs an important point to un-
derstand, so we‚Äôll run through some diÔ¨Äerent examples. Let‚Äôs
start by using an arithmetic operation that isn‚Äôt associative:
Prelude&gt; foldr (^) 2 [1..3]
1
Prelude&gt; foldl (^) 2 [1..3]
64
This time we can see clearly that we got diÔ¨Äerent results, and</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 552
that diÔ¨Äerence results from the way the functions associate.
Here‚Äôs a breakdown:
-- if you want to follow along,
-- use paper and not the REPL.
foldr(^)2[1..3]
(1^(2^(3^2)))
(1^(2^9))
1^512
1
Contrast that with this:
foldl(^)2[1..3]
((2^1)^2)^3
(2^2)^3
4^3
64
In this next set of comparisons, we will demonstrate the
eÔ¨Äect of associativity on argument order by folding the list
into a new list, like this:
Prelude&gt; foldr (:) [] [1..3]
[1,2,3]
Prelude&gt; foldl (flip (:)) [] [1..3]
[3,2,1]</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 553
We must use flipwithfoldl. Let‚Äôs examine why.
Like a right fold, a left fold cannot perform magic and go to
the end of the list instantly; it must start from the beginning
of the list. However, the parentheses dictate how our code
evaluates. The type of the argument to the folding function
changes in addition to the associativity:
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
-- [1] [2] [3]
foldl::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;b
-- [4] [5] [6]
1.The parameter of type ùëérepresents one of the list element
arguments the folding function of foldris applied to.
2.The parameter of type ùëèwill either be the start value or
the result of the fold accumulated so far, depending on
how far you are into the fold.
3.The final result of having combined the list element and
the start value or fold so far to compute the fold.
4.The start value or fold accumulated so far is the first ar-
gument to foldl‚Äôs folding function.
5.The list element is the second argument to foldl‚Äôs folding
function.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 554
6.The final result of foldl‚Äôs fold function is of type ùëè, like
that offoldr.
The type of (:)requires that a value be the first argument
and a list be the second argument:
(:) :: a -&gt; [a] -&gt; [a]
So the value is prepended, or ‚Äúconsed onto,‚Äù the front of
that list.
In the following examples, the tilde means ‚Äúis equivalent or
equal to.‚Äù If we write a right fold that has the cons constructor
as ourùëìand the empty list as our ùëß, we get:
-- foldr f z [1, 2, 3]
-- f ~ (:); z ~ []
-- Run it in your REPL. It'll return True.
foldr (:)<a href="HaskellProgramming/1:2:3:%5B%5D"></a>
==1:(2:(3:[]))
The consing process for foldrmatches the type signature
for(:). It also reproduces the same list because we‚Äôre replacing
the cons constructors with cons constructors and the null list
with null list. However, for it to be identical, it also has to be
right associative.
Doing the same with foldldoes not produce the same result.
When using foldl, the result we‚Äôve accumulated so far is the</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 555
first argument instead of the list element. This is opposite of
what(:)expects if we‚Äôre accumulating a list. Trying to fold
the identity of the list as above but with foldlwould give us a
type error because the reconstructing process for foldlwould
look like this:
foldlf z [1,2,3]
-- f ~ (:); z ~ []
-- (((z <code>f</code> 1) <code>f</code> 2) <code>f</code> 3)
((([]:1):2):3)
That won‚Äôt work because the ùëßis an empty list and the ùëìis
cons, so we have the order of arguments backwards for cons.
Enterflip, whose job is to take backwards arguments and turn
that frown upside down. It will flip each set of arguments
around for us, like this:
foldlf z [1,2,3]
-- f ~ (flip (:)); z ~ []
-- (((z <code>f</code> 1) <code>f</code> 2) <code>f</code> 3)
f=flip (:)
((([]<code>f</code>1) <code>f</code>2) <code>f</code>3)
(([1] <code>f</code>2) <code>f</code>3)
([2,1] <code>f</code>3)
[3,2,1]</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 556
Evenwhenwe‚Äôvesatisfiedthetypesbyflippingthingsaround,
the left-associating nature of foldlleads to a diÔ¨Äerent result
from that of foldr.
For the next set of comparisons, we‚Äôre going to use a func-
tion called constthat takes two arguments and always returns
the first one. When we fold constover a list, it will take as its
first pair of arguments the accvalue and a value from the list
‚Äî which value it takes first depends on which type of fold it is.
We‚Äôll show you how it evaluates for the first example:
Prelude&gt; foldr const 0 [1..5]
(const 1 _)
1
Sinceconstdoesn‚Äôt evaluate its second argument the rest
of the fold is never evaluated. The underscore represents the
rest of the unevaluated fold. Now, let‚Äôs look at the eÔ¨Äect of
flipping the arguments. The 0 result is because zero is our
accumulator value here, so it‚Äôs the first (or last) value of the
list:
Prelude&gt; foldr (flip const) 0 [1..5]
0
Next let‚Äôs look at what happens when we use the same func-
tions but this time with foldl. Take a few moments to under-
stand the evaluation process that leads to these results:</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 557
Prelude&gt; foldl (flip const) 0 [1..5]
5
Prelude&gt; foldl const 0 [1..5]
0
This is the eÔ¨Äect of left associativity. The spine traversal
happens in the same order in a left or right fold ‚Äî it must, be-
cause of the way lists are defined. Depending on your folding
function, a left fold can lead to a diÔ¨Äerent result than a right
fold of the same.
Exercises: Understanding Folds
1.foldr(<em>)1[1..5]
will return the same result as which of the following:
a)flip(</em>)1[1..5]
b)foldl(flip (<em>))1[1..5]
c)foldl(</em>)1[1..5]
2.Write out the evaluation steps for
foldl(flip (*))1[1..3]
3.One diÔ¨Äerence between foldrandfoldlis:
a)foldr, but not foldl, traverses the spine of a list from
right to left</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 558
b)foldr, but not foldl, always forces the rest of the fold
c)foldr, but not foldl, associates to the right
d)foldr, but not foldl, is recursive
4.Folds are catamorphisms, which means they are generally
used to
a)reduce structure
b)expand structure
c)render you catatonic
d)generate infinite data structures
5.The following are simple folds very similar to what you‚Äôve
already seen, but each has at least one error. Please fix
them and test in your REPL:
a)foldr(++) [&quot;woot&quot;,&quot;WOOT&quot;,&quot;woot&quot;]
b)foldrmax[]&quot;fear is the little death&quot;
c)foldrandTrue[False,True]
d)This one is more subtle than the previous. Can it ever
return a diÔ¨Äerent answer?
foldr(||)True[False,True]
e)foldl((++).show)&quot;&quot;[1..5]
f)foldrconst'a'[1..5]</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 559
g)foldrconst0&quot;tacos&quot;
h)foldl(flip const) 0&quot;burritos&quot;
i)foldl(flip const) 'z'[1..5]
Unconditional spine recursion
An important diÔ¨Äerence between foldrandfoldlis that a left
fold has the successive steps of the fold as its first argument.
The next recursion of the spine isn‚Äôt intermediated by the
folding function as it is in foldr, which also means recursion of
the spine is unconditional. Having a function that doesn‚Äôt force
evaluation of either of its arguments won‚Äôt change anything.
Let‚Äôs review const:
Prelude&gt; const 1 undefined
1
Prelude&gt; (flip const) 1 undefined
*** Exception: Prelude.undefined
Prelude&gt; (flip const) undefined 1
1
Now compare:
Prelude&gt; let xs = [1..5] ++ undefined
Prelude&gt; foldr const 0 xs
1
Prelude&gt; foldr (flip const) 0 xs</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 560
*** Exception: Prelude.undefined
Prelude&gt; foldl const 0 xs
*** Exception: Prelude.undefined
Prelude&gt; foldl (flip const) 0 xs
*** Exception: Prelude.undefined
However, while foldlunconditionally evaluates the spine
you can still selectively evaluate the values in the list. This will
throw an error because the bottom is part of the spine and
foldlmust evaluate the spine:
Prelude&gt; let xs = [1..5] ++ undefined
Prelude&gt; foldl (_ _ -&gt; 5) 0 xs
*** Exception: Prelude.undefined
But this is OK because bottom is a value here:
Prelude&gt; let xs = [1..5] ++ [undefined]
Prelude&gt; foldl (_ _ -&gt; 5) 0 xs
5
This feature means that foldlis generally inappropriate
with lists that are or could be infinite, but the combination of
the forced spine evaluation with nonstrictness means that it is
also usually inappropriate even for long lists, as the forced eval-
uation of the spine aÔ¨Äects performance negatively. Because</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 561
foldlmust evaluate its whole spine before it starts evaluating
values in each cell, it accumulates a pile of unevaluated values
as it traverses the spine.
In most cases, when you need a left fold, you should use
foldl'. This function, called ‚Äúfold-l-prime,‚Äù works the same
except it is strict. In other words, it forces evaluation of the
values inside cons cells as it traverses the spine, rather than
accumulating unevaluated expressions for each element of
the list. The strict evaluation here means it has less negative
eÔ¨Äect on performance over long lists.
10.6 How to write fold functions
When we write folds, we begin by thinking about what our
start value for the fold is. This is usually the identity value for
the function. When we sum the elements of a list, the identity
of summation is 0. When we multiply the elements of the list,
the identity is 1. This start value is also our fallback in case the
list is empty.
Next we consider our arguments. A folding function takes
two arguments, ùëéandùëè, where ùëéis going to always be one of
the elements in the list and ùëèis either the start value or the
value accumulated as the list is being processed.
Let‚Äôs say we want to write a function to take the first three
letters of each String value in a list of strings and concatenate</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 562
that result into a final String . The type of the right fold for lists
is:
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
First, we‚Äôll set up the beginnings of our expression:
foldr(\a b-&gt;undefined) []
[&quot;Pizza&quot;,&quot;Apple&quot;,&quot;Banana&quot; ]
We used an empty list as the start value, but since we plan to
return a String as our result, we could be a little more explicit
about our intent to build a String and make a small syntactic
change:
foldr(\a b-&gt;undefined) &quot;&quot;
[&quot;Pizza&quot;,&quot;Apple&quot;,&quot;Banana&quot; ]
Of course, because a String is a list, these are the same value:
Prelude&gt; &quot;&quot; == []
True
But&quot;&quot;signals intent with respect to the types involved:
Prelude&gt; :t &quot;&quot;
&quot;&quot; :: [Char]
Prelude&gt; :t []
[] :: [t]</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 563
Moving along, we next want to work on the function. We
already know how to take the first three elements from a list
and we can reuse this for String :
foldr(\a b-&gt;take3a)&quot;&quot;
[&quot;Pizza&quot;,&quot;Apple&quot;,&quot;Banana&quot; ]
Now this will already typecheck and work, but it doesn‚Äôt
match the semantics we asked for:
Prelude&gt; :{
*Main| let pab =
*Main| [&quot;Pizza&quot;, &quot;Apple&quot;, &quot;Banana&quot;]
*Main| :}
Prelude&gt; foldr (\a b -&gt; take 3 a) &quot;&quot; pab
&quot;Piz&quot;
Prelude&gt; foldl (\b a -&gt; take 3 a) &quot;&quot; pab
&quot;Ban&quot;
We‚Äôre only getting the first three letters of the first or the
last string, depending on whether we did a right or left fold.
Note the argument naming order due to the diÔ¨Äerence in the
types of foldrandfoldl:
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
foldl::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;b</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 564
The problem here is that right now we‚Äôre not folding the
list. We‚Äôre only mapping our take 3 over the list and selecting
the first or last result:
Prelude&gt; map (take 3) pab
[&quot;Piz&quot;,&quot;App&quot;,&quot;Ban&quot;]
Prelude&gt; head $ map (take 3) pab
&quot;Piz&quot;
Prelude&gt; last $ map (take 3) pab
&quot;Ban&quot;
So let us make this a proper fold and accumulate the result
by making use of the ùëèargument. Remember the ùëèis the
start value. Technically we could use concat on the result of
having mapped take 3 over the list (or its reverse, if we want
to simulate foldl):
Prelude&gt; concat $ map (take 3) pab
&quot;PizAppBan&quot;
Prelude&gt; let rpab = reverse pab
Prelude&gt; concat $ map (take 3) rpab
&quot;BanAppPiz&quot;
But we need an excuse to play with foldrandfoldl, so we‚Äôll
pretend none of this happened!
Prelude&gt; let f = (\a b -&gt; take 3 a ++ b)</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 565
Prelude&gt; foldr f &quot;&quot; pab
&quot;PizAppBan&quot;
Prelude&gt; let f' = (\b a -&gt; take 3 a ++ b)
Prelude&gt; foldl f' &quot;&quot; pab
&quot;BanAppPiz&quot;
Here we concatenated the result of having taken three el-
ements from the string value in our input list onto the front
of the string we‚Äôre accumulating. If we want to be explicit, we
can assert types for the values:
Prelude&gt; :{
*Prelude| let f a b = take 3
*Prelude| (a :: String) ++
*Prelude| (b :: String)
*Prelude| :}
Prelude&gt; foldr f &quot;&quot; pab
&quot;PizAppBan&quot;
Ifweassertsomethingthatisn‚Äôttrue, thetypecheckercatches
us:
Prelude&gt; :{
*Prelude| let f a b = take 3 (a :: String)
*Prelude| ++ (b :: [String])
*Prelude| :}</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 566
<interactive>:12:42:
Couldn't match type ‚ÄòChar‚Äô with ‚Äò[Char]‚Äô
Expected type: [String]
Actual type: [Char]
In the second argument of ‚Äò(++)‚Äô,
namely ‚Äò(b :: [String])‚Äô
In the expression:
take 3 (a :: String) ++ (b :: [String])
This can be useful for checking that your mental model of
the code is accurate.
Exercises: Database Processing
Write the following functions for processing this data.
importData.Time
dataDatabaseItem =DbString String
|DbNumber Integer
|DbDate UTCTime
deriving (Eq,Ord,Show)</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 567
theDatabase ::[DatabaseItem ]
theDatabase =
[DbDate(UTCTime
(fromGregorian 191151)
(secondsToDiffTime 34123))
,DbNumber 9001
,DbString &quot;Hello, world!&quot;
,DbDate(UTCTime
(fromGregorian 192151)
(secondsToDiffTime 34123))
]
1.Write a function that filters for DbDate values and returns
a list of the UTCTime values inside them.
filterDbDate ::[DatabaseItem ]
-&gt;[UTCTime]
filterDbDate =undefined
2.Write a function that filters for DbNumber values and returns
a list of the Integer values inside them.
filterDbNumber ::[DatabaseItem ]
-&gt;[Integer]
filterDbNumber =undefined
3.Write a function that gets the most recent date.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 568
mostRecent ::[DatabaseItem ]
-&gt;UTCTime
mostRecent =undefined
4.Write a function that sums all of the DbNumber values.
sumDb::[DatabaseItem ]
-&gt;Integer
sumDb=undefined
5.Write a function that gets the average of the DbNumber val-
ues.
-- You'll probably need to use fromIntegral
-- to get from Integer to Double.
avgDb::[DatabaseItem ]
-&gt;Double
avgDb=undefined
10.7 Folding and evaluation
What diÔ¨Äerentiates foldrandfoldlis associativity. The right
associativity of foldrmeans the folding function evaluates
from the innermost cons cell to the outermost (the head). On
the other hand, foldlrecurses unconditionally to the end of the</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 569
list through self-calls and then the folding function evaluates
from the outermost cons cell to the innermost:
Prelude&gt; let rcf = foldr (:) []
Prelude&gt; let xs = [1, 2, 3] ++ undefined
Prelude&gt; take 3 $ rcf xs
[1,2,3]
Prelude&gt; let lcf = foldl (flip (:)) []
Prelude&gt; take 3 $ lcf xs
*** Exception: Prelude.undefined
Let‚Äôs dive into our constexample a little more carefully:
foldr const 0 [1..5]
Withfoldr, you‚Äôll evaluate const 1 (...) , butconstignores
the rest of the fold that would have occurred from the end of
the list up to the number 1, so this returns 1 without having
evaluated any more of the values or the spine. One way you
could examine this for yourself would be:
Prelude&gt; foldr const 0 ([1] ++ undefined)
1
Prelude&gt; head ([1] ++ undefined)
1
Prelude&gt; tail ([1] ++ undefined)
*** Exception: Prelude.undefined</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 570
Similarly for foldl:
foldl (flip const) 0 [1..5]
Herefoldlwill recurse to the final cons cell, evaluate (flip
const) (...) 5 , ignore the rest of the fold that would occur
from the beginning up to the number 5, and return 5.
The relationship between foldrandfoldlis such that:
foldr f z xs =
foldl (flip f) z (reverse xs)
Butonlyfor finite lists! Consider:
Prelude&gt; let xs = repeat 0 ++ [1,2,3]
Prelude&gt; foldr const 0 xs
0
Prelude&gt; let xs' = repeat 1 ++ [1,2,3]
Prelude&gt; let rxs = reverse xs'
Prelude&gt; foldl (flip const) 0 rxs
^CInterrupted.
-- ^^ bottom.
If we flip our folding function ùëìand reverse the list ùë•ùë†,foldr
andfoldlwill return the same result:
Prelude&gt; let xs = [1..5]
Prelude&gt; foldr (:) [] xs</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 571
[1,2,3,4,5]
Prelude&gt; foldl (flip (:)) [] xs
[5,4,3,2,1]
Prelude&gt; foldl (flip (:)) [] (reverse xs)
[1,2,3,4,5]
Prelude&gt; reverse $ foldl (flip (:)) [] xs
[1,2,3,4,5]
10.8 Summary
We presented a lot of material in this chapter. You might be
feeling a little weary of folds right now. So what‚Äôs the executive
summary?
foldr
1.The rest of the fold (recursive invocation of foldr) is an
argument to the folding function you passed to foldr. It
doesn‚Äôt directly self-call as a tail-call like foldl. You could
think of it as alternating between applications of foldrand
your folding function ùëì. The next invocation of foldris
conditional on ùëìhaving asked for more of the results of
having folded the list. That is:
foldr::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b
-- ^</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 572
Thatùëèwe‚Äôre pointing at in (a -&gt; b -&gt; b) istherestofthefold.
Evaluating that evaluates the next application of foldr.
2.Associates to the right.
3.Works with infinite lists. We know this because:
Prelude&gt; foldr const 0 [1..]
1
4.Is a good default choice whenever you want to transform
data structures, be they finite or infinite.
foldl
1.Self-calls (tail-call) through the list, only beginning to
produce values after reaching the end of the list.
2.Associates to the left.
3.Cannot be used with infinite lists. Try the infinite list
example earlier and your REPL will hang.
4.Is nearly useless and should almost always be replaced
withfoldl' for reasons we‚Äôll explain later when we talk
about writing efficient Haskell programs.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 573
10.9 Scans
Scans, which we have mentioned above, work similarly to
maps and also to folds. Like folds, they accumulate values
instead of keeping the list‚Äôs individual values separate. Like
maps, they return a list of results. In this case, the list of results
shows the intermediate stages of evaluation, that is, the values
that accumulate as the function is doing its work.
Scans are not used as frequently as folds, and once you
understand the basic mechanics of folding, there isn‚Äôt a whole
lot new to understand. Still, it is useful to know about them
and get an idea of why you might need them.3
First, let‚Äôs take a look at the types. We‚Äôll do a direct com-
parison of the types of folds and scans so the diÔ¨Äerence is
clear:
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
scanr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
scanl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]
The primary diÔ¨Äerence is that the final result is a list (folds
canreturn a list as a result as well, but they don‚Äôt always). This
3The truth is scans are not used often, but there are times when you want to fold
a function over a list and return a list of the intermediate values that you can then use
as input to some other function. For a particularly elegant use of this, please see Chris
Done‚Äôs blog post about this solution to the waterfall problem at http://chrisdone.com/
posts/twitter-problem-loeb .</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 574
means that they are not catamorphisms and, in an important
sense, aren‚Äôt folds at all. But no matter! The type signatures
are similar, and the routes of spine traversal and evaluation
are similar. This does mean that you can use scans in places
that you can‚Äôt use a fold, precisely because you return a list of
results rather than reducing the spine of the list.
The results that scans produce can be represented like this:
scanr (+) 0 [1..3]
[1 + (2 + (3 + 0)), 2 + (3 + 0), 3 + 0, 0]
[6, 5, 3, 0]
scanl (+) 0 [1..3]
[0, 0 + 1,0 + 1 + 2, 0 + 1 + 2 + 3]
[0, 1, 3, 6]</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 575
scanl(+)1[1..3]
-- unfolding the
-- definition of scanl
=[1,1+1
, (1+1)+2
, ((1+1)+2)+3
]
-- evaluating addition
=[1,2,4,7]
Then to make this more explicit and properly equational,
we can follow along with how scanlexpands for this expression
based on the definition. First, we must see how scanlis defined.
We‚Äôre going to show you a version of it from a slightly older
baselibrary for GHC Haskell. The diÔ¨Äerences don‚Äôt change
anything important for us here:
scanl::(a-&gt;b-&gt;a)-&gt;a-&gt;[b]-&gt;[a]
scanlf q ls=
q:(caselsof
[]-&gt;[]
x:xs-&gt;scanl f (f q x) xs)
In an earlier chapter, we wrote a recursive function that</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 576
returned the nth Fibonacci number to us. You can use a scan
function to return a list of Fibonacci numbers. We‚Äôre going
to do this in a source file because this will, in this state, return
an infinite list (feel free to try loading it into your REPL and
running it, but be quick with the ctrl-c):
fibs=1:scanl (+)1fibs
We start with a value of 1 and cons that onto the front of the
list generated by our scan. The list itself has to be recursive
because, as we saw previously, the idea of Fibonacci numbers
is that each one is the sum of the previous two in the sequence;
scanning the results of (+)over a nonrecursive list of numbers
whose start value is 1 would give us this:
scanl (+) 1 [1..3]
[1, 1 + 1, (1 + 1) + 2, ((1 + 1) + 2) + 3]
[1,2,4,7]
instead of the [1, 1, 2, 3, 5...] that we‚Äôre looking for.
Getting the fibonacci number we want
But we don‚Äôt really want an infinite list of Fibonacci numbers;
that isn‚Äôt very useful. We need a method to either take some
number of elements from that list or find the ùëõth element as
we had done before. Fortunately, that‚Äôs the easy part. We‚Äôll</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 577
use the ‚Äúbang bang‚Äù operator, !!, to find the ùëõth element. This
operator is a way to index into a list, and indexing in Haskell
starts from zero. That is, the first value in your list is indexed
as zero. But otherwise the operator is straightforward:
(!!) :: [a] -&gt; Int -&gt; a
It needs a list as its first argument, an Intas its second argu-
ment and it returns one element from the list. Which item it
returns is the value that is in the ùëõth spot where ùëõis ourInt.
We will modify our source file:
fibs =1:scanl (+)1fibs
fibsNx=fibs!!x
Once we load the file into our REPL, we can use fibsNto
return the ùëõth element of our scan:
Prelude&gt; fibsN 0
1
Prelude&gt; fibsN 2
2
Prelude&gt; fibsN 6
13
Now you can modify your source code to use the takeor
takeWhile functions or to filter it in any way you like. One</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 578
note: filtering without also taking won‚Äôt work too well, because
you‚Äôre still getting an infinite list. It‚Äôs a filtered infinite list, sure,
but still infinite.
Scans Exercises
1.Modify your fibsfunction to only return the first 20 Fi-
bonacci numbers.
2.Modify fibsto return the Fibonacci numbers that are less
than 100.
3.Try to write the factorial function from Recursion as a
scan. You‚Äôll want scanlagain, and your start value will be</p>
<ol>
<li>Warning: this will also generate an infinite list, so you
may want to pass it through a takefunction or similar.
10.10 Chapter Exercises
Warm-up and review
For the following set of exercises, you are not expected to use
folds. These are intended to review material from previous
chapters. Feelfreetouseanysyntaxorstructurefromprevious
chapters that seems appropriate.
1.Given the following sets of consonants and vowels:</li>
</ol>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 579
stops = &quot;pbtdkg&quot;
vowels = &quot;aeiou&quot;
a)Write a function that takes inputs from stopsand
vowels and makes 3-tuples of all possible stop-vowel-
stop combinations. These will not all correspond to
real words in English, although the stop-vowel-stop
pattern is common enough that many of them will.
b)Modify that function so that it only returns the com-
binations that begin with a p.
c)Now set up lists of nouns and verbs (instead of stops
and vowels) and modify the function to make tuples
representing possible noun-verb-noun sentences.
2.What does the following mystery function do? What is
its type? Try to get a good sense of what it does before
you test it in the REPL to verify it.
seekritFunc x=
div (sum (map length (words x)))
(length (words x))
3.We‚Äôd really like the answer to be more precise. Can you
rewrite that using fractional division?</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 580
Rewriting functions using folds
In the previous chapter, you wrote these functions using direct
recursion over lists. The goal now is to rewrite them using
folds. Where possible, to gain a deeper understanding of
folding, try rewriting the fold version so that it is point-free.
Point-free versions of these functions written with a fold
should look like:
myFunc=foldr f z
So for example with the andfunction:
-- Again, this type will be less
-- reusable than the one in GHC 7.10
-- and newer. Don't worry.
-- direct recursion, not using (&amp;&amp;)
myAnd::[Bool]-&gt;Bool
myAnd[]=True
myAnd(x:xs)=
ifx==False
thenFalse
elsemyAnd xs</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 581
-- direct recursion, using (&amp;&amp;)
myAnd::[Bool]-&gt;Bool
myAnd[]=True
myAnd(x:xs)=x&amp;&amp;myAnd xs
-- fold, not point-free
-- in the folding function
myAnd::[Bool]-&gt;Bool
myAnd=foldr
(\a b-&gt;
ifa==False
thenFalse
elseb)True
-- fold, both myAnd and the folding
-- function are point-free now
myAnd::[Bool]-&gt;Bool
myAnd=foldr (&amp;&amp;)True
The goal here is to converge on the final version where
possible. You don‚Äôt need to write all variations for each ex-
ample, but the more variations you write, the deeper your
understanding of these functions will become.
1.myOrreturns Trueif anyBoolin the list is True.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 582
myOr::[Bool]-&gt;Bool
myOr=undefined
2.myAnyreturns Trueifa -&gt; Bool applied to any of the values
in the list returns True.
myAny::(a-&gt;Bool)-&gt;[a]-&gt;Bool
myAny=undefined
Example for validating myAny:
Prelude&gt; myAny even [1, 3, 5]
False
Prelude&gt; myAny odd [1, 3, 5]
True
3.Write two versions of myElem. One version should use
folding and the other should use any.
myElem::Eqa=&gt;a-&gt;[a]-&gt;Bool
Prelude&gt; myElem 1 [1..10]
True
Prelude&gt; myElem 1 [2..10]
False
4.Implement myReverse, don‚Äôt worry about trying to make
it lazy.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 583
myReverse ::[a]-&gt;[a]
myReverse =undefined
Prelude&gt; myReverse &quot;blah&quot;
&quot;halb&quot;
Prelude&gt; myReverse [1..5]
[5,4,3,2,1]
5.WritemyMapin terms of foldr. It should have the same
behavior as the built-in map.
myMap::(a-&gt;b)-&gt;[a]-&gt;[b]
myMap=undefined
6.WritemyFilter in terms of foldr. It should have the same
behavior as the built-in filter .
myFilter ::(a-&gt;Bool)-&gt;[a]-&gt;[a]
myFilter =undefined
7.squish flattens a list of lists into a list
squish::[[a]]-&gt;[a]
squish=undefined
8.squishMap maps a function over a list and concatenates the
results.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 584
squishMap ::(a-&gt;[b])-&gt;[a]-&gt;[b]
squishMap =undefined
Prelude&gt; squishMap (\x -&gt; [1, x, 3]) [2]
[1,2,3]
Prelude&gt; let f x = &quot;WO &quot; ++ [x] ++ &quot; OT &quot;
Prelude&gt; squishMap f &quot;blah&quot;
&quot;WO b OT WO l OT WO a OT WO h OT &quot;
9.squishAgain flattens a list of lists into a list. This time re-use
thesquishMap function.
squishAgain ::[[a]]-&gt;[a]
squishAgain =undefined
10.myMaximumBy takes a comparison function and a list and
returns the greatest element of the list based on the last
value that the comparison returned GTfor.
myMaximumBy ::(a-&gt;a-&gt;Ordering )
-&gt;[a]
-&gt;a
myMaximumBy =undefined
Prelude&gt; myMaximumBy (_ _ -&gt; GT) [1..10]
1
Prelude&gt; myMaximumBy (_ _ -&gt; LT) [1..10]</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 585
10
Prelude&gt; myMaximumBy compare [1..10]
10
11.myMinimumBy takes a comparison function and a list and
returns the least element of the list based on the last value
that the comparison returned LTfor.
myMinimumBy ::(a-&gt;a-&gt;Ordering )
-&gt;[a]
-&gt;a
myMinimumBy =undefined
Prelude&gt; myMinimumBy (_ _ -&gt; GT) [1..10]
10
Prelude&gt; myMinimumBy (_ _ -&gt; LT) [1..10]
1
Prelude&gt; myMinimumBy compare [1..10]
1
10.11 Definitions
1.Afoldis a higher-order function which, given a function
to accumulate the results and a recursive data structure,
returns the built up value. Usually a ‚Äústart value‚Äù for the
accumulation is provided along with a function that can</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 586
combine the type of values in the data structure with the
accumulation. The term fold is typically used with ref-
erence to collections of values referenced by a recursive
datatype. For a generalization of ‚Äúbreaking down struc-
ture‚Äù, see catamorphism .
2.Acatamorphism is a generalization of folds to arbitrary
datatypes. Where a fold allows you to break down a list
into an arbitrary datatype, a catamorphism is a means of
breaking down the structure of any datatype. The bool
:: a -&gt; a -&gt; Bool -&gt; a function in Data.Bool is an example
of a simple catamorphism for a simple, non-collection
datatype. Similarly, maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt;
bis the catamorphism for Maybe. See if you can notice a
pattern:</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 587
dataBool=False|True
bool::a-&gt;a-&gt;Bool-&gt;a
dataMaybea=Nothing |Justa
maybe::b-&gt;(a-&gt;b)-&gt;Maybea-&gt;b
dataEithera b=Lefta|Rightb
either::(a-&gt;c)
-&gt;(b-&gt;c)
-&gt;Eithera b
-&gt;c
3.Atail call is the final result of a function. Some examples
of tail calls in Haskell functions:
fx y z=h (subFunction x y z)
wheresubFunction x y z =g x y z
-- the ``tail call'' is
-- h (subFunction x y z)
-- or more precisely, h.
4.Tail recursion is a function whose tail calls are recursive
invocations of itself. This is distinguished from functions
that call other functions in their tail call.
fx y z=h (subFunction x y z)
wheresubFunction x y z =g x y z</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 588
The above is not tail recursive, calls ‚Ñé, not itself.
fx y z=h (f (x -1) y z)
Still not tail recursive. ùëìis invoked again but not in the
tail call of ùëì; it‚Äôs an argument to the tail call, ‚Ñé:
fx y z=f (x-1) y z
This is tail recursive. ùëìis calling itself directly with no
intermediaries.
foldrf z[]=z
foldrf z (x:xs)=f x (foldr f z xs)
Not tail recursive, we give up control to the combining
function ùëìbefore continuing through the list. foldr‚Äôs re-
cursive calls will bounce between foldrandùëì.
foldlf z[]=z
foldlf z (x:xs)=foldl f (f z x) xs
Tail recursive. foldlinvokes itself recursively. The com-
bining function is only an argument to the recursive fold.</p>
<p>CHAPTER 10. DATA STRUCTURE ORIGAMI 589
10.12 Follow-up resources
1.Haskell Wiki. Fold.
https://wiki.haskell.org/Fold
2.Richard Bird. Sections 4.5 and 4.6 of Introduction to
Functional Programming using Haskell (1998).
3.Antoni Diller. Introduction to Haskell.
4.Graham Hutton. A tutorial on the universality and ex-
pressiveness of fold.
http://www.cs.nott.ac.uk/~gmh/fold.pdf</p>
<p>Chapter 11
Algebraic datatypes
The most depressing
thing about life as a
programmer, I think, is if
you‚Äôre faced with a chunk
of code that either
someone else wrote or,
worse still, you wrote
yourself but no longer
dare to modify. That‚Äôs
depressing.
Simon Peyton Jones
590</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 591
11.1 Algebraic datatypes
We have spent a lot of time talking about datatypes already, so
you may think we‚Äôve covered everything that needs to be said
about those. This chapter‚Äôs purpose is ultimately to explain
how to construct your own datatypes in Haskell. Writing your
own datatypes can help you leverage some of Haskell‚Äôs most
powerful features ‚Äî pattern matching, type checking, and
inference ‚Äî in a way that makes your code more concise and
safer. But to understand that, first we need to explain the dif-
ferences among datatypes more fully and understand what it
means when we say datatypes are algebraic .
A type can be thought of as an enumeration of constructors
that have zero or more arguments.1We will return to this
description throughout the chapter, each time emphasizing a
diÔ¨Äerent portion of it.
Haskell oÔ¨Äers sum types, product types, product types with
record syntax, type aliases (for example, String is a type alias
for[Char] ), and a special datatype called a newtype that provides
for a diÔ¨Äerent set of options and constraints from either type
synonyms or data declarations. We will explain each of these
in detail in this chapter and show you how to exploit them for
maximum utility and type safety.
This chapter will:
1This description, slightly edited for our purposes, was proposed by Orah Kittrell in
the#haskell-beginners IRC channel.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 592
‚Ä¢explain the ‚Äúalgebra‚Äù of algebraic datatypes;
‚Ä¢analyze the construction of data constructors;
‚Ä¢spell out when and how to write your own datatypes;
‚Ä¢clarify usage of type synonyms and newtype ;
‚Ä¢introduce kinds.
11.2 Data declarations review
We often want to create custom datatypes for structuring and
describing the data we are processing. Doing so can help you
analyze your problem by allowing you to focus first on how
youmodel the domain before you begin thinking about how
you write computations that solve your problem. It can also
make your code easier to read and use because it lays the
domain model out clearly.
In order to write your own types, though, you must under-
stand the way datatypes are constructed in more detail than
we‚Äôve covered so far. Let‚Äôs begin with a review of the important
parts of datatypes, using the data declarations for Booland lists:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 593
dataBool=False|True
-- [1] [2] [3] [4] [5] [6]
data[]a=[ ]|a:[a]
-- [ 7 ] [8] [9]
1.Keyword datato signal that what follows is a data declara-
tion, or a declaration of a datatype.
2.Type constructor (with no arguments).
3.Equals sign divides the type constructor from its data
constructors.
4.Data constructor. In this case, a data constructor that takes
no arguments and so is called a nullary constructor. This
is one of the possible values of this type that can show up
in term-level code.
5.The pipe denotes a sum type which indicates a logical
disjunction (colloquially, or) in what values can have that
type.
6.Constructor for the value True, another nullary construc-
tor.
7.Type constructor with an argument. An empty list has
to be applied to an argument in order to become a list</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 594
ofsomething . Here the argument is a polymorphic type
variable, so the list‚Äôs argument can be of diÔ¨Äerent types.
8.Data constructor for the empty list.
9.Data constructor that takes two arguments: an ùëéand also
a[a].
When we talk about a data declaration, we are talking about
the definition of the entiretype. If wethink of a type as ‚Äúanenu-
meration of constructors that have zeroor more arguments,‚Äù
thenBoolis an enumeration of two possible constructors, each
of which takes zeroarguments, while the type constructor []
enumerates two possible constructors and one of them takes
twoarguments. The pipe denotes what we call a sum type , a
type that has more than one constructor inhabiting it.
In addition to sum types, Haskell also has product types , and
we‚Äôll talk more about those in a bit. The data constructors in
product types have more than one parameter. But first, let‚Äôs
turn our attention to the meaning of the word constructors .
11.3 Data and type constructors
There are two kinds of constructors in Haskell: type construc-
tors and data constructors. Type constructors are used only
at the type level, in type signatures and typeclass declarations
and instances. Types are static and resolve at compile time.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 595
Data constructors construct the values at term level, values
you can interact with at runtime. We call them constructors
because they define a means of creating or building a type or
a value.
Although the term constructor is often used to describe all
type constructors and data constructors, we can make a dis-
tinction between constants andconstructors . Type and data con-
structors that take no arguments are constants. They can only
store a fixed type and amount of data. So, in the Booldatatype,
for example, Boolis a type constant, a concrete type that isn‚Äôt
waiting for any additional information in the form of an argu-
ment in order to be fully realized as a type. It enumerates two
values that are also constants, TrueandFalse, because they take
no arguments. While we call TrueandFalse‚Äúdata constructors,‚Äù
in fact since they take no arguments, their value is already es-
tablished and not being constructed in any meaningful sense.
However, sometimes we need the flexibility of allowing dif-
ferent types or amounts of data to be stored in our datatypes.
For those times, type and data constructors may be parame-
terized. When a constructor takes an argument, then it‚Äôs like a
function in at least one sense ‚Äî it must be applied to become a
concrete type or value. The following datatypes are pseudony-
mous versions of real datatypes in Haskell. We‚Äôve given them
pseudonyms because we want to focus on the syntax, not the
semantics, for now.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 596
dataTrivial =Trivial'
-- [1] [2]
dataUnaryTypeCon a=UnaryValueCon a
-- [3] [4]
1.Here the type constructor Trivial is like a constant value,
but at the type level. It takes no arguments and is thus
nullary . The Haskell Report calls these typeconstants to dis-
tinguish them from type constructors that take arguments.
2.The data constructor Trivial' is also like a constant value,
but it exists in value, term, or runtime space. These are
not three diÔ¨Äerent things, but three diÔ¨Äerent words for
the same space that types serve to describe.
3.UnaryTypeCon is a type constructor of one argument. It‚Äôs a
constructor awaiting a type constant to be applied to, but
it has no behavior in the sense that we think of functions
as having. Such type-level functions exist but are not
covered in this book.2
4.UnaryValueCon is a data constructor of one argument await-
ing a value to be applied to. Again, it doesn‚Äôt behave like
2If you‚Äôre interested in learning about this topic, Brent Yorgey‚Äôs blog posts about type
families and functional dependencies are a good place to start. https://byorgey.wordpress.
com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 597
a term-level function in the sense of performing an oper-
ation on data. It‚Äôs more like a box to put values into. Be
careful with the box/container analogy as it will betray
you later ‚Äî not all type arguments to constructors have
value-level witnesses! Some are phantom .
Each of these datatypes only enumerates one data construc-
tor. Whereas Trivial' is the only possible concrete value for
typeTrivial ,UnaryValueCon could show up as diÔ¨Äerent literal
values at runtime, depending on what type of ùëéit is applied to.
Think back to the list datatype: at the type level, you have a :
[a]where the ùëéis a variable. At the term level, in your code,
that will be applied to some type of values and become, for
example, [Char] or[Integer] (or list of whatever other concrete
type ‚Äî obviously the set of possible lists is large).
11.4 Type constructors and kinds
Let‚Äôs look again at the list datatype:
data[]a=[]|a:[a]
This must be applied to a concrete type before you have a
list. We can see the parallel with functions when we look at
thekindsignature.
Kinds are the types of types, or types one level up. We
represent kinds in Haskell with *. We know something is a</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 598
fully applied, concrete type when it is represented as <em>. When
it is</em> -&gt; * , it, like a function, is still waiting to be applied.
Compare the following:
Prelude&gt; let f = not True
Prelude&gt; :t f
f :: Bool
Prelude&gt; let f x = x &gt; 3
Prelude&gt; :t f
f :: (Ord a, Num a) =&gt; a -&gt; Bool
The first ùëìtakes no arguments and is not awaiting appli-
cation to anything in order to produce a value, so its type
signature is a concrete type ‚Äî note the lack of a function ar-
row. But the second ùëìis awaiting application to an ùë•so its type
signature has a function arrow. Once we apply it to a value, it
also has a concrete type:
Prelude&gt; let f x = x &gt; 3
Prelude&gt; :t f 5
f 5 :: Bool
We query the kind signature of a type constructor (not a
data constructor) in GHCi with a :kindor:k. We see that kind
signatures give us similar information about type constructors:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 599
Prelude&gt; :k Bool
Bool :: *
Prelude&gt; :k [Int]
[Int] :: *
Prelude&gt; :k []
[] :: * -&gt; *
BothBooland[Int]are fully applied, concrete types, so their
kind signatures have no function arrows. That is, they are not
awaiting application to anything in order to be fully realized.
The kind of [], though, is * -&gt; * because it still needs to be
applied to a concrete type before it is itself a concrete type.
This is what the constructor of ‚Äútype constructor‚Äù is referring
to.
11.5 Data constructors and values
We mentioned a bit ago that the Haskell Report draws a distinc-
tion between type constants and type constructors . We can draw
a similar distinction between data constructors and constant
values.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 600
dataPugType =PugData
-- [1] [2]
dataHuskyType a=HuskyData
-- [3] [4]
dataDogueDeBordeaux doge=
-- [5]
DogueDeBordeaux doge
-- [6]
1.PugType is the type constructor, but it takes no arguments
so we can think of it as being a type constant . This is
how the Haskell Report refers to such types. This type
enumerates one constructor.
2.PugData is the only data constructor for the type PugType .
It also happens to be a constant value because it takes no
arguments and stands only for itself. For any function
that requires a value of type PugType , you know that value
will bePugData .
3.HuskyType is the type constructor and it takes a single para-
metrically polymorphic type variable as an argument. It
also enumerates one data constructor.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 601
4.HuskyData is the data constructor for HuskyType . Note that
the type variable argument ùëédoesnotoccur as an argu-
ment to HuskyData or anywhere else after the =. That means
our type argument ùëéisphantom , or, ‚Äúhas no witness.‚Äù We
will elaborate on this later. Here HuskyData is a constant
value, like PugData .
5.DogueDeBordeaux is a type constructor and has a single type
variable argument like HuskyType , but called ùëëùëúùëîùëíinstead
ofùëé. Why? Because the names of variables don‚Äôt matter.
At any rate, this type also enumerates one constructor.
6.DogueDeBordeaux is the lone data constructor. It has the
same name as the type constructor, but they are not the
same thing. The ùëëùëúùëîùëítype variable in the type construc-
tor occurs also in the data constructor. Remember that,
because they are the same type variable, these must agree
with each other: ùëëùëúùëîùëímust equal ùëëùëúùëîùëí. If your type is
DogueDeBordeaux [Person] , you must necessarily have a list
ofPerson values contained in the DogueDeBordeaux value.
But because DogueDeBordeaux must be applied before it‚Äôs a
concrete value, its literal value at runtime can change:
Prelude&gt; :t DogueDeBordeaux
DogueDeBordeaux :: doge
-&gt; DogueDeBordeaux doge</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 602
We can query the type of the value (not the type construc-
tor but the data constructor ‚Äî it can be confusing when
the type constructor and the data constructor have the
same name, but it‚Äôs pretty common to do that in Haskell
because the compiler doesn‚Äôt confuse type names with
value names the way we mortals do). It tells us that once
ùëëùëúùëîùëíis bound to a concrete type, then this will be a value
of type DogueDeBordeaux doge . It isn‚Äôt a value yet, but it‚Äôs a
definition for how to construct a value of that type.
Here‚Äôs how to make a value of the type of each:
myPug=PugData ::PugType
myHusky ::HuskyType a
myHusky =HuskyData
myOtherHusky ::Numa=&gt;HuskyType a
myOtherHusky =HuskyData
myOtherOtherHusky ::HuskyType [[[[Int]]]]
myOtherOtherHusky =HuskyData
-- no witness to the contrary ^
This will work because the value 10 agrees with the type
variable being bound to Int:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 603
myDoge::DogueDeBordeaux Int
myDoge=DogueDeBordeaux 10
This will not work because 10 cannot be reconciled with
the type variable being bound to String :
badDoge ::DogueDeBordeaux String
badDoge =DogueDeBordeaux 10
Given this, we can see that constructors are how we create
values of types and refer to types in type signatures. There‚Äôs a
parallel here between type constructors and data constructors
that should be noted. We can illustrate this with a new canine-
oriented datatype:
dataDoggies a=
Huskya
|Mastiff a
deriving (Eq,Show)
-- type constructor awaiting an argument
Doggies
Note that the kind signature for the type constructor looks
like a function, and the type signature for either of its data
constructors looks similar.
This needs to be applied to become a concrete type:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 604
Prelude&gt; :k Doggies
Doggies :: * -&gt; *
And this needs to be applied to become a concrete value:
Prelude&gt; :t Husky
Husky :: a -&gt; Doggies a
So the behavior of constructors is such that if they don‚Äôt take
any arguments, they behave like (type or value-level) constants.
If they do take arguments, they act like (type or value-level)
functions that don‚Äôt doanything except get applied.
Exercises: Dog Types
Given the datatypes defined in the above sections,
1.IsDoggies a type constructor or a data constructor?
2.What is the kind of Doggies ?
3.What is the kind of Doggies String ?
4.What is the type of Husky 10 ?
5.What is the type of Husky (10 :: Integer) ?
6.What is the type of Mastiff &quot;Scooby Doo&quot; ?
7.IsDogueDeBordeaux a type constructor or a data constructor?</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 605
8.What is the type of DogueDeBordeaux ?
9.What is the type of DogueDeBordeaux &quot;doggie!&quot;
11.6 What‚Äôs a type and what‚Äôs data?
As we‚Äôve said, types are static and resolve at compile time.
Types are known before runtime, whether through explicit
declaration or type inference, and that‚Äôs what makes them
static types. Information about types does not persist through
to runtime. Data are what we‚Äôre working with at runtime.
Here compile time is literally when your program is getting
compiled by GHC or checked before execution in a REPL
like GHCi. Runtime is the actual execution of your program.
Types circumscribe values and in that way, they describe which
values are flowing through what parts of your program.
type constructors -- compile-time
-------------------- phase separation
data constructors -- runtime
Both data constructors and type constructors begin with
capital letters, but a constructor beforethe=in a datatype defini-
tion is a type constructor, while constructors afterthe=are data
constructors. Data constructors are usually generated by the</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 606
declaration. One tricky bit here is that when data constructors
take arguments, those arguments refer to other types . Because
of this, not everything referred to in a datatype declaration is
necessarily generated by that datatype itself. Let‚Äôs take a look at
a short example with diÔ¨Äerent datatypes to demonstrate what
we mean by this.
We start with a datatype Pricethat has one type construc-
tor, one data constructor, and one type argument in the data
constructor:
dataPrice=
-- (a)
PriceInteger deriving (Eq,Show)
-- (b) [1]
The type constructor is (a). The data constructor is (b), and
that takes one type argument, [1].
The value Pricedoes not depend solely on this datatype
definition. It depends on the type Integer as well. If, for some
reason, Integer wasn‚Äôt in scope, we‚Äôd be unable to generate
Pricevalues.
Next, we‚Äôll define two datatypes, Manufacturer andAirline ,
that are each sum types with three data constructors. Each data
constructor in these is a possible value of that type, and since
none of them take arguments, all are generated by their decla-</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 607
rations and are more like constant values than constructors:
dataManufacturer =
-- (c)
Mini
-- (d)
|Mazda
-- (e)
|Tata
-- (f)
deriving (Eq,Show)
Manufacturer has the type constructor (c). Manufacturer has
three data constructors (d), (e), and (f).
dataAirline =
-- (g)
PapuAir
-- (h)
|CatapultsR'Us
-- (i)
|TakeYourChancesUnited
-- (j)
deriving (Eq,Show)</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 608
The type constructor is (g). Airline has three data construc-
tors (h), (i), and (j).
Next we‚Äôll look at another sum type, but this one has data
constructors that take arguments. For the type Vehicle , the
data constructors are CarandPlane, so aVehicle is either a Car
value or a Planevalue. They each take types as arguments, just
asPriceitself took the type Integer as an argument:
dataVehicle =CarManufacturer Price
-- (k) (l) [2] [3]
|PlaneAirline
-- (m) [4]
deriving (Eq,Show)
The type constructor is (k). There are two data constructors,
(l) and (m). The type arguments are numbered [2], [3], and
[4]. [2] and [3] are type arguments to the data constructor Car,
while [4] is the type argument to the data constructor Plane. To
construct a Planevalue, therefore, we need a value from the
Airline type.
In the above, the datatypes are generating the constructors
marked with a letter. The type arguments marked with a
number existed prior to the declarations. Their definitions
exist outside of this declaration, and they must be in scope to
be used as part of this declaration.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 609
Each of the above datatypes has a deriving clause. We have
seen this before, as it is usually true that you will want to de-
rive an instance of Showfor datatypes you write. The instance
allows your data to be printed to the screen as a string. De-
rivingEqis also common and allows you to derive equality
operations automatically for most datatypes where that would
make sense. There are other typeclasses that allow derivation
in this manner, and it obviates the need for manually writing
instances for each datatype and typeclass (reminder: you saw
an example of this in the Typeclasses chapter).
As we‚Äôve seen, data constructors can take arguments. Those
arguments will be specific types, but not specific values. In
standard Haskell, we can‚Äôt choose specific values of types as
type arguments. We can‚Äôt say, for example, ‚Äú Boolwithout the
possibility of Falseas a value.‚Äù If you accept Boolas a valid type
for a function or as the component of a datatype, you must
accept all of Bool.
Exercises: Vehicles
For these exercises, we‚Äôll use the datatypes defined in the above
section. It would be good if you‚Äôd typed them all into a source
file already, but if you hadn‚Äôt, please do so now. You can then
define some sample data on your own, or use these to get you
started:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 610
myCar =CarMini(Price14000)
urCar =CarMazda(Price20000)
clownCar =CarTata(Price7000)
doge =PlanePapuAir
1.What is the type of myCar?
2.Given the following, define the functions:
isCar::Vehicle -&gt;Bool
isCar=undefined
isPlane ::Vehicle -&gt;Bool
isPlane =undefined
areCars ::[Vehicle]-&gt;[Bool]
areCars =undefined
3.Now we‚Äôre going to write a function to tell us the manu-
facturer of a piece of data:
getManu ::Vehicle -&gt;Manufacturer
getManu =undefined
4.Given that we‚Äôre returning the Manufacturer , what will hap-
pen if you use this on Planedata?</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 611
5.All right. Let‚Äôs say you‚Äôve decided to add the size of the
plane as an argument to the Planeconstructor. Add that
to your datatypes in the appropriate places and change
your data and functions appropriately.
11.7 Data constructor arities
Now that we have a good understanding of the anatomy of
datatypes, we want to start demonstrating why we call them ‚Äúal-
gebraic.‚Äù We‚Äôll start by looking at something called arity. Arity
refers to the number of arguments a function or constructor
takes. A function that takes no arguments is called nullary ,
where nullary is a contraction of ‚Äúnull‚Äù and ‚Äú-ary‚Äù. Null means
zero, the ‚Äú-ary‚Äù suffix means ‚Äúof or pertaining to‚Äù. ‚Äú-ary‚Äù is a
common suffix used when talking about mathematical arity,
such as with nullary, unary, binary, and the like.
Data constructors which take no arguments are also called
nullary. Nullary data constructors, such as TrueandFalse, are
constant values at the term level and, since they have no argu-
ments, they can‚Äôt construct or represent any data other than
themselves. They are values which stand for themselves and
act as a witness of the datatype they were declared in.
We‚Äôve said that ‚ÄúA type can be thought of as an enumeration
of constructors that have zero or morearguments.‚Äù We‚Äôll look
next at constructors with arguments.
We‚Äôve seen how data constructors may take arguments and</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 612
that makes them more like a function in that they must be
applied to something before you have a value. Data construc-
tors that take one argument are called unary. As we will see
later in this chapter, data constructors that take more than one
argument are called products .
All of the following are valid data declarations:
-- nullary
dataExample0 =
Example0
deriving (Eq,Show)
-- unary
dataExample1 =
Example1 Int
deriving (Eq,Show)
-- product of Int and String
dataExample2 =
Example2 IntString
deriving (Eq,Show)
Prelude&gt; Example0
Example0
Prelude&gt; Example1 10
Example1 10</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 613
Prelude&gt; Example1 10 == Example1 42
False
Prelude&gt; let nc = Example2 1 &quot;NC&quot;
Prelude&gt; Example2 10 &quot;FlappityBat&quot; == nc
False
OurExample2 is an example of a product , like tuples, which
we‚Äôve seen before. Tuples can take several arguments ‚Äî as
many as there are inhabitants of each tuple ‚Äî and are consid-
ered the canonical product type; they are anonymous products
because they have no name. We‚Äôll talk more about product
types soon.
Unary (one argument) data constructors contain a single
value of whatever type their argument was. The following is a
data declaration that contains the data constructor MyVal.MyVal
takes one Intargument and creates a type named MyType :
dataMyType=MyValInt
-- [1] [2] [3]
deriving (Eq,Show)
-- [4] [5]
1.Type constructor.
2.Data constructor. MyValtakes one type argument, so it is
called a unary data constructor.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 614
3.Type argument to the definition of the data constructor
from [2].
4.Deriving clause.
5.Typeclass instances being derived. We‚Äôre getting equality
Eqand value stringification Showfor free.
Prelude&gt; :t MyVal
MyVal :: Int -&gt; MyType
Prelude&gt; MyVal 10
MyVal 10
Prelude&gt; MyVal 10 == MyVal 10
True
Prelude&gt; MyVal 10 == MyVal 9
False
Because MyValhas one Intargument, a value of type MyType
must contain one ‚Äî only one ‚Äî Intvalue.
11.8 What makes these datatypes
algebraic?
Algebraic datatypes in Haskell are algebraic because we can
describe the patterns of argument structures using two basic
operations: sum and product. The most direct way to explain
why they‚Äôre called sum and product is to demonstrate sum</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 615
and product in terms of cardinality . This can be understood in
terms of the cardinality you see with finite sets.3This doesn‚Äôt
map perfectly as we can have infinite data structures in Haskell,
but it‚Äôs a good way to begin understanding and appreciating
how datatypes work. When it comes to programming lan-
guages we are concerned with computable functions, not just
those which can generate a set.
The cardinality of a datatype is the number of possible
values it defines. That number can be as small as 0 or as large
as infinite (for example, numeric datatypes, lists). Knowing
how many possible values inhabit a type can help you reason
about your programs. In the following sections we‚Äôll show
you how to calculate the cardinality of a given datatype based
solely on how it is defined. From there, we can determine
how many diÔ¨Äerent possible implementations there are of a
function for a given type signature.
Before we get into the specifics of how to calculate cardi-
nality in general, we‚Äôre going to take cursory glances at some
datatypes with easy to understand cardinalities: BoolandInt.
We‚Äôve looked extensively at the Booltype already so you
already know it only has two inhabitants that are both nullary
data constructors, so Boolonly has two possible values. The
cardinality of Boolis, therefore, 2. Even without understanding
3Type theory was developed as an alternative mathematical foundation to set theory.
We won‚Äôt write formal proofs based on this, but the way we reason informally about types
as programmers derives in part from their origins as sets. Finite sets contain a number of
unique objects; that number is called cardinality.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 616
the rules of cardinality of sum types, we can see why this is
true.
Another set of datatypes with cardinality that is reasonably
easy to understand are the Inttypes. In part this is because Int
and related types Int8,Int16, andInt32have clearly delineated
upper and lower bounds, defined by the amount of memory
they are permitted to use. We‚Äôll use Int8here, even though it
isn‚Äôt very common in Haskell, because it has the smallest set
of possible inhabitants and thus the arithmetic is a bit easier
to do. Valid Int8values are whole numbers from (-128) to 127.
Int8is not included in the standard Prelude , unlike standard
Int, so we need to import it to see it in the REPL, but after
we do that we can use maxBound andminBound from the Bounded
typeclass to view the upper and lower values:
Prelude&gt; import Data.Int
Prelude Data.Int&gt; minBound :: Int8
-128
Prelude Data.Int&gt; maxBound :: Int8
127
Given that this range includes the value 0, we can easily
figure out the cardinality of Int8with some quick addition:
128 + 127 + 1 = 256. So the cardinality of Int8is 256. Anywhere
in your code where you‚Äôd have a value of type Int8, there are
256 possible runtime values.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 617
Exercises: Cardinality
While we haven‚Äôt explicitly described the rules for calculating
the cardinality of datatypes yet, you might already have an idea
of how to do it for simple datatypes with nullary constructors.
Try not to overthink these exercises ‚Äî follow your intuition
based on what you know.
1.dataPugType =PugData
2.For this one, recall that Boolis also defined with the |:
dataAirline =
PapuAir
|CatapultsR'Us
|TakeYourChancesUnited
3.Given what we know about Int8, what‚Äôs the cardinality of
Int16?
4.Use the REPL and maxBound andminBound to examine Int
andInteger . What can you say about the cardinality of
those types?
5.Extra credit (impress your friends!): What‚Äôs the connec-
tion between the 8 in Int8and that type‚Äôs cardinality of
256?</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 618
Simple datatypes with nullary data constructors
We‚Äôllstartourexplorationofcardinalitybylookingatdatatypes
with nullary data constructors:
dataExample =MakeExample deriving Show
Example is our type constructor, and MakeExample is our only
data constructor. Since MakeExample takes no type arguments, it
is a nullary constructor. We know that nullary data construc-
tors are constants and represent only themselves as values. It
is a single value whose only content is its name, not any other
data. Nullary constructors represent onevalue when reasoning
about the cardinality of the types they inhabit.
All you can say about MakeExample is that the constructor is
the value MakeExample and that it inhabits the type Example .
Theretheonlyinhabitantis MakeExample . Giventhat MakeExample
is a single nullary value, so the cardinality of the type Example is</p>
<ol>
<li>This is useful because it tells us that any time we see Example
in the type signature of a function, we only have to reason
about one possible value.
Exercises: For Example
1.You can query the type of a value in GHCi with the :type
command, also abbreviated :t.
Example:</li>
</ol>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 619
Prelude&gt; :t False
False :: Bool
What is the type of data constructor MakeExample ? What
happens when you request the type of Example ?
2.What if you try :infoonExample in GHCi? Can you deter-
mine what typeclass instances are defined for the Example
type using :infoin GHCi?
3.Try making a new datatype like Example but with a single
type argument added to MakeExample , such as Int. What has
changed when you query MakeExample with:typein GHCi?
Unary constructors
In the last section, we asked you to add a single type argument
to theMakeExample data constructor. In doing so, you changed
it from a nullary constructor to a unary one. A unary data con-
structor takes one argument. In the declaration of the datatype,
that parameter will be a type, not a value. Now, instead of your
data constructor being a constant, or a known value, the value
will be constructed at runtime from the argument we applied
it to.
Datatypes that only contain a unary constructor always have
the same cardinality as the type they contain. In the following,
Goatshas the same number of inhabitants as Int:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 620
dataGoats=GoatsIntderiving (Eq,Show)
Anything that is a valid Int, must also be a valid argument
to theGoatsconstructor. Anything that isn‚Äôt a valid Intalso
isn‚Äôt a valid count of Goats.
For cardinality, this means unary constructors are the iden-
tity function.
11.9 newtype
We will now look at a way to define a type that can only ever
have a single unary data constructor. We use the newtype key-
word to mark these types, as they are diÔ¨Äerent from type
declarations marked with the datakeyword as well as from
type synonym definitions marked by the typekeyword. Like
other datatypes that have a single unary constructor, the car-
dinality of a newtype is the same as that of the type it contains.
Anewtype cannot be a product type, sum type, or contain
nullary constructors, but it has a few advantages over a vanilla
datadeclaration. One is that it has no runtime overhead, as
it reuses the representation of the type it contains. It can do
this because it‚Äôs not allowed to be a record (product type) or
tagged union (sum type). The diÔ¨Äerence between newtype and
the type it contains is gone by the time the compiler generates
the code.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 621
To illustrate, let‚Äôs say we have a function from Int -&gt; Bool
for checking whether we have too many goats:
tooManyGoats ::Int-&gt;Bool
tooManyGoats n=n&gt;42
We might run into a problem here if we had diÔ¨Äerent limits
for diÔ¨Äerent sorts of livestock. What if we mixed up the Int
value of cows where we meant goats? Fortunately, there‚Äôs a
way to address this with unary constructors:
newtype Goats=
GoatsIntderiving (Eq,Show)
newtype Cows=
CowsIntderiving (Eq,Show)
Now we can rewrite our type to be safer, pattern matching
in order to access the Intinside our data constructor Goats:
tooManyGoats ::Goats-&gt;Bool
tooManyGoats (Goatsn)=n&gt;42
Now we can‚Äôt mix up our livestock counts:
Prelude&gt; tooManyGoats (Goats 43)
True
Prelude&gt; tooManyGoats (Cows 43)</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 622
Couldn't match expected type
‚ÄòGoats‚Äô with actual type ‚ÄòCows‚Äô
In the first argument of
‚ÄòtooManyGoats‚Äô, namely ‚Äò(Cows 43)‚Äô
In the expression: tooManyGoats (Cows 43)
Usingnewtype can deliver other advantages related to type-
class instances. To see these, we need to compare newtypes to
type synonyms and regular data declarations. We‚Äôll start with
a short comparison to type synonyms.
Anewtype is similar to a type synonym in that the represen-
tations of the named type and the type it contains are identical
and any distinction between them is gone at compile time. So,
aString really is a [Char] andGoatsabove is really an Int. On
the surface, for the human writers and readers of code, the
distinction can be helpful in tracking where data came from
and what it‚Äôs being used for, but the diÔ¨Äerence is irrelevant to
the compiler.
However, one key contrast between a newtype and a type
alias is that you can define typeclass instances for newtype s that
diÔ¨Äer from the instances for their underlying type. You can‚Äôt
do that for type synonyms. Let‚Äôs take a look at how that works.
We‚Äôll first define a typeclass called TooMany and an instance for
Int:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 623
classTooMany awhere
tooMany ::a-&gt;Bool
instance TooMany Intwhere
tooMany n =n&gt;42
We can use that instance in the REPL but only if we assign
the type Intto whatever numeric literal we‚Äôre passing as an
argument, because numeric literals are polymorphic. That
looks like this:
Prelude&gt; tooMany (42 :: Int)
Take a moment and play around with this ‚Äî try leaving oÔ¨Ä
the type declaration and giving it diÔ¨Äerent arguments.
Now, let‚Äôs say for your goat counting you wanted a special
instance of TooMany that will have diÔ¨Äerent behavior from the
Intinstance. Under the hood, Goatsis stillIntbut the newtype
declaration will allow you to define a custom instance:
newtype Goats=GoatsIntderiving Show
instance TooMany Goatswhere
tooMany ( Goatsn)=n&gt;43
Try loading this and passing diÔ¨Äerent arguments to it. Does
it behave diÔ¨Äerently than the Intinstance above? Do you still</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 624
need to explicitly assign a type to your numeric literals? What
is the type of tooMany ?
Here we were able to make the Goatsnewtype have an in-
stance of TooMany which had diÔ¨Äerent behavior than the type
Intwhich it contains. We can‚Äôt do this if it‚Äôs a type synonym.
Don‚Äôt believe us? Try it.
On the other hand, what about the case where we want to
reuse the typeclass instances of the type our newtype contains?
For common typeclasses built into GHC like Eq,Ord,Enum, and
Showwe get this facility for free, as you‚Äôve seen with the deriving
clauses in most datatypes.
For user-defined typeclasses, we can use a language exten-
sion called GeneralizedNewtypeDeriving . Language extensions,
enabled in GHC by the LANGUAGE pragma,4tell the compiler to
process input in ways beyond what the standard provides for.
In this case, this extension will tell the compiler to allow our
newtype to rely on a typeclass instance for the type it contains.
We can do this because the representations of the newtype and
the type it contains are the same. Still, it is outside of the
compiler‚Äôs standard behavior so we must give it the special
instruction to allow us to do this.
First, let‚Äôs take the case of what we must do without gener-
alized newtype deriving:
4Apragma is a special instruction to the compiler placed in source code. The LANGUAGE
pragma is perhaps more common in GHC Haskell than the other pragmas, but there are
other pragmas we will see later in the book.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 625
classTooMany awhere
tooMany ::a-&gt;Bool
instance TooMany Intwhere
tooMany n =n&gt;42
newtype Goats=
GoatsIntderiving (Eq,Show)
instance TooMany Goatswhere
tooMany ( Goatsn)=tooMany n
TheGoatsinstance will do the same thing as the Intinstance,
but we still have to define it separately.
You can test this yourself to see that they‚Äôll return the same
answers.
Now we‚Äôll add the pragma at the top of our source file:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 626
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
classTooMany awhere
tooMany ::a-&gt;Bool
instance TooMany Intwhere
tooMany n =n&gt;42
newtype Goats=
GoatsIntderiving (Eq,Show,TooMany)
Now we don‚Äôt have to define an instance of TooMany forGoats
that‚Äôs identical to the Intinstance. We can reuse the instance
that we already have.
This is also nice for times when we want every typeclass
instance to be the same except for the one we want to change.
Exercises: Logic Goats
1.Reusing the TooMany typeclass, write an instance of the
typeclass for the type (Int, String) . This will require
adding a language pragma named FlexibleInstances5if
you do not use a newtype ‚Äî GHC will tell you what to do.
5https://ghc.haskell.org/trac/haskell-prime/wiki/FlexibleInstances</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 627
2.Make another TooMany instance for (Int, Int) . Sum the
values together under the assumption this is a count of
goats from two fields.
3.Makeanother TooMany instance, thistimefor (Num a, TooMany
a) =&gt; (a, a) . This can mean whatever you want, such as
summing the two numbers together.
11.10 Sum types
Now that we‚Äôve looked at data constructor arities, we‚Äôre ready
to define the algebra of algebraic datatypes. The first that we‚Äôll
look at is the sum type such as Bool:
dataBool=False|True
We‚Äôve mentioned previously that the |represents logical
disjunction‚Äîthatis, ‚Äúor.‚Äù Thisisthe suminalgebraicdatatypes.
To know the cardinality of sum types, we addthe cardinalities
of their data constructors. TrueandFalsetake no type argu-
ments and thus are nullary constructors, each with a value of</p>
<ol>
<li></li>
</ol>
<p>Now we do some arithmetic. As we said earlier, nullary
constructors are 1, and sum types are +or addition, when we
are talking about cardinality:
dataBool=False|True</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 628
How many values inhabit Bool? There are two data con-
structors, each representing only one possible value. Given
that the |syntax represents (+)or addition:
-- ?? represents the cardinality
True|False= ??
True+False== ??
-- False and True both == 1
1+1== ??
We see that the cardinality of Boolis:
1+1==2
-- List of all possible values for Bool
[True,False]-- length is 2
You can check that in your REPL:
Prelude&gt; length (enumFrom False)
2
From this, we see that when working with a Boolvalue we
must reason about two possible values. Sum types are a way
of expressing alternate possibilities within a single datatype.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 629
Signed 8-bit hardware integers in Haskell are defined using
the aforementioned Int8datatype with a range of values from
-128 to 127. It‚Äôs not defined this way, but you could think of
it as a sum type of the numbers in that range, leading to the
cardinality of 256 as we saw.
Exercises: Pity the Bool
1.Given a datatype
dataBigSmall =
BigBool
|SmallBool
deriving (Eq,Show)
What is the cardinality of this datatype? Hint: We already
knowBool‚Äôs cardinality. Show your work as demonstrated
earlier.
2.Given a datatype</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 630
-- bring Int8 in scope
importData.Int
dataNumberOrBool =
NumbaInt8
|BoolyBool Bool
deriving (Eq,Show)
-- parentheses due to syntactic
-- collision between (-) minus
-- and the negate function
letmyNumba =Numba(-128)
What is the cardinality of NumberOrBool ? What happens if
you try to create a Numbawith a numeric literal larger than
127? And with a numeric literal smaller than (-128)?
If you choose (-128) for a value precisely, you‚Äôll notice
you get a spurious warning:
Prelude&gt; let n = Numba (-128)
Literal 128 is out of the
Int8 range -128..127
If you are trying to write a large negative
literal, use NegativeLiterals</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 631
Now, since -128 is a perfectly valid Int8value you could
choose to ignore this. What happens is that (-128) desug-
ars into (negate 128) . The compiler sees that you expect
the type Int8, butInt8‚Äôs max boundary is 127. So even
though you‚Äôre negating 128, it hasn‚Äôt done that step yet
andimmediately whines about 128 being larger than 127.
One way to avoid the warning is the following:
Prelude&gt; let n = (-128)
Prelude&gt; let x = Numba n
Or you can use the NegativeLiterals extension as it recom-
mends:
Prelude&gt; :set -XNegativeLiterals
Prelude&gt; let n = Numba (-128)
Note that the negative literals extension doesn‚Äôt prevent
the warning if you use negate .
11.11 Product types
What does it mean for a type to be a product? A product type‚Äôs
cardinality is the product of the cardinalities of its inhabitants.
Arithmetically, products are the result of multiplication . Where
a sum type was expressing or, a product type expresses and.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 632
For those that have programmed in C-like languages before,
a product is like a struct. For those that haven‚Äôt, a product is a
way to carry multiple values around in a single data construc-
tor. Any data constructor with two or more type arguments is
a product.
We said previously that tuples are anonymous products.
The declaration of the tuple type looks like this:
( , ) :: a -&gt; b -&gt; (a, b)
This is a product, like a product type: it gives you a way
to encapsulate two pieces of data, of possibly (though not
necessarily) diÔ¨Äerent types, in a single value.
We‚Äôll look next at a somewhat silly sum type:
dataQuantumBool =QuantumTrue
|QuantumFalse
|QuantumBoth
deriving (Eq,Show)
What is the cardinality of this sum type?
For reasons that will become obvious, a cardinality of 2
makes it harder to show the diÔ¨Äerence between sum and prod-
uct cardinality, so QuantumBool has a cardinality of 3. Now we‚Äôre
going to define a product type that contains two QuantumBool
values:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 633
dataTwoQs=
MkTwoQs QuantumBool QuantumBool
deriving (Eq,Show)
The datatype TwoQshas one data constructor, MkTwoQs , that
takes two arguments, making it a product of the two types that
inhabit it. Each argument is of type QuantumBool , which has a
cardinality of 3.
You can write this out to help you visualize it if you like. A
MkTwoQs value could be:
MkTwoQs QuantumTrue QuantumTrue
MkTwoQs QuantumTrue QuantumFalse
MkTwoQs QuantumTrue QuantumBoth
MkTwoQs QuantumFalse QuantumFalse
-- ...... and so on
Note that there is no special syntax denoting product types
as there was with sums and |.MkTwoQs is a data constructor
taking two type arguments, which both happen to be the same
type. It is a product type, the product of two QuantumBool s. The
number of potential values that can manifest in this type is the
cardinality of one of its type arguments times the cardinality
of the other. So, what is the cardinality of TwoQs?
We could have also written the TwoQstype using a type alias
and the tuple data constructor. Type aliases create type con-
structors, not data constructors:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 634
typeTwoQs=(QuantumBool ,QuantumBool )
The cardinality of this will be the same as it was previously.
The reason it‚Äôs important to understand cardinality is that
the cardinality of a datatype roughly equates to how difficult
it is to reason about.
Record syntax
Records in Haskell are product types with additional syntax to
provide convenient accessors to fields within the record. Let‚Äôs
begin by definining a simple product type:
dataPerson=
MkPerson StringInt
deriving (Eq,Show)
That is the familiar product type structure: the MkPerson
data constructor takes two type arguments in its definition, a
String value (a name) and an Intvalue (an age). The cardinality
of this is frankly terrifying.
As we‚Äôve seen in previous examples, we can unpack the
contents of this type using functions that return the value we
want from our little box of values:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 635
-- sample data
jm=MkPerson &quot;julie&quot; 108
ca=MkPerson &quot;chris&quot; 16
namae::Person-&gt;String
namae(MkPerson s_)=s
If you use the namaefunction in your REPL, it will return
theString value from your data.
Now let‚Äôs see how we could define a similar product type
but with record syntax:
dataPerson=
Person{ name::String
, age::Int}
deriving (Eq,Show)
You can see the similarity to the Person type defined above,
but defining it as a record means there are now named record
field accessors. They‚Äôre just functions that go from the product
type to a member of product:
Prelude&gt; :t name
name :: Person -&gt; String
Prelude&gt; :t age
age :: Person -&gt; Int</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 636
You can use this directly in GHCi:
Prelude&gt; Person &quot;Papu&quot; 5
Person {name = &quot;Papu&quot;, age = 5}
Prelude&gt; let papu = Person &quot;Papu&quot; 5
Prelude&gt; age papu
5
Prelude&gt; name papu
&quot;Papu&quot;
You can also do it from data that is in a file. Change the jm
andcadata above so that it is now of type Person , reload your
source file, and try using the record field accessors in GHCi to
query the values.
11.12 Normal form
We‚ÄôvelookedatthealgebrabehindHaskell‚Äôsalgebraicdatatypes,
and explored how this is useful for understanding the cardi-
nality of datatypes. But the algebra doesn‚Äôt stop there. All the
existing algebraic rules for products and sums apply in type
systems, and that includes the distributive property. Let‚Äôs take
a look at how that works in arithmetic:
2 * (3 + 4)
2 * (7)</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 637
14
We can rewrite this with the multiplication distributed over
the addition and obtain the same result:
2 * 3 + 2 * 4
(6) + (8)
14
This is known as a ‚Äúsum of products.‚Äù In normal arithmetic,
the expression is in normal form when it‚Äôs been reduced to
a final result. However, if you think of the numerals in the
above expressions as representations of set cardinality, then
the sum of products expression is in normal form, as there is
no computation to perform.
The distributive property can be generalized:
a * (b + c) -&gt; (a * b) + (a * c)
And this is true of Haskell‚Äôs types as well! Product types
distribute over sum types. To play with this, we‚Äôll first define
some datatypes:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 638
dataFiction =Fiction deriving Show
dataNonfiction =Nonfiction deriving Show
dataBookType =FictionBook Fiction
|NonfictionBook Nonfiction
deriving Show
We define two types with only single, nullary inhabitants:
Fiction andNonfiction . The reasons for doing that may not
be immediately clear but recall that we said you can‚Äôt use a
type while only permitting one of its inhabitants as a possible
value. You can‚Äôt ask for a value of type Boolwhile declaring
in your types that it must always be True‚Äî you must admit
the possibility of either Boolvalue. So, declaring the Fiction
andNonfiction types will allow us to factor out the book types
(below).
Then we have a sum type, BookType , with constructors that
take the Fiction andNonfiction typesas arguments. It‚Äôs impor-
tant to remember that, although the type constructors and data
constructors of Fiction andNonfiction have the same name,
they are not the same, and it is the type constructors that
are the arguments to FictionBook andNonfictionBook . Take a
moment and rename them to demonstrate this to yourself.
So, we have our sum type. Next we‚Äôre going to define a type
synonym called AuthorName and a product type called Author.
The type synonym doesn‚Äôt really do anything except help us</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 639
keep track of which String we‚Äôre using in the Author type:
typeAuthorName =String
dataAuthor=Author(AuthorName ,BookType )
This isn‚Äôt a sum of products, so it isn‚Äôt normal form. It
can, in some sense, be evaluated to tease apart the values that
are hiding in the sum type, BookType . Again, we can apply the
distributive property and rewrite Author in normal form:
typeAuthorName =String
-- If you have them in the same
-- file, you'll need to comment
-- out previous definitions of
-- Fiction and Nonfiction.
dataAuthor=
Fiction AuthorName
|Nonfiction AuthorName
deriving (Eq,Show)
Products distribute over sums. Just as we would do with
the expression a * (b + c) , where the inhabitants of the sum
typeBookType are the ùëèandùëê, we broke those values out and</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 640
made a sum of products. Now it‚Äôs in normal form because
no further evaluation can be done of these constructors until
some operation or computation is done using these types.
Another example of normal form can be found in the Expr
type which is very common to papers about type systems and
programming languages:
dataExpr=
NumberInt
|AddExprExpr
|MinusExpr
|MultExprExpr
|DivideExprExpr
This is in normal form because it‚Äôs a sum (type) of products:
(Number Int) + Add (Expr Expr) + ‚Ä¶
A stricter interpretation of normal form or ‚Äúsum of prod-
ucts‚Äù would require representing products with tuples and
sums with Either. The previous datatype in that form would
look like the following:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 641
typeNumber=Int
typeAdd=(Expr,Expr)
typeMinus=Expr
typeMult=(Expr,Expr)
typeDivide=(Expr,Expr)
typeExpr=
EitherNumber
(EitherAdd
(EitherMinus
(EitherMultDivide)))
This representation finds applications in problems where
one is writing functions or foldsover the representations of
datatypes, such as with generics and metaprogramming. Some
of these methods have their application in Haskell but should
be used judiciously and aren‚Äôt always easy to use.
TheEither type will be explained in detail in the next chap-
ter.
Exercises: How Does Your Garden Grow?</p>
<ol>
<li>Given the type</li>
</ol>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 642
dataFlowerType =Gardenia
|Daisy
|Rose
|Lilac
deriving Show
typeGardener =String
dataGarden=
GardenGardener FlowerType
deriving Show
What is the sum of products normal form of Garden ?
11.13 Constructing and deconstructing
values
There are essentially two things we can do with a value: we can
generate or construct it or we can match on it and consume
it. We talked above about why data and type constructors are
calledconstructors , and this section will elaborate on that and
how to construct values of diÔ¨Äerent types. You have already
been doing this in previous chapters, but we hope this section
will lead you to a deeper understanding.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 643
Construction and deconstruction of values form a duality.
Data is immutable in Haskell, so values carry with them the
information about how they were created. We can use that
information when we consume or deconstruct the value.
We‚Äôll start by defining a collection of datatypes:
dataGuessWhat =
Chickenbutt deriving (Eq,Show)
dataIda=
MkIdaderiving (Eq,Show)
dataProduct a b=
Product a bderiving (Eq,Show)
dataSuma b=
Firsta
|Secondb
deriving (Eq,Show)
dataRecordProduct a b=
RecordProduct { pfirst ::a
, psecond ::b }
deriving (Eq,Show)
Now that we have diÔ¨Äerent sorts of datatypes to work with,</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 644
we‚Äôll move on to constructing values of those types.
Sum and Product
HereSumandProduct are ways to represent arbitrary sums and
products in types. In ordinary Haskell code, it‚Äôs unlikely you‚Äôd
need or want nestable sums and products unless you were
doing something fairly advanced, but here we use them as a
means of demonstration.
If you have two values in a product, then the conversion
to using Product is straightforward (n.b.: The SumandProduct
declarations from above will need to be in scope for all the
following examples):</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 645
newtype NumCow=
NumCowInt
deriving (Eq,Show)
newtype NumPig=
NumPigInt
deriving (Eq,Show)
dataFarmhouse =
Farmhouse NumCowNumPig
deriving (Eq,Show)
typeFarmhouse' =Product NumCowNumPig
Farmhouse andFarmhouse' are the same.
For an example with three values in the product instead of
two, we must begin to take advantage of the fact that Product
takes two arguments, one of which can also be another Product
of values. In fact, you can nest them as far as you can stomach
or until the compiler chokes:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 646
newtype NumSheep =
NumSheep Int
deriving (Eq,Show)
dataBigFarmhouse =
BigFarmhouse NumCowNumPigNumSheep
deriving (Eq,Show)
typeBigFarmhouse' =
Product NumCow(Product NumPigNumSheep )
We can perform a similar trick with Sum:
typeName=String
typeAge=Int
typeLovesMud =Bool
Sheep can produce between 2 and 30 pounds (0.9 and 13
kilos) of wool per year! Icelandic sheep don‚Äôt produce as much
wool per year as other breeds but the wool they do produce is
a finer wool.
typePoundsOfWool =Int
dataCowInfo =
CowInfo NameAge
deriving (Eq,Show)</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 647
dataPigInfo =
PigInfo NameAgeLovesMud
deriving (Eq,Show)
dataSheepInfo =
SheepInfo NameAgePoundsOfWool
deriving (Eq,Show)
dataAnimal=
CowCowInfo
|PigPigInfo
|SheepSheepInfo
deriving (Eq,Show)
-- Alternately
typeAnimal' =
SumCowInfo (SumPigInfo SheepInfo )
Again in the REPL, we use FirstandSecond to pattern match
on the data constructors of Sum:
-- Getting it right
Prelude&gt; let bess' = (CowInfo &quot;Bess&quot; 4)
Prelude&gt; let bess = First bess' :: Animal'</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 648
Prelude&gt; :{
*Main| let e' =
*Main| Second (SheepInfo &quot;Elmer&quot; 5 5)
*Main| :}
Prelude&gt; let elmer = Second e' :: Animal'
-- Making a mistake
Prelude&gt; :{
*Main| let elmo' =
*Main| Second (SheepInfo &quot;Elmo&quot; 5 5)
*Main| :}
Prelude&gt; let elmo = First elmo' :: Animal'
Couldn't match expected type ‚ÄòCowInfo‚Äô
with actual type ‚ÄòSum a0 SheepInfo‚Äô
In the first argument of ‚ÄòFirst‚Äô, namely
‚Äò(Second (SheepInfo &quot;Elmo&quot; 5 5))‚Äô
In the expression:
First (Second (SheepInfo &quot;Elmo&quot; 5 5))
:: Animal'
The first data constructor, First, has the argument CowInfo ,
butSheepInfo is nested within the Second constructor (it is the
Second of the Second). We can see how they don‚Äôt match and
the mistaken attempt nests in the wrong direction.
Prelude&gt; let sheep = SheepInfo &quot;Baaaaa&quot; 5 5</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 649
Prelude&gt; :t First (Second sheep)
First (Second (SheepInfo &quot;Baaaaa&quot; 5 5))
:: Sum (Sum a SheepInfo) b
Prelude&gt; :info Animal'
type Animal' =
Sum CowInfo (Sum PigInfo SheepInfo)
-- Defined at code/animalFarm1.hs:61:1
As we said, the actual types SumandProduct themselves aren‚Äôt
used very often in standard Haskell code, but it can be useful to
develop an intuition about this structure to sum and product
types.
Constructing values
Our first datatype, GuessWhat , is trivial, equivalent to the ()unit
type:
trivialValue ::GuessWhat
trivialValue =Chickenbutt
Types like this are sometimes used to signal discrete con-
cepts that you don‚Äôt want to flatten into the unit type. We‚Äôll
elaborate on how this can make code easier to understand or
better abstracted later. There is nothing special in the syntax</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 650
here. We define trivialValue to be the nullary data constructor
Chickenbutt and we have a value of the type GuessWhat .
Next we look at a unary type constructor that contains one
unary data constructor:
dataIda=
MkIdaderiving (Eq,Show)
Because Idhas an argument, we have to apply it to some-
thing before we can construct a value of that type:
-- note:
-- MkId :: a -&gt; Id a
idInt::IdInteger
idInt=MkId10
We turn our attention to our product type with two argu-
ments. We‚Äôre going to define some type synonyms first to
make this more readable:
typeAwesome =Bool
typeName=String
person::Product NameAwesome
person=Product &quot;Simon&quot; True</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 651
The type synonyms Awesome andNamehere are for clarity.
They don‚Äôt obligate us to change our terms. We could have
used datatypes instead of type synonyms, as we will in the sum
type example below, but this is a quick and painless way to
construct the value that we need. Notice that we‚Äôre relying on
theProduct data constructor that we defined above. The Product
data constructor is a function of two arguments, the Nameand
Awesome . Notice, also, that Simons are invariably awesome.
Now we‚Äôll use the Sumtype defined above:
dataSuma b=
Firsta
|Secondb
deriving (Eq,Show)
dataTwitter =
Twitter deriving (Eq,Show)
dataAskFm=
AskFmderiving (Eq,Show)
socialNetwork ::SumTwitter AskFm
socialNetwork =FirstTwitter
Here our type is a sum of Twitter orAskFm. We don‚Äôt have
both values at the same time without the use of a product</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 652
because sums are a means of expressing disjunction or the
ability to have one of several possible values. We have to use
one of the data constructors generated by the definition of Sum
in order to indicate which of the possibilities in the disjunction
we mean to express. Consider the case where we mix them
up:
Prelude&gt; type SN = Sum Twitter AskFm
Prelude&gt; Second Twitter :: SN
Couldn't match expected type ‚ÄòAskFm‚Äô with
actual type ‚ÄòTwitter‚Äô
In the first argument of ‚ÄòSecond‚Äô,
namely ‚ÄòTwitter‚Äô
In the expression:
Second Twitter :: Sum Twitter AskFm
Prelude&gt; First AskFm :: Sum Twitter AskFm
Couldn't match expected type ‚ÄòTwitter‚Äô with
actual type ‚ÄòAskFm‚Äô
In the first argument of ‚ÄòFirst‚Äô,
namely ‚ÄòAskFm‚Äô
In the expression:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 653
First AskFm :: Sum Twitter AskFm
The appropriate assignment of types to specific construc-
tors is dependent on the assertions in the type. The type signa-
tureSum Twitter AskFm tells you which goes with the data con-
structor Firstand which goes with the data constructor Second .
We can assert that ordering directly by writing a datatype like
this:
dataSocialNetwork =
Twitter
|AskFm
deriving (Eq,Show)
Now the data constructors for Twitter andAskFmare direct
inhabitants of the sum type SocialNetwork , where before they
inhabited the Sumtype. Now let‚Äôs consider how this might look
with type synonyms:
typeTwitter =String
typeAskFm=String
twitter ::SumTwitter AskFm
twitter =First&quot;Twitter&quot;
askfm::SumTwitter AskFm
askfm=First&quot;AskFm&quot;</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 654
There‚Äôs a problem with the above example. The name
ofaskfmimplies we meant Second &quot;AskFm&quot; , but we messed up.
Because we used type synonyms instead of defining datatypes,
the type system didn‚Äôt catch the mistake. The typechecker has
no way of knowing we made a mistake because both values are
Strings . Try to avoid using type synonyms with unstructured
data like text or binary. Type synonyms are best used when
you want something lighter weight than newtypes but also
want your type signatures to be more explicit.
Finally, we‚Äôll consider the product that uses record syntax:
Prelude&gt; :t RecordProduct
RecordProduct :: a
-&gt; b
-&gt; RecordProduct a b
Prelude&gt; :t Product
Product :: a -&gt; b -&gt; Product a b
The first thing to notice is that you can construct values of
products that use record syntax in a manner identical to that
of non-record products. Records are just syntax to create field
references. They don‚Äôt do much heavy lifting in Haskell, but
they are convenient:
myRecord ::RecordProduct Integer Float
myRecord =RecordProduct 420.00001</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 655
We can take advantage of the fields that we defined on our
record to construct values in a slightly diÔ¨Äerent style. This can
be convenient for making things a little more obvious:
myRecord ::RecordProduct Integer Float
myRecord =
RecordProduct { pfirst =42
, psecond =0.00001 }
This is a bit more compelling when you have domain-
specific names for things:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 656
dataOperatingSystem =
GnuPlusLinux
|OpenBSDPlusNevermindJustBSDStill
|Mac
|Windows
deriving (Eq,Show)
dataProgLang =
Haskell
|Agda
|Idris
|PureScript
deriving (Eq,Show)
dataProgrammer =
Programmer { os::OperatingSystem
, lang::ProgLang }
deriving (Eq,Show)
Then we can construct a value from the record product
Programmer :
Prelude&gt; :t Programmer
Programmer :: OperatingSystem
-&gt; ProgLang
-&gt; Programmer</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 657
nineToFive ::Programmer
nineToFive =Programmer { os=Mac
, lang=Haskell }
-- We can reorder stuff
-- when we use record syntax
feelingWizardly ::Programmer
feelingWizardly =
Programmer { lang=Agda
, os=GnuPlusLinux }
Exercise: Programmers
Write a function that generates all possible values of Programmer .
Use the provided lists of inhabitants of OperatingSystem and
ProgLang .</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 658
allOperatingSystems ::[OperatingSystem ]
allOperatingSystems =
[GnuPlusLinux
,OpenBSDPlusNevermindJustBSDStill
,Mac
,Windows
]
allLanguages ::[ProgLang ]
allLanguages =
[Haskell,Agda,Idris,PureScript ]
allProgrammers ::[Programmer ]
allProgrammers =undefined
Programmer is a product of two types, you can determine how
many inhabitants of Programmer you have by calculating:
length allOperatingSystems
*length allLanguages
This is the essence of how product types and the number
of inhabitants relate.
There are several ways you could write a function to do
that, and some may produce a list that has duplicate values
in it. If your resulting list has duplicate values in it, you can</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 659
usenubfromData.List to remove duplicate values over your
allProgrammers value. Either way, if your result (minus any
duplicate values) equals the number returned by multiplying
those lengths together, you‚Äôve probably got it figured out. Try
to be clever and make it work without manually typing out
the values.
Accidental bottoms from records
We‚Äôre going to reuse the previous Programmer datatype to see
what happens if we construct a value using record syntax but
forget a field:
Prelude&gt; :{
*Main| let partialAf =
*Main| Programmer {os = GnuPlusLinux}
*Main| :}
Fields of ‚ÄòProgrammer‚Äô
not initialised: lang
In the expression:
Programmer {os = GnuPlusLinux}
In an equation for ‚ÄòpartialAf‚Äô:
partialAf =
Programmer {os = GnuPlusLinux}
-- and if we don't heed this warning...</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 660
Prelude&gt; partialAf
Programmer {os = GnuPlusLinux, lang =
*** Exception:
Missing field in
record construction lang
Donotdo this in your code! Either define the whole record
at once or not at all. If you think you need this, your code needs
to be refactored. Partial application of the data constructor
suffices to handle this:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 661
-- Works the same as if
-- we'd used record syntax.
dataThereYet =
ThereFloatIntBool
deriving (Eq,Show)
-- who needs a &quot;builder pattern&quot;?
notYet::Int-&gt;Bool-&gt;ThereYet
notYet=nope25.5
notQuite ::Bool-&gt;ThereYet
notQuite =notYet10
yusssss ::ThereYet
yusssss =notQuite False
-- Not I, said the Haskell user.
Notice the way our types progressed.
There::Float-&gt;Int-&gt;Bool-&gt;ThereYet
notYet:: Int-&gt;Bool-&gt;ThereYet
notQuite :: Bool-&gt;ThereYet
yusssss :: ThereYet</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 662
Percolate values through your programs, not bottoms.6
Deconstructing values
When we discussed folds, we mentioned the idea of catamor-
phism. We explained that catamorphism was about deconstruct-
inglists. This idea is generally applicable to any datatype that
has values. Now that we‚Äôve thoroughly explored constructing
values, the time has come to destroy what we have built. Wait,
no ‚Äî we mean deconstruct.
We begin, as always, with some datatypes:
6A favorite snack of the North American Yeti is bottom-propagating Haskellers.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 663
newtype Name =NameStringderiving Show
newtype Acres =AcresIntderiving Show
-- FarmerType is a Sum
dataFarmerType =DairyFarmer
|WheatFarmer
|SoybeanFarmer
deriving Show
-- Farmer is a plain ole product of
-- Name, Acres, and FarmerType
dataFarmer=
FarmerNameAcresFarmerType
deriving Show
Now we‚Äôre going to write a very basic function that breaks
down and unpacks the data inside our constructors:
isDairyFarmer ::Farmer-&gt;Bool
isDairyFarmer (Farmer_ _DairyFarmer )=
True
isDairyFarmer _ =
False
DairyFarmer is one value of the FarmerType type that is packed
up inside our Farmer product type. But our function can pull</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 664
that value out, pattern match on it, and tell us just what we‚Äôre
looking for.
Now an alternate formulation with a product that uses
record syntax:
dataFarmerRec =
FarmerRec { name ::Name
, acres ::Acres
, farmerType ::FarmerType }
deriving Show
isDairyFarmerRec ::FarmerRec -&gt;Bool
isDairyFarmerRec farmer=
casefarmerType farmer of
DairyFarmer -&gt;True
_ -&gt; False
This is just another way of unpacking or deconstructing the
contents of a product type.
Accidental bottoms from records
We take bottoms very seriously. You can easily propagate bottoms
through record types, and we implore you not to do so. Please,
do not do this:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 665
dataAutomobile =Null
|Car{ make::String
, model ::String
, year::Integer }
deriving (Eq,Show)
This is a terrible thing to do, for a couple of reasons. One
is thisNullnonsense. Haskell oÔ¨Äers you the perfectly lovely
datatype Maybe, which you should use instead. Secondly, con-
sider the case where one has a Nullvalue, but you‚Äôve used one
of the record accessors:
Prelude&gt; make Null
&quot;*** Exception: No match in
record selector make
-- Don't.
How do we fix this? Well, first, whenever we have a product
that uses record accessors, keep it separate of any sum type
that is wrapping it. To do this, split out the product into an
independent type with its own type constructor instead of
only as an inline data constructor product:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 666
-- Split out the record/product
dataCar=Car{ make::String
, model ::String
, year::Integer }
deriving (Eq,Show)
-- The Null is still not great, but
-- we're leaving it in to make a point
dataAutomobile =Null
|Automobile Car
deriving (Eq,Show)
Now if we attempt to do something silly, the type system
catches us:
Prelude&gt; make Null
Couldn't match expected type ‚ÄòCar‚Äô
with actual type ‚ÄòAutomobile‚Äô
In the first argument of ‚Äòmake‚Äô,
namely ‚ÄòNull‚Äô
In the expression: make Null
In Haskell, we want the typechecker to catch us doing things
wrong, so we can fix it before problems multiply and things go</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 667
wrong at runtime. But the typechecker can best help those
who help themselves.
11.14 Function type is exponential
In the arithmetic of calculating inhabitants of types, function
type is the exponent operator. Given a function a -&gt; b , we can
calculate the inhabitants with the formula ùëèu?.
So ifùëèandùëéareBool, then22is how you could express the
number of inhabitants in a function of Bool -&gt; Bool . Similarly,
a function of Boolto something of 3 inhabitants would be 32
and thus have nine possible implementations.
a-&gt;b-&gt;c
(c^b)^a
-- given arithmetic laws,
-- can be rewritten as
c^(b*a)
Earlier we identified the type (Bool, Bool) as having four
inhabitants. This can be determined by either writing out all
the possible unique inhabitants or, more easily, by doing the
arithmetic of (1 + 1) * (1 + 1) . Next we‚Äôll see that the type of
functions (-&gt;)is, in the algebra of types, the exponentiation</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 668
operator. We‚Äôll use a datatype with three cases because Bool
has one difficulty: two plus two, two times two, and two to
the power of two all equal the same thing. Let‚Äôs review the
arithmetic of sum types:
dataQuantum =
Yes
|No
|Both
deriving (Eq,Show)
-- 3 + 3
quantSum1 ::EitherQuantum Quantum
quantSum1 =RightYes
quantSum2 ::EitherQuantum Quantum
quantSum2 =RightNo
quantSum3 ::EitherQuantum Quantum
quantSum3 =RightBoth
quantSum4 ::EitherQuantum Quantum
quantSum4 =LeftYes
-- You can fill in the next two.
And now the arithmetic of product types:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 669
-- 3 * 3
quantProd1 ::(Quantum,Quantum)
quantProd1 =(Yes,Yes)
quantProd2 ::(Quantum,Quantum)
quantProd2 =(Yes,No)
quantProd3 ::(Quantum,Quantum)
quantProd3 =(Yes,Both)
quantProd4 ::(Quantum,Quantum)
quantProd4 =(No,Yes)
quantProd5 ::(Quantum,Quantum)
quantProd5 =(No,No)
quantProd6 ::(Quantum,Quantum)
quantProd6 =(No,Both)
quantProd7 ::(Quantum,Quantum)
quantProd7 =(Both,Yes)
-- You can determine the final two.
And now a function type. Each possible unique implemen-
tation of the function is an inhabitant:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 670
-- 3 ^ 3
quantFlip1 ::Quantum -&gt;Quantum
quantFlip1 Yes=Yes
quantFlip1 No=Yes
quantFlip1 Both=Yes
quantFlip2 ::Quantum -&gt;Quantum
quantFlip2 Yes=Yes
quantFlip2 No=Yes
quantFlip2 Both=No
quantFlip3 ::Quantum -&gt;Quantum
quantFlip3 Yes=Yes
quantFlip3 No=Yes
quantFlip3 Both=Both</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 671
quantFlip4 ::Quantum -&gt;Quantum
quantFlip4 Yes=Yes
quantFlip4 No=No
quantFlip4 Both=Yes
quantFlip5 ::Quantum -&gt;Quantum
quantFlip5 Yes=Yes
quantFlip5 No=Both
quantFlip5 Both=Yes
quantFlip6 ::Quantum -&gt;Quantum
quantFlip6 Yes=No
quantFlip6 No=Yes
quantFlip6 Both=Yes</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 672
quantFlip7 ::Quantum -&gt;Quantum
quantFlip7 Yes=Both
quantFlip7 No=Yes
quantFlip7 Both=Yes
quantFlip8 ::Quantum -&gt;Quantum
quantFlip8 Yes=Both
quantFlip8 No=Yes
quantFlip8 Both=No
quantFlip9 ::Quantum -&gt;Quantum
quantFlip9 Yes=Both
quantFlip9 No=No
quantFlip9 Both=No
quantFlip10 ::Quantum -&gt;Quantum
quantFlip10 Yes=Both
quantFlip10 No=No
quantFlip10 Both=Both
-- You can figure out the remaining
-- possibilities yourself.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 673
Exponentiation in what order?
Consider the following function:
convert ::Quantum -&gt;Bool
convert =undefined
According to the equality of a -&gt; b andùëèu?there should be 23
or 8 implementations of this function. Does this hold? Write
it out and prove it for yourself.
Exercises: The Quad
Determine how many unique inhabitants each type has.
Suggestion: do the arithmetic unless you want to verify.
Writing them out gets tedious quickly.
1.dataQuad=
One
|Two
|Three
|Four
deriving (Eq,Show)
-- how many different forms can this take?
eQuad::EitherQuadQuad
eQuad= ???</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 674
2.prodQuad ::(Quad,Quad)
3.funcQuad ::Quad-&gt;Quad
4.prodTBool ::(Bool,Bool,Bool)
5.gTwo::Bool-&gt;Bool-&gt;Bool
6.Hint: 5 digit number
fTwo::Bool-&gt;Quad-&gt;Quad
11.15 Higher-kinded datatypes
You may recall we discussed kinds earlier in this chapter. Kinds
are the types of type constructors, primarily encoding the
number of arguments they take. The default kind in Haskell is
*. Kind signatures work like type signatures, using the same ::
and-&gt;syntax, but there are only a few kinds and you‚Äôll most
often see *.
Kinds are not types until they are fully applied. Only types
have inhabitants at the term level. The kind * -&gt; * is waiting
for a single *before it is fully applied. The kind * -&gt; * -&gt; *
must be applied twice before it will be a real type. This is
known as a higher-kinded type . Lists, for example, are higher-
kinded datatypes in Haskell.
Because types can be generically polymorphic by taking
type arguments, they can be applied at the type level:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 675
-- identical to (a, b, c, d)
dataSillya b c d =
MkSilly a b c d deriving Show
-- in GHCi
Prelude&gt;:kindSilly
Silly:: * -&gt; * -&gt; * -&gt; * -&gt; *
Prelude&gt;:kindSillyInt
SillyInt:: * -&gt; * -&gt; * -&gt; *
Prelude&gt;:kindSillyIntString
SillyIntString:: * -&gt; * -&gt; *
Prelude&gt;:kindSillyIntStringBool
SillyIntStringBool:: * -&gt; *
Prelude&gt;:kindSillyIntStringBoolString
SillyIntStringBoolString:: *
-- Identical to (a, b, c, d)
Prelude&gt;:kind (,,,)
(,,,):: * -&gt; * -&gt; * -&gt; * -&gt; *
Prelude&gt;:kind (Int,String,Bool,String)
(Int,String,Bool,String):: *</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 676
Getting comfortable with higher-kinded types is important
as type arguments provide a generic way to express a ‚Äúhole‚Äù
to be filled by consumers of your datatype later. Take the
following as an example from a library one of the authors
maintains called Bloodhound.7
dataEsResultFound a=
EsResultFound { _version ::DocVersion
, _source ::a
}deriving (Eq,Show)
We know that this particular kind of response from Elastic-
search will include a DocVersion value, so that‚Äôs been assigned a
type. On the other hand, _source has type ùëébecause we have
no idea what the structure of the documents they‚Äôre pulling
from Elasticsearch look like. In practice, we do need to be able
to dosomething with that value of type ùëé. The thing we will
want to do with it ‚Äî the way we will consume or use that data
‚Äî will usually be a FromJSON typeclass instance for deserializing
JSON data into a Haskell datatype. But in Haskell, we do not
conventionally put constraints on datatypes. That is, we don‚Äôt
want to constrain that polymorphic ùëéin the datatype. The
FromJSON typeclass will likely (assuming that‚Äôs what is needed in
7http://hackage.haskell.org/package/bloodhound If you are not a programmer and do
not know what Elasticsearch and JSON are, try not to worry too much about the specifics.
Elasticsearch is a search engine and JSON is a format for transmitting data, especially
between servers and web applications.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 677
a given context) constrain the variable in the type signature(s)
for the function(s) that will process this data.
Accordingly, the FromJSON typeclassinstancefor EsResultFound
requires a FromJSON instance for that ùëé:
instance (FromJSON a)=&gt;
FromJSON (EsResultFound a)where
parseJSON ( Objectv)=
EsResultFound
&lt;$&gt;v.:&quot;_version&quot;
&lt;*&gt;v.:&quot;_source&quot;
parseJSON _ =empty
As you can hopefully see from this, by not fully applying
the type ‚Äî by leaving it higher-kinded ‚Äî space is left for the
type of the response to vary, for the ‚Äúhole‚Äù to be filled in by
the end user.
11.16 Lists are polymorphic
What makes a list polymorphic? In what way can it take many
forms? What makes them polymorphic is that lists in Haskell
can contain values of any type. You do not have an ùëéuntil the
list type‚Äôs type argument has been fully applied:
data[]a=[]|a:[a]
-- [1] [2] [3] [4] [5] [6]</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 678
1.Type constructor for list has special []syntax.
2.Single type argument to []. This is the type of value our
list contains.
3.Nil / empty list value constructor, again with the special
[] syntax. [] marks the end of the list.
4.A single value of type ùëé.
5.:is an infix data constructor. It is a product of ùëé[4] and
[a][6]
6.The rest of our list.
Infix type and data constructors When we give an operator
a nonalphanumeric name, it is infix by default. For example,
all the nonalphanumeric arithmetic functions are infix opera-
tors, while we have some alphanumeric arithmetic functions,
such as divandmodthat are prefix by default. So far, we‚Äôve only
seen alphanumeric data constructors, except for this cons con-
structor in the list type, but the same rule applies to them.
Any operator that starts with a colon ( :) must be an in-
fix type or data constructor. All infix data constructors must
start with a colon. The type constructor of functions, (-&gt;), is
the only infix type constructor that doesn‚Äôt start with a colon.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 679
Another exception is that they cannot be ::as this syntax is
reserved for type assertions.
In the following example, we‚Äôll define the list type without
using an infix constructor:
-- Same type, redefined
-- with different syntax
dataLista=Nil|Consa (Lista)
-- [1] [2] [3] [5] [4] [6]
1.TheListtype constructor.
2.Theùëétype parameter to List.
3.Nil / empty list value, which also marks the end of a list.
4.A single value of type ùëéin theConsproduct.
5.TheConsconstructor, product of ùëéandList a .
6.The rest of our list.
How do we use our Listtype?
Prelude&gt; let nil = Nil
Prelude&gt; :t nil
nil :: List a</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 680
Thetypeparameterisn‚Äôtappliedbecause Nilbyitselfdoesn‚Äôt
tell the type inference what the Listcontains. But if we give it
some information, then the ùëécan be assigned a concrete type:
Prelude&gt; let oneItem = (Cons &quot;woohoo!&quot; Nil)
Prelude&gt; :t oneItem
oneItem :: List [Char]
And how are our list types kinded?
Prelude&gt; :kind List
List :: * -&gt; *
Prelude&gt; :kind []
[] :: * -&gt; *
Prelude&gt; :kind List Int
List Int :: *
Prelude&gt; :kind [Int]
[Int] :: *
Much as we can refer to the function notbefore we‚Äôve ap-
plied its argument, we can refer to the list type constructor, [],
before we‚Äôve applied it to a type argument:
Prelude&gt; :t not
not :: Bool -&gt; Bool</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 681
Prelude&gt; :t not True
not True :: Bool
Prelude&gt; :k []
[] :: * -&gt; *
Prelude&gt; :k [Int]
[Int] :: *
The diÔ¨Äerence is that the argument of notis any value of
typeBool, and the argument of []is any type of kind *. So,
they‚Äôre similar, but type constructors are functions one level
up, structuring things that cannot exist at runtime ‚Äî it‚Äôs purely
static and describes the structure of your types.
11.17 Binary Tree
Now we turn our attention to a type similar to list. The type
constructor for binary trees can take an argument, and it is
also recursive like lists:
dataBinaryTree a=
Leaf
|Node(BinaryTree a) a (BinaryTree a)
deriving (Eq,Ord,Show)
This tree has a value of type ùëéat each node. Each node
could be a terminal node, called a leaf, or it could branch and</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 682
have two subtrees. The subtrees are also of type BinaryTree a ,
so this type is recursive. Each binary tree can store yet another
binary tree, which allows for trees of arbitrary depth.
In some cases, binary trees can be more efficient for struc-
turing and accessing data than a list, especially if you know
how to order your values in a way that lets you know whether
to look ‚Äúleft‚Äù or ‚Äúright‚Äù to find what you want. On the other
hand, a tree that only branches to the right is indistinguishable
from an ordinary list. For now, we won‚Äôt concern ourselves
too much with this as we‚Äôll talk about the proper application
of data structures later. Instead, you‚Äôre going to write some
functions for processing BinaryTree values.
Inserting into trees
The first thing to be aware of is that we need Ordin order to have
enough information about our values to know how to arrange
them in our tree. Accordingly, if something is lower, we want
to insert it somewhere on the left-hand part of our tree. If it‚Äôs
greater than the current node value, it should go somewhere
to the right. Left lesser, right greater is a common convention
for arranging binary trees ‚Äî it could be the opposite and not
really change anything, but this matches our usual intuitions
of ordering as we do with, say, number lines. The point is you
want to be able to know where to look in the tree for values
greater or less than the current one you‚Äôre looking at.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 683
Ourinsert function will insert a value into a tree or, if no
tree exists yet, give us a means of building a tree by inserting
values. It‚Äôs important to remember that data is immutable in
Haskell. We do not insert a value into an existing tree; each
time we want to insert a value into the data structure, we build
a whole new tree:
insert' ::Orda
=&gt;a
-&gt;BinaryTree a
-&gt;BinaryTree a
insert' bLeaf=NodeLeafbLeaf
insert' b (Nodeleft a right)
|b==a=Nodeleft a right
|b&lt;a=Node(insert' b left) a right
|b&gt;a=Nodeleft a (insert' b right)
The base case in our insert' function serves a couple pur-
poses. It handles inserting into an empty tree ( Leaf) and begin-
ning the construction of a new tree and also the case of having
reached the bottom of a much larger tree. The simplicity here
lets us ignore any inessential diÔ¨Äerences between those two
cases.
-- Leaf being the &quot;empty tree&quot; case</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 684
Prelude&gt; let t1 = insert' 0 Leaf
Prelude&gt; t1
Node Leaf 0 Leaf
Prelude&gt; let t2 = insert' 3 t1
Prelude&gt; t2
Node Leaf 0 (Node Leaf 3 Leaf)
Prelude&gt; let t3 = insert' 5 t2
Prelude&gt; t3
Node Leaf 0
(Node Leaf 3
(Node Leaf 5 Leaf))
We will examine binary trees and their properties later in
the book. For now, we want to focus not on the properties
of binary trees themselves, but on the structure of their type.
You might find the following exercises tricky or tedious, but
they will deepen your intuition for how recursive types work.
Write map for BinaryTree
Given the definition of BinaryTree above, write a map function
for the data structure. You don‚Äôt really need to know anything
about binary trees to write these functions. The structure
inherent in the definition of the type is all you need. All you
need to do is write the recursive functions.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 685
No special algorithms are needed, and we don‚Äôt expect you
to keep the tree balanced or ordered. Also, remember that
we‚Äôve never once mutated anything. We‚Äôve only built new
values from input data. Given that, when you go to implement
mapTree , you‚Äôre not changing an existing tree ‚Äî you‚Äôre building
a new one based on an existing one (as when you are mapping
functions over lists).
Note, you do notneed to use insert' for this. Retain the
original structure of the tree.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 686
mapTree ::(a-&gt;b)
-&gt;BinaryTree a
-&gt;BinaryTree b
mapTree _Leaf=Leaf
mapTree f (Nodeleft a right) =
Nodeundefined undefined undefined
testTree' ::BinaryTree Integer
testTree' =
Node(NodeLeaf3Leaf)
1
(NodeLeaf4Leaf)
mapExpected =
Node(NodeLeaf4Leaf)
2
(NodeLeaf5Leaf)
-- acceptance test for mapTree
mapOkay =
ifmapTree ( +1) testTree' ==mapExpected
thenprint&quot;yup okay!&quot;
elseerror&quot;test failed!&quot;
Some hints for implementing mapTree follow.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 687
The first pattern match in our mapTree function is the base
case, where we have a Leafvalue. We can‚Äôt apply the ùëìthere
because we don‚Äôt have an ùëé, so we ignored it. Since we have
to return a value of type BinaryTree b whatever happens, we
return a Leafvalue.
We return a Nodein the second pattern match of our mapTree
function. Note that the Nodedata constructor takes three argu-
ments:
Prelude&gt; :t Node
Node :: BinaryTree a
-&gt; a
-&gt; BinaryTree a
-&gt; BinaryTree a
So you need to pass it more BinaryTree , a single value, and
moreBinaryTree . You have the following terms available to
you:
1.f::(a-&gt;b)
2.left::BinaryTree a
3.a::a
4.right::BinaryTree a</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 688
5.mapTree ::(a-&gt;b)
-&gt;BinaryTree a
-&gt;BinaryTree b
Now the Nodereturn needs to have a value of type ùëèand
BinaryTree values with type ùëèinside them. You have two func-
tions at your disposal. One gets you (a -&gt; b) , the other maps
BinaryTree s of type ùëéintoBinaryTree s of type ùëè. Get ‚Äôem tiger.
A few suggestions that might help you with this exercise.
1.Split out the patterns your function should match on first.
2.Implement the base case first.
3.Try manually writing out the steps of recursion at first,
then collapse them into a single step that is recursive.
Convert binary trees to lists
Write functions to convert BinaryTree values to lists. Make
certain your implementation passes the tests.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 689
preorder ::BinaryTree a-&gt;[a]
preorder =undefined
inorder ::BinaryTree a-&gt;[a]
inorder =undefined
postorder ::BinaryTree a-&gt;[a]
postorder =undefined
testTree ::BinaryTree Integer
testTree =
Node(NodeLeaf1Leaf)
2
(NodeLeaf3Leaf)
testPreorder ::IO()
testPreorder =
ifpreorder testTree ==[2,1,3]
thenputStrLn &quot;Preorder fine!&quot;
elseputStrLn &quot;Bad news bears.&quot;
testInorder ::IO()
testInorder =
ifinorder testTree ==[1,2,3]
thenputStrLn &quot;Inorder fine!&quot;
elseputStrLn &quot;Bad news bears.&quot;
testPostorder ::IO()
testPostorder =
ifpostorder testTree ==[1,3,2]
thenputStrLn &quot;Postorder fine!&quot;
elseputStrLn &quot;postorder failed check&quot;
main::IO()
main= do
testPreorder
testInorder
testPostorder</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 690
Write foldr for BinaryTree
Given the definition of BinaryTree we have provided, write a
catamorphism for the binary trees.
-- any traversal order is fine
foldTree ::(a-&gt;b-&gt;b)
-&gt;b
-&gt;BinaryTree a
-&gt;b
11.18 Chapter Exercises
Multiple choice
1.Given the following datatype:
dataWeekday =
Monday
|Tuesday
|Wednesday
|Thursday
|Friday
we can say:
a)Weekday is a type with five data constructors</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 691
b)Weekday is a tree with five branches
c)Weekday is a product type
d)Weekday takes five arguments
2.and with the same datatype definition in mind, what is
the type of the following function, f?
fFriday=&quot;Miller Time&quot;
a)f :: [Char]
b)f :: String -&gt; String
c)f :: Weekday -&gt; String
d)f :: Day -&gt; Beer
3.Types defined with the datakeyword
a)must have at least one argument
b)must begin with a capital letter
c)must be polymorphic
d)cannot be imported from modules
4.The function g xs = xs !! (length xs - 1)
a)is recursive and may not terminate
b)delivers the head of xs
c)delivers the final element of xs
d)has the same type as xs</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 692
Ciphers
In the Lists chapter, you wrote a Caesar cipher. Now, we want
to expand on that idea by writing a Vigen√®re cipher. A Vi-
gen√®re cipher is another substitution cipher, based on a Caesar
cipher, but it uses a series of Caesar ciphers for polyalphabetic
substitution. The substitution for each letter in the plaintext
is determined by a fixed keyword.
So, for example, if you want to encode the message ‚Äúmeet
at dawn,‚Äù the first step is to pick a keyword that will determine
which Caesar cipher to use. We‚Äôll use the keyword ‚ÄúALLY‚Äù
here. You repeat the keyword for as many characters as there
are in your original message:
MEET AT DAWN
ALLY AL LYAL
Now the number of rightward shifts to make to encode each
character is set by the character of the keyword that lines up
with it. The ‚ÄôA‚Äô means a shift of 0, so the initial M will remain
M. But the ‚ÄôL‚Äô for our second character sets a rightward shift
of 11, so ‚ÄôE‚Äô becomes ‚ÄôP‚Äô. And so on, so ‚Äúmeet at dawn‚Äù encoded
with the keyword ‚ÄúALLY‚Äù becomes ‚ÄúMPPR AE OYWY.‚Äù
Like the Caesar cipher, you can find all kinds of resources to
help you understand the cipher and also many examples writ-
ten in Haskell. Consider using a combination of chr,ord, and</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 693
modagain, possibly very similar to what you used for writing
the original Caesar cipher.
As-patterns
As-patterns in Haskell are a nifty way to be able to pattern match
on part of something and still refer to the entire original value.
Some examples:
f::Showa=&gt;(a, b)-&gt;IO(a, b)
ft@(a,_)= do
print a
return t
Here we pattern-matched on a tuple so we could get at the
first value for printing, but used the @symbol to introduce a
binding named ùë°in order to refer to the whole tuple rather
than just a part.
Prelude&gt; f (1, 2)
1
(1,2)
We can use as-patterns with pattern matching on arbitrary
data constructors, which includes lists:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 694
doubleUp ::[a]-&gt;[a]
doubleUp []=[]
doubleUp xs@(x:_)=x:xs
Prelude&gt; doubleUp []
[]
Prelude&gt; doubleUp [1]
[1,1]
Prelude&gt; doubleUp [1, 2]
[1,1,2]
Prelude&gt; doubleUp [1, 2, 3]
[1,1,2,3]
Use as-patterns in implementing the following functions:
1.This should return Trueif (and only if) all the values in
the first list appear in the second list, though they need
not be contiguous.
isSubseqOf ::(Eqa)
=&gt;[a]
-&gt;[a]
-&gt;Bool
The following are examples of how this function should
work:</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 695
Prelude&gt; isSubseqOf &quot;blah&quot; &quot;blahwoot&quot;
True
Prelude&gt; isSubseqOf &quot;blah&quot; &quot;wootblah&quot;
True
Prelude&gt; isSubseqOf &quot;blah&quot; &quot;wboloath&quot;
True
Prelude&gt; isSubseqOf &quot;blah&quot; &quot;wootbla&quot;
False
Prelude&gt; isSubseqOf &quot;blah&quot; &quot;halbwoot&quot;
False
Prelude&gt; isSubseqOf &quot;blah&quot; &quot;blawhoot&quot;
True
Remember that the sub-sequence has to be in the original
order!
2.Split a sentence into words, then tuple each word with the
capitalized form of each.
capitalizeWords ::String
-&gt;[(String,String)]
Prelude&gt; capitalizeWords &quot;hello world&quot;
[(&quot;hello&quot;, &quot;Hello&quot;), (&quot;world&quot;, &quot;World&quot;)]
Language exercises
1.Write a function that capitalizes a word.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 696
capitalizeWord ::String-&gt;String
capitalizeWord =undefined
Example output.
Prelude&gt; capitalizeWord &quot;Chortle&quot;
&quot;Chortle&quot;
Prelude&gt; capitalizeWord &quot;chortle&quot;
&quot;Chortle&quot;
2.Write a function that capitalizes sentences in a paragraph.
Recognize when a new sentence has begun by checking
for periods. Reuse the capitalizeWord function.
capitalizeParagraph ::String-&gt;String
capitalizeParagraph =undefined
Example result you should get from your function:
Prelude&gt; let s = &quot;blah. woot ha.&quot;
Prelude&gt; capitalizeParagraph s
&quot;Blah. Woot ha.&quot;
Phone exercise
This exercise by geophf8originally for 1HaskellADay.9Thank
you for letting us use this exercise!
8https://twitter.com/geophf
9https://twitter.com/1haskelladay</p>
<h2>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 697
Remember old-fashioned phone inputs for writing text
where you had to press a button multiple times to get diÔ¨Äerent
letters to come up? You may still have to do this when you try
to search for a movie to watch using your television remote
control. You‚Äôre going to write code to translate sequences of
button presses into strings and vice versa.
So! Here is the layout of the phone:</h2>
<p>| 1 | 2 ABC | 3 DEF |</p>
<hr />
<h2 id="-4-ghi--5-jkl--6-mno-"><a class="header" href="#-4-ghi--5-jkl--6-mno-">| 4 GHI | 5 JKL | 6 MNO |</a></h2>
<h2 id="-7-pqrs--8-tuv--9-wxyz-"><a class="header" href="#-7-pqrs--8-tuv--9-wxyz-">| 7 PQRS | 8 TUV | 9 WXYZ |</a></h2>
<h2 id="----0--_----"><a class="header" href="#----0--_----">| * ^ | 0 + _ | # ., |</a></h2>
<p>Where star (*) gives you capitalization of the letter you‚Äôre
writing to your friends, and 0 is your space bar. To represent
the digit itself, you press that digit once more than the letters it
represents. If you press a button one more than is required to
type the digit, it wraps around to the first letter. For example,
2 -&gt; 'A'
22 -&gt; 'B'
222 -&gt; 'C'</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 698
2222 -&gt; '2'
22222 -&gt; 'A'
So on and so forth. We‚Äôre going to kick this around.
1.Create a data structure that captures the phone layout
above. Thedatastructureshouldbeabletoexpressenough
of how the layout works that you can use it to dictate the
behavior of the functions in the following exercises.
-- fill in the rest.
dataDaPhone =DaPhone
2.Convert the following conversations into the keypresses
required to express them. We‚Äôre going to suggest types
and functions to fill in order to accomplish the goal, but
they‚Äôre not obligatory. If you want to do it diÔ¨Äerently, go
right ahead.</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 699
convo::[String]
convo=
[&quot;Wanna play 20 questions&quot; ,
&quot;Ya&quot;,
&quot;U 1st haha&quot; ,
&quot;Lol ok. Have u ever tasted alcohol&quot; ,
&quot;Lol ya&quot; ,
&quot;Wow ur cool haha. Ur turn&quot; ,
&quot;Ok. Do u think I am pretty Lol&quot; ,
&quot;Lol ya&quot; ,
&quot;Just making sure rofl ur turn&quot; ]</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 700
-- validButtons = &quot;1234567890*#&quot;
typeDigit=Char
-- Valid presses: 1 and up
typePresses =Int
reverseTaps ::DaPhone
-&gt;Char
-&gt;[(Digit,Presses)]
reverseTaps =undefined
-- assuming the default phone definition
-- 'a' -&gt; [('2', 1)]
-- 'A' -&gt; [('*', 1), ('2', 1)]
cellPhonesDead ::DaPhone
-&gt;String
-&gt;[(Digit,Presses)]
cellPhonesDead =undefined
3.How many times do digits need to be pressed for each
message?
fingerTaps ::[(Digit,Presses)]-&gt;Presses
fingerTaps =undefined
4.What was the most popular letter for each message? What</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 701
wasitscost? You‚Äôllwanttocombine reverseTaps andfingerTaps
to figure out what it cost in taps. reverseTaps is a list be-
cause you need to press a diÔ¨Äerent button in order to get
capitals.
mostPopularLetter ::String-&gt;Char
mostPopularLetter =undefined
5.What was the most popular letter overall? What was the
most popular word?
coolestLtr ::[String]-&gt;Char
coolestLtr =undefined
coolestWord ::[String]-&gt;String
coolestWord =undefined
Hutton‚Äôs Razor
Hutton‚Äôs Razor10is a very simple expression language that
expresses integer literals and addition of values in that expres-
sion language. The ‚Äútrick‚Äù to it is that it‚Äôs recursive and the
two expressions you‚Äôre summing together could be literals or
themselves further addition operations. This sort of datatype
is stereotypical of expression languages used to motivate ideas
in research papers and functional pearls. Evaluating or folding</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 702
a datatype is also in some sense what you‚Äôre doing most of the
time while programming anyway.
1.Your first task is to write the ‚Äúeval‚Äù function which reduces
an expression to a final sum.
dataExpr
=LitInteger
|AddExprExpr
eval::Expr-&gt;Integer
eval=error&quot;do it to it&quot;
Example of expected output:
Prelude&gt; eval (Add (Lit 1) (Lit 9001))
9002
2.Write a printer for the expressions.
printExpr ::Expr-&gt;String
printExpr =undefined
Expected output:
10http://www.cs.nott.ac.uk/~pszgmh/bib.html#semantics</p>
<p>CHAPTER 11. RULE THE TYPES, RULE THE UNIVERSE 703
Prelude&gt; printExpr (Add (Lit 1) (Lit 9001))
&quot;1 + 9001&quot;
Prelude&gt; let a1 = Add (Lit 9001) (Lit 1)
Prelude&gt; let a2 = Add a1 (Lit 20001)
Prelude&gt; let a3 = Add (Lit 1) a2
Prelude&gt; printExpr a3
&quot;1 + 9001 + 1 + 20001&quot;
11.19 Definitions
1.Adatatype is how we declare and create data for our func-
tions to receive as inputs. Datatype declarations begin
with the keyword data. A datatype is made up of a type
constructor and zero or more data constructors which
each have zero or more arguments.</p>
<p>Chapter 12
Signaling adversity
Thank goodness we don‚Äôt
have only serious
problems, but ridiculous
ones as well
Edsger W. Dijkstra
704</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 705
12.1 Signaling adversity
Sometimes it‚Äôs not convenient or possible for every value
in a datatype to make sense for your programs. When that
happens in Haskell, we use explicit datatypes to signal when
our functions receiveda combination of inputs that don‚Äôt make
sense. Later, we‚Äôll see how to defend against those adverse
inputs at the time we construct our datatypes, but the Maybe
andEither datatypes we will demonstrate here are common.
This chapter will include:
‚Ä¢Nothing , orJust Maybe ;
‚Ä¢Either left or right, but not both;
‚Ä¢higher-kindedness;
‚Ä¢anamorphisms, but not animorphs.
12.2 How I learned to stop worrying
and love Nothing
Let‚Äôs consider the definition of Maybeagain:
dataMaybea=Nothing |Justa
You don‚Äôt need to define this yourself, as it‚Äôs included in the
Prelude by default. It‚Äôs also a very common datatype in Haskell</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 706
because it lets us return a default Nothing value when we don‚Äôt
have any sensible values to return for our intended type ùëé.
In the following intentionally simplistic function, we could
do several things with the odd numbers ‚Äî we could return
them unmodified, we could modify them in some way dif-
ferent from the evens, we could return a zero, or we could
write an explicit signal that nothing happened because the
number wasn‚Äôt even:
ifEvenAdd2 ::Integer -&gt;Integer
ifEvenAdd2 n=
ifeven nthenn+2else ???
What can we do to make it say, ‚Äúhey, this number wasn‚Äôt
even so I have nothing for you, my friend?‚Äù Instead of promis-
ing anInteger result, we can return Maybe Integer :
ifEvenAdd2 ::Integer -&gt;MaybeInteger
ifEvenAdd2 n=
ifeven nthenn+2elseNothing
This isn‚Äôt quite complete or correct either. While Nothing
has the type Maybe a , andùëécan be assumed to be any type the
Maybeconstructor could contain, n+2is still of the type Integer .
We need to wrap that value in the other constructor Maybe
provides: Just. Here‚Äôs the error you‚Äôd get if you tried to load
it:</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 707
<interactive>:9:75:
Couldn't match expected type
‚ÄòMaybe Integer‚Äô
with actual type ‚ÄòInteger‚Äô
In the first argument of ‚Äò(+)‚Äô, namely ‚Äòn‚Äô
In the expression: n + 2
And here‚Äôs how we fix it:
ifEvenAdd2 ::Integer -&gt;MaybeInteger
ifEvenAdd2 n=
ifeven nthenJust(n+2)elseNothing
We had to parenthesize n+2because function application
binds the most tightly in Haskell (has the highest precedence),
so the compiler otherwise would‚Äôve parsed it as (Just n) + 2 ,
which is wrong and throws a type error. Now our function
is correct and explicit about the possibility of not getting a
result!
Smart constructors for datatypes
Let‚Äôs consider a Person type which keeps track of two things,
their name and their age. We‚Äôll write this up as a simple prod-
uct type (note that NameandAgeare type aliases):</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 708
typeName=String
typeAge=Integer
dataPerson=PersonNameAgederiving Show
There are already a few problems here. One is that we could
construct a Person with an empty String for a name or make
a person who is negative years old. This is no problem to fix
withMaybe, though:
typeName=String
typeAge=Integer
dataPerson=PersonNameAgederiving Show
mkPerson ::Name-&gt;Age-&gt;MaybePerson
mkPerson name age
|name/=&quot;&quot;&amp;&amp;age&gt;=0=
Just$Personname age
|otherwise =Nothing
And if you load this into your REPL:
Prelude&gt; mkPerson &quot;John Browning&quot; 160
Just (Person &quot;John Browning&quot; 160)
Cool. What happens when we feed it adverse data?</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 709
Prelude&gt; mkPerson &quot;&quot; 160
Nothing
Prelude&gt; mkPerson &quot;blah&quot; 0
Just (Person &quot;blah&quot; 0)
Prelude&gt; mkPerson &quot;blah&quot; (-9001)
Nothing
mkPerson is what we call a smart constructor . It allows us to
construct values of a type only when they meet certain criteria,
so that we know we have a valid value, and return an explicit
signal when we do not.
This is much better than our original, but what if we want
to know if it was the name, age, or both that was bad? We may
want to tell our user something was wrong with their input.
Fortunately, we have a datatype for that!
12.3 Bleating either
We want a way to express why we didn‚Äôt get a successful result
back from our mkPerson constructor. To handle that, we‚Äôve got
theEither datatype which is defined as follows in the Prelude :
dataEithera b=Lefta|Rightb
What we want is a way to know whyour inputs were incor-
rectifthey were incorrect. So we‚Äôll start by making a sum type
to enumerate our failure modes:</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 710
dataPersonInvalid =NameEmpty
|AgeTooLow
deriving (Eq,Show)
By now, you know why we derived Show, but it‚Äôs important
that we derive Eqbecause otherwise we can‚Äôt equality check the
constructors. Pattern matching is a case expression, where the
data constructor is the condition. Case expressions and pattern
matching will work without an Eqinstance, but guards using
(==)will not. As we‚Äôve shown you previously, you can write
your own Eqinstance for your datatype if you want a specific
behavior, but it‚Äôs usually not necessary to do, so we will usually
derive the Eqinstance. Here‚Äôs the diÔ¨Äerence demonstrated in
code:
moduleEqCaseGuard where
dataPersonInvalid =NameEmpty
|AgeTooLow
-- Compiles without Eq
toString ::PersonInvalid -&gt;String
toString NameEmpty =&quot;NameEmpty&quot;
toString AgeTooLow =&quot;AgeTooLow&quot;</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 711
instance ShowPersonInvalid where
show=toString
-- This does not work without an
-- Eq instance
blah::PersonInvalid -&gt;String
blahpi
|pi==NameEmpty =&quot;NameEmpty&quot;
|pi==AgeTooLow =&quot;AgeTooLow&quot;
|otherwise =&quot;???&quot;
It‚Äôs worth considering that if you needed to have an Eqin-
stance to pattern match, how would you write the Eqinstances?
Next our constructor type is going to change to:
mkPerson ::Name
-&gt;Age
-&gt;EitherPersonInvalid Person
This signifies that we‚Äôre going to get a Person value if we suc-
ceed but a PersonInvalid if it fails. Now we need to change our
logic to return PersonInvalid values inside a Leftconstructor
when the data is invalid, discriminating by each case as we go:</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 712
typeName=String
typeAge=Integer
dataPerson=PersonNameAgederiving Show
dataPersonInvalid =NameEmpty
|AgeTooLow
deriving (Eq,Show)
mkPerson ::Name
-&gt;Age
-&gt;EitherPersonInvalid Person
-- [1] [2] [3]
mkPerson name age
|name/=&quot;&quot;&amp;&amp;age&gt;=0=
Right$Personname age
-- [4]
|name==&quot;&quot;=LeftNameEmpty
-- [5]
|otherwise =LeftAgeTooLow
1.OurmkPerson type takes a NameandAgereturns an Either
result.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 713
2.TheLeftresult of the Either is an invalid person, when
either the name or age is an invalid input.
3.TheRightresult is a valid person.
4.The first case of our mkPerson function, then, matches on
theRightconstructor of the Either and returns a Person
result. We could have written
name/=&quot;&quot;&amp;&amp;age&gt;=0=
Right(Personname age)
instead of using the dollar sign.
5.The next two cases match on the Leftconstructor and
allow us to tailor our invalid results based on the failure
reasons. We can pattern match on Leftbecause it‚Äôs one of
the constructors of Either .
We use Leftas our invalid or error constructor for a couple
of reasons. It is conventional to do so in Haskell, but that con-
vention came about for a reason. The reason has to do with the
ordering of type arguments and application of functions. Nor-
mally it is your error or invalid result that is going to cause a
stop to whatever work is being done by your program. Functor
will not map over the left type argument because it has been
applied away. You may remember Functor from our introduc-
tion offmapback in the chapter about lists; don‚Äôt worry, a full</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 714
explanation of Functor is coming soon. Since you normally
want to apply functions and map over the case that doesn‚Äôt
stop your program (that is, notthe error case), it has become
convention that the LeftofEither is used for whatever case is
going to cause the work to stop.
Let‚Äôs see what it looks like when we have good data, although
Djali isn‚Äôt a person.1
Prelude&gt; :t mkPerson &quot;Djali&quot; 5
mkPerson &quot;Djali&quot; 5 :: Either PersonInvalid Person
Prelude&gt; mkPerson &quot;Djali&quot; 5
Right (Person &quot;Djali&quot; 5)
Then we can see what this does for us when dealing with
bad data:
Prelude&gt; mkPerson &quot;&quot; 10
Left NameEmpty
Prelude&gt; mkPerson &quot;Djali&quot; (-1)
Left AgeTooLow
Prelude&gt; mkPerson &quot;&quot; (-1)
Left NameEmpty
Notice in the last example that when both the name and
the age are wrong, we‚Äôre only going to see the result of the first
failure case, not both.
1Don‚Äôt know what we mean? Check the name Djali on a search engine.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 715
This is imperfect in one respect, as it doesn‚Äôt let us express a
list of errors. We can fix this, too! One thing that will change is
that instead of validating all the data for a Person at once, we‚Äôre
going to make separate checking functions and then combine
the results. We‚Äôll see means of abstracting patterns like this
out later. We‚Äôre adding a type alias that wasn‚Äôt in our previous
version; otherwise, these types are the same as above:
typeName=String
typeAge=Integer
typeValidatePerson a=
Either[PersonInvalid ] a
dataPerson=PersonNameAgederiving Show
dataPersonInvalid =NameEmpty
|AgeTooLow
deriving (Eq,Show)
Now we‚Äôll write our checking functions. Although more
than one thing could hypothetically be wrong with the age
value, we‚Äôll keep this simple and only check to make sure it‚Äôs a
positive Integer value:</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 716
ageOkay ::Age
-&gt;Either[PersonInvalid ]Age
ageOkay age= caseage&gt;=0of
True-&gt;Rightage
False-&gt;Left[AgeTooLow ]
nameOkay ::Name
-&gt;Either[PersonInvalid ]Name
nameOkay name= casename/=&quot;&quot;of
True-&gt;Rightname
False-&gt;Left[NameEmpty ]
We can nest the PersonInvalid sum type right into the Left
position of Either, just as we saw in the previous chapter (al-
though we weren‚Äôt using Either there, but similar types).
A couple of things to note here:
‚Ä¢TheNamevalue will only return this invalid result when
it‚Äôs an empty String .
‚Ä¢SinceNameis only a String value, it can be any String with
characters inside it, so ‚Äú42‚Äù is still going to be returned as
a valid name. Try it.
‚Ä¢If you try to put an Integer in for the name, you won‚Äôt get
aLeftresult, you‚Äôll get a type error. Try it. You‚Äôll get a</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 717
similar result if you try to feed a string value to the ageOkay
function.
‚Ä¢We‚Äôre going to return a list of PersonInvalid results. That
will allow us to return bothNameEmpty andAgeTooLow in cases
where both of those are true.
Now that our functions rely on Either to validate that the
age and name values are independently valid, we can write a
mkPerson function that will use our type alias ValidatePerson :</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 718
mkPerson ::Name
-&gt;Age
-&gt;ValidatePerson Person
-- [1] [2]
mkPerson name age =
mkPerson' (nameOkay name) (ageOkay age)
-- [3] [4] [5]
mkPerson' ::ValidatePerson Name
-&gt;ValidatePerson Age
-&gt;ValidatePerson Person
-- [6]
mkPerson' (RightnameOk) ( RightageOk)=
Right(PersonnameOk ageOk)
mkPerson' (LeftbadName) ( LeftbadAge) =
Left(badName ++badAge)
mkPerson' (LeftbadName) _ =LeftbadName
mkPerson' _(LeftbadAge) =LeftbadAge
1.A type alias for Either [PersonInvalid] a .
2.This is the ùëéargument to ValidatePerson type.
3.Ourmainfunctionnowreliesonasimilarly-namedhelper</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 719
function.
4.First argument to this function is the result of the nameOkay
function.
5.Second argument is the result of the ageOkay function.
6.The type relies on the synonym for Either .
The rest of our helper function mkPerson' consists of plain
old pattern matches.
Now let‚Äôs see what we get:
Prelude&gt; mkPerson &quot;&quot; (-1)
Left [NameEmpty,AgeTooLow]
Ahh, that‚Äôs more like it. Now we can tell the user what was
incorrect in one go without them having to round-trip each
mistake! Later in the book, we‚Äôll be able to replace mkPerson
andmkPerson' with the following:
mkPerson
::Name
-&gt;Age
-&gt;Validation [PersonInvalid ]Person
mkPerson name age =
liftA2
Person(nameOkay name) (ageOkay age)</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 720
12.4 Kinds, a thousand stars in your
types
Kinds are types one level up. They are used to describe the
types of type constructors. One noteworthy feature of Haskell
is that it has higher-kinded types . Here the term ‚Äòhigher-kinded‚Äô
derives from higher-order functions, functions that take more
functions as arguments. Type constructors (that is, higher-
kinded types) are types that take more types as arguments. The
Haskell Report uses the term type constant to refer to types that
take no arguments and are already types. In the Report, type
constructor is used to refer to types which must have arguments
applied to become a type.
As we discussed in the last chapter, these are examples of
type constants :
Prelude&gt; :kind Int
Int :: *
Prelude&gt; :k Bool
Bool :: *
Prelude&gt; :k Char
Char :: *
The::syntax usually means ‚Äúhas type of,‚Äù but it is used for
kind signatures as well as type signatures.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 721
The following is an example of a type that has a type con-
structor rather than a type constant :
dataExample a=Blah|RoofGoats |Woota
Example is a type constructor rather than a constant because
it takes a type argument ùëéwhich is used with the Wootdata
constructor. In GHCi we can query kinds with :k:
Prelude&gt; data Example a = Blah | RoofGoats | Woot a
Prelude&gt; :k Example
Example :: * -&gt; *
Example has one parameter, so it must be applied to one type
in order to become a concrete type represented by a single *.
The two-tuple takes two arguments, so it must be applied to
two types to become a concrete type:
Prelude&gt; :k (,)
(,) :: * -&gt; * -&gt; *
Prelude&gt; :k (Int, Int)
(Int, Int) :: *
TheMaybeandEither datatypes we‚Äôve just reviewed also have
type constructors rather than constants. They have to be ap-
plied to an argument before they become concrete types. As
with the eÔ¨Äect of currying in type signatures, applying Maybe</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 722
to anùëétype constructor relieves us of one arrow and makes it
a kind star:
Prelude&gt; :k Maybe
Maybe :: * -&gt; *
Prelude&gt; :k Maybe Int
Maybe Int :: *
On the other hand, Either has to be applied to two argu-
ments, an ùëéand aùëè, so the kind of Either is star to star to star:
Prelude&gt; :k Either
Either :: * -&gt; * -&gt; *
And, again, we can query the eÔ¨Äects of applying it to argu-
ments:
Prelude&gt; :k Either Int
Either Int :: * -&gt; *
Prelude&gt; :k Either Int String
Either Int String :: *
As we‚Äôve said, the kind *represents a concrete type. There
is nothing left awaiting application.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 723
Lifted and unlifted types To be precise, kind <em>is the kind of
all standard lifted types, while types that have the kind #are
unlifted. A lifted type, which includes any datatype you could
define yourself, is any that can be inhabited by bottom . Lifted
types are represented by a pointer and include most of the
datatypes we‚Äôve seen and most that you‚Äôre likely to encounter
and use. Unlifted types are any type which cannot be inhabited
by bottom. Types of kind #are often native machine types
and raw pointers. Newtypes are a special case in that they are
kind</em>, but are unlifted because their representation is identical
to that of the type they contain, so the newtype itself is not
creating any new pointer beyond that of the type it contains.
That fact means that the newtype itself cannot be inhabited
by bottom, only the thing it contains can be, so newtypes are
unlifted. The default kind of concrete, fully-applied datatypes
in GHC is kind *.
Now what happens if we let our type constructor take an
argument?
Prelude&gt; data Identity a = Identity a
Prelude&gt; :k Identity
Identity :: * -&gt; *
As we discussed in the previous chapter, the arrow in the
kind signature, like the function arrow in type signatures, sig-
nals a need for application. In this case, we construct the type
by applying it to another type.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 724
Let‚Äôs consider the case of Maybe, which is defined as follows:
dataMaybea=Nothing |Justa
The type Maybeis a type constructor because it takes one
argument before it becomes a concrete type:
Prelude&gt; :k Maybe
Maybe :: * -&gt; *
Prelude&gt; :k Maybe Int
Maybe Int :: *
Prelude&gt; :k Maybe Bool
Maybe Bool :: *
Prelude&gt; :k Int
Int :: *
Prelude&gt; :k Bool
Bool :: *
Whereas the following will not work, because the kinds
don‚Äôt match up:
Prelude&gt; :k Maybe Maybe
Expecting one more argument to ‚ÄòMaybe‚Äô</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 725
The first argument of ‚ÄòMaybe‚Äô should have kind ‚Äò<em>‚Äô,
but ‚ÄòMaybe‚Äô has kind ‚Äò</em> -&gt; *‚Äô
In a type in a GHCi command: Maybe Maybe
Maybeexpects a single type argument of kind *, which Maybe
is not.
If we give Maybea type argument that is kind *, it also be-
comes kind <em>so then it can be an argument to another Maybe:
Prelude&gt; :k Maybe Char
Maybe Char :: *
Prelude&gt; :k Maybe (Maybe Char)
Maybe (Maybe Char) :: *
OurExample datatype from earlier also won‚Äôt work as an
argument for Maybeby itself:
Prelude&gt; data Example a = Blah | RoofGoats | Woot a
Prelude&gt; :k Maybe Example
Expecting one more argument to ‚ÄòExample‚Äô
The first argument of ‚ÄòMaybe‚Äô should have kind ‚Äò</em>‚Äô,</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 726
but ‚ÄòExample‚Äô has kind ‚Äò* -&gt; *‚Äô
In a type in a GHCi command: Maybe Example
However, if we apply the Example type constructor, we can
make it work and create a value of that type:
Prelude&gt; :k Maybe (Example Int)
Maybe (Example Int) :: *
Prelude&gt; :t Just (Woot n)
Just (Woot n) :: Maybe (Example Int)
Note that the list type constructor []is also kind * -&gt; * and
otherwise unexceptional save for the bracket syntax that lets
you type [a]and[Int]instead of [] aand[] Int :
Prelude&gt; :k []
[] :: * -&gt; *
Prelude :k [] Int
[] Int :: *
Prelude&gt; :k [Int]
[Int] :: *
So, we can‚Äôt have a Maybe [] for the same reason we couldn‚Äôt
have aMaybe Maybe , but we can have a Maybe [Bool] :</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 727
Prelude&gt; :k Maybe []
Expecting one more argument to ‚Äò[]‚Äô
The first argument of ‚ÄòMaybe‚Äô should have kind ‚Äò<em>‚Äô,
but ‚Äò[]‚Äô has kind ‚Äò</em> -&gt; *‚Äô
In a type in a GHCi command: Maybe []
Prelude&gt; :k Maybe [Bool]
Maybe [Bool] :: *
If you recall, one of the first times we used Maybein the book
was to write a safe version of a tailfunction back in the chapter
on lists:
safeTail ::[a]-&gt;Maybe[a]
safeTail []=Nothing
safeTail (x:[])=Nothing
safeTail (_:xs)=Justxs
As soon as we apply this to a value, the polymorphic type
variables become constrained or concrete types:
Prelude&gt; safeTail &quot;julie&quot;
Just &quot;ulie&quot;
Prelude&gt; :t safeTail &quot;julie&quot;
safeTail &quot;julie&quot; :: Maybe [Char]</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 728
Prelude&gt; safeTail [1..10]
Just [2,3,4,5,6,7,8,9,10]
Prelude&gt; :t safeTail [1..10]
safeTail [1..10] :: (Num a, Enum a) =&gt; Maybe [a]
Prelude&gt; :t safeTail [1..10 :: Int]
safeTail [1..10 :: Int] :: Maybe [Int]
We can expand on type constructors that take a single argu-
ment and see how the kind changes as we go:
Prelude&gt; data Trivial = Trivial
Prelude&gt; :k Trivial
Trivial :: *
Prelude&gt; data Unary a = Unary a
Prelude&gt; :k Unary
Unary :: * -&gt; *
Prelude&gt; data TwoArgs a b = TwoArgs a b
Prelude&gt; :k TwoArgs
TwoArgs :: * -&gt; * -&gt; *
Prelude&gt; data ThreeArgs a b c = ThreeArgs a b c
Prelude&gt; :k ThreeArgs
ThreeArgs :: * -&gt; * -&gt; * -&gt; *</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 729
It may not be clear why this is useful to know right now,
other than helping to understand when your type errors are
caused by things not being fully applied. The implications of
higher-kindedness will be clearer in a later chapter.
Data constructors are functions
In the previous chapter, we noted the diÔ¨Äerence between data
constants and data constructors and noted that data construc-
tors that haven‚Äôt been fully applied have function arrows in
them. Once you apply them to their arguments, they return a
value of the appropriate type. In other words, data construc-
tors are functions. As it happens, they behave like Haskell
functions in that they are curried as well.
First let‚Äôs observe that nullary data constructors, which are
values taking no arguments, are notlike functions:
Prelude&gt; data Trivial = Trivial deriving Show
Prelude&gt; Trivial 1
Couldn't match expected type ‚ÄòInteger -&gt; t‚Äô
with actual type ‚ÄòTrivial‚Äô
(... etc ...)
However, data constructors that take arguments dobehave
like functions:</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 730
Prelude&gt; data UnaryC = UnaryC Int deriving Show
Prelude&gt; :t UnaryC
UnaryC :: Int -&gt; UnaryC
Prelude&gt; UnaryC 10
UnaryC 10
Prelude&gt; :t UnaryC 10
UnaryC 10 :: UnaryC
Like functions, their arguments are typechecked against
the specification in the type:
Prelude&gt; UnaryC &quot;blah&quot;
Couldn't match expected type ‚ÄòInt‚Äô
with actual type ‚Äò[Char]‚Äô
If we wanted a unary data constructor which could contain
any type, we would parameterize the type like so:
Prelude&gt; data Unary a = Unary a deriving Show
Prelude&gt; :t Unary
Unary :: a -&gt; Unary a
Prelude&gt; :t Unary 10
Unary 10 :: Num a =&gt; Unary a
Prelude&gt; :t Unary &quot;blah&quot;
Unary &quot;blah&quot; :: Unary [Char]</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 731
And again, this works just like a function, except the type
of the argument can be whatever we want.
Note that if we want to use a derived (GHC generated) Show
instance for Unary, it has to be able to also show the contents,
the type ùëévalue contained by Unary‚Äôs data constructor:
Prelude&gt; :info Unary
data Unary a = Unary a
instance Show a =&gt; Show (Unary a)
If we try to use a type for ùëéthat does not have a Showinstance,
it won‚Äôt cause a problem until we try to show the value:
Prelude&gt; :t (Unary id)
(Unary id) :: Unary (t -&gt; t)
-- id doesn't have a Show instance
Prelude&gt; show (Unary id)
<interactive>:53:1:
No instance for (Show (t0 -&gt; t0))
...
The only way to avoid this would be to write an instance that
did not show the value contained in the Unarydata constructor,
but that would be somewhat unusual.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 732
Another thing to keep in mind is that you can‚Äôt ordinarily
hide polymorphic types from your type constructor, so the
following is invalid:
Prelude&gt; data Unary = Unary a deriving Show
Not in scope: type variable ‚Äòa‚Äô
In order for the type variable ùëéto be in scope, we usually
need to introduce it with our type constructor. There are ways
around this, but they‚Äôre rarely necessary or a good idea and
not relevant to the beginning Haskeller.
Here‚Äôs an example using fmapand the Justdata constructor
fromMaybeto demonstrate how Justis also like a function:
Prelude&gt; fmap Just [1, 2, 3]
[Just 1,Just 2,Just 3]
The significance and utility of this may not be immediately
obvious but will be more clear in later chapters.
12.5 Chapter Exercises
Determine the kinds
1.Given
id::a-&gt;a</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 733
What is the kind of a?
2.r::a-&gt;f a
What are the kinds of aandf?
String processing
Because this is the kind of thing linguists ahemenjoy doing in
their spare time.
1.Write a recursive function named replaceThe which takes a
text/string, breaks it into words and replaces each instance
of ‚Äúthe‚Äù with ‚Äúa‚Äù. It‚Äôs intended only to replace exactly
the word ‚Äúthe‚Äù. notThe is a suggested helper function for
accomplishing this.
-- example GHCi session
-- above the functions
-- &gt;&gt;&gt; notThe &quot;the&quot;
-- Nothing
-- &gt;&gt;&gt; notThe &quot;blahtheblah&quot;
-- Just &quot;blahtheblah&quot;
-- &gt;&gt;&gt; notThe &quot;woot&quot;
-- Just &quot;woot&quot;
notThe::String-&gt;MaybeString
notThe=undefined</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 734
-- &gt;&gt;&gt; replaceThe &quot;the cow loves us&quot;
-- &quot;a cow loves us&quot;
replaceThe ::String-&gt;String
replaceThe =undefined
2.Write a recursive function that takes a text/string, breaks
it into words, and counts the number of instances of ‚Äùthe‚Äù
followed by a vowel-initial word.
-- &gt;&gt;&gt; countTheBeforeVowel &quot;the cow&quot;
-- 0
-- &gt;&gt;&gt; countTheBeforeVowel &quot;the evil cow&quot;
-- 1
countTheBeforeVowel ::String-&gt;Integer
countTheBeforeVowel =undefined
3.Return the number of letters that are vowels in a word.
Hint: it‚Äôs helpful to break this into steps. Add any helper
functions necessary to achieve your objectives.
a)Test for vowelhood
b)Return the vowels of a string
c)Count the number of elements returned</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 735
-- &gt;&gt;&gt; countVowels &quot;the cow&quot;
-- 2
-- &gt;&gt;&gt; countVowels &quot;Mikolajczak&quot;
-- 4
countVowels ::String-&gt;Integer
countVowels =undefined
Validate the word
Use the Maybetype to write a function that counts the number
of vowels in a string and the number of consonants. If the
number of vowels exceeds the number of consonants, the
function returns Nothing . In many human languages, vowels
rarely exceed the number of consonants so when they do, it
mayindicate the input isn‚Äôt a word (that is, a valid input to your
dataset):
newtype Word'=
Word'String
deriving (Eq,Show)
vowels=&quot;aeiou&quot;
mkWord::String-&gt;MaybeWord'
mkWord=undefined</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 736
It‚Äôs only Natural
You‚Äôll be presented with a datatype to represent the natural
numbers. The only values representable with the naturals
are whole numbers from zero to infinity. Your task will be
to implement functions to convert Natural s toInteger s and
Integer s toNatural s. The conversion from Natural s toInteger s
won‚Äôt return Maybebecause Integer is a strict superset of Natural .
AnyNatural can be represented by an Integer , but the same is
nottrue of any Integer . Negative numbers are not valid natural
numbers.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 737
-- As natural as any
-- competitive bodybuilder
dataNat=
Zero
|SuccNat
deriving (Eq,Show)
-- &gt;&gt;&gt; natToInteger Zero
-- 0
-- &gt;&gt;&gt; natToInteger (Succ Zero)
-- 1
-- &gt;&gt;&gt; natToInteger (Succ (Succ Zero))
-- 2
natToInteger ::Nat-&gt;Integer
natToInteger =undefined
-- &gt;&gt;&gt; integerToNat 0
-- Just Zero
-- &gt;&gt;&gt; integerToNat 1
-- Just (Succ Zero)
-- &gt;&gt;&gt; integerToNat 2
-- Just (Succ (Succ Zero))
-- &gt;&gt;&gt; integerToNat (-1)
-- Nothing
integerToNat ::Integer -&gt;MaybeNat
integerToNat =undefined</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 738
Small library for Maybe
Write the following functions. This may take some time.
1.Simple boolean checks for Maybevalues.
-- &gt;&gt;&gt; isJust (Just 1)
-- True
-- &gt;&gt;&gt; isJust Nothing
-- False
isJust::Maybea-&gt;Bool
-- &gt;&gt;&gt; isNothing (Just 1)
-- False
-- &gt;&gt;&gt; isNothing Nothing
-- True
isNothing ::Maybea-&gt;Bool
2.The following is the Maybecatamorphism. You can turn a
Maybevalue into anything else with this.
-- &gt;&gt;&gt; mayybee 0 (+1) Nothing
-- 0
-- &gt;&gt;&gt; mayybee 0 (+1) (Just 1)
-- 2
mayybee ::b-&gt;(a-&gt;b)-&gt;Maybea-&gt;b</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 739
3.In case you just want to provide a fallback value.
-- &gt;&gt;&gt; fromMaybe 0 Nothing
-- 0
-- &gt;&gt;&gt; fromMaybe 0 (Just 1)
-- 1
fromMaybe ::a-&gt;Maybea-&gt;a
-- Try writing it in terms
-- of the maybe catamorphism
4.Converting between ListandMaybe.
-- &gt;&gt;&gt; listToMaybe [1, 2, 3]
-- Just 1
-- &gt;&gt;&gt; listToMaybe []
-- Nothing
listToMaybe ::[a]-&gt;Maybea
-- &gt;&gt;&gt; maybeToList (Just 1)
-- [1]
-- &gt;&gt;&gt; maybeToList Nothing
-- []
maybeToList ::Maybea-&gt;[a]
5.For when we want to drop the Nothing values from our list.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 740
-- &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 2]
-- [1, 2]
-- &gt;&gt;&gt; let xs = take 3 $ repeat Nothing
-- &gt;&gt;&gt; catMaybes xs
-- []
catMaybes ::[Maybea]-&gt;[a]
6.You‚Äôll see this called ‚Äúsequence‚Äù later.
-- &gt;&gt;&gt; flipMaybe [Just 1, Just 2, Just 3]
-- Just [1, 2, 3]
-- &gt;&gt;&gt; flipMaybe [Just 1, Nothing, Just 3]
-- Nothing
flipMaybe ::[Maybea]-&gt;Maybe[a]
Small library for Either
Write each of the following functions. If more than one possi-
ble unique function exists for the type, use common sense to
determine what it should do.
1.Try to eventually arrive at a solution that uses foldr, even
if earlier versions don‚Äôt use foldr.
lefts'::[Eithera b]-&gt;[a]
2.Same as the last one. Use foldreventually.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 741
rights' ::[Eithera b]-&gt;[b]
3.partitionEithers' ::[Eithera b]
-&gt;([a], [b])
4.eitherMaybe' ::(b-&gt;c)
-&gt;Eithera b
-&gt;Maybec
5.This is a general catamorphism for Either values.
either' ::(a-&gt;c)
-&gt;(b-&gt;c)
-&gt;Eithera b
-&gt;c
6.Same as before, but use the either' function you just
wrote.
eitherMaybe'' ::(b-&gt;c)
-&gt;Eithera b
-&gt;Maybec
Mostofthefunctionsyoujustsawareinthe Prelude ,Data.Maybe ,
orData.Either but you should strive to write them yourself
without looking at existing implementations. You will deprive
yourself if you cheat.</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 742
Unfolds
While the idea of catamorphisms is still relatively fresh in our
minds, let‚Äôs turn our attention to their dual: anamorphisms . If
folds, or catamorphisms, let us break data structures down
then unfolds let us build them up. There are, as with folds, a
few diÔ¨Äerent ways to unfold a data structure. We can use them
to create finite and infinite data structures alike.
-- iterate is like a limited
-- unfold that never ends
Prelude&gt; :t iterate
iterate :: (a -&gt; a) -&gt; a -&gt; [a]
-- because it never ends, we must use
-- take to get a finite list
Prelude&gt; take 10 $ iterate (+1) 0
[0,1,2,3,4,5,6,7,8,9]
-- unfoldr is more general
Prelude&gt; :t unfoldr
unfoldr :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a]
-- Using unfoldr to do
-- the same thing as iterate
Prelude&gt; take 10 $ unfoldr (\b -&gt; Just (b, b+1)) 0</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 743
[0,1,2,3,4,5,6,7,8,9]
Why bother?
We bother with this for the same reason we abstracted direct
recursion into folds, such as with sum,product , andconcat .
importData.List
mehSum::Numa=&gt;[a]-&gt;a
mehSumxs=go0xs
wherego::Numa=&gt;a-&gt;[a]-&gt;a
go n[]=n
go n (x:xs)=(go (n+x) xs)
niceSum ::Numa=&gt;[a]-&gt;a
niceSum =foldl' ( +)0
mehProduct ::Numa=&gt;[a]-&gt;a
mehProduct xs=go1xs
wherego::Numa=&gt;a-&gt;[a]-&gt;a
go n[]=n</p>
<div style="break-before: page; page-break-before: always;"></div><p>go n (x:xs)=(go (n*x) xs)
niceProduct ::Numa=&gt;[a]-&gt;a
niceProduct =foldl' ( *)1</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 744
Remember the redundant structure when we looked at
folds?
mehConcat ::[[a]]-&gt;[a]
mehConcat xs=go[]xs
wherego::[a]-&gt;[[a]]-&gt;[a]
go xs'[]=xs'
go xs' (x :xs)=(go (xs' ++x) xs)
niceConcat ::[[a]]-&gt;[a]
niceConcat =foldr (++)[]
This may have given you a mild headache, but you may
also see that this same principle of abstracting out common
patterns and giving them names applies as well to unfolds as
it does to folds.
Write your own iterate and unfoldr
1.Write the function myIterate using direct recursion. Com-
pare the behavior with the built-in iterate to gauge cor-
rectness. Do not look at the source or any examples of
iterate so that you are forced to do this yourself.
myIterate ::(a-&gt;a)-&gt;a-&gt;[a]
myIterate =undefined</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 745
2.Write the function myUnfoldr using direct recursion. Com-
pare with the built-in unfoldr to check your implementa-
tion. Again, don‚Äôt look at implementations of unfoldr so
that you figure it out yourself.
myUnfoldr ::(b-&gt;Maybe(a, b))
-&gt;b
-&gt;[a]
myUnfoldr =undefined
3.Rewrite myIterate intobetterIterate usingmyUnfoldr . A
hint ‚Äî we used unfoldr to produce the same results as
iterate earlier. Do this with diÔ¨Äerent functions and see if
you can abstract the structure out.
-- It helps to have the
-- types in front of you
-- myUnfoldr :: (b -&gt; Maybe (a, b))
-- -&gt; b
-- -&gt; [a]
betterIterate ::(a-&gt;a)-&gt;a-&gt;[a]
betterIterate f x=myUnfoldr ...?
Remember, your betterIterate should have the same re-
sults as iterate .</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 746
Prelude&gt; take 10 $ iterate (+1) 0
[0,1,2,3,4,5,6,7,8,9]
Prelude&gt; take 10 $ betterIterate (+1) 0
[0,1,2,3,4,5,6,7,8,9]
Finally something other than a list!
Given the BinaryTree from last chapter, complete the following
exercises. Here‚Äôs that datatype again:
dataBinaryTree a=
Leaf
|Node(BinaryTree a) a (BinaryTree a)
deriving (Eq,Ord,Show)
1.Writeunfold forBinaryTree .
unfold::(a-&gt;Maybe(a,b,a))
-&gt;a
-&gt;BinaryTree b
unfold=undefined
2.Make a tree builder.
Usingthe unfold functionyou‚Äôvemadefor BinaryTree , write
the following function:</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 747
treeBuild ::Integer -&gt;BinaryTree Integer
treeBuild n=undefined
You should be producing results that look like the following:
Prelude&gt; treeBuild 0
Leaf
Prelude&gt; treeBuild 1
Node Leaf 0 Leaf
Prelude&gt; treeBuild 2
Node (Node Leaf 1 Leaf)
0
(Node Leaf 1 Leaf)
Prelude&gt; treeBuild 3
Node (Node (Node Leaf 2 Leaf)
1
(Node Leaf 2 Leaf))
0
(Node (Node Leaf 2 Leaf)
1
(Node Leaf 2 Leaf))
Or in a slightly diÔ¨Äerent representation:
0
0</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 748
/ <br />
1 1
0
/ <br />
1 1
/\ /<br />
2 2 2 2
Good work.
12.6 Definitions
1.Ahigher-kinded type type is any type whose kind has a
function arrow in it and which can be described as a type
constructor rather than a type constant. The following
types are of a higher kind than *:
Maybe:: * -&gt; *
[]:: * -&gt; *
Either:: * -&gt; * -&gt; *
(-&gt;):: * -&gt; * -&gt; *
The following are not:</p>
<p>CHAPTER 12. SIGNALING ADVERSITY 749
Int:: *
Char:: *
String:: *
[Char]:: *
This is not to be confused with higher kinded polymor-
phism, which we‚Äôll discuss later.</p>
<p>Chapter 13
Building projects
Wherever there is
modularity there is the
potential for
misunderstanding:
Hiding information
implies a need to check
communication
Alan Perlis
750</p>
<p>CHAPTER 13. BUILDING PROJECTS 751
13.1 Modules
Haskell programs are organized into modules. Modules con-
tain the datatypes, type synonyms, typeclasses, typeclass in-
stances, and values you‚Äôve defined at the top level. They oÔ¨Äer
a means to import other modules into the scope of your pro-
gram, and they also contain values that can be exported to
other modules. If you‚Äôve ever used a language with names-
paces, it‚Äôs the same thing.
In this chapter, we will be building a small, interactive
hangman-style game. Students of Haskell often ask what kind
of project they should work on as a way to learn Haskell, and
they want to jump right into the kind of program they‚Äôre
used to building in the languages they already know. What
most often happens is the student realizes how much they still
don‚Äôt understand about Haskell, shakes their fist at the sky, and
curses Haskell‚Äôs very name and all the elitist jerks who write
Haskell and flees to relative safety. Nobody wants that. Haskell
is sufficiently diÔ¨Äerent from other languages that we think it‚Äôs
best to spend time getting comfortable with how Haskell itself
works before trying to build substantial projects.
This chapter‚Äôs primary focus is not so much on code but on
how to set up a project in Haskell, use the package manager
known as Cabal, build the project with Stack, and work with
Haskell modules as they are. There are a few times we ask
you to implement part of the hangman game yourself, but</p>
<p>CHAPTER 13. BUILDING PROJECTS 752
much of the code is already written for you, and we‚Äôve tried to
explain the structure as well as we can at this point in the book.
Some of it you won‚Äôt properly understand until we‚Äôve covered
at least monads and IO. But if you finish the chapter feeling
like you now know how to set up a project environment and
get things running, then this chapter will have accomplished
its goal and we‚Äôll all go oÔ¨Ä and take a much needed mid-book
nap.
Try to relax and have fun with this. You‚Äôve earned it after
those binary tree exercises.
In this chapter, we‚Äôll cover:
‚Ä¢writing Haskell programs with modules;
‚Ä¢using the Cabal package manager;
‚Ä¢building our project with Stack;
‚Ä¢conventions around project organization;
‚Ä¢building a small interactive game.
Note that you‚Äôll need to have Stack1and Git2to follow along
with the instructions in this chapter. We‚Äôll be using gitto
download an example project. Depending on your level of
prior experience, some of this may not be new information
1http://haskellstack.org
2https://git-scm.com/</p>
<p>CHAPTER 13. BUILDING PROJECTS 753
for you. Feel free to move as quickly through this material as
feels comfortable.
13.2 Making packages with Stack
The Haskell Cabal, or Common Architecture for Building Ap-
plications and Libraries, is a package manager. A package is
a program you‚Äôre building, including all of its modules and
dependencies, whether you‚Äôve written it or you‚Äôre building
someone else‚Äôs program. A package has dependencies which are
the interlinked elements of that program, the other packages
and libraries it may depend on and any tests and documenta-
tion associated with the project. Cabal exists to help organize
all this and make sure all dependencies are properly in scope.
Stack is a cross-platform program for developing Haskell
projects. It is aimed at Haskellers both new and experienced,
and it helps you manage both projects made up of multiple
packages as well as individual packages, whereas Cabal exists
primarily to describe a single package with a Cabal file that
has the .cabal file extension.
Stack is built on top of Cabal in some important senses,
so we will still be working with .cabal files. However, Stack
simplifies the process somewhat, especially in large projects
with multiple dependencies, by allowing you to build those
large libraries only once and use them across projects. Stack</p>
<p>CHAPTER 13. BUILDING PROJECTS 754
also relies on an LTS (long term support) snapshot of Haskell
packages from Stackage3that are guaranteed to work together,
unlike packages from Hackage which may have conflicting
dependencies.
While the Haskell community does not have a prescribed
project layout, we recommend the basic structure embodied
in the Stack templates.
13.3 Working with a basic project
We‚Äôre going to start learning Cabal and Stack by building a
sample project called hello. To make this less tedious, we‚Äôre
going to use gitto checkout the sample project. In an appro-
priate directory for storing your projects, you‚Äôll want to git
clonethe repository https://github.com/haskellbook/hello .
Building the project
Change into the project directory that the git clone invocation
created.
$ cd hello
You could edit the hello.cabal file. There you can replace
‚ÄúYour Name Here‚Äù with‚Ä¶your name. We‚Äôll next build our
project:
3https://www.stackage.org/</p>
<p>CHAPTER 13. BUILDING PROJECTS 755
$ stack build
If it complains about needing GHC to be installed, don‚Äôt
panic! Part of the benefit of Stack is that it can manage your
GHC installs for you. Before re-attempting stack build , do the
following:
$ stack setup
Thesetupcommand for Stack determines what version of
GHC you need based on the LTS snapshot specified in the
stack.yaml file of your project. The stack.yaml file is used to
determine the versions of your packages and what version
of GHC they‚Äôll work best with. If you didn‚Äôt need to do this,
it‚Äôs possible you had a compatible version of GHC already
installed or that you‚Äôd run setup for an LTS snapshot that
needed the same version of GHC in the past. To learn more
about this, check out the Stackage website.
Loading and running code from the REPL
Having done that, next we‚Äôll fire up the REPL.
$ stack ghci
[... some other noise...]
Ok, modules loaded: Main.
Prelude&gt; :l Main</p>
<p>CHAPTER 13. BUILDING PROJECTS 756
[1 of 1] Compiling Main
Ok, modules loaded: Main.
Prelude&gt; main
hello world
Above, we successfully started a GHCi REPL that is aware
of our project, loaded our Mainmodule, and then ran the main
function. Using Stack‚Äôs GHCi integration to fire up a REPL
doesn‚Äôt just let us load and run code in our project, but also
enables us to make use of our project‚Äôs dependencies. We‚Äôll
demonstrate this later. indexmain@ main
stack exec
When you ran buildearlier, you may have seen something
like:
Linking .stack-work/dist/{...noise...}/hello
This noise is Stack compiling an executable binary and
linking to it. You can type the full path that Stack mentioned
in order to run the binary, but there‚Äôs an easier way ‚Äî exec!
From our project directory, consider the following:
$ hello
zsh: command not found: hello
$ stack exec -- hello
hello world</p>
<p>CHAPTER 13. BUILDING PROJECTS 757
Stack knows what paths any executables might be located in,
so using Stack‚Äôs execcommand saves you the hassle of typing
out a potentially verbose path.
Executable stanzas in Cabal files
Stack created an executable earlier because of the following
stanza in the hello.cabal file:
executable hello
-- [1]
hs-source-dirs: src
-- [2]
main-is: Main.hs
-- [3]
default-language: Haskell2010
-- [4]
build-depends: base &gt;= 4.7 &amp;&amp; &lt; 5
-- [5]
1.Thisnamefollowingthedeclarationofan executable stanza
tells Stack or Cabal what to name the binary or executable
it creates.
2.Tells this stanza where to look for source code ‚Äî in this
case, the srcsubdirectory.</p>
<p>CHAPTER 13. BUILDING PROJECTS 758
3.Execution of this binary should begin by looking for a main
function inside a file named Mainwith the module name
Main. Note that module names have to match filenames.
Your compiler (not just Stack) will reject using a file that
isn‚Äôt aMainmodule as the entry point to executing the
program. Also note that it‚Äôll look for the Main.hs file under
all directories you specified in hs-source-dirs . Since we
specified only one, it‚Äôll find this in src/Main.hs , which is
our only source file right now anyway.
4.Defines the version of the Haskell standard to expect. Not
very interesting and doesn‚Äôt do much ‚Äî mostly boiler-
plate, but necessary.
5.This is usually a meatier part of any Cabal stanza, whether
it‚Äôs an executable, library, or test suite. This example ( base)
is really the bare minimum or baseline dependency in
almost any Haskell project as you can‚Äôt really get anything
done without the baselibrary. We‚Äôll show you how to add
and install dependencies later.
A sidebar about executables and libraries Our project here
only has an executable stanza, which is appropriate for mak-
ing a command-line application which will be run and used.
When we‚Äôre writing code we want people to be able to reuse
in other projects, we need a library stanza in the .cabal file
and to choose which modules we want to expose. Executables</p>
<p>CHAPTER 13. BUILDING PROJECTS 759
are applications that the operating system will run directly,
while software libraries are code arranged in a manner so that
they can be reused by the compiler in the building of other
libraries and programs.
13.4 Making our project a library
First we‚Äôre going to add a library stanza to hello.cabal :
library
hs-source-dirs: src
exposed-modules: Hello
build-depends: base &gt;= 4.7 &amp;&amp; &lt; 5
default-language: Haskell2010
Then we‚Äôre going to create a file located at src/Hello.hs :
moduleHellowhere
sayHello ::IO()
sayHello = do
putStrLn &quot;hello world&quot;
Then we‚Äôre going to change our Mainmodule to use this
library function:</p>
<p>CHAPTER 13. BUILDING PROJECTS 760
moduleMainwhere
importHello
main::IO()
main= do
sayHello
If we try to build and run this now, it‚Äôll work.
$ stack build
$ stack exec hello
hello world
But what if we had made a separate exedirectory?
$ mkdir exe
$ mv src/Main.hs exe/Main.hs
Then we need to edit the .cabal file to let it know our hello
executable uses the exedirectory:
executable hello
hs-source-dirs: exe
main-is: Main.hs
default-language: Haskell2010
build-depends: base &gt;= 4.7 &amp;&amp; &lt; 5</p>
<p>CHAPTER 13. BUILDING PROJECTS 761
If you then attempt to build this, it will fail.
hello/exe/Main.hs:3:8:
Could not find module ‚ÄòHello‚Äô
It is a member of the hidden package
‚Äòhello-0.1.0.0@hello_IJIUuynUbgsHAquBKsAsb5‚Äô.
Perhaps you need to add ‚Äòhello‚Äô to the
build-depends in your .cabal file.
Use -v to see a list of the files searched for.
We have two paths for fixing this, one better than the other.
One way is to simply add srcto the source directories the
executable is permitted to search. But it turns out that Cabal‚Äôs
suggestion here is precisely right. The better way to fix this is
to respect the boundaries of the library and executable and
instead to add your own library as a dependency:
executable hello
hs-source-dirs: exe
main-is: Main.hs
default-language: Haskell2010
build-depends: base &gt;= 4.7 &amp;&amp; &lt; 5
, hello
The build will now succeed. This also makes it easier to
know when you need to change what is exposed or exported
in your library, because you‚Äôre using your own interface.</p>
<p>CHAPTER 13. BUILDING PROJECTS 762
13.5 Module exports
By default, when you don‚Äôt specify any exports in a module,
every top-level binding is exported and can be imported by
another module. This is the case in our Hellomodule:
moduleHellowhere
sayHello ::IO()
sayHello = do
putStrLn &quot;hello world&quot;
But what happens if we specify an empty export list?
moduleHello
()
where
sayHello ::IO()
sayHello = do
putStrLn &quot;hello world&quot;
We‚Äôll get the following error if we attempt to build it:
Not in scope: ‚ÄòsayHello‚Äô
To fix that explicitly, we add the top-level binding to the
export list:</p>
<p>CHAPTER 13. BUILDING PROJECTS 763
moduleHello
(sayHello )
where
sayHello ::IO()
sayHello = do
putStrLn &quot;hello world&quot;
Now the sayHello function will be exported. It seems point-
less in a module like this, but in bigger projects, it sometimes
makes sense to specify your exports in this way.
Exposing modules
First we‚Äôll add a new module with a new IO action for our main
action to run: indexmain@ main
-- src/DogsRule.hs
moduleDogsRule
(dogs)
where
dogs::IO()
dogs= do
putStrLn &quot;Who's a good puppy?!&quot;
putStrLn &quot;YOU ARE!!!!!&quot;</p>
<p>CHAPTER 13. BUILDING PROJECTS 764
Then we‚Äôll change our Mainmodule to make use of this:
moduleMainwhere
importDogsRule
importHello
main::IO()
main= do
sayHello
dogs
But if we attempt to build this, we‚Äôll get the following error:
Could not find module ‚ÄòDogsRule‚Äô
As we did earlier with our library stanza, we need to also
expose the DogsRule module:
library
hs-source-dirs: src
exposed-modules: DogsRule
, Hello
build-depends: base &gt;= 4.7 &amp;&amp; &lt; 5
default-language: Haskell2010
Now it should be able to find our very important dog prais-
ing.</p>
<p>CHAPTER 13. BUILDING PROJECTS 765
13.6 More on importing modules
Importing modules brings more functions into scope beyond
those available in the standard Prelude . Imported modules
are top-level declarations. The entities imported as part of
thosedeclarations, likeothertop-leveldeclarations, havescope
throughout the module, although they can be shadowed by
local bindings. The eÔ¨Äect of multiple import declarations is cu-
mulative, but the ordering of import declarations is irrelevant.
An entity is in scope for the entire module if it is imported by
any of the import declarations.
In previous chapters, we‚Äôve brought functions like booland
toUpper into scope for exercises by importing the modules they
are part of, Data.Bool andData.Char , respectively.
Let‚Äôs refresh our memory of how to do this in GHCi. The
:browse command allows us to see what functions are included
in the named module, while importing the module allows
us to use those functions. You can browse modules that you
haven‚Äôt imported yet, which can be useful if you‚Äôre not sure
which module the function you‚Äôre looking for is in:
Prelude&gt; :browse Data.Bool
bool :: a -&gt; a -&gt; Bool -&gt; a
(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
data Bool = False | True
not :: Bool -&gt; Bool</p>
<p>CHAPTER 13. BUILDING PROJECTS 766
otherwise :: Bool
(||) :: Bool -&gt; Bool -&gt; Bool
Prelude&gt; import Data.Bool
Prelude&gt; :t bool
bool :: a -&gt; a -&gt; Bool -&gt; a
In the example above, we used an unqualified import of
everything in Data.Bool . What if we only wanted boolfrom
Data.Bool ?
First, we‚Äôre going to turn oÔ¨Ä Prelude so that we don‚Äôt have
any of the default imports. We will use another extension
when we start GHCi to turn Prelude oÔ¨Ä. You‚Äôve previously seen
how to use language extensions in source files, but now we‚Äôll
enter-XNoImplicitPrelude right when we enter our REPL:
-- Do this outside of any projects
$ stack ghci --ghci-options -XNoImplicitPrelude
Prelude&gt;
We can check that boolandnotare not in scope yet:
Prelude&gt; :t bool
<interactive>:1:1: Not in scope: ‚Äòbool‚Äô
Prelude&gt; :t not</p>
<p>CHAPTER 13. BUILDING PROJECTS 767
<interactive>:1:1: Not in scope: ‚Äònot‚Äô
Next we‚Äôll do a selective import from Data.Bool , specifying
that we only want to import bool:
Prelude&gt; import Data.Bool (bool)
Prelude&gt; :t bool
bool :: a -&gt; a -&gt; GHC.Types.Bool -&gt; a
Prelude&gt; :t not
<interactive>:1:1: Not in scope: ‚Äònot‚Äô
Now, normally in the Prelude ,notis in scope already but
boolis not. So you can see that by turning oÔ¨Ä Prelude , taking
its standard functions out of scope, and then importing only
bool, we no longer have the standard notfunction in scope.
You can import one or more functions from a module or
library. The syntax is just as we demonstrated with GHCi,
but your import declarations have to be at the beginning of
a module. Putting import Data.Char (toUpper) in the import
declarations of a module will ensure that toUpper , but not any
of the other entities contained in Data.Char , is in scope for that
module.
For the examples in the next section, you‚Äôll want Prelude
back on, so please restart GHCi before proceeding.</p>
<p>CHAPTER 13. BUILDING PROJECTS 768
Qualified imports
What if you wanted to know where something you imported
came from in the code that uses it? We can use qualified
imports to make the names more explicit.
We use the qualified keyword in our imports to do this.
Sometimes you‚Äôll have stuÔ¨Ä with the same name imported
from two diÔ¨Äerent modules; qualifying your imports is a com-
mon way of dealing with this. We‚Äôll go through an example of
how you might use a qualified import.
Prelude&gt; import qualified Data.Bool
Prelude&gt; :t bool
<interactive>:1:1:
Not in scope: ‚Äòbool‚Äô
Perhaps you meant ‚ÄòData.Bool.bool‚Äô
Prelude&gt; :t Data.Bool.bool
Data.Bool.bool :: a -&gt; a -&gt; Bool -&gt; a
Prelude&gt; :t Data.Bool.not
Data.Bool.not :: Bool -&gt; Bool
In the case of import qualified Data.Bool , everything from
Data.Bool is in scope, but only when accessed with the full</p>
<p>CHAPTER 13. BUILDING PROJECTS 769
Data.Bool namespace. Now we are marking where the func-
tions that we‚Äôre using came from, which can be useful.
We can also provide aliases or alternate names for our mod-
ules when we qualify them so we don‚Äôt have to type out the
full namespace:
Prelude&gt; import qualified Data.Bool as B
Prelude&gt; :t bool
<interactive>:1:1:
Not in scope: ‚Äòbool‚Äô
Perhaps you meant ‚ÄòB.bool‚Äô
Prelude&gt; :t B.bool
B.bool :: a -&gt; a -&gt; Bool -&gt; a
Prelude&gt; :t B.not
B.not :: Bool -&gt; Bool
You can do qualified imports in the import declarations at
the beginning of your module in the same way.
Setting the Prelude prompt When you imported Data.Bool
asBabove, you may have seen your prompt change:
Prelude&gt; import qualified Data.Bool as B
Prelude B&gt;</p>
<p>CHAPTER 13. BUILDING PROJECTS 770
And if you don‚Äôt want to unload the imported modules
(because you want them all to stay in scope), your prompt
could keep growing:
Prelude B&gt; import Data.Char
Prelude B Data.Char&gt;
(Reminder: you can use :mto unload the modules, which
does, of course, prevent the prompt from growing ever larger,
but also, well, unloads the modules so they‚Äôre not in scope
anymore!)
If you want to prevent the ever-growing prompt, you can
use the :setcommand to set the prompt to whatever you
prefer:
Prelude&gt; :set prompt &quot;Lambda&gt; &quot;
Lambda&gt; import Data.Char
Lambda&gt; :t B.bool
B.bool :: a -&gt; a -&gt; Bool -&gt; a
As you can see, Data.Bool is still in scope as B, but it doesn‚Äôt
show up in our prompt. You can set your Prelude prompt
permanently, if you wish, by changing it in your GHCi config-
uration file, but instructions for doing that are somewhat out
of the scope of the current chapter.</p>
<p>CHAPTER 13. BUILDING PROJECTS 771
Intermission: Check your understanding
Here is the import list from one of the modules in Chris‚Äôs
library called blacktip :
import qualified Control.Concurrent
asCC
import qualified Control.Concurrent.MVar
asMV
import qualified Data.ByteString.Char8
asB
import qualified Data.Locator
asDL
import qualified Data.Time.Clock.POSIX
asPSX
import qualified Filesystem
asFS
import qualified Filesystem.Path.CurrentOS
asFPC
import qualified Network.Info
asNI</p>
<p>CHAPTER 13. BUILDING PROJECTS 772
import qualified Safe
importControl.Exception (mask,try)
importControl.Monad (forever,when)
importData.Bits
importData.Bits.Bitwise (fromListBE )
importData.List.Split (chunksOf )
importDatabase.Blacktip.Types
importSystem.IO.Unsafe (unsafePerformIO )
For our purposes right now, it does not matter whether you
are familiar with the modules referenced in the import list.
Look at the declarations and answer the questions below:
1.What functions are being imported from Control.Monad ?
2.Which imports are both unqualified and imported in their
entirety?
3.From the name, what do you suppose importing blacktip ‚Äôs
Typesmodule brings in?
4.Now let‚Äôs compare a small part of blacktip ‚Äôs code to the
above import list:</p>
<p>CHAPTER 13. BUILDING PROJECTS 773
writeTimestamp ::MV.MVarServerState
-&gt;FPC.FilePath
-&gt;IOCC.ThreadId
writeTimestamp s path= do
CC.forkIO go
wherego=forever $ do
ss&lt;-MV.readMVar s
mask$_ -&gt; do
FS.writeFile path
(B.pack (show (ssTime ss)))
-- sleep for 1 second
CC.threadDelay 1000000
a)The type signature refers to three aliased imports.
What modules are named in those aliases?
b)Which import does FS.writeFile refer to?
c)Which import did forever come from?
13.7 Making our program interactive
Now we‚Äôre going to make our program ask for your name, then
greet you by name. First, we‚Äôll rewrite our sayHello function
to take an argument:</p>
<p>CHAPTER 13. BUILDING PROJECTS 774
sayHello ::String-&gt;IO()
sayHello name=
putStrLn ( &quot;Hi &quot;++name++&quot;!&quot;)
Note we parenthesized the appending (++)function of the
String argument to putStrLn .
Next we‚Äôll change mainto get the user‚Äôs name:
-- src/Main.hs
main::IO()
main= do
name&lt;-getLine
sayHello name
dogs
There are a couple of new things here. We‚Äôre using some-
thing called dosyntax, which is syntactic sugar. We use do
inside functions that return IOin order to sequence side eÔ¨Äects
in a convenient syntax. Let‚Äôs decompose what‚Äôs going on here:</p>
<p>CHAPTER 13. BUILDING PROJECTS 775
main::IO()
main= do
-- [1]
name&lt;-getLine
-- [4] [3] [2]
sayHello name
-- [5]
dogs
-- [6]
1.Thedohere begins the block.
2.getLine has type IO String , because it must perform I/O
(input/output, side eÔ¨Äects) in order to obtain the String.
getLine is what will allow you to enter your name to be
used in the mainfunction.
3.&lt;-in adoblock is pronounced bind. We‚Äôll explain what
this is and how it works in the chapters on MonadandIO.
4.The result of binding ( &lt;-) over the IO String isString . We
bound it to the variable name. Remember, getLine has type
IO String ,namehas type String .
5.sayHello expects an argument String , which is the type of
namebutnotgetLine .</p>
<p>CHAPTER 13. BUILDING PROJECTS 776
6.dogs4expects nothing and is an IOaction of type IO (),
which fits the overall type of main.
indexmain@ main
Now we‚Äôll fire oÔ¨Ä a build:
$ stack build
And run the program:
$ stack exec hello
After you hit enter, the program is going to wait for your
input. You‚Äôll just see the cursor blinking on the line, waiting
for you to enter your name. As soon as you do, and hit enter,
it should greet you and then rave about the wonderfulness of
a dog.
What if we tried to pass getLine to sayHello? If we tried to
writemainwithout the use of dosyntax, particularly without
using&lt;-such as in the following example:
main::IO()
main=sayHello getLine
We‚Äôd get the following type error:
4Much like actual dogs.</p>
<p>CHAPTER 13. BUILDING PROJECTS 777
$ stack build
[2 of 2] Compiling Main
src/Main.hs:8:17:
Couldn't match type ‚ÄòIO String‚Äô with ‚Äò[Char]‚Äô
Expected type: String
Actual type: IO String
In the first argument of ‚ÄòsayHello‚Äô, namely ‚ÄògetLine‚Äô
In the expression: sayHello getLine
This is because getLine is anIOaction with type IO String ,
whereas sayHello expects a value of type String. We have to
use&lt;-to bind over the IOto get the string that we want to
pass tosayHello . This will be explained in more detail ‚Äî a bit
more detail later in the chapter, and a lot more detail in a later
chapter.
Adding a prompt
Let‚Äôs make our program a bit easier to use by adding a prompt
that tells us our program is expecting input! We need to change
main:</p>
<p>CHAPTER 13. BUILDING PROJECTS 778
moduleMainwhere
importDogsRule
importHello
importSystem.IO
main::IO()
main= do
hSetBuffering stdout NoBuffering
putStr&quot;Please input your name: &quot;
name&lt;-getLine
sayHello name
dogs
We did several things here. One is that we used putStr in-
stead of putStrLn so that our input could be on the same line as
our prompt. We also imported from System.IO so that we could
usehSetBuffering ,stdout, andNoBuffering . That line of code is
so thatputStr isn‚Äôt buÔ¨Äered (deferred) and prints immediately.
Rebuild and rerun your program, and it should now work like
this:
$ stack exec hello
Please input your name: julie
Hi julie!
Who's a good puppy?!</p>
<p>CHAPTER 13. BUILDING PROJECTS 779
YOU ARE!!!!!
You can try removing the NoBuffering line (that whole first
line) from mainand rebuilding and running your program
to see how it changes. We will be using this as part of our
hangman game in a bit, but it isn‚Äôt necessary at this point to
understand how the buÔ¨Äering functions work in any detail.
13.8 do syntax and IO
We touched on donotation a bit above, but we want to explain
a few more things about it. doblocks are convenient syntactic
sugar that allow for sequencing actions, but because they are
only syntactic sugar, they are not, strictly speaking, necessary.
They can make blocks of code more readable and also hide
the underlying nesting, and that can help you write eÔ¨Äectful
code before you understand monads and IO. So you‚Äôll see it
a lot in this chapter (and, indeed, you‚Äôll see it quite a bit in
idiomatic Haskell code).
Themainexecutable in a Haskell program must always have
the type IO (). Thedosyntax specifically allows us to sequence
monadic actions .Monadis a typeclass we‚Äôll explain in great detail
in a later chapter; here, the instance of Monad we care about is
IO. That is why mainfunctions are often (not always) doblocks.
indexmain@ main</p>
<p>CHAPTER 13. BUILDING PROJECTS 780
This syntax also provides a way of naming values returned
by monadic IOactions so that they can be used as inputs to
actions that happen later in the program. Let‚Äôs look at a very
simpledoblock and try to get a feel for what‚Äôs happening here:
main= do
-- [1]
x1&lt;-getLine
-- [2] [3] [4]
x2&lt;-getLine
-- [5]
return (x1 ++x2)
-- [6] [7]
1.dointroduces the block of IO actions.
2.ùë•1is a variable representing the value obtained from the
IO action getLine .
3.&lt;-binds the variable on the left to the result of the IO
action on the right.
4.getLine has the type IO String and takes user input of a
string value. In this case, the string the user inputs will be
the value bound to the ùë•1name.</p>
<p>CHAPTER 13. BUILDING PROJECTS 781
5.ùë•2is a variable representing the value obtained from our
second getLine . As above it is bound to that value by the
&lt;-.
6.return will be discussed in more detail shortly, but here it
is the concluding action of our doblock.
7.This is the value return , well, returns ‚Äî the conjunction of
the two strings we obtained from our two getLine actions.
While&lt;-is used to bind a variable, it is diÔ¨Äerent from other
methods we‚Äôve seen in earlier chapters for naming and binding
variables. This arrow is part of the special dosugar and specif-
ically binds a name to the ùëéof anm avalue, where ùëöis some
monadic structure, in this case IO. The&lt;-allows us to extract
thatùëéand name it within the limited scope of the doblock
and use that named value as an input to another expression
within that same scope. Each assignment using &lt;-creates a
new variable rather than mutating an existing variable because
data is immutable.
return
This function really doesn‚Äôt do a lot, but the purpose it serves
is important, given the way monads and IOwork. It does noth-
ing but return a value, but it returns a value inside monadic
structure:</p>
<p>CHAPTER 13. BUILDING PROJECTS 782
Prelude&gt; :t return
return :: Monad m =&gt; a -&gt; m a
For our purposes in this chapter, return returns a value in
IO. Because the obligatory type of mainisIO (), the final value
must also have an IO ()type, and return gives us a way to add
no extra function except putting the final value in IO. If the
final action of a doblock is return () , that means there is no
real value to return at the end of performing the I/O actions,
but since Haskell programs can‚Äôt return literally nothing, they
return this empty tuple called unit simply to have something
to return. That empty tuple will not print to the screen in the
REPL, but it‚Äôs there in the underlying representation.
Let‚Äôs take a look at return in action. Let‚Äôs say you want to get
user input of two characters and test them for equality. You
can‚Äôt do this:
twoo::IOBool
twoo= doc&lt;-getChar
c'&lt;-getChar
c==c'
Try it and see what your type error looks like. It should
tell you that it can‚Äôt match the expected type IO Bool with the
actual type of c == c' , which is Bool. So, our final line needs to
return that Boolvalue in IO:</p>
<p>CHAPTER 13. BUILDING PROJECTS 783
twoo::IOBool
twoo= doc&lt;-getChar
c'&lt;-getChar
return (c ==c')
We put the Boolvalue into IOby using return. Cool. How
about if we have cases where we want to return nothing? We‚Äôll
reuse the same basic code from above but make an if-then-else
within our doblock:
main::IO()
main= doc&lt;-getChar
c'&lt;-getChar
ifc==c'
thenputStrLn &quot;True&quot;
elsereturn()
What happens when the two input characters are equal?
What happens when they aren‚Äôt?
Some people have noted that dosyntax makes it feel like
you‚Äôre doing imperative programming in Haskell. It‚Äôs impor-
tant to note that this eÔ¨Äectful imperative style requires having
IOin our result type. We cannot perform eÔ¨Äects without evi-
dence of having done so in the type. dois only syntactic sugar,
but the monadic syntax we‚Äôll cover in a later chapter works in
a similar way for monads other than IO.</p>
<p>CHAPTER 13. BUILDING PROJECTS 784
Do notation considered harmful! Just kidding. But some-
times enthusiastic programmers overuse doblocks. It is not
necessary, and considered bad style, to use doin single-line
expressions. You will eventually learn to use &gt;&gt;=in single-
line expressions instead of do(there‚Äôs an example of that in
this chapter). Similarly, it is unnecessary to use dowith func-
tions like putStrLn andprintthat already have the eÔ¨Äects baked
in. In the function above, we could have put doin front of
bothputStrLn andreturn and it would have worked the same,
but things get messy and the Haskell ninjas will come and be
severely disappointed in you.
13.9 Hangman game
Now we‚Äôre ready to build a game. We‚Äôll use Stack‚Äôs newcom-
mand to create this project:
$ stack new hangman simple
That will generate a directory named hangman for you and
some put some default files into the directory.
You need a wordsfile for getting words from. Most Unix-
based operating systems will have a words list located at a
directory like the following:
$ ls /usr/share/dict/
american-english british-english</p>
<p>CHAPTER 13. BUILDING PROJECTS 785
cracklib-small README.select-wordlist
words words.pre-dictionaries-common
In this case, we‚Äôll use the wordsword list which should be
your operating system‚Äôs default. You may have one that is
diÔ¨Äerently located, or you may need to download one. We
put it in the working directory at data/dict.txt :
$ tree .
.
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Setup.hs
‚îú‚îÄ‚îÄ data
‚îÇ ‚îî‚îÄ‚îÄ dict.txt
‚îú‚îÄ‚îÄ hangman.cabal
‚îú‚îÄ‚îÄ src
‚îÇ ‚îî‚îÄ‚îÄ Main.hs
‚îî‚îÄ‚îÄ stack.yaml
The file was newline separated and so looked like:
$ head data/dict.txt
A
a
aa
aal
aalii</p>
<p>CHAPTER 13. BUILDING PROJECTS 786
aam
Aani
aardvark
aardwolf
Aaron
Now edit the .cabal file as follows:
name: hangman
version: 0.1.0.0
synopsis: Playing Hangman
homepage: Chris N Julie
license: BSD3
license-file: LICENSE
author: Chris Allen and Julie Moronuki
maintainer: haskellbook.com
category: Game
build-type: Simple
extra-source-files: data/dict.txt
cabal-version: &gt;=1.10
executable hangman
main-is: Main.hs
hs-source-dirs: src
build-depends: base &gt;=4.7 &amp;&amp; &lt;5
, random
, split
default-language: Haskell2010</p>
<p>CHAPTER 13. BUILDING PROJECTS 787
The important bit here is that we used two libraries: random
andsplit. Normally you‚Äôd do version ranges for your depen-
dencies like you see with base, but we left the versions of random
andsplitunassigned because they do not change much. The
primary and only source file was in src/Main.hs .
13.10 Step One: Importing modules
-- src/Main.hs
moduleMainwhere
importControl.Monad (forever)-- [1]
importData.Char (toLower)-- [2]
importData.Maybe (isJust)-- [3]
importData.List (intersperse )-- [4]
importSystem.Exit (exitSuccess )-- [5]
importSystem.Random (randomRIO )-- [6]
Here the imports are enumerated in the source code. For
your version of this project, you don‚Äôt need to add the enumer-
ating comments. All modules listed below are part of the main
baselibrary that comes with your GHC install unless otherwise
noted.</p>
<p>CHAPTER 13. BUILDING PROJECTS 788
1.We‚Äôre using forever fromControl.Monad to make an infinite
loop. A couple points to note:
a)You don‚Äôt haveto useforever to do this, but we‚Äôre going
to.
b)You are not expected to understand what it does or
how it works exactly. Basically it allows us to execute
a function over and over again, infinitely, or until we
cause the program to exit or fail, instead of evaluating
once and then stopping.
2.We will use toLower fromData.Char to convert all characters
of our string to lowercase:
Prelude&gt; import Data.Char (toLower)
Prelude&gt; toLower 'A'
'a'
Be aware that if you pass a character that doesn‚Äôt have a
sensible lowercase, toLower will kick the same character
back out:
Prelude&gt; toLower ':'
':'</p>
<p>CHAPTER 13. BUILDING PROJECTS 789
3.We will use isJust fromData.Maybe to determine if every
character in our puzzle has been discovered already or
not:
Prelude&gt; import Data.Maybe (isJust)
Prelude&gt; isJust Nothing
False
Prelude&gt; isJust (Just 10)
True
We will combine this with all, a standard function in the
Prelude . Hereallis a function which answers the question,
‚Äúgiven a function that will return True or False for each
element, does it return True for allof them?‚Äù
Prelude&gt; all even [2, 4, 6]
True
Prelude&gt; all even [2, 4, 7]
False
Prelude&gt; all isJust [Just 'd', Nothing, Just 'g']
False
Prelude&gt; all isJust [Just 'd', Just 'o', Just 'g']
True
The function allhas the type:</p>
<p>CHAPTER 13. BUILDING PROJECTS 790
Foldable t=&gt;(a-&gt;Bool)-&gt;t a-&gt;Bool
We haven‚Äôt explained the Foldable typeclass. For your
purposes you can assume it‚Äôs a set of operations for types
that can be folded in a manner conceptually similar to
the list type but which don‚Äôt necessarily contain more than
one value (or any values at all) the way a list or similar
datatype does. We can make the type more specific by
asserting a type signature like so:
Prelude&gt; :t all :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
all :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
This will work for any type which has a Foldable instance:
Prelude&gt; :t all :: (a -&gt; Bool) -&gt; Maybe a -&gt; Bool
all :: (a -&gt; Bool) -&gt; Maybe a -&gt; Bool
-- note the type variables used and
-- experiment independently
Prelude&gt; :t all :: (a -&gt; Bool) -&gt; Either b a -&gt; Bool
all :: (a -&gt; Bool) -&gt; Either b a -&gt; Bool
But it will not work if the datatype doesn‚Äôt have an instance
ofFoldable :</p>
<p>CHAPTER 13. BUILDING PROJECTS 791
Prelude&gt; :t all :: (a -&gt; Bool) -&gt; (b -&gt; a) -&gt; Bool
No instance for (Foldable ((-&gt;) b1)) arising
from a use of ‚Äòall‚Äô
In the expression:
all :: (a -&gt; Bool) -&gt; (b -&gt; a) -&gt; Bool
4.Weuseintersperse fromData.List to‚Ä¶intersperseelements
in a list. In this case, we‚Äôre putting spaces between the
characters guessed so far by the player. You may remem-
ber we used intersperse back in the Recursion chapter to
put hyphens in our Numbers Into Words exercise:
Prelude&gt; import Data.List (intersperse)
Prelude&gt; intersperse ' ' &quot;Blah&quot;
&quot;B l a h&quot;
Conveniently, the type of intersperse says nothing about
characters or strings, so we can use it with lists containing
elements of any type:
Prelude&gt; :t intersperse
intersperse :: a -&gt; [a] -&gt; [a]
Prelude&gt; intersperse 0 [1, 1, 1]</p>
<p>CHAPTER 13. BUILDING PROJECTS 792
[1,0,1,0,1]
5.We use exitSuccess fromSystem.Exit to exit successfully ‚Äî
no errors, we‚Äôre simply done. We indicate whether it was
a success or not so our operating system knows whether
an error occurred. Note that if you evaluate exitSuccess
in the REPL, it‚Äôll report that an exception occurred. In a
normal running program that doesn‚Äôt catch the exception,
it‚Äôll end your whole program.
6.We use randomRIO fromSystem.Random to select a word from
our dictionary at random. System.Random is in the library
random . Once again, you‚Äôll need to have the library in scope
for your REPL to be able to load it. Once it‚Äôs in scope,
we can use randomRIO to get a random number. You can
see from the type signature that it takes a tuple as an
argument, but it uses the tuple as a range from which to
select a random item:
Prelude&gt; import System.Random
Prelude System.Random&gt; :t randomRIO
randomRIO :: Random a =&gt; (a, a) -&gt; IO a
Prelude System.Random&gt; randomRIO (0, 5)
4
Prelude System.Random&gt; randomRIO (1, 100)
71</p>
<p>CHAPTER 13. BUILDING PROJECTS 793
Prelude System.Random&gt; randomRIO (1, 100)
12
We will later use this random number generation to pro-
duce a random index of a word list to provide a means of
selecting random words for our puzzle.
13.11 Step Two: Generating a word list
For clarity‚Äôs sake, we‚Äôre using a type synonym to declare what
we mean by [String] in our types. Later we‚Äôll show you a
version that‚Äôs even more explicit using newtype . We also use do
syntax to read the contents of our dictionary into a variable
named dict. We use the linesfunction to split our big blob
string we read from the file into a list of string values each
representing a single line. Each line is a single word, so our
result is the WordList :
typeWordList =[String]
allWords ::IOWordList
allWords = do
dict&lt;-readFile &quot;data/dict.txt&quot;
return (lines dict)
Let‚Äôs take a moment to look at lines, which splits strings at
the newline marks and returns a list of strings:</p>
<p>CHAPTER 13. BUILDING PROJECTS 794
Prelude&gt; lines &quot;aardvark\naaron&quot;
[&quot;aardvark&quot;,&quot;aaron&quot;]
Prelude&gt; length $ lines &quot;aardvark\naaron&quot;
2
Prelude&gt; length $ lines &quot;aardvark\naaron\nwoot&quot;
3
Prelude&gt; lines &quot;aardvark aaron&quot;
[&quot;aardvark aaron&quot;]
Prelude&gt; length $ lines &quot;aardvark aaron&quot;
1
Note that this does something similar but diÔ¨Äerent from
wordswhich splits by spaces (ostensibly between words) and
newlines:
Prelude&gt; words &quot;aardvark aaron&quot;
[&quot;aardvark&quot;,&quot;aaron&quot;]
Prelude&gt; words &quot;aardvark\naaron&quot;
[&quot;aardvark&quot;,&quot;aaron&quot;]
The next part of building our word list for our puzzle is to
set upper and lower bounds for the size of words we‚Äôll use in
the puzzles. Feel free to change them if you want:</p>
<p>CHAPTER 13. BUILDING PROJECTS 795
minWordLength ::Int
minWordLength =5
maxWordLength ::Int
maxWordLength =9
The next thing we‚Äôre going to do is take the output of
allWords and filter it to fit the length criteria we defined above.
That will give us a shorter list of words to use in the puzzles:
gameWords ::IOWordList
gameWords = do
aw&lt;-allWords
return (filter gameLength aw)
wheregameLength w =
letl=length (w ::String)
inl&gt;=minWordLength
&amp;&amp;l&lt;maxWordLength
We next need to write a pair of functions that will pull a
random word out of our word list for us, so that the puzzle
player doesn‚Äôt know what the word will be. We‚Äôre going to use
therandomRIO function we mentioned above to facilitate that.
We‚Äôll pass randomRIO a tuple of zero (the first indexed position
in our word list) and the number that is the length of our word
list minus one. Why minus one?</p>
<p>CHAPTER 13. BUILDING PROJECTS 796
We have to subtract one from the length of the word list
in order to index it because length starts counting from 1 but
an index of the list starts from 0. A list of length 5 does not
have a member indexed at position 5 ‚Äî it has inhabitants at
positions 0-4 instead:
Prelude&gt; [1..5] !! 4
5
Prelude&gt; [1..5] !! 5
*** Exception: Prelude.(!!): index too large
In order to get the last value in the list, then, we must ask
for the member in the position of the length of the list minus
one:
Prelude&gt; let myList = [1..5]
Prelude&gt; length myList
5
Prelude&gt; myList !! length myList
*** Exception: Prelude.!!: index too large
Prelude&gt; myList !! (length myList - 1)
5
The next two functions work together to pull a random
word out of the gameWords list we had created above. Roughly
speaking, randomWord generates a random index number based</p>
<p>CHAPTER 13. BUILDING PROJECTS 797
on the length of a word list, wl, and then selects the member
of that list that is at that indexed position and returns an IO
String. Given what you know about randomRIO and indexing,
you should be able to supply the tuple argument to randomRIO
yourself:
randomWord ::WordList -&gt;IOString
randomWord wl= do
randomIndex &lt;-randomRIO ( , )
-- fill this part in ^^^
return$wl!!randomIndex
The second function, randomWord' binds the gameWords list to
therandomWord function so that the random word we‚Äôre getting
is from that list. We‚Äôre going to delay a full discussion of the
&gt;&gt;=operator known as ‚Äúbind‚Äù until we get to the Monadchapter.
For now, we can say that, as we said about dosyntax, bindallows
us to sequentially compose actions such that a value generated
by the first becomes an argument to the second:
randomWord' ::IOString
randomWord' =gameWords &gt;&gt;=randomWord
Now that we have a word list, we turn our attention to the
building of an interactive game using it.</p>
<p>CHAPTER 13. BUILDING PROJECTS 798
13.12 Step Three: Making a puzzle
Our next step is to formulate the core game play. We need a
way to hide the word from the player (while giving them an
indication of how many letters it has) and create a means of
asking for letter guesses, determining if the guessed letter is
in the word, putting it in the word if it is and putting it into
an ‚Äúalready guessed‚Äù list if it‚Äôs not, and determining when the
game ends.
We start with a datatype for our puzzle. The puzzle is a
product of aString , a list of Maybe Char , and a list of Char:
dataPuzzle=
PuzzleString[MaybeChar] [Char]
-- [1] [2] [3]
1.the word we‚Äôre trying to guess
2.the characters we‚Äôve filled in so far
3.the letters we‚Äôve guessed so far
Next we‚Äôre going to write an instance of the typeclass Show
for our datatype Puzzle. You may recall that showallows us to
print human-readable stringy things to the screen, which is
obviously something we have to do to interact with our game.
But we want it to print our puzzle a certain way, so we define
this instance.</p>
<p>CHAPTER 13. BUILDING PROJECTS 799
Notice how the argument to showlines up with our datatype
definition above. Now discovered refers to our list of Maybe Char
andguessed is what we‚Äôve named our list of Char, but we‚Äôve
done nothing with the String itself:
instance ShowPuzzlewhere
show (Puzzle_discovered guessed) =
(intersperse ' '$
fmap renderPuzzleChar discovered)
++&quot; Guessed so far: &quot; ++guessed
This is going to show us two things as part of our puzzle:
the list of Maybe Char which is the string of characters we have
correctly guessed and the rest of the characters of the puzzle
word represented by underscores, interspersed with spaces;
and a list of Charthat reminds us of which characters we‚Äôve
already guessed. We‚Äôll talk about renderPuzzleChar below.
First we‚Äôre going to write a function that will take our puzzle
word and turn it into a list of Nothing . This is the first step in
hiding the word from the player. We‚Äôre going to ask you to
write this one yourself, using the following information:
‚Ä¢We‚Äôve given you a type signature. Your first argument is a
String , which will be the word that is in play. It will return
a value of type Puzzle . Remember that the Puzzle type is a
product of three things.</p>
<p>CHAPTER 13. BUILDING PROJECTS 800
‚Ä¢Your first value in the output will be the same string as
the argument to the function.
‚Ä¢The second value will be the result of mapping a function
over that String argument. Consider using constin the
mapped function, as it will always return its first argument,
no matter what its second argument is.
‚Ä¢For purposes of this function, the final argument of Puzzle
is an empty list.
Go for it:
freshPuzzle ::String-&gt;Puzzle
freshPuzzle =undefined
Now we need a function that looks at the Puzzle String and
determines whether the character you guessed is an element
of that string. Here are some hints:
‚Ä¢This is going to need two arguments, and one of those
is of type Puzzle which is a product of 3 types. But for
the purpose of this function, we only care about the first
argument to Puzzle .
‚Ä¢We can use underscores to signal that there are values
we don‚Äôt care about and tell the function to ignore them.
Whether you use underscores to represent the arguments</p>
<p>CHAPTER 13. BUILDING PROJECTS 801
you don‚Äôt care about or go ahead and put the names of
those in won‚Äôt aÔ¨Äect the result of the function. It does,
however, keep your code a bit cleaner and easier to read
by explicitly signaling which arguments you care about
in a given function.
‚Ä¢The standard function elemworks like this:
Prelude&gt; :t elem
elem :: Eq a =&gt; a -&gt; [a] -&gt; Bool
Prelude&gt; elem 'a' &quot;julie&quot;
False
Prelude&gt; elem 3 [1..5]
True
So, here you go:
charInWord ::Puzzle-&gt;Char-&gt;Bool
charInWord =undefined
The next function is very similar to the one you just wrote,
but this time we don‚Äôt care if the Charis part of the String
argument ‚Äî this time we want to check and see if it is an
element of the guessed list.
You‚Äôve totally got this:
alreadyGuessed ::Puzzle-&gt;Char-&gt;Bool
alreadyGuessed =undefined</p>
<p>CHAPTER 13. BUILDING PROJECTS 802
OK, so far we have ways to choose a word that we‚Äôre trying
to guess and determine if a guessed character is part of that
word or not. But we need a way to hide the rest of the word
from the player while they‚Äôre guessing. Computers are a bit
dumb, after all, and can‚Äôt figure out how to keep secrets on
their own. Back when we defined our Showinstance for this
puzzle, we fmapped a function called renderPuzzleChar over
our second Puzzle argument. Let‚Äôs work on that function next.
The goal here is to use Maybeto permit two diÔ¨Äerent out-
comes. It will be mapped over a string in the typeclass instance,
so this function works on only one character at a time. If that
character has not been correctly guessed yet, it‚Äôs a Nothing value
and should appear on the screen as an underscore. If the char-
acter has been guessed, we want to display that character so
the player can see which positions they‚Äôve correctly filled:
Prelude&gt; renderPuzzleChar Nothing
'_'
Prelude&gt; renderPuzzleChar (Just 'c')
'c'
Prelude&gt; let n = Nothing
Prelude&gt; let daturr = [n, Just 'h', n, Just 'e', n]
Prelude&gt; fmap renderPuzzleChar daturr
&quot;<em>h_e</em>&quot;
Your turn. Remember, you don‚Äôt need to do the mapping
part of it here:</p>
<p>CHAPTER 13. BUILDING PROJECTS 803
renderPuzzleChar ::MaybeChar-&gt;Char
renderPuzzleChar =undefined
The next bit is a touch tricky. The point is to insert a cor-
rectly guessed character into the string. Although none of the
components here are new to you, they‚Äôre put together in a
somewhat dense manner, so we‚Äôre going to unpack it (obvi-
ously, when you type this into your own file, you do not need
to add the enumerations):</p>
<p>CHAPTER 13. BUILDING PROJECTS 804
fillInCharacter ::Puzzle-&gt;Char-&gt;Puzzle
fillInCharacter (Puzzleword
-- [1]
filledInSoFar s) c =
-- [2]
Puzzleword newFilledInSoFar (c :s)
-- [ 3 ]
wherezipper guessed wordChar guessChar =
-- [4] [5] [6] [7]
ifwordChar ==guessed
thenJustwordChar
elseguessChar
-- [ 8 ]
newFilledInSoFar =
-- [9]
zipWith (zipper c)
word filledInSoFar
-- [ 10 ]
1.The first argument is our Puzzle with its three arguments,
withùë†representing the list of characters already guessed.
2.Theùëêis ourCharargument and is the character the player
guessed on this turn.
3.Our result is the Puzzle with the filledInSoFar replaced by</p>
<p>CHAPTER 13. BUILDING PROJECTS 805
newFilledInSoFar theùëêconsed onto the front of the ùë†list.
4.zipper is a combining function for deciding how to handle
the character in the word, what‚Äôs been guessed already,
and the character that was just guessed. If the current
character in the word is equal to what the player guessed,
then we go ahead and return Just wordChar to fill in that
spot in the puzzle. Otherwise, we kick the guessChar back
out. We kick guessChar back out because it might either be
a previously correctly guessed character oraNothing that
has not been guessed correctly this time nor in the past.
5.guessed is the character they guessed.
6.wordChar is the characters in the puzzle word ‚Äî not the
ones they‚Äôve guessed or not guessed, but the characters
in the word that they‚Äôre supposed to be guessing.
7.guessChar is the list that keeps track of the characters the
player has guessed so far.
8.Thisif-then-else expression checks to see if the guessed
character is one of the word characters. If it is, it wraps it
in aJustbecause our puzzle word is a list of Maybevalues.
9.newFilledInSoFar is the new state of the puzzle which uses
zipWith and the zipper combining function to fill in char-
acters in the puzzle. The zipper function is first applied to</p>
<p>CHAPTER 13. BUILDING PROJECTS 806
the character the player just guessed because that doesn‚Äôt
change. Then it‚Äôs zipped across two lists. One list is word
which is the word the user is trying to guess. The second
list,filledInSoFar is the puzzle state we‚Äôre starting with of
type[Maybe Char] . That‚Äôs telling us which characters in
wordhave been guessed.
10.Now we‚Äôre going to make our newFilledInSoFar by using
zipWith . You may remember this from the Lists chapter.
It‚Äôs going to zip the wordwith the filledInSoFar values while
applying the zipper function from just above it to the
values as it does.
Next we have this big doblock with a case expression and
each case also has a doblock inside it. Why not, right?
First, it tells the player what you guessed. The case ex-
pression is to give diÔ¨Äerent responses based on whether the
guessed character:
‚Ä¢had already been guessed previously;
‚Ä¢is in the word and needs to be filled in;
‚Ä¢or, was not previously guessed but also isn‚Äôt in the puzzle
word.
Despite the initial appearance of complexity, most of this
is syntax you‚Äôve seen before, and you can look through it step-
by-step and see what‚Äôs going on:</p>
<p>CHAPTER 13. BUILDING PROJECTS 807
handleGuess ::Puzzle-&gt;Char-&gt;IOPuzzle
handleGuess puzzle guess = do
putStrLn $&quot;Your guess was: &quot; ++[guess]
case(charInWord puzzle guess
, alreadyGuessed puzzle guess) of
(<em>,True)-&gt; do
putStrLn &quot;You already guessed that <br />
\character, pick <br />
\something else!&quot;
return puzzle
(True,</em>)-&gt; do
putStrLn &quot;This character was in the <br />
\word, filling in the word <br />
\accordingly&quot;
return (fillInCharacter puzzle guess)
(False,_)-&gt; do
putStrLn &quot;This character wasn't in <br />
\the word, try again.&quot;
return (fillInCharacter puzzle guess)
All right, next we need to devise a way to stop the game
after a certain number of guesses. Hangman games normally
stop only after a certain number of incorrect guesses, but for
the sake of simplicity here, we‚Äôre stopping after a set number
of guesses, whether they‚Äôre correct or not. Again, the syntax</p>
<p>CHAPTER 13. BUILDING PROJECTS 808
here should be comprehensible to you from what we‚Äôve done
so far:
gameOver ::Puzzle-&gt;IO()
gameOver (PuzzlewordToGuess _guessed) =
if(length guessed) &gt;7then
doputStrLn &quot;You lose!&quot;
putStrLn $
&quot;The word was: &quot; ++wordToGuess
exitSuccess
elsereturn()
Notice the way it‚Äôs written says you lose and exits the game
once you‚Äôve guessed seven characters, even if the final (seventh)
guess is the final letter to fill into the word. There are, of course,
ways to modify that to make it more the way you‚Äôd expect a
hangman game to go, and we encourage you to play with that.
Next we need to provide a way to exit after winning the
game. We showed you how the combination of isJust andall
works earlier in the chapter, and you can see that in action
here. Recall that our puzzle word is a list of Maybevalues, so
when each character is represented by a Just Char rather than
aNothing , you win the game and we exit:</p>
<p>CHAPTER 13. BUILDING PROJECTS 809
gameWin ::Puzzle-&gt;IO()
gameWin (Puzzle_filledInSoFar _)=
ifall isJust filledInSoFar then
doputStrLn &quot;You win!&quot;
exitSuccess
elsereturn()
Next is the instruction for running a game. Here we use
forever so that this will execute this series of actions indef-
initely:
runGame ::Puzzle-&gt;IO()
runGame puzzle=forever $ do
gameOver puzzle
gameWin puzzle
putStrLn $
&quot;Current puzzle is: &quot; ++show puzzle
putStr&quot;Guess a letter: &quot;
guess&lt;-getLine
caseguessof
[c]-&gt;handleGuess puzzle c &gt;&gt;=runGame
_ -&gt;
putStrLn &quot;Your guess must <br />
\be a single character&quot;
And, finally, here is mainbringing everything together: it</p>
<p>CHAPTER 13. BUILDING PROJECTS 810
gets a word from the word list we generated, generates a fresh
puzzle, and then executes the runGame actions we saw above,
until such time as you guess all the characters in the word
correctly or have made seven guesses, whichever comes first:
indexmain@ main
main::IO()
main= do
word&lt;-randomWord'
letpuzzle=
freshPuzzle (fmap toLower word)
runGame puzzle
13.13 Adding a newtype
Another way you could modify your code in the above and
gain, perhaps, more clarity in places is with the use of newtype:
-- replace this type synonym
-- type WordList = [String]
newtype WordList =
WordList [String]
deriving (Eq,Show)</p>
<p>CHAPTER 13. BUILDING PROJECTS 811
allWords ::IOWordList
allWords = do
dict&lt;-readFile &quot;data/dict.txt&quot;
return$WordList (lines dict)
gameWords ::IOWordList
gameWords = do
(WordList aw)&lt;-allWords
return$WordList (filter gameLength aw)
wheregameLength w =
letl=length (w ::String)
inl&gt;minWordLength
&amp;&amp;l&lt;maxWordLength
randomWord ::WordList -&gt;IOString
randomWord (WordList wl)= do
randomIndex &lt;-
randomRIO ( 0, (length wl) -1)
return$wl!!randomIndex
13.14 Chapter exercises
Hangman game logic
You may have noticed when you were playing with the hang-
man game, that there are some weird things about its game</p>
<p>CHAPTER 13. BUILDING PROJECTS 812
logic:
‚Ä¢although it can play with words up to 9 characters long,
you only get to guess 7 characters;
‚Ä¢it ends the game after 7 guesses, whether they were correct
or incorrect;
‚Ä¢if your 7th guess supplies the last letter in the word, it may
still tell you you lost;
‚Ä¢it picks some very strange words that you didn‚Äôt suspect
were even in the dictionary.
These make it unlike hangman as you might have played it
in the past. Ordinarily, only incorrect guesses count against
you, so you can make as many correct guesses as you need
to fill in the word. Modifying the game so that it either gives
you more guesses before the game ends or only uses shorter
words (or both) involves only a couple of uncomplicated steps.
A bit more complicated but worth attempting as an exercise
is changing the game so that, as with normal hangman, only
incorrect guesses count towards the guess limit.
Modifying code
1.Ciphers: Open your Ciphers module and modify it so that
the Caesar and Vigen√®re ciphers work with user input.</p>
<p>CHAPTER 13. BUILDING PROJECTS 813
2.Here is a very simple, short block of code. Notice it has
aforever that will make it keep running, over and over
again. Load it into your REPL and test it out. Then refer
back to the chapter and modify it to exit successfully after
a False result.
importControl.Monad
palindrome ::IO()
palindrome =forever $ do
line1&lt;-getLine
case(line1==reverse line1) of
True-&gt;putStrLn &quot;It's a palindrome!&quot;
False-&gt;putStrLn &quot;Nope!&quot;
3.If you tried using palindrome on a sentence such as ‚ÄúMadam
I‚ÄômAdam,‚Äùyoumayhavenoticedthatpalindromechecker
doesn‚Äôt work on that. Modifying the above so that it works
on sentences, too, involves several steps. You may need
to refer back to previous examples in the chapter to get
ideas for proper ordering and nesting. You may wish to
import Data.Char to use the function toLower . Have fun.</p>
<p>CHAPTER 13. BUILDING PROJECTS 814
4.typeName=String
typeAge=Integer
dataPerson=PersonNameAgederiving Show
dataPersonInvalid =
NameEmpty
|AgeTooLow
|PersonInvalidUnknown String
deriving (Eq,Show)
mkPerson ::Name
-&gt;Age
-&gt;EitherPersonInvalid Person
mkPerson name age
|name/=&quot;&quot;&amp;&amp;age&gt;0=
Right$Personname age
|name==&quot;&quot;=LeftNameEmpty
|not (age &gt;0)=LeftAgeTooLow
|otherwise =
Left$PersonInvalidUnknown $
&quot;Name was: &quot; ++show name ++
&quot; Age was: &quot; ++show age
Your job is to write the following function without modi-</p>
<p>CHAPTER 13. BUILDING PROJECTS 815
fying the code above.
gimmePerson ::IO()
gimmePerson =undefined
SinceIO ()is about the least informative type imaginable,
we‚Äôll tell what it should do.
a)It should prompt the user for a name and age input.
b)It should attempt to construct a Person value using
the name and age the user entered. You‚Äôll need the
readfunction for Age because it‚Äôs an Integer rather
than a String.
c)If it constructed a successful person, it should print
‚ÄùYay! Successfully got a person:‚Äù followed by the Per-
son value.
d)If it got an error value, report that an error occurred
and print the error.
13.15 Follow-up resources
1.Stack
https://github.com/commercialhaskell/stack
2.How I Start: Haskell
http://bitemyapp.com/posts/2014-11-18-how-i-start-haskell.
html</p>
<p>CHAPTER 13. BUILDING PROJECTS 816
3.Cabal FAQ
https://www.haskell.org/cabal/FAQ.html
4.Cabal user‚Äôs guide
https://www.haskell.org/cabal/users-guide/
5.A Gentle Introduction to Haskell, Modules chapter.
https://www.haskell.org/tutorial/modules.html</p>
<p>Chapter 14
Testing
We‚Äôve tended to forget
that no computer will
ever ask a new question.
Grace Murray Hopper
817</p>
<p>CHAPTER 14. TESTING 818
14.1 Testing
This chapter, likethe one before it, is more focused on practical
matters rather than writing Haskell code per se. We will be
covering two testing libraries (there are others) and how and
when to use them. You will not be writing much of the code
in the chapter on your own; instead, please follow along by
entering it into files as directed (you will learn more if you
type rather than copy and paste). At the end of the chapter,
there are a number of exercises that ask you to write your own
tests for practice.
Testing is a core part of the working programmer‚Äôs toolkit,
and Haskell is no exception. Well-specified types can enable
programmers to avoid many obvious and tedious tests that
mightotherwisebenecessarytomaintaininuntypedprogram-
ming languages, but there‚Äôs still a lot of value to be obtained
in executable specifications. This chapter will introduce you
to testing methods for Haskell.
This chapter will cover:
‚Ä¢the whats and whys of testing;
‚Ä¢using the testing libraries HspecandQuickCheck ;
‚Ä¢a bit of fun with Morse code.</p>
<p>CHAPTER 14. TESTING 819
14.2 A quick tour of testing for the
uninitiated
When we write Haskell, we rely on the compiler to judge for
us whether our code is well formed. That prevents a great
number of errors, but it does not prevent them all. It is still
possible to write well-typed code that doesn‚Äôt perform as ex-
pected, and runtime errors can still occur. That‚Äôs where testing
comes in.
In general, tests allow you to state an expectation and then
verify that the result of an operation meets that expectation.
They allow you to verify that your code will do what you want
when executed.
For the sake of simplicity, we‚Äôll say there are two broad cate-
gories of testing: unit testing and property testing. Unit testing
tests the smallest atomic units of software independently of
one another. Unit testing allows the programmer to check that
each function is performing the task it is meant to do. You
assert that when the code runs with a specified input, the result
is equal to the result you want.
Spec testing is a somewhat newer version of unit testing.
Like unit testing, it tests specific functions independently and
asksyoutoassertthat, whengiventhedeclaredinput, theresult
of the operation will be equal to the desired result. When you
run the test, the computer checks that the expected result is</p>
<p>CHAPTER 14. TESTING 820
equal to the actual result and everyone moves on with their day.
Some people prefer spec testing to unit testing because spec
testing is more often written in terms of assertions that are in
human-readable language. This can be especially valuable if
nonprogrammers need to be able to read and interpret the
results of the tests ‚Äî they can read the English-language results
of the tests and, in some cases, write tests themselves.
Haskell provides libraries for both unit and spec testing.
We‚Äôll focus on specification testing with the hspeclibrary in
this chapter, but HUnitis also available. One limitation to unit
and spec testing is that they test atomic units of code indepen-
dently, so they do not verify that all the pieces work together
properly.
Property testing is a diÔ¨Äerent beast. This kind of testing
was pioneered in Haskell because the type system and straight-
forward logic of the language lend themselves to property
tests, but it has since been adopted by other languages as well.
Property tests test the formal properties of programs without
requiring formal proofs by allowing you to express a truth-
valued, universally quantified (that is, will apply to all cases)
function ‚Äî usually equality ‚Äî which will then be checked
against randomly generated inputs.
The inputs are generated randomly by the standard func-
tions inside the QuickCheck library we use for property testing.
This relies on the type system to know what kinds of data to
generate. The default setting is for 100 inputs to be generated,</p>
<p>CHAPTER 14. TESTING 821
giving you 100 results. If it fails any one of these, then you
know your program doesn‚Äôt have the specified property. If
it passes, you can‚Äôt be positive it will never fail because the
data are randomly generated ‚Äî there could be a weird edge
case out there that will cause your software to fail. QuickCheck is
cleverly written to be as thorough as possible and will usually
check the most common edge cases (for example, empty lists
and the maxBound andminBound s of the types in question, where
appropriate). You can also change the setting so that it runs
more tests.
Property testing is fantastic for ensuring that you‚Äôve met
the minimum requirements to satisfy laws, such as the laws
of monads or basic associativity. It is not appropriate for all
programs, though, as it is not useful for times when there are
no assertable, truth-valued properties of the software.
14.3 Conventional testing
We are going to use the library hspec1to demonstrate a test
case, but we‚Äôre not going to explain hspecdeeply. The current
chapter will equip you with a means of writing tests for your
code later, but it‚Äôs not necessary to understand the details of
how the library works to do that. Some of the concepts hspec
leans on, such as functor, applicative, and monad, are covered</p>
<p>CHAPTER 14. TESTING 822
later as independent concepts.
First, let‚Äôs come up with a test case for addition. Generally
we want to make a Cabal project, even for small experiments.
Having a permanent project for experiments can eliminate
some of this overhead, but we‚Äôll assume you haven‚Äôt done this
yet and start a small project:
-- addition.cabal
name: addition
version: 0.1.0.0
license-file: LICENSE
author: Chicken Little
maintainer: sky@isfalling.org
category: Text
build-type: Simple
cabal-version: &gt;=1.10
library
exposed-modules: Addition
ghc-options: -Wall -fwarn-tabs
build-depends: base &gt;=4.7 &amp;&amp; &lt;5
, hspec
hs-source-dirs: .
default-language: Haskell2010
1http://hackage.haskell.org/package/hspec</p>
<p>CHAPTER 14. TESTING 823
Note we‚Äôve specified the hspecdependency, but not a version
range for it. You‚Äôll probably want whatever the newest version
of it is but can probably get away with not specifying it for
now.
Next we‚Äôll make the Addition module (exposed-modules) in
thesamedirectoryasourCabalfile. Thisiswhythe hs-source-dirs
option in the library stanza was set to .‚Äî this is the convention
for referring to the current directory.
For now, we‚Äôll write a simple placeholder function to make
sure everything‚Äôs working:
-- Addition.hs
moduleAddition where
sayHello ::IO()
sayHello =putStrLn &quot;hello!&quot;
Then you can create an empty LICENSE file so the build
doesn‚Äôt complain:
$ touch LICENSE
Your local project directory should look like this now, before
having run any Stack commands:
$ tree
.</p>
<p>CHAPTER 14. TESTING 824
‚îú‚îÄ‚îÄ Addition.hs
‚îî‚îÄ‚îÄ addition.cabal
‚îî‚îÄ‚îÄ LICENSE
The next steps are to initialize the Stack file for describing
what snapshot of Stackage we‚Äôll use:
$ stack init
Then we‚Äôll want to build our project which will also install
the dependencies we need:
$ stack build
If that succeeded, let‚Äôs fire up a REEEEEEEPL and see if we
can call sayHello :
$ stack ghci
[some noise about configuring, loading packages, etc.]
Ok, modules loaded: Addition.
Prelude&gt; sayHello
hello!
If you got here, you‚Äôve got a working test bed for making a
simple test case in hspec!</p>
<p>CHAPTER 14. TESTING 825
Truth according to Hspec
Next we‚Äôll add the import of hspec‚Äôs primary module:
moduleAddition where
importTest.Hspec
sayHello ::IO()
sayHello =putStrLn &quot;hello!&quot;
Note that allof your imports must occur after the module
has been declared and before any expressions have been de-
fined in your module. You may have encountered an error or
a mistake might‚Äôve been made. Here are a couple of examples.
moduleAddition where
sayHello ::IO()
sayHello =putStrLn &quot;hello!&quot;
importTest.Hspec
Here we put an import after at least one declaration. The
compiler parser doesn‚Äôt have a means of recognizing this spe-
cific mistake, so it can‚Äôt tell you properly what the error is:</p>
<p>CHAPTER 14. TESTING 826
Prelude&gt; :r
[1 of 1] Compiling Addition
Addition.hs:7:1: parse error on input ‚Äòimport‚Äô
Failed, modules loaded: none.
What else may have gone wrong? Well, we might have the
package hspecinstalled, but not included in our build-depends
for our project. Note you‚Äôll need to quit and reopen the REPL
if you‚Äôve made any changes to your .cabal file to reproduce
this error or fixed a mistake:
$ stack build
{... noise ...}
Could not find module ‚ÄòTest.Hspec‚Äô
It is a member of the hidden package
‚Äòhspec-2.2.3@hspec_JWyjr3DNMsw1kiPzf88M5w‚Äô.
Perhaps you need to add ‚Äòhspec‚Äô to the
build-depends in your .cabal file.
Use -v to see a list of the files searched for.
{... other noise ...}
Process exited with code: ExitFailure 1</p>
<p>CHAPTER 14. TESTING 827
If you changed anything in order to test these error modes,
you‚Äôll need to add hspecback to your build-depends and reinstall
it. Ifhspecis listed in your dependencies, stack build will set
you right.
Assuming everything is in order and Test.Hspec is being
imported, we can do a little exploration. We can use the :browse
command to get a listing of types from a module and get a
thousand-foot-view of what it oÔ¨Äers:
Prelude&gt; :browse Test.Hspec
context :: String -&gt; SpecWith a -&gt; SpecWith a
example :: Expectation -&gt; Expectation
specify :: Example a =&gt; String -&gt; a -&gt; SpecWith (Arg a)
(... list goes on for awhile ..)
Prelude&gt;
:browse is more useful when you already have some famil-
iarity with the library and how it works. When you‚Äôre using
an unfamiliar library, documentation is easier to digest. Good
documentation explains how important pieces of the library
work and gives examples of their use. This is especially valu-
able when encountering new concepts. As it happens, hspec
has some pretty good documentation at their website.2
2http://hspec.github.io/</p>
<p>CHAPTER 14. TESTING 828
Our first Hspec test
Let‚Äôs add a test assertion to our module now. If you glance
at the documentation, you‚Äôll see that our example isn‚Äôt very
interesting, but we‚Äôll make it somewhat more interesting soon:
moduleAddition where
importTest.Hspec
main::IO()
main=hspec$ do
describe &quot;Addition&quot; $ do
it&quot;1 + 1 is greater than 1&quot; $ do
(1+1)&gt;1<code>shouldBe</code> True
We‚Äôve asserted in both English and code that (1 + 1) should
be greater than 1, and that is what hspecwill test for us. You
may recognize the donotation from the previous chapter. As
we said then, this syntax allows us to sequence monadic actions.
In the previous chapter, the monad in question was IO.
Here, we‚Äôre nesting multiple doblocks. The types of the do
blocks passed to hspec,describe , anditaren‚ÄôtIO ()but some-
thing more specific to hspec. They result in IO ()in the end, but
there are other monads involved. We haven‚Äôt covered monads
yet, and this works fine without understanding precisely how
it works, so let‚Äôs just roll with it for now.</p>
<p>CHAPTER 14. TESTING 829
Note that you‚Äôll get warnings about the Num a =&gt; a literals
getting defaulted to Integer . You can ignore this or add explicit
type signatures, it is up to you. With the above code in place,
we can load or reload our module and run mainto see the test
results:
Prelude&gt; main
Addition
1 + 1 is greater than 1
Finished in 0.0041 seconds
1 example, 0 failures
OK, so what happened here? Basically, hspecruns your code
and verifies that the arguments you passed to shouldBe are
equal. Let‚Äôs look at the types:
shouldBe ::(Eqa,Showa)
=&gt;a-&gt;a-&gt;Expectation
-- contrast with
(==)::Eqa=&gt;a-&gt;a-&gt;Bool
In a sense, it‚Äôs an augmented ==embedded in hspec‚Äôs model
of the universe. It needs the Showinstance in order to render a</p>
<p>CHAPTER 14. TESTING 830
value. That is, the Showinstance allows hspecto show you the
result of the tests, not just return a Boolvalue.
Let‚Äôs add another test, one that reads a little diÔ¨Äerently:
main::IO()
main=hspec$ do
describe &quot;Addition&quot; $ do
it&quot;1 + 1 is greater than 1&quot; $ do
(1+1)&gt;1<code>shouldBe</code> True
it&quot;2 + 2 is equal to 4&quot; $ do
2+2<code>shouldBe</code> 4
Modify your describe block about Addition so that it looks
like the above and run it in the REPL:
Prelude&gt; main
Addition
1 + 1 is greater than 1
2 + 2 is equal to 4
Finished in 0.0004 seconds
2 examples, 0 failures
For fun, we‚Äôll look back to something you wrote early in the
book and write a short hspectest for it. Back in the Recursion</p>
<p>CHAPTER 14. TESTING 831
chapter, we wrote our own division function that looked like
this:
dividedBy ::Integral a=&gt;a-&gt;a-&gt;(a, a)
dividedBy num denom =go num denom 0
wherego n d count
|n&lt;d=(count, n)
|otherwise =
go (n-d) d (count +1)
We want to test that to see that it works as it should. To keep
things simple, we added dividedBy to ourAddition.hs file and
then rewrote the hspectests that were already there. We want
to test that the function is both subtracting the correct number
of times and keeping an accurate count of that subtraction
and also that it‚Äôs telling us the correct remainder, so we‚Äôll give
hspectwo things to test for:
main::IO()
main=hspec$ do
describe &quot;Addition&quot; $ do
it&quot;15 divided by 3 is 5&quot; $ do
dividedBy 153<code>shouldBe</code> ( 5,0)
it&quot;22 divided by 5 is <br />
\4 remainder 2&quot; $ do
dividedBy 225<code>shouldBe</code> ( 4,2)</p>
<p>CHAPTER 14. TESTING 832
That‚Äôs it. When we reload Addition.hs in our REPL, we can
test our division function:
*Addition&gt; main
Addition
15 divided by 3 is 5
22 divided by 5 is 4 remainder 2
Finished in 0.0012 seconds
2 examples, 0 failures
Hurrah! We can do arithmetic!
Intermission: Short Exercise
In the Chapter Exercises at the end of Recursion, you were
given this exercise:
Write a function that multiplies two numbers using recur-
sive summation. The type should be (Eq a, Num a) =&gt; a -&gt; a
-&gt; aalthough, depending on how you do it, you might also
consider adding an Ordconstraint.
If you still have your answer, great! If not, rewrite it and
then write hspectests for it.
The above examples demonstrate the basics of writing in-
dividual tests to test particular values. If you‚Äôd like to see a</p>
<p>CHAPTER 14. TESTING 833
more developed example, you could refer to Chris‚Äôs library,
Bloodhound.3
14.4 Enter QuickCheck
hspecdoes a nice job with spec testing, but we‚Äôre Haskell users
‚Äî we‚Äôre never satisfied!! hspeccan only prove something about
particular values. Can we get assurances that are stronger,
something closer to proofs? As it happens, we can.
QuickCheck was the first library to oÔ¨Äer what is today called
property testing. hspectesting is more like what is known
as unit testing ‚Äî the testing of individual units of code ‚Äî
whereas property testing is done with the assertion of laws or
properties.
First, we‚Äôll need to add QuickCheck to ourbuild-depends . Open
your.cabal file and add it. Be sure to capitalize QuickCheck (un-
likehspec, which begins with a lowercase ‚Ñé). It should already
be installed, as hspechasQuickCheck as a dependency, but you
may need to reinstall it ( stack build ). Then open a new stack
ghcisession.
hspechasQuickCheck integration out of the box, so once that
is done, add the following to your module:
3https://github.com/bitemyapp/bloodhound</p>
<p>CHAPTER 14. TESTING 834
-- with your imports
importTest.QuickCheck
-- to the same describe block as the others
it&quot;x + 1 is always <br />
\greater than x&quot; $ do
property $\x-&gt;x+1&gt;(x::Int)
If we had not asserted the type of ùë•in the property test, the
compiler would not have known what concrete type to use,
and we‚Äôd see a message like this:
No instance for (Show a0) arising from a use of ‚Äòproperty‚Äô
The type variable ‚Äòa0‚Äô is ambiguous
...
No instance for (Num a0) arising from a use of ‚Äò+‚Äô
The type variable ‚Äòa0‚Äô is ambiguous
...
No instance for (Ord a0) arising from a use of ‚Äò&gt;‚Äô
The type variable ‚Äòa0‚Äô is ambiguous
Avoid this by asserting a concrete type, for example, (x ::
Int), in the property.
Assuming all is well, when we run it, we‚Äôll see something
like the following:
Prelude&gt; main</p>
<p>CHAPTER 14. TESTING 835
Addition
1 + 1 is greater than 1
2 + 2 is equal to 4
x + 1 is always greater than x
Finished in 0.0067 seconds
3 examples, 0 failures
What‚Äôs being hidden a bit by hspecis that QuickCheck tests
manyvalues to see if your assertions hold for all of them. It
does this by randomly generating values of the type you said
you expected. So, it‚Äôll keep feeding our function random Int
values to see if the property is ever false. The number of tests
QuickCheck runs defaults to 100.
Arbitrary instances
QuickCheck relies on a typeclass called Arbitrary and anewtype
calledGenfor generating its random data.
arbitrary is a value of type Gen:
Prelude&gt; :t arbitrary
arbitrary :: Arbitrary a =&gt; Gen a
This is a way to set a default generator for a type. When
you use the arbitrary value, you have to specify the type to</p>
<p>CHAPTER 14. TESTING 836
dispatch the right typeclass instance, as types and typeclass
instances form unique pairings. But this is just a value. How
do we see a list of values of the correct type?
We can use sample andsample' from the Test.QuickCheck mod-
ule in order to see some random data:
-- this prints each value on a new line
Prelude&gt; :t sample
sample :: Show a =&gt; Gen a -&gt; IO ()
-- this one returns a list
Prelude&gt; :t sample'
sample' :: Gen a -&gt; IO [a]
TheIOis necessary because it‚Äôs using a global resource of
random values to generate the data. A common way to gener-
ate pseudorandom data is to have a function that, given some
input ‚Äúseed‚Äù value, returns a value and another seed value for
generating a diÔ¨Äerent value. You can bind the two actions
together, as we explained in the last chapter, to pass a new seed
value each time and keep generating seemingly random data.
In this case, however, we‚Äôre not doing that. Here we‚Äôre using
IOso that our function that generates our data can return a
diÔ¨Äerent result each time (not something pure functions are
allowed to do) by pulling from a global resource of random
values. If this doesn‚Äôt make a great deal of sense at this point,</p>
<p>CHAPTER 14. TESTING 837
it will be more clear once we‚Äôve covered monads, and even
more so once we cover IO.
We use the Arbitrary typeclass in order to provide a genera-
tor forsample. It isn‚Äôt a terribly principled typeclass, but it is
popular and useful for this. We say it is unprincipled because
it has no laws and nothing specific it‚Äôs supposed to do. It‚Äôs a
convenient way of plucking a canonical generator for Gen a
out of thin air without having to know where it comes from.
If it feels a bit like <em>MAGICK</em> at this point, that‚Äôs fine. It is, a
bit, and the inner workings of Arbitrary are not worth fussing
over right now.
As you‚Äôll see later, this isn‚Äôt necessary if you have a Genvalue
ready to go already. Genis a newtype with a single type argu-
ment. It exists for wrapping up a function to generate pseudo-
random values. The function takes an argument that is usually
provided by some kind of random value generator to give you
a pseudorandom value of that type, assuming it‚Äôs a type that
has an instance of the Arbitrary typeclass.
And this is what we get when we use the sample functions.
We use the arbitrary value but specify the type, so that it gives
us a list of random values of that type:
Prelude&gt; sample (arbitrary :: Gen Int)
0
-2
-1</p>
<p>CHAPTER 14. TESTING 838
4
-3
4
2
4
-3
2
-4
Prelude&gt; sample (arbitrary :: Gen Double)
0.0
0.13712502861905426
2.9801894108743605
-8.960645064542609
4.494161946149201
7.903662448338119
-5.221729489254451
31.64874305324701
77.43118278366954
-539.7148886375935
26.87468214215407
If you run sample arbitrary directly in GHCi without speci-
fying a type, it will default the type to ()and give you a very
nice list of empty tuples. If you try loading an unspecified
sample arbitrary from a source file, though, you will get an af-
fectionate message from GHC about having an ambiguous</p>
<p>CHAPTER 14. TESTING 839
type. Try it if you like. GHCi has somewhat diÔ¨Äerent rules for
default types than GHC does.
We can specify our own data for generating Genvalues. In
this example, we‚Äôll specify a trivial function that always returns
a1of type Int:
-- trivial generator of values
trivialInt ::GenInt
trivialInt =return1
You may remember return from the previous chapter as
well. Here, it providesan expedientwayto construct a function.
Inthelastchapter, wenotedthatitdoesn‚Äôtdoawholelotexcept
return a value inside of a monad. Before we were using it to
put a value into IObut it‚Äôs not limited to use with that monad:
return::Monadm=&gt;a-&gt;m a
-- when <code>m</code> is Gen:
return::a-&gt;Gena
Putting 1into the Genmonad constructs a generator that
always returns the same value, 1.
So, what happens when we sample data from this?</p>
<p>CHAPTER 14. TESTING 840
Prelude&gt; sample' trivialInt
[1,1,1,1,1,1,1,1,1,1,1]
Notice now our value isn‚Äôt arbitrary for some type, but the
trivialInt value we defined above. That generator always re-
turns1, so allsample' can return for us is a list of 1.
Let‚Äôs explore diÔ¨Äerent means of generating values:
oneThroughThree ::GenInt
oneThroughThree =elements [ 1,2,3]
Try loading that via your Addition module and asking for a
sample set of random oneThroughThree values:
*Addition&gt; sample' oneThroughThree
[2,3,3,2,2,1,2,1,1,3,3]
Yep, it gave us random values from only that limited set.
At this time, each number in that set has the same chance of
showing up in our random data set. We could tinker with
those odds by having a list with repeated elements to give
those elements a higher probability of showing up in each
generation:
oneThroughThree ::GenInt
oneThroughThree =
elements [ 1,2,2,2,2,3]</p>
<p>CHAPTER 14. TESTING 841
Try running sample' again with this set and see if you no-
tice the diÔ¨Äerence. You may not, of course, because due to
the nature of probability, there is at least some chance that
2wouldn‚Äôt show up any more than it did with the previous
sample.
Next we‚Äôll use choose andelements from the QuickCheck library
as generators of values:
-- choose :: System.Random.Random a
-- =&gt; (a, a) -&gt; Gen a
-- elements :: [a] -&gt; Gen a
genBool ::GenBool
genBool =choose ( False,True)
genBool' ::GenBool
genBool' =elements [ False,True]
genOrdering ::GenOrdering
genOrdering =elements [ LT,EQ,GT]
genChar ::GenChar
genChar =elements [ 'a'..'z']
You should enter all these into your Addition module, load
them into your REPL, and play with getting lists of sample</p>
<p>CHAPTER 14. TESTING 842
data for each.
Our next examples are a bit more complex:
genTuple ::(Arbitrary a,Arbitrary b)
=&gt;Gen(a, b)
genTuple = do
a&lt;-arbitrary
b&lt;-arbitrary
return (a, b)
genThreeple ::(Arbitrary a,Arbitrary b,
Arbitrary c)
=&gt;Gen(a, b, c)
genThreeple = do
a&lt;-arbitrary
b&lt;-arbitrary
c&lt;-arbitrary
return (a, b, c)
Here‚Äôs how to use generators when they have polymor-
phic type arguments. Remember that if you leave the types
unspecified, the extended defaulting behavior of GHCi will
(helpfully?) pick ())for you. Outside of GHCi, you‚Äôll get an
error about an ambiguous type ‚Äî we covered some of this
when we explained typeclasses earlier:</p>
<p>CHAPTER 14. TESTING 843
Prelude&gt; sample genTuple
((),())
((),())
((),())
Here it‚Äôs defaulting the ùëéandùëèto(). We can get more
interesting output if we tell it what we expect ùëéandùëèto be.
Note it‚Äôll always pick 0 and 0.0 for the first numeric values:
Prelude&gt; sample (genTuple :: Gen (Int, Float))
(0,0.0)
(-1,0.2516606)
(3,0.7800742)
(5,-61.62875)
We can ask for lists and characters, or anything with an
instance of the Arbitrary typeclass:
Prelude&gt; sample (genTuple :: Gen ([()], Char))
([],'\STX')
([()],'X')
([],'?')
([],'\137')
([(),()],'\DC1')
([(),()],'z')
You can use :info Arbitrary in your GHCi to see what in-
stances are available.</p>
<p>CHAPTER 14. TESTING 844
We can also generate arbitrary MaybeandEither values:
genEither ::(Arbitrary a,Arbitrary b)
=&gt;Gen(Eithera b)
genEither = do
a&lt;-arbitrary
b&lt;-arbitrary
elements [ Lefta,Rightb]
-- equal probability
genMaybe ::Arbitrary a=&gt;Gen(Maybea)
genMaybe = do
a&lt;-arbitrary
elements [ Nothing,Justa]
-- What QuickCheck does so
-- you get more Just values
genMaybe' ::Arbitrary a=&gt;Gen(Maybea)
genMaybe' = do
a&lt;-arbitrary
frequency [ ( 1, return Nothing)
, (3, return ( Justa))]
-- frequency :: [(Int, Gen a)] -&gt; Gen a
For now, you should play with this in the REPL; it will</p>
<p>CHAPTER 14. TESTING 845
become useful to know later on.
Using QuickCheck without Hspec
We can also use QuickCheck without hspec. In that case, we no
longer need to specify ùë•in our expression, because the type
ofprop_additionGreater provides for it. Thus, we rewrite our
previous example as follows:
prop_additionGreater ::Int-&gt;Bool
prop_additionGreater x=x+1&gt;x
runQc::IO()
runQc=quickCheck prop_additionGreater
For now, we don‚Äôt need to worry about how runQcdoes its
work. It‚Äôs a generic function, like main, that signals that it‚Äôs time
to do stuÔ¨Ä. Specifically, in this case, it‚Äôs time to perform the
QuickCheck tests.
Now, when we run it in the REPL, instead of the mainwe were
calling with hspec, we‚Äôll call runQc, which will call on QuickCheck
to test the property we defined. When we run QuickCheck di-
rectly, it reports how many tests it ran:
Prelude&gt; runQc
+++ OK, passed 100 tests.
What happens if we assert something untrue?</p>
<p>CHAPTER 14. TESTING 846
prop_additionGreater x=x+0&gt;x
Prelude&gt; :r
[1 of 1] Compiling Addition
Ok, modules loaded: Addition.
Prelude&gt; runQc
*** Failed! Falsifiable (after 1 test):
0
Conveniently, QuickCheck doesn‚Äôt only tell us that our test
failed, but it tells us the first input it encountered that it failed
on. If you try to keep running it, you may notice that the
value that it fails on is always 0. A while ago, we said that
QuickCheck has some built-in cleverness and tries to ensure that
common error boundaries will always get tested. The input 0
is a frequent point of failure, so QuickCheck tries to ensure that
it is always tested (when appropriate, given the types, etc etc).
14.5 Morse code
In the interest of playing with testing, we‚Äôll work through an
example project where we translate text to and from Morse
code. We‚Äôre going to start a new project for this. When you
do usestack new project-name to start a new project instead of
stack init for an existing project, it automatically generates a
file called Setup.hs that looks like this:</p>
<p>CHAPTER 14. TESTING 847
importDistribution.Simple
main=defaultMain
This isn‚Äôt terribly important. You rarely need to modify
or do anything at all with the Setup.hs file, and usually you
shouldn‚Äôt touch it at all. Occasionally, you may need to edit it
for certain tasks, so it is good to recognize that it‚Äôs there.
Next, as always, let‚Äôs get our .cabal file configured properly.
Some of this will be automatically generated by your stack new
project-name , but you‚Äôll have to add to what it generates, being
careful about things like capitalization and indentation:
name: morse
version: 0.1.0.0
license-file: LICENSE
author: Chris Allen
maintainer: cma@bitemyapp.com
category: Text
build-type: Simple
cabal-version: &gt;=1.10
library
exposed-modules: Morse
ghc-options: -Wall -fwarn-tabs
build-depends: base &gt;=4.7 &amp;&amp; &lt;5
, containers</p>
<p>CHAPTER 14. TESTING 848
, QuickCheck
hs-source-dirs: src
default-language: Haskell2010
executable morse
main-is: Main.hs
ghc-options: -Wall -fwarn-tabs
hs-source-dirs: src
build-depends: base &gt;=4.7 &amp;&amp; &lt;5
, containers
, morse
, QuickCheck
default-language: Haskell2010
test-suite tests
ghc-options: -Wall -fno-warn-orphans
type: exitcode-stdio-1.0
main-is: tests.hs
hs-source-dirs: tests
build-depends: base
, containers
, morse
, QuickCheck
default-language: Haskell2010
Don‚Äôt forget to capitalize the QuickCheck dependency prop-</p>
<p>CHAPTER 14. TESTING 849
erly! Now that is set up and ready for us, so the next step is
to make our srcdirectory and the file called Morse.hs as our
‚Äúexposed module:‚Äù
-- src/Morse.hs
moduleMorse
(Morse
,charToMorse
,morseToChar
,stringToMorse
,letterToMorse
,morseToLetter
)where
import qualified Data.Map asM
typeMorse=String
Whoa, there ‚Äî what‚Äôs all that stuÔ¨Ä after the module name?
That is a list of everything this module will export. We talked
a bit about this in the previous chapter, but didn‚Äôt make use of
it. In the hangman game, we had all our functions in one file,
so nothing needed to be exported.</p>
<p>CHAPTER 14. TESTING 850
Nota bene You don‚Äôt have to specify exports in this manner.
By default, the entire module is exposed and can be imported
by any other module. If you want to export everything in a
module, then specifying exports is unnecessary. However, it
can help, when managing large projects, to specify what will
get used by another module (and, by exclusion, what will not)
as a way of documenting your intent. In this case, we have
exported here more than we imported into Main, as we realized
that we only needed the two specified functions for Main. We
could go back and remove the things we didn‚Äôt specifically
import from the above export list, but we haven‚Äôt now, to give
you an idea of the process we‚Äôre going through putting our
project together.
Turning words into code
We are also using a qualified import of Data.Map . We covered
this type of import somewhat in the previous chapter. We
qualify the import and name it ùëÄso that we can use that ùëÄ
as a prefix for the functions we‚Äôre using from that package.
That will help us keep track of where the functions came from
and also avoid same-name clashes with Prelude functions, but
without requiring us to tediously type Data.Map as a prefix to
each function name.
We‚Äôll talk more about Mapas a data structure later in the book.
For now, we can understand it as being a balanced binary tree,</p>
<p>CHAPTER 14. TESTING 851
where each node is a pairing of a key and a value. The key is
an index for the value ‚Äî a marker of how to find the value
in the tree. The key must be orderable (that is, must have an
Ordinstance), much like our binary tree functions earlier, such
asinsert , needed an Ordinstance. Maps can be more efficient
than lists because you do not have to search linearly through
a bunch of data. Because the keys are ordered and the tree is
balanced, searching through the binary tree divides the search
space in half each time you go ‚Äúleft‚Äù or ‚Äúright.‚Äù You compare
the key to the index of the current node to determine if you
need to go left (less), right (greater), or if you‚Äôve arrived at the
node for your value (equal).
You can see below why we used a Mapinstead of a simple list.
We want to make a list of pairs, where each pair includes both
the English-language character and its Morse code represen-
tation. We define our transliteration table thus:
letterToMorse ::(M.MapCharMorse)
letterToMorse =M.fromList [
('a',&quot;.-&quot;)
, ('b',&quot;-...&quot;)
, ('c',&quot;-.-.&quot;)
, ('d',&quot;-..&quot;)
, ('e',&quot;.&quot;)</p>
<p>CHAPTER 14. TESTING 852
, ('f',&quot;..-.&quot;)
, ('g',&quot;--.&quot;)
, ('h',&quot;....&quot;)
, ('i',&quot;..&quot;)
, ('j',&quot;.---&quot;)
, ('k',&quot;-.-&quot;)
, ('l',&quot;.-..&quot;)
, ('m',&quot;--&quot;)
, ('n',&quot;-.&quot;)
, ('o',&quot;---&quot;)
, ('p',&quot;.--.&quot;)
, ('q',&quot;--.-&quot;)
, ('r',&quot;.-.&quot;)
, ('s',&quot;...&quot;)
, ('t',&quot;-&quot;)
, ('u',&quot;..-&quot;)
, ('v',&quot;...-&quot;)
, ('w',&quot;.--&quot;)
, ('x',&quot;-..-&quot;)
, ('y',&quot;-.--&quot;)
, ('z',&quot;--..&quot;)
, ('1',&quot;.----&quot;)
, ('2',&quot;..---&quot;)</p>
<p>CHAPTER 14. TESTING 853
, ('3',&quot;...--&quot;)
, ('4',&quot;....-&quot;)
, ('5',&quot;.....&quot;)
, ('6',&quot;-....&quot;)
, ('7',&quot;--...&quot;)
, ('8',&quot;---..&quot;)
, ('9',&quot;----.&quot;)
, ('0',&quot;-----&quot;)
]
Note that we used M.fromList ‚Äî theùëÄprefix tells us this
comes from Data.Map . We‚Äôre using a Mapto associate characters
with their Morse code representations. letterToMorse is the def-
inition of the Mapwe‚Äôll use to look up the codes for individual
characters.
Next we write a few functions that allow us to convert a
Morse character to an English character and vice versa, and
also functions to do the same for strings:</p>
<p>CHAPTER 14. TESTING 854
morseToLetter ::M.MapMorseChar
morseToLetter =
M.foldWithKey (flip M.insert) M.empty
letterToMorse
charToMorse ::Char-&gt;MaybeMorse
charToMorse c=
M.lookup c letterToMorse
stringToMorse ::String-&gt;Maybe[Morse]
stringToMorse s=
sequence $fmap charToMorse s
morseToChar ::Morse-&gt;MaybeChar
morseToChar m=
M.lookup m morseToLetter
Notice we used Maybein three of those: not every Charthat
could potentially occur in a String has a Morse representation.
The Main event
Next we want to set up a Mainmodule that will handle our
Morse code conversions. Note that it‚Äôs going to import a bunch
of things, some of which we covered in the last chapter and
some we have not. Since we will not be going into the specifics</p>
<p>CHAPTER 14. TESTING 855
of how this code works, we won‚Äôt discuss those imports here.
It is, however, important to note that one of our imports is our
Morse.hs module from above:
-- src/Main.hs
moduleMainwhere
importControl.Monad (forever,when)
importData.List (intercalate )
importData.Traversable (traverse )
importMorse(stringToMorse ,morseToChar )
importSystem.Environment (getArgs)
importSystem.Exit (exitFailure ,
exitSuccess )
importSystem.IO (hGetLine ,hIsEOF,stdin)
As we said, we‚Äôre not going to explain this part in detail.
We encourage you to do your best reading and interpreting
it, but it‚Äôs quite dense, and this chapter isn‚Äôt about this code
‚Äî it‚Äôs about the tests. We‚Äôre cargo-culting a bit here, which
we don‚Äôt like to do, but we‚Äôre doing it so that we can focus on
the testing. Type this all into your Mainmodule ‚Äî first the
function to convert to Morse:</p>
<p>CHAPTER 14. TESTING 856
convertToMorse ::IO()
convertToMorse =forever $ do
weAreDone &lt;-hIsEOF stdin
when weAreDone exitSuccess
-- otherwise, proceed.
line&lt;-hGetLine stdin
convertLine line
where
convertLine line = do
letmorse=stringToMorse line
casemorseof
(Juststr)
-&gt;putStrLn
(intercalate &quot; &quot;str)
Nothing
-&gt; do
putStrLn $&quot;ERROR: &quot; ++line
exitFailure
Now add the function to convert from Morse:</p>
<p>CHAPTER 14. TESTING 857
convertFromMorse ::IO()
convertFromMorse =forever $ do
weAreDone &lt;-hIsEOF stdin
when weAreDone exitSuccess
-- otherwise, proceed.
line&lt;-hGetLine stdin
convertLine line
where
convertLine line = do
letdecoded ::MaybeString
decoded =
traverse morseToChar
(words line)
casedecoded of
(Justs)-&gt;putStrLn s
Nothing -&gt; do
putStrLn $&quot;ERROR: &quot; ++line
exitFailure
And now our obligatory main:</p>
<p>CHAPTER 14. TESTING 858
main::IO()
main= do
mode&lt;-getArgs
casemodeof
[arg]-&gt;
caseargof
&quot;from&quot;-&gt;convertFromMorse
&quot;to&quot;-&gt;convertToMorse
_ -&gt; argError
_ -&gt;argError
whereargError = do
putStrLn &quot;Please specify the <br />
\first argument <br />
\as being 'from' or <br />
'to' morse, <br />
\such as: morse to&quot;
exitFailure
Make sure it‚Äôs all working
One way we can make sure everything is working for us from
the command line is by using echo. If this is familiar to you
and you feel comfortable with this, go ahead and try this:
$ echo &quot;hi&quot; | stack exec morse to</p>
<p>CHAPTER 14. TESTING 859
.... ..
$ echo &quot;.... ..&quot; | stack exec morse from
hi
If you‚Äôd like to find out where Stack put the executable, you
can use stack exec which morse on Mac and Linux. You can also
usestack install to ask Stack to build (if needed) and copy the
binaries from your project into a common directory. On Mac
and Linux that will be .local/bin in your home directory. The
location was chosen partly to respect XDG4guidelines.
Otherwise, load this module into your GHCi REPL and
give it a try to ensure everything compiles and seems to be in
working order. It‚Äôll be helpful to fix any type or syntax errors
now, before we start trying to run the tests.
Time to test!
Now we need to write our test suite. We have those in their
own directory and file. We will again call the module Main
but note the file name (the name per se isn‚Äôt important, but
it must agree with the test file you have named in your Cabal
configuration for this project):
4https://wiki.archlinux.org/index.php/Xdg_user_directories</p>
<p>CHAPTER 14. TESTING 860
-- tests/tests.hs
moduleMainwhere
import qualified Data.Map asM
importMorse
importTest.QuickCheck
We have many fewer imports for this, which should all
already be familiar to you.
Now we set up our generators for ensuring that the random
valuesQuickCheck uses to test our program are sensible for our
Morse code program:
allowedChars ::[Char]
allowedChars =M.keys letterToMorse
allowedMorse ::[Morse]
allowedMorse =M.elems letterToMorse
charGen ::GenChar
charGen =elements allowedChars
morseGen ::GenMorse
morseGen =elements allowedMorse</p>
<p>CHAPTER 14. TESTING 861
We saw elements briefly above. It takes a list of some type
‚Äî in these cases, our lists of allowed characters and Morse
characters ‚Äî and chooses a Genvalue from the values in that
list. Because Charincludes thousands of characters that have
no legitimate equivalent in Morse code, we need to write our
own custom generators.
Now we write up the property we want to check. We want
to check that when we convert something to Morse code and
then back again, it comes out as the same string we started out
with:
prop_thereAndBackAgain ::Property
prop_thereAndBackAgain =
forAll charGen
(\c-&gt;((charToMorse c)
&gt;&gt;=morseToChar) ==Justc)
main::IO()
main=quickCheck prop_thereAndBackAgain
This is how your setup should look when you have all this
done:
$ tree
.
‚îú‚îÄ‚îÄ LICENSE</p>
<p>CHAPTER 14. TESTING 862
‚îú‚îÄ‚îÄ Setup.hs
‚îú‚îÄ‚îÄ morse.cabal
‚îú‚îÄ‚îÄ src
‚îÇ ‚îú‚îÄ‚îÄ Main.hs
‚îÇ ‚îî‚îÄ‚îÄ Morse.hs
‚îú‚îÄ‚îÄ stack.yaml
‚îî‚îÄ‚îÄ tests
‚îî‚îÄ‚îÄ tests.hs
Testing the Morse code
Now that our conversions seem to be working, let‚Äôs run our
tests to make sure. The property we‚Äôre testing is that we get the
same string after we convert it to Morse and back again. Let‚Äôs
load up our tests by opening a REPL from our main project
directory:
$ stack ghci morse:tests
{... noise noise noise ...}
Ok, modules loaded: Main.
Prelude&gt;
Sweet. Stack loaded everything for us and even built our
dependencies if needs be. Let‚Äôs see what happens:</p>
<p>CHAPTER 14. TESTING 863
Prelude&gt; main
+++ OK, passed 100 tests.
The test generates 100 random Morse code conversions
(a bunch of random strings) and makes sure they are always
equal once you have converted to and then from Morse code.
This gives you a pretty strong assurance that your program is
correct and will perform as expected for any input value.
14.6 Arbitrary instances
One of the more important parts of QuickCheck is learning to
write instances of the Arbitrary typeclass for your datatypes.
It‚Äôs a somewhat unfortunate but still necessary convenience
for your code to integrate cleanly with QuickCheck code. It‚Äôs
initially a bit confusing for beginners because it compacts a
few diÔ¨Äerent concepts and solutions to problems into a single
typeclass.
Babby‚Äôs First Arbitrary
First, we‚Äôll begin with a maximally simple Arbitrary instance
for theTrivial datatype:</p>
<p>CHAPTER 14. TESTING 864
moduleMainwhere
importTest.QuickCheck
dataTrivial =
Trivial
deriving (Eq,Show)
trivialGen ::GenTrivial
trivialGen =
returnTrivial
instance Arbitrary Trivial where
arbitrary =trivialGen
Thereturn is necessary to return Trivial in theGenmonad:
main::IO()
main= do
sample trivialGen
Let‚Äôs take a sample:
Prelude&gt; sample trivialGen
Trivial
Trivial
Trivial</p>
<p>CHAPTER 14. TESTING 865
Trivial
Trivial
Trivial
Trivial
Trivial
Trivial
Trivial
Trivial
Although it‚Äôs impossible to see the point with Trivial by it-
self,Genvalues are generators of random values that QuickCheck
uses to get test values from.
Identity Crisis
This one is a little diÔ¨Äerent. It will produce random values
even if the Identity structure itself doesn‚Äôt and cannot vary.
dataIdentity a=
Identity a
deriving (Eq,Show)
identityGen ::Arbitrary a=&gt;
Gen(Identity a)
identityGen = do
a&lt;-arbitrary
return ( Identity a)</p>
<p>CHAPTER 14. TESTING 866
We‚Äôre using the Genmonad to pluck a single value of type
ùëéout of the air, embed it in Identity , then return as part of
theGenmonad. We know this is weird, but if you do it ten or
twenty times you might start to like it.
We‚Äôll reuse the original identityGen we wrote. We can make
it the default generator for the Identity type by making it the
arbitrary value in the Arbitrary instance:
instance Arbitrary a=&gt;
Arbitrary (Identity a)where
arbitrary =identityGen
identityGenInt ::Gen(Identity Int)
identityGenInt =identityGen
We‚Äôre making a generator suitable for sampling by making
the type argument of Identity unambiguous for testing with
thesample function. Your output in the terminal could look
something like:
Prelude&gt; sample identityGenInt
Identity 0
Identity (-1)
Identity 2
Identity 4
Identity (-3)</p>
<p>CHAPTER 14. TESTING 867
Identity 5
Identity 3
Identity (-1)
Identity 12
Identity 16
Identity 0
You should be able to change the concrete type of Identity ‚Äôs
type argument and generate diÔ¨Äerent types of sample values.
Arbitrary Products
Arbitrary instances for product types get a teensy bit more
interesting, but they‚Äôre really an extension of what we did for
Identity :
dataPaira b=
Paira b
deriving (Eq,Show)
pairGen ::(Arbitrary a,
Arbitrary b)=&gt;
Gen(Paira b)
pairGen = do
a&lt;-arbitrary
b&lt;-arbitrary
return ( Paira b)</p>
<p>CHAPTER 14. TESTING 868
We will reuse our pairGen function as the arbitrary value in
the instance:
instance (Arbitrary a,
Arbitrary b)=&gt;
Arbitrary (Paira b)where
arbitrary =pairGen
pairGenIntString ::Gen(PairIntString)
pairGenIntString =pairGen
And now we can generate some sample values:
Pair 0 &quot;&quot;
Pair (-2) &quot;&quot;
Pair (-3) &quot;26&quot;
Pair (-5) &quot;B\NUL\143:\254\SO&quot;
Pair (-6) &quot;\184*\239\DC4&quot;
Pair 5 &quot;\238\213=J\NAK!&quot;
Pair 6 &quot;Pv$y&quot;
Pair (-10) &quot;G|J^&quot;
Pair 16 &quot;R&quot;
Pair (-7) &quot;(&quot;
Pair 19 &quot;i\ETX]\182\ENQ&quot;
Ah, the beauty of random String values.</p>
<p>CHAPTER 14. TESTING 869
Greater than the sum of its parts
Writing Arbitrary instances for sum types is a bit more inter-
esting still. First, make sure the following is included in your
imports:
importTest.QuickCheck.Gen (oneof)
Sum types represent disjunction, so with a sum type like
Sum, we need to represent the exclusive possibilities in our Gen.
One way to do that is to pull out as many arbitrary values
as you require for the cases of your sum type. We have two
data constructors in this sum type, so we‚Äôll want two arbitrary
values. Then we‚Äôll repack them into Genvalues, resulting in a
value of type [Gen a] that can be passed to oneof:</p>
<p>CHAPTER 14. TESTING 870
dataSuma b=
Firsta
|Secondb
deriving (Eq,Show)
-- equal odds for each
sumGenEqual ::(Arbitrary a,
Arbitrary b)=&gt;
Gen(Suma b)
sumGenEqual = do
a&lt;-arbitrary
b&lt;-arbitrary
oneof [return $Firsta,
return$Secondb]
Theoneoffunction will create a Gen afrom a list of Gen aby
giving each value an equal probability. From there, you‚Äôre
delegating to the Arbitrary instances of the types ùëéandùëè.
sumGenCharInt ::Gen(SumCharInt)
sumGenCharInt =sumGenEqual
We specify which Arbitrary instances to use for ùëéandùëèand
do a test run:
Prelude&gt; sample sumGenCharInt</p>
<p>CHAPTER 14. TESTING 871
First 'P'
First '\227'
First '\238'
First '.'
Second (-3)
First '\132'
Second (-12)
Second (-12)
First '\186'
Second (-11)
First '\v'
Where sum types get even more interesting is that you can
choose a diÔ¨Äerent weighting of probabilities than an equal dis-
tribution. Consider this snippet of the Maybe Arbitrary instance
from the QuickCheck library:
instance Arbitrary a=&gt;
Arbitrary (Maybea)where
arbitrary =
frequency [( 1, return Nothing),
(3, liftM Justarbitrary)]
It‚Äôs making an arbitrary Justvalue three times more likely
than aNothing value because the former is more likely to be
interesting and useful, but you still want to try shaking things
out with a Nothing from time to time.</p>
<p>CHAPTER 14. TESTING 872
Accordingly, we can assign a 10 times higher probability to
ourFirstdata constructor in a diÔ¨Äerent GenforSum:
sumGenFirstPls ::(Arbitrary a,
Arbitrary b)=&gt;
Gen(Suma b)
sumGenFirstPls = do
a&lt;-arbitrary
b&lt;-arbitrary
frequency [( 10, return $Firsta),
(1, return $Secondb)]
sumGenCharIntFirst ::Gen(SumCharInt)
sumGenCharIntFirst =sumGenFirstPls
With that modified version, you‚Äôll find Second values are
much less common:
First '\208'
First '\242'
First '\159'
First 'v'
First '\159'
First '\232'
First '3'
First 'l'</p>
<p>CHAPTER 14. TESTING 873
Second (-16)
First 'x'
First 'Y'
One of the key insights here is that the Arbitrary instance
for a datatype doesn‚Äôt have to be the only way to generate or
provide random values of your datatype for QuickCheck tests.
You can oÔ¨Äer alternative Gens for your type with interesting or
useful behavior as well.
CoArbitrary
CoArbitrary is a counterpart to Arbitrary that enables the gener-
ation of functions fitting a particular type. Rather than talking
about random values you can get via Gen, it lets you provide
functions with a value of type ùëéas an argument in order to
varyaGen:
arbitrary ::Arbitrary a=&gt;
Gena
coarbitrary ::CoArbitrary a=&gt;
a-&gt;Genb-&gt;Genb
-- [1] [ 2 ] [ 3 ]
Here[1]is used to return a modification or variant of [2]
which is the result [3]at the end.</p>
<p>CHAPTER 14. TESTING 874
It turns out, as long as your datatype has a Generic instance
derived, you can get these instances for free. The following
should work fine:
{-# LANGUAGE DeriveGeneric #-}
moduleCoArbitrary where
importGHC.Generics
importTest.QuickCheck
dataBool'=
True'
|False'
deriving (Generic)
instance CoArbitrary Bool'
This‚Äôll then let you do things like the following:</p>
<p>CHAPTER 14. TESTING 875
importTest.QuickCheck
-- plus the above
trueGen ::GenInt
trueGen =coarbitrary True'arbitrary
falseGen ::GenInt
falseGen =coarbitrary False'arbitrary
Essentially this lets you randomly generate a function. It
might be a little hard to see why you‚Äôd care for now, but if
you ever find yourself wanting to randomly generate anything
with the (-&gt;)type inside it somewhere, it becomes salient in a
hurry.
14.7 Chapter Exercises
Now it‚Äôs time to write some tests of your own. You could write
tests for most of the exercises you‚Äôve done in the book, but
whether you‚Äôd want to use hspecorQuickCheck depends on what
you‚Äôre trying to test. We‚Äôve tried to simplify things a bit by
telling you which to use for these exercises, but, as always, we
encourage you to experiment on your own.</p>
<p>CHAPTER 14. TESTING 876
Validating numbers into words
Remember the ‚Äúnumbers into words‚Äù exercise in Recursion?
You‚Äôll be writing tests to validate the functions you wrote.</p>
<p>CHAPTER 14. TESTING 877
moduleWordNumberTest where
importTest.Hspec
importWordNumber
(digitToWord ,digits,wordNumber )
main::IO()
main=hspec$ do
describe &quot;digitToWord&quot; $ do
it&quot;returns zero for 0&quot; $ do
digitToWord 0<code>shouldBe</code> &quot;zero&quot;
it&quot;returns one for 1&quot; $ do
print&quot;???&quot;
describe &quot;digits&quot; $ do
it&quot;returns [1] for 1&quot; $ do
digits1<code>shouldBe</code> [ 1]
it&quot;returns [1, 0, 0] for 100&quot; $ do
print&quot;???&quot;
describe &quot;wordNumber&quot; $ do
it&quot;one-zero-zero given 100&quot; $ do
wordNumber 100
<code>shouldBe</code> &quot;one-zero-zero&quot;
it&quot;nine-zero-zero-one for 9001&quot; $ do
print&quot;???&quot;</p>
<p>CHAPTER 14. TESTING 878
Fill in the test cases that print question marks. If you think
of additional tests you could perform, add them.
Using QuickCheck
Test some simple arithmetic properties using QuickCheck .
1.-- for a function
halfx=x/2
-- this property should hold
halfIdentity =(*2).half
2.importData.List (sort)
-- for any list you apply sort to
-- this property should hold
listOrdered ::(Orda)=&gt;[a]-&gt;Bool
listOrdered xs=
snd$foldr go ( Nothing,True) xs
wherego_status@(_,False)=status
go y (Nothing, t)=(Justy, t)
go y (Justx, t)=(Justy, x&gt;=y)
3.Now we‚Äôll test the associative and commutative properties
of addition:</p>
<p>CHAPTER 14. TESTING 879
plusAssociative x y z=
x+(y+z)==(x+y)+z
plusCommutative x y=
x+y==y+x
Keep in mind these properties won‚Äôt hold for types based
on IEEE-754 floating point numbers, such as Floator
Double .
4.Now do the same for multiplication.
5.We mentioned in one of the first chapters that there are
some laws involving the relationship of quotandremand
divandmod. Write QuickCheck tests to prove them.
-- quot rem
(quot x y) *y+(rem x y) ==x
(div x y) *y+(mod x y) ==x
6.Is (^) associative? Is it commutative? Use QuickCheck to see
if the computer can contradict such an assertion.
7.Test that reversing a list twice is the same as the identity
of the list:
reverse .reverse ==id
8.Write a property for the definition of ($).</p>
<p>CHAPTER 14. TESTING 880
f$a=f a
f.g=\x-&gt;f (g x)
9.See if these two functions are equal:
foldr(:)==(++)
foldr(++)[]==concat
10.Hm. Is that so?
fn xs=length (take n xs) ==n
11.Finally, this is a fun one. You may remember we had you
compose readandshowone time to complete a ‚Äúround
trip.‚Äù Well, now you can test that it works:
fx=(read (show x)) ==x
Failure
Find out why this property fails.</p>
<p>CHAPTER 14. TESTING 881
-- for a function
squarex=x*x
-- why does this property not hold?
-- Examine the type of sqrt.
squareIdentity =square.sqrt
Hint: Read about floating point arithmetic and precision if
you‚Äôre unfamiliar with it.
Idempotence
Idempotence refers to a property of some functions in which
the result value does not change beyond the initial application.
If you apply the function once, it returns a result, and applying
the same function to that value won‚Äôt ever change it. You might
think of a list that you sort: once you sort it, the sorted list will
remain the same after applying the same sorting function to
it. It‚Äôs already sorted, so new applications of the sort function
won‚Äôt change it.
UseQuickCheck and the following helper functions to demon-
strate idempotence for the following:
twicef=f.f
fourTimes =twice.twice</p>
<p>CHAPTER 14. TESTING 882
1.fx=
(capitalizeWord x
==twice capitalizeWord x)
&amp;&amp;
(capitalizeWord x
==fourTimes capitalizeWord x)
2.f'x=
(sort x
==twice sort x)
&amp;&amp;
(sort x
==fourTimes sort x)
Make a Gen random generator for the datatype
We demonstrated in the chapter how to make Gengenerators
for diÔ¨Äerent datatypes. We are so certain you enjoyed that, we
are going to ask you to do it for some new datatypes:
1.Equal probabilities for each.
dataFool=
Fulse
|Frue
deriving (Eq,Show)</p>
<p>CHAPTER 14. TESTING 883
2.2/3s chance of Fulse, 1/3 chance of Frue.
dataFool=
Fulse
|Frue
deriving (Eq,Show)
Hangman testing
Next, you should go back to the hangman project from the
previous chapter and write tests. The kinds of tests you can
write at this point will be limited due to the interactive nature
of the game. However, you can test the functions. Focus your
attention on testing the following:
fillInCharacter ::Puzzle-&gt;Char-&gt;Puzzle
fillInCharacter (Puzzleword
filledInSoFar s) c =
Puzzleword newFilledInSoFar (c :s)
wherezipper guessed wordChar guessChar =
ifwordChar ==guessed
thenJustwordChar
elseguessChar
newFilledInSoFar =
letzd=(zipper c)
inzipWith zd word filledInSoFar</p>
<p>CHAPTER 14. TESTING 884
and:
handleGuess ::Puzzle-&gt;Char-&gt;IOPuzzle
handleGuess puzzle guess = do
putStrLn $&quot;Your guess was: &quot; ++[guess]
case(charInWord puzzle guess
, alreadyGuessed puzzle guess) of
(<em>,True)-&gt; do
putStrLn &quot;You already guessed that <br />
\character, pick <br />
\something else!&quot;
return puzzle
(True,</em>)-&gt; do
putStrLn &quot;This character was in the <br />
\word, filling in the <br />
\word accordingly&quot;
return (fillInCharacter puzzle guess)
(False,_)-&gt; do
putStrLn &quot;This character wasn't in <br />
\the word, try again.&quot;
return (fillInCharacter puzzle guess)
Refresh your memory on what those are supposed to do
and then test to make sure they do.</p>
<p>CHAPTER 14. TESTING 885
Validating ciphers
As a final exercise, create QuickCheck properties that verify your
Caesar and Vigen√®re ciphers return the same data after encod-
ing and decoding a string.
14.8 Definitions
1.Unit testing is a method in which you test the smallest
parts of an application possible. These units are individu-
ally and independently scrutinized for desired behaviors.
Unit testing is better automated but it can also be done
manually via a human entering inputs and verifying out-
puts.
2.Property testing is a testing method where a subset of a
large input space is validated, usually against a property
or law some code should abide by. In Haskell, this is
usually done with QuickCheck which facilitates the random
generation of input and definition of properties to be veri-
fied. Common properties that are checked using property
testing are things like identity, associativity, isomorphism,
and idempotence.
3.When we say an operation or function is idempotent or
satisfies idempotence , we mean that applying it multiple
times doesn‚Äôt produce a diÔ¨Äerent result from the first time.</p>
<p>CHAPTER 14. TESTING 886
One example is multiplying by one or zero. You always
get the same result as the first time you multipled by one
or zero.
14.9 Follow-up resources
1.Pedro Vasconcelos; An introduction to QuickCheck
testing;
https://www.fpcomplete.com/user/pbv/
an-introduction-to-quickcheck-testing
2.Koen Claessen and John Hughes; (2000)
QuickCheck: A Lightweight Tool for Random Testing of
Haskell Programs
3.Pedro Vasconcelos; Verifying a Simple Compiler Using
Property-based Random Testing;
http://www.dcc.fc.up.pt/dcc/Pubs/TReports/TR13/
dcc-2013-06.pdf</p>
<p>Chapter 15
Monoid, Semigroup
Simplicity does not
precede complexity, but
follows it.
Alan Perlis
887</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 888
15.1 Monoids and semigroups
One of the finer points of the Haskell community has been
its propensity for recognizing abstract patterns in code which
have well-defined, lawful representations in mathematics. A
word frequently used to describe these abstractions is algebra ,
by which we mean one or more operations and the setthey
operate over. Over the next few chapters, we‚Äôre going to be
looking at some of these. Some you may have heard of, such
as functor and monad. Some, such as monoid and the humble
semigroup, may seem new to you. One of the things that
Haskell is really good at is these algebras, and it‚Äôs important to
master them before we can do some of the exciting stuÔ¨Ä that‚Äôs
coming.
This chapter will include:
‚Ä¢Algebras!
‚Ä¢Laws!
‚Ä¢Monoids!
‚Ä¢Semigroups!</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 889
15.2 What we talk about when we talk
about algebras
For some of us, talking about ‚Äúan algebra‚Äù may sound some-
what foreign. So let‚Äôs take a second and talk about what we‚Äôre
talking about when we use this phrase, at least when we‚Äôre
talking about Haskell.
Algebra generally refers to one of the most important fields
of mathematics. In this usage, it means the study of mathe-
matical symbols and the rules governing their manipulation.
It is diÔ¨Äerentiated from arithmetic by its use of abstractions
such as variables. By the use of variables, we‚Äôre saying we don‚Äôt
care much what value will be put into that slot. We care about
the rules of how to manipulate this thing without reference to
its particular value.
And so, as we said above, an algebra refers to some opera-
tions and the set they operate over. Here again, we care less
about the particulars of the values or data we‚Äôre working with
and more about the general rules of their use.
In Haskell, these algebras can be implemented with type-
classes; the typeclasses define the set of operations. When we
talk about operations over a set, the set is the typethe opera-
tions are for. The instance defines how each operation will
perform for a given type or set. One of those algebras we use
ismonoid . If you‚Äôre a working programmer, you‚Äôve probably</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 890
had monoidal patterns in your code already, perhaps without
realizing it.
15.3 Monoid
A monoid is a binary associative operation with an identity.
This definition tells you a lot ‚Äî if you‚Äôre accustomed to picking
apart mathematical definitions. Let us dissect this frog!
A monoid is a binary associative operation with an identity.
[1] [2] [3] [4] [5]
1.The thing we‚Äôre talking about ‚Äî monoids. That‚Äôll end up
being the name of our typeclass.
2.Binary, i.e., two. So, there will be two of something.
3.Associative ‚Äî this is a property or law that must be satis-
fied. You‚Äôve seen associativity with addition and multipli-
cation. We‚Äôll explain it more in a moment.
4.Operation ‚Äî so called because in mathematics, it‚Äôs usually
used as an infix operator. You can read this interchange-
ably as ‚Äúfunction.‚Äù Note that given the mention of ‚Äúbinary‚Äù
earlier, we know that this is a function of two arguments.
5.Identity is one of those words in mathematics that pops
up a lot. In this context, we can take this to mean there‚Äôll</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 891
be some value which, when combined with any other
value, will always return that other value. This can be
seen most immediately with examples.
For lists, we have a binary operator, (++), that joins two
lists together. We can also use a function, mappend , from
theMonoid typeclass to do the same thing:
Prelude&gt; mappend [1, 2, 3] [4, 5, 6]
[1,2,3,4,5,6]
For lists, the empty list, [], is the identity value:
mappend [1..5][]=[1..5]
mappend [][1..5]=[1..5]
We can rewrite this as a more general rule, using mempty
from the Monoid typeclass as a generic identity value (more
on this later):
mappend x mempty =x
mappend mempty x =x
In plain English, a monoid is a function that takes two argu-
ments and follows two laws: associativity and identity. Asso-
ciativity means the arguments can be regrouped (or reparen-
thesized, or reassociated) in diÔ¨Äerent orders and give the same</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 892
result, as in addition. Identity means there exists some value
such that when we pass it as input to our function, the opera-
tion is rendered moot and the other value is returned, such as
when we add zero or multiply by one. Monoid is the typeclass
that generalizes these laws across types.
15.4 How Monoid is defined in Haskell
Typeclasses give us a way to recognize, organize, and use com-
mon functionalities and patterns across types that diÔ¨Äer in
some ways but also have things in common. So, we recognize
that, although there are many types of numbers, all of them
can be arguments in addition, and then we make an addition
function as part of the Numclass that all numbers implement.
TheMonoid typeclass recognizes and orders a diÔ¨Äerent pat-
tern than Numbut the goal is similar. The pattern of Monoid is
outlined above: types that have binary functions that let you
join things together in accordance with the laws of associa-
tivity, along with an identity value that will return the other
argument unmodified. This is the pattern of summation, mul-
tiplication, and list concatenation, among other things. The
typeclass abstracts and generalizes the pattern so that you write
code in terms of anytype that can be monoidally combined.
The typeclass Monoid is defined:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 893
classMonoidmwhere
mempty ::m
mappend ::m-&gt;m-&gt;m
mconcat ::[m]-&gt;m
mconcat =foldr mappend mempty
mappend is howanytwo values that inhabit your type can be
joined together. mempty is the identity value for that mappend
operation. There are some laws that all Monoid instances must
abide, and we‚Äôll get to those soon. Next, let‚Äôs look at some
examples of monoids in action!
15.5 Examples of using Monoid
The nice thing about monoids is that they are familiar; they‚Äôre
all over the place. The best way to understand them initially
is to look at examples of some common monoidal operations
and remember that this typeclass abstracts the pattern out,
giving you the ability to use the operations over a larger range
of types.
List
One common type with an instance of Monoid isList. Check
out how monoidal operations work with lists:
Prelude&gt; mappend [1, 2, 3] [4, 5, 6]</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 894
[1,2,3,4,5,6]
Prelude&gt; mconcat [[1..3], [4..6]]
[1,2,3,4,5,6]
Prelude&gt; mappend &quot;Trout&quot; &quot; goes well with garlic&quot;
&quot;Trout goes well with garlic&quot;
This should look familiar, because we‚Äôve certainly seen this
before:
Prelude&gt; (++) [1, 2, 3] [4, 5, 6]
[1,2,3,4,5,6]
Prelude&gt; (++) &quot;Trout&quot; &quot; goes well with garlic&quot;
&quot;Trout goes well with garlic&quot;
Prelude&gt; foldr (++) [] [[1..3], [4..6]]
[1,2,3,4,5,6]
Prelude&gt; foldr mappend mempty [[1..3], [4..6]]
[1,2,3,4,5,6]
Our old friend (++)! And if we look at the definition of
Monoid for lists, we can see how this all lines up:
instance Monoid[a]where
mempty =[]
mappend =(++)
For other types, the instances would be diÔ¨Äerent, but the
ideas behind them remain the same.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 895
15.6 Why Integer doesn‚Äôt have a
Monoid
The type Integer does not have a Monoid instance. None of the
numeric types do. Yet it‚Äôs clear that numbers have monoidal
operations, so what‚Äôs up with that, Haskell?
While in mathematics the monoid of numbers is summa-
tion, there‚Äôs not a clear reason why it can‚Äôt be multiplication.
Both operations are monoidal (binary, associative, having an
identity value), but each type should only have one unique
instance for a given typeclass, not two (one instance for a sum,
one for a product).
This won‚Äôt work:
Prelude&gt; let x = 1 :: Integer
Prelude&gt; let y = 3 :: Integer
Prelude&gt; mappend x y
<interactive>:6:1: error:
‚Ä¢ No instance for (Monoid Integer)
arising from a use of ‚Äòmappend‚Äô
‚Ä¢ In the expression: mappend x y
In an equation for ‚Äòit‚Äô:
it = mappend x y</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 896
It isn‚Äôt clear if those should be added or multiplied as a
mappend operation. It says there‚Äôs no Monoid for those Integer s
for that reason. You get the idea.
To resolve the conflict, we have the SumandProduct newtypes
to wrap numeric values and signal which Monoid instance we
want. These newtypes are built into the Data.Monoid module.
While there are two possible instances of Monoid for numeric
values, we avoid using scoping tricks and abide by the rule that
typeclass instances are unique to the types they are for:
Prelude&gt; mappend (Sum 1) (Sum 5)
Sum {getSum = 6}
Prelude&gt; mappend (Product 5) (Product 5)
Product {getProduct = 25}
Prelude&gt; mappend (Sum 4.5) (Sum 3.4)
Sum {getSum = 7.9}
Note that we could use it with values that aren‚Äôt integral.
We can use these Monoid newtypes for all the types that have
instances of Num.
Integersformamonoidundersummationandmultiplication . We
can similarly say that lists form a monoid under concatenation.
It‚Äôs worth pointing out here that numbers aren‚Äôt the only
sets that have more than one possible monoid. Lists have
more than one possible monoid, although for now we‚Äôre only
working with concatenation (we‚Äôll look at the other list monoid</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 897
in another chapter). Several other types do as well. We usually
enforce the unique instance rule by using newtype to separate
the diÔ¨Äerent monoidal behaviors.
Why newtype?
Use of a newtype can be hard to justify or explain to people that
don‚Äôt yet have good intuitions for how Haskell code gets com-
piled and the representations of data used by your computer
in the course of executing your programs. With that in mind,
we‚Äôll do our best and oÔ¨Äer two explanations intended for two
diÔ¨Äerent audiences. We will return to the topic of newtype in
more detail later in the book.
First, there‚Äôs not much semantic diÔ¨Äerence (except for cir-
cumstances involving bottom , explained later) between the fol-
lowing datatypes:
dataServer=ServerString
newtype Server' =Server' String
The main diÔ¨Äerences are that using newtype constrains the
datatype to having a single unary data constructor and newtype
guarantees no additional runtime overhead in ‚Äúwrapping‚Äù the
original type. That is, the runtime representation of newtype
and what it wraps are always identical ‚Äî no additional ‚Äúboxing
up‚Äù of the data as is necessary for typical products and sums.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 898
Forveteranprogrammerswhounderstandpointers newtype
is like a single-member C union that avoids creating an extra
pointer, but still gives you a new type constructor and data
constructor so you don‚Äôt mix up the many many many things
that share a single representation.
In summary, why you might use newtype
1.To signal intent: using newtype makes it clear that you only
intend for it to be a wrapper for the underlying type. The
newtype cannot eventually grow into a more complicated
sum or product type, while a normal datatype can.
2.To improve type safety: avoid mixing up many values of
the same representation, such as TextorInteger .
3.To add diÔ¨Äerent typeclass instances to a type that is other-
wise unchanged representationally, such as with Sumand
Product .
More on Sum and Product
There‚Äôs more than one valid Monoid instance one can write for
numbers, so we use newtype wrappers to distinguish which we
want. If you import Data.Monoid you‚Äôll see the SumandProduct
newtypes:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 899
Prelude&gt; import Data.Monoid
Prelude&gt; :info Sum
newtype Sum a = Sum {getSum :: a}
...some instances elided...
instance Num a =&gt; Monoid (Sum a)
Prelude&gt; :info Product
newtype Product a =
Product {getProduct :: a}
...some instances elided...
instance Num a =&gt; Monoid (Product a)
The instances say that we can use SumorProduct values as a
Monoid as long as they contain numeric values. We can prove
this is the case for ourselves. We‚Äôre going to be using the infix
operator for mappend in these examples. It has the same type
and does the same thing but saves some characters and will
make these examples a bit cleaner:
Prelude Data.Monoid&gt; :t (&lt;&gt;)
(&lt;&gt;) :: Monoid m =&gt; m -&gt; m -&gt; m
Prelude&gt; Sum &quot;Frank&quot; &lt;&gt; Sum &quot;Herbert&quot;
No instance for (Num [Char]) ...</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 900
The example didn‚Äôt work because the ùëéinSum awasString
which is not an instance of Num.
SumandProduct do what you‚Äôd expect with a bit of syntactic
surprise:
Prelude Data.Monoid&gt; (Sum 8) &lt;&gt; (Sum 9)
Sum {getSum = 17}
Prelude Data.Monoid&gt; mappend mempty Sum 9
Sum {getSum = 9}
Butmappend joins two things, so you can‚Äôt do this:
Prelude&gt; mappend (Sum 8) (Sum 9) (Sum 10)
You‚Äôll get a big error message including this line:
Possible cause: ‚ÄòSum‚Äô is applied to too many arguments
In the first argument of ‚Äòmappend‚Äô, namely ‚Äò(Sum 8)‚Äô
So, that‚Äôs easy enough to fix by nesting:
Prelude&gt; mappend (Sum 1) (mappend (Sum 2) (Sum 3))
Sum {getSum = 6}
Or somewhat less tedious by infixing the mappend function:
Prelude&gt; Sum 1 &lt;&gt; Sum 1 &lt;&gt; Sum 1
Sum {getSum = 3}</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 901
Or you could also put your Sums in a list and use mconcat :
Prelude&gt; mconcat [Sum 8, Sum 9, Sum 10]
Sum {getSum = 27}
Due to the special syntax of SumandProduct , we also have
built-in record field accessors we can use to unwrap the value:
Prelude&gt; getSum $ mappend (Sum 1) (Sum 1)
2
Prelude&gt; getProduct $ mappend (Product 5) (Product 5)
25
Prelude&gt; getSum $ mconcat [(Sum 5), (Sum 6), (Sum 7)]
18
Product is similar to Sumbut for multiplication.
15.7 Why bother?
Because monoids are common and they‚Äôre a nice abstraction
to work with when you have multiple monoidal things run-
ning around in a project. Knowing what a monoid is can help
you to recognize when you‚Äôve encountered the pattern. Fur-
ther, having principled laws for it means you know you can
combine monoidal operations safely. When we say something</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 902
is a monoid or can be described as monoidal , we mean you can
define at least one law-abiding Monoid instance for it.
A common use of monoids is to structure and describe com-
mon modes of processing data. Sometimes this is to describe
an API for incrementally processing a large dataset, sometimes
to describe guarantees needed to roll up aggregations (think
summation) in a parallel, concurrent, or distributed processing
framework.
One example of where things like the identity can be useful
is if you want to write a generic library for doing work in
parallel. You could choose to describe your work as being like
a tree, with each unit of work being a leaf. From there you
can partition the tree into as many chunks as are necessary to
saturate the number of processor cores or entire computers
you want to devote to the work. The problem is, if we have a
pair-wise operation and we need to combine an odd number
of leaves, how do we even out the count?
One straightforward way could be to simply provide mempty
(the identity value) to the odd leaves out so we get the same
result and pass it up to the next layer of aggregation!
A variant of monoid that provides more guarantees is the
Abelian or commutative monoid. Commutativity can be par-
ticularly helpful when doing concurrent or distributed pro-
cessing of data because it means the intermediate results being
computed in a diÔ¨Äerent order won‚Äôt change the eventual an-
swer.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 903
Monoids are even strongly associated with the concept of
folding or catamorphism ‚Äî something we do all the time in
Haskell. You‚Äôll see this more explicitly in the Foldable chapter,
but here‚Äôs a taste:
Prelude&gt; foldr mappend mempty ([2, 4, 6] :: [Product Int])
Product {getProduct = 48}
Prelude&gt; foldr mappend mempty ([2, 4, 6] :: [Sum Int])
Sum {getSum = 12}
Prelude&gt; foldr mappend mempty [&quot;blah&quot;, &quot;woot&quot;]
&quot;blahwoot&quot;
You‚Äôll see monoidal structure come up when we explain
Applicative andMonadas well.
15.8 Laws
We‚Äôll get to those laws in a moment. First, heed our little cri de
coeurabout why you should care about mathematical laws:
Laws circumscribe what constitutes a valid instance or con-
crete instance of the algebra or set of operations we‚Äôre working
with. We care about the laws a Monoid instance must adhere to
because we want our programs to be correct wherever possible.
Proofs are programs, and programs are proofs. We care about</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 904
programs that compose well, that are easy to understand, and
which have predictable behavior. To that end, we should steal
prolifically from mathematics.
Algebras are defined by their laws and are useful principally
fortheir laws. Laws make up what algebras are.
Among other things, laws provide us guarantees that let
us build on solid foundations. Those guarantees give us pre-
dictable composition (or combination) of programs. Without
the ability to safely combine programs, everything must be
written from scratch, nothing could be reused. The physical
world has enjoyed the useful properties of stone stacked up
on top of stone since the Great Pyramid of Giza was built in
the pharaoh Sneferu‚Äôs reign in 2,600 BC. Similarly, if we want
to be able to stack up functions scalably, they need to obey
laws. Stones don‚Äôt evaporate into thin air or explode violently.
It‚Äôd be nice if our programs were similarly trustworthy.
There are more possible laws we can require for an algebra
than associativity or an identity, but these are simple examples
we are starting with for now, partly because Monoid is a good
place to start with algebras-as-typeclasses. We‚Äôll see examples
of more later.
Monoid instances must abide by the following laws:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 905
-- left identity
mappend mempty x =x
-- right identity
mappend x mempty =x
-- associativity
mappend x (mappend y z) =
mappend (mappend x y) z
mconcat =foldr mappend mempty
Here is how the identity law looks in practice:
Prelude&gt; import Data.Monoid
-- left identity
Prelude&gt; mappend mempty (Sum 1)
Sum {getSum = 1}
-- right identity
Prelude&gt; mappend (Sum 1) mempty
Sum {getSum = 1}
We can demonstrate associativity more easily if we first
introduce the infix operator for mappend ,&lt;&gt;. Note the parenthe-
sization on the two examples:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 906
Prelude&gt; :t (&lt;&gt;)
(&lt;&gt;) :: Monoid m =&gt; m -&gt; m -&gt; m
-- associativity
Prelude&gt; (Sum 1) &lt;&gt; (Sum 2 &lt;&gt; Sum 3)
Sum {getSum = 6}
Prelude&gt; (Sum 1 &lt;&gt; Sum 2) &lt;&gt; (Sum 3)
Sum {getSum = 6}
Andmconcat should have the same result as foldr mappend
mempty :
Prelude&gt; mconcat [Sum 1, Sum 2, Sum 3]
Sum {getSum = 6}
Prelude&gt; foldr mappend mempty [Sum 1, Sum 2, Sum 3]
Sum {getSum = 6}
Now let‚Äôs see all of that again, but using the Monoid of lists:
-- mempty is []
-- mappend is (++)
-- left identity
Prelude&gt; mappend mempty [1, 2, 3]
[1,2,3]</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 907
-- right identity
Prelude&gt; mappend [1, 2, 3] mempty
[1,2,3]
-- associativity
Prelude&gt; [1] &lt;&gt; ([2] &lt;&gt; [3])
[1,2,3]
Prelude&gt; ([1] &lt;&gt; [2]) &lt;&gt; [3]
[1,2,3]
-- mconcat ~ foldr mappend mempty
Prelude&gt; mconcat [[1], [2], [3]]
[1,2,3]
Prelude&gt; foldr mappend mempty [[1], [2], [3]]
[1,2,3]
Prelude&gt; concat [[1], [2], [3]]
[1,2,3]
The important part here is that you have these guarantees
even when you don‚Äôt know whatMonoid you‚Äôll be working with.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 908
15.9 DiÔ¨Äerent instance, same
representation
Monoid is somewhat diÔ¨Äerent from other typeclasses in Haskell,
in that many datatypes have more than one valid monoid. We
saw that for numbers, both addition and multiplication are sen-
sible monoids with diÔ¨Äerent behaviors. When we have more
than one potential implementation for Monoid for a datatype,
it‚Äôs most convenient to use newtypes to tell them apart, as we
did with SumandProduct .
Addition is a classic appending operation, as is list concate-
nation. Referring to multiplication as an appending operation
may also seem intuitive enough, as it still follows the basic
pattern of combining two values of one type into one value.
But for other datatypes the meaning of append is less clear.
In these cases, the monoidal operation is less about combining
the values and more about finding a summary value for the set.
We mentioned above that monoids are important to folding
and catamorphisms more generally. Mappending is perhaps
bestthoughtofnotasawayofcombiningvaluesinthewaythat
addition or list concatenation does, but as a way to condense
any set of values to a summary value. We‚Äôll start by looking at
theMonoid instances for Boolto see what we mean.
Boolean values have two possible monoids ‚Äî a monoid of
conjunction and one of disjunction. As we do with numbers,</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 909
we use newtypes to distinguish the two instances. AllandAny
are the newtypes for Bool‚Äôs monoids:
Prelude&gt; import Data.Monoid
Prelude&gt; All True &lt;&gt; All True
All {getAll = True}
Prelude&gt; All True &lt;&gt; All False
All {getAll = False}
Prelude&gt; Any True &lt;&gt; Any False
Any {getAny = True}
Prelude&gt; Any False &lt;&gt; Any False
Any {getAny = False}
Allrepresents boolean conjunction: it returns a Trueif and
only if all values it is ‚Äúappending‚Äù are True.Anyis the monoid
of boolean disjunction: it returns a Trueif any value is True.
There is some sense in which it might feel strange to think of
this as a combining or mappending operation, unless we recall
that mappending is less about combining and more about
condensing or reducing.
TheMaybetype has more than two possible Monoids. We‚Äôll
look at each in turn, but the two that have an obvious relation-
ship are FirstandLast. They are like boolean disjunction, but
with explicit preference for the leftmost or rightmost success</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 910
in a series of Maybevalues. We have to choose because with
Bool, all you know is TrueorFalse‚Äî it doesn‚Äôt matter where
yourTrueorFalsevalues occurred. With Maybe, however, you
need to make a decision as to which Justvalue you‚Äôll return
if there are multiple successes. FirstandLastencode these
diÔ¨Äerent possibilities.
Firstreturns the first or leftmost non- Nothing value:
Prelude&gt; First (Just 1) <code>mappend</code> First (Just 2)
First {getFirst = Just 1}
Lastreturns the last or rightmost non- Nothing value:
Prelude&gt; Last (Just 1) <code>mappend</code> Last (Just 2)
Last {getLast = Just 2}
Both will succeed in returning something in spite of Nothing
values as long as there‚Äôs at least one Just:
Prelude&gt; Last Nothing <code>mappend</code> Last (Just 2)
Last {getLast = Just 2}
Prelude&gt; First Nothing <code>mappend</code> First (Just 2)
First {getFirst = Just 2}
Neither can, for obvious reasons, return anything if all val-
ues are Nothing :</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 911
Prelude&gt; First Nothing <code>mappend</code> First Nothing
First {getFirst = Nothing}
Prelude&gt; Last Nothing <code>mappend</code> Last Nothing
Last {getLast = Nothing}
To maintain the unique pairing of type and typeclass in-
stance, newtypes are used for all of those, the same as we saw
withSumandProduct .
Let‚Äôs look next at the third variety of Maybe Monoid .
15.10 Reusing algebras by asking for
algebras
We alluded to there being more possible Monoid s forMaybethan
justFirstandLast. Let‚Äôs write that other Monoid instance. We
will now be concerned not with choosing one value out of a
set of values but of combining the ùëévalues contained within
theMaybe a type.
First, try to notice a pattern:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 912
instance Monoidb=&gt;Monoid(a-&gt;b)
instance (Monoida,Monoidb)
=&gt;Monoid(a, b)
instance (Monoida,Monoidb,Monoidc)
=&gt;Monoid(a, b, c)
What these Monoids have in common is that they are giv-
ing you a new Monoid for a larger type by reusing the Monoid
instances of types that represent components of the larger
type.
This obligation to ask for a Monoid for an encapsulated type
(such as the ùëéinMaybe a ) exists even when not all possible val-
ues of the larger type contain the value of the type argument.
For example, Nothing does not contain the ùëéwe‚Äôre trying to
get aMonoid for, but Just a does, so not all possible Maybevalues
contain the ùëétype argument. For a Maybe Monoid that will have
amappend operation for the ùëévalues, we need a Monoid for what-
ever type ùëéis.Monoids likeFirstandLastwrap the Maybe a but
do not require a Monoid for theùëévalue itself because they don‚Äôt
mappend theùëévalues or provide a mempty of them.
If you do have a datatype that has a type argument that
does not appear anywhere in the terms (a phantom type), the
typechecker does not demand that you have a Monoid instance
for that argument. For example:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 913
dataBoolya=
False'
|True'
deriving (Eq,Show)
-- conjunction
instance Monoid(Boolya)where
mappend False'_ =False'
mappend _False'=False'
mappend True'True'=True'
We didn‚Äôt need a Monoid constraint for ùëébecause we‚Äôre never
mappending ùëévalues (we can‚Äôt; none exist) and we‚Äôre never
asking for a mempty of type ùëé. This is the fundamental reason
we don‚Äôt need the constraint, but it can happen that we don‚Äôt
do this even when the type doesoccur in the datatype.
Exercise: Optional Monoid
Writethe Monoid instanceforour Maybetyperenamedto Optional .</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 914
dataOptional a=
Nada
|Onlya
deriving (Eq,Show)
instance Monoida
=&gt;Monoid(Optional a)where
mempty=undefined
mappend =undefined
Expected output:
Prelude&gt; Only (Sum 1) <code>mappend</code> Only (Sum 1)
Only (Sum {getSum = 2})
Prelude&gt; Only (Product 4) <code>mappend</code> Only (Product 2)
Only (Product {getProduct = 8})
Prelude&gt; Only (Sum 1) <code>mappend</code> Nada
Only (Sum {getSum = 1})
Prelude&gt; Only [1] <code>mappend</code> Nada
Only [1]
Prelude&gt; Nada <code>mappend</code> Only (Sum 1)
Only (Sum {getSum = 1})</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 915
Associativity
This will be mostly review, but we want to be specific about
associativity. Associativitysaysthatyoucanassociate, orgroup,
the arguments of your operation diÔ¨Äerently and the result will
be the same.
Let‚Äôs review examples of some operations that can be reas-
sociated :
Prelude&gt; (1 + 9001) + 9001
18003
Prelude&gt; 1 + (9001 + 9001)
18003
Prelude&gt; (7 * 8) * 3
168
Prelude&gt; 7 * (8 * 3)
168
And some that cannot have the parentheses reassociated
without changing the result:
Prelude&gt; (1 - 10) - 100
-109
Prelude&gt; 1 - (10 - 100)
91
This isnotas strong a property as an operation that com-
mutes or is commutative . Commutative means you can reorder</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 916
the arguments and still get the same result. Addition and mul-
tiplication are commutative, but (++)for the list type is only
associative.
Let‚Äôs demonstrate this by writing a mildly evil version of
addition that flips the order of its arguments:
Prelude&gt; let evilPlus = flip (+)
Prelude&gt; 76 + 67
143
Prelude&gt; 76 <code>evilPlus</code> 67
143
We have some evidence, but not proof, that(+)commutes.
However, we can‚Äôt do the same with (++):
Prelude&gt; let evilPlusPlus = flip (++)
Prelude&gt; let oneList = [1..3]
Prelude&gt; let otherList = [4..6]
Prelude&gt; oneList ++ otherList
[1,2,3,4,5,6]
Prelude&gt; oneList <code>evilPlusPlus</code> otherList
[4,5,6,1,2,3]
In this case, this serves as a proof by counterexample that
(++)doesnotcommute. It doesn‚Äôt matter if it commutes for all</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 917
other inputs; that it doesn‚Äôt commute for one of them means
thelaw of commutativity does not hold.
Commutativity is a useful property and can be helpful in
circumstances when you might need to be able to reorder
evaluation of your data for efficiency purposes without need-
ing to worry about the result changing. Distributed systems
use commutative monoids in designing and thinking about
constraints, which are monoids that guarantee their operation
commutes.
But, for our purposes, Monoid abides by the law of associa-
tivity but not the law of commutativity, even though some
monoidal operations (addition and multiplication) are com-
mutative.
Identity
An identity is a value with a special relationship with an oper-
ation: it turns the operation into the identity function. There
are no identities without operations. The concept is defined in
terms of its relationship with a given operation. If you‚Äôve done
grade school arithmetic, you‚Äôve already seen some identities:
Prelude&gt; 1 + 0
1
Prelude&gt; 521 + 0
521
Prelude&gt; 1 * 1</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 918
1
Prelude&gt; 521 * 1
521
Zero is the identity value for addition, while 1is the identity
value for multiplication. As we said, it doesn‚Äôt make sense to
talk about zero and one as identity values outside the context
of those operations. That is, zero is definitely not the identity
value for other operations. We can check this property with a
simple equality test as well:
Prelude&gt; let myList = [1..424242]
-- 0 serves as identity for addition
Prelude&gt; map (+0) myList == myList
True
-- but not for multiplication
Prelude&gt; map (*0) myList == myList
False
-- 1 serves as identity for multiplication
Prelude&gt; map (*1) myList == myList
True
-- but not for addition
Prelude&gt; map (+1) myList == myList
False</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 919
This is the other law for Monoid : the binary operation must
be associative andit must have a sensible identity value.
The problem of orphan instances
We‚Äôve said both in this chapter and in the earlier chapter de-
voted to Typeclasses that typeclasses have unique pairings of
the class and the instance for a particular type.
We do sometimes end up with multiple instances for a
single type when orphan instances are written. But writing
orphan instances should be avoided at all costs . If you get an
orphan instance warning from GHC, fix it.
An orphan instance is when an instance is defined for a
datatype and typeclass, but not in the same module as either
the declaration of the typeclass or the datatype. If you don‚Äôt
own the typeclass or the datatype, newtype it!
If you want an orphan instance so that you can have multi-
ple instances for the same type, you still want to use newtype .
We saw this earlier with SumandProduct which let us have two
diÔ¨Äerent Monoid instances for numbers without resorting to
orphans or messing up typeclass instance uniqueness.
Let‚Äôs see an example of an orphan instance and how to fix it.
First, make a project directory and change into that directory:
$ mkdir orphan-instance &amp;&amp; cd orphan-instance</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 920
Then we‚Äôre going to make a couple of files, one module in
each:
moduleListywhere
newtype Listya=
Listy[a]
deriving (Eq,Show)
moduleListyInstances where
importData.Monoid
importListy
instance Monoid(Listya)where
mempty=Listy[]
mappend ( Listyl) (Listyl')=
Listy$mappend l l'
So our directory will look like:
$ tree
.
‚îú‚îÄ‚îÄ Listy.hs
‚îî‚îÄ‚îÄ ListyInstances.hs</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 921
Then to build ListyInstances such that it can see Listy, we
must use the -Iflag to include the current directory and make
modules within it discoverable. The .after the Iis how we
say ‚Äúthis directory‚Äù in Unix-alikes. If you succeed, you should
see something like the following:
$ ghc -I. --make ListyInstances.hs
[2 of 2] Compiling ListyInstances
Note that the only output will be an object file, the result of
compiling a module that can be reused as a library by Haskell
code, because we didn‚Äôt define a mainsuitable for producing an
executable. We‚Äôre only using this approach to build this so that
we can avoid the hassle of initializing (via stack new or similar)
a project. For anything more complicated or long-lived than
this, use a dependency and build management tool like Cabal
(if you‚Äôre using Stack, you‚Äôre also using Cabal).
Now to provide one example of why orphan instances are
problematic. Ifwecopyour Monoid instancefrom ListyInstances
intoListy, then rebuild ListyInstances , we‚Äôll get the following
error.
$ ghc -I. --make ListyInstances.hs
[1 of 2] Compiling Listy
[2 of 2] Compiling ListyInstances
Listy.hs:7:10:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 922
Duplicate instance declarations:
instance Monoid (Listy a)
-- Defined at Listy.hs:7:10
instance Monoid (Listy a)
-- Defined at ListyInstances.hs:5:10
These conflicting instance declarations could happen to
anybody who uses the previous version of our code. And
that‚Äôs a problem.
Orphan instances are stilla problem even if duplicate in-
stances aren‚Äôt both imported into a module because it means
your typeclass methods will start behaving diÔ¨Äerently depend-
ing on what modules are imported, which breaks the funda-
mental assumptions and niceties of typeclasses.
There are a few solutions for addressing orphan instances:
1.You defined the type but not the typeclass? Put the in-
stance in the same module as the type so that the type
cannot be imported without its instances.
2.You defined the typeclass but not the type? Put the in-
stance in the same module as the typeclass definition
so that the typeclass cannot be imported without its in-
stances.
3.Neither the type nor the typeclass are yours? Define your
own newtype wrapping the original type and now you‚Äôve</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 923
got a type that ‚Äúbelongs‚Äù to you for which you can rightly
define typeclass instances. There are means of making
this less annoying which we‚Äôll discuss later.
These restrictions must be maintained in order for us to
reap the full benefit of typeclasses along with the reasoning
properties that are associated with them. A type musthave
a unique (singular) implementation of a typeclass in scope,
and avoiding orphan instances is how we prevent conflict-
ing instances. Be aware, however, that avoidance of orphan
instances is more strictly adhered to among library authors
rather than application developers, although it‚Äôs no less im-
portant in applications.
15.11 Madness
You may have seen mad libs before. The idea is to take a tem-
plate of phrases, fill them in with blindly selected categories
of words, and see if saying the final version is amusing.
Using a lightly edited example from the Wikipedia article
on Mad Libs:
&quot;___________! he said ______ as he
exclamation adverb
jumped into his car ____ and drove
noun</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 924
off with his _________ wife.&quot;
adjective
We can make this into a function, like the following:
importData.Monoid
typeVerb=String
typeAdjective =String
typeAdverb=String
typeNoun=String
typeExclamation =String
madlibbin' ::Exclamation
-&gt;Adverb
-&gt;Noun
-&gt;Adjective
-&gt;String
madlibbin' e adv noun adj =
e&lt;&gt;&quot;! he said &quot; &lt;&gt;
adv&lt;&gt;&quot; as he jumped into his car &quot; &lt;&gt;
noun&lt;&gt;&quot; and drove off with his &quot; &lt;&gt;
adj&lt;&gt;&quot; wife.&quot;
Now you‚Äôre going to refactor this code a bit! Rewrite it using
mconcat .</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 925
madlibbinBetter' ::Exclamation
-&gt;Adverb
-&gt;Noun
-&gt;Adjective
-&gt;String
madlibbinBetter' e adv noun adj =undefined
15.12 Better living through QuickCheck
Proving laws can be tedious, especially if the code we‚Äôre check-
ing is in the middle of changing frequently. Accordingly, hav-
ing a cheap way to get a sense of whether or not the laws are
likelyto be obeyed by an instance is pretty useful. QuickCheck
happens to be an excellent way to accomplish this.
Validating associativity with QuickCheck
You can check the associativity of some simple arithemetic
expressions by asserting equality between two versions with
diÔ¨Äerent parenthesization and checking them in the REPL:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 926
-- we're saying these are the same because
-- (+) and (<em>) are associative
1+(2+3)==(1+2)+3
4</em>(5<em>6)==(4</em>5)<em>6
This doesn‚Äôt tell us that associativity holds for anyinputs to
(+)and(</em>), though, and that is what we want to test. Our old
friend from the lambda calculus ‚Äî abstraction! ‚Äî suffices for
this:
\a b c-&gt;a+(b+c)==(a+b)+c
\a b c-&gt;a*(b<em>c)==(a</em>b)*c
But our arguments aren‚Äôt the only thing we can abstract.
What if we want to talk about the abstract property of associa-
tivity for some given function ùëì?
\f a b c -&gt;
f a (f b c) ==f (f a b) c
-- or infix
(&lt;&gt;) a b c -&gt;
a&lt;&gt;(b&lt;&gt;c)==(a&lt;&gt;b)&lt;&gt;c</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 927
Surprise! You can bind infix names for function arguments.
asc::Eqa
=&gt;(a-&gt;a-&gt;a)
-&gt;a-&gt;a-&gt;a
-&gt;Bool
asc(&lt;&gt;) a b c =
a&lt;&gt;(b&lt;&gt;c)==(a&lt;&gt;b)&lt;&gt;c
Now how do we turn this function into something we can
property test with QuickCheck ? The quickest and easiest way
would probably look something like the following:
importData.Monoid
importTest.QuickCheck
monoidAssoc ::(Eqm,Monoidm)
=&gt;m-&gt;m-&gt;m-&gt;Bool
monoidAssoc a b c=
(a&lt;&gt;(b&lt;&gt;c))==((a&lt;&gt;b)&lt;&gt;c)
We have to declare the types for the function in order to
run the tests, so that QuickCheck knows what types of data to
generate.
We can now use this to check associativity of functions:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 928
-- for brevity
Prelude&gt; type S = String
Prelude&gt; type B = Bool
Prelude&gt; quickCheck (monoidAssoc :: S -&gt; S -&gt; S -&gt; B)
+++ OK, passed 100 tests.
ThequickCheck function uses the Arbitrary typeclass to pro-
vide the randomly generated inputs for testing the function.
Although it‚Äôs common to do so, we may not want to rely on an
Arbitrary instance existing for the type of our inputs, for one
of a few reasons. It may be that we need a generator for a type
that doesn‚Äôt belong to us, so we‚Äôd rather not make an orphan
instance. Or it could be a type that already has an Arbitrary
instance, but we want to run tests with a diÔ¨Äerent random
distribution of values, or to make sure we check certain special
edge cases in addition to the random values.
You want to be careful to assert types so that QuickCheck
knows which Arbitrary instance to get random values for test-
ing from. You can use verboseCheck to see what values were
tested. If you try running the check verbosely and without
asserting a type for the arguments:
Prelude&gt; verboseCheck monoidAssoc
Passed:
()
()</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 929
()
(repeated 100 times)
This is GHCi‚Äôs type-defaulting biting you, as we saw back in
the Testing chapter. GHCi has slightly more aggressive type-
defaulting which can be handy in an interactive session when
you want to fire oÔ¨Ä some code and have your REPL pick a
winner for the typeclasses it doesn‚Äôt know how to dispatch.
Compiled in a source file, GHC would‚Äôve complained about
an ambiguous type.
Testing left and right identity
Following on from what we did with associativity, we can also
useQuickCheck to test left and right identity:
monoidLeftIdentity ::(Eqm,Monoidm)
=&gt;m
-&gt;Bool
monoidLeftIdentity a=(mempty &lt;&gt;a)==a
monoidRightIdentity ::(Eqm,Monoidm)
=&gt;m
-&gt;Bool
monoidRightIdentity a=(a&lt;&gt;mempty) ==a</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 930
Then running these properties against a Monoid :
Prelude&gt; quickCheck (monoidLeftIdentity :: String -&gt; Bool)
+++ OK, passed 100 tests.
Prelude&gt; quickCheck (monoidRightIdentity :: String -&gt; Bool)
+++ OK, passed 100 tests.
Testing QuickCheck‚Äôs patience
Let us see an example of QuickCheck catching us out for having
an invalid Monoid . Here we‚Äôre going to demonstrate why a Bool
Monoid can‚Äôt have Falseas the identity, always returning the
valueFalse, and still be a valid Monoid :
-- associative, left identity, and right
-- identity properties have been elided.
-- Add them to your copy of this.
importControl.Monad
importData.Monoid
importTest.QuickCheck
dataBull=
Fools
|Twoo
deriving (Eq,Show)</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 931
instance Arbitrary Bullwhere
arbitrary =
frequency [ ( 1, return Fools)
, (1, return Twoo) ]
instance MonoidBullwhere
mempty=Fools
mappend _ _ =Fools
typeBullMappend =
Bull-&gt;Bull-&gt;Bull-&gt;Bool
main::IO()
main= do
letma=monoidAssoc
mli=monoidLeftIdentity
mlr=monoidRightIdentity
quickCheck (ma ::BullMappend )
quickCheck (mli ::Bull-&gt;Bool)
quickCheck (mlr ::Bull-&gt;Bool)
If you load this up in GHCi and run main, you‚Äôll get the
following output:
Prelude&gt; main
+++ OK, passed 100 tests.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 932
*** Failed! Falsifiable (after 1 test):
Twoo
*** Failed! Falsifiable (after 1 test):
Twoo
So this not-actually-a- Monoid forBoolturns out to pass asso-
ciativity, but fail on the right and left identity checks. To see
why, let‚Äôs line up the laws against what our mempty andmappend
are:
-- how the instance is defined
mempty=Fools
mappend _ _ =Fools
-- identity laws
mappend mempty x =x
mappend x mempty =x
-- Does it obey the laws?
-- because of how mappend is defined
mappend mempty x =Fools
mappend x mempty =Fools
-- Fools is not x, so it
-- fails the identity laws.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 933
It‚Äôs fine if your identity value is Fools, but if your mappend
always returns the identity, then it‚Äôs not an identity. It‚Äôs not
behaving like a zero as you‚Äôre not even checking if either argu-
ment is Foolsbefore returning Fools. It‚Äôs a black hole that spits
out one value, which is senseless. For an example of what is
meant by zero, consider multiplication which has an identity
anda zero:
-- Thus why the mempty for Sum is 0
0+x==x
x+0==x
-- Thus why the mempty for Product is 1
1<em>x==x
x</em>1==x
-- Thus why the mempty for
-- Product is <em>not</em> 0
0<em>x==0
x</em>0==0
UsingQuickCheck can be a great way to cheaply and easily
sanity check the validity of your instances against their laws.
You‚Äôll see more of this.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 934
Exercise: Maybe Another Monoid
Write a Monoid instance for a Maybetype which doesn‚Äôt require
aMonoid for the contents. Reuse the Monoid lawQuickCheck prop-
erties and use them to validate the instance.
Don‚Äôt forget to write an Arbitrary instance for First'. We
won‚Äôt always stub that out explicitly for you. We suggest
learning how to use the frequency function from QuickCheck
forFirst' ‚Äôs instance.
newtype First'a=
First'{ getFirst' ::Optional a }
deriving (Eq,Show)
instance Monoid(First'a)where
mempty=undefined
mappend =undefined
firstMappend ::First'a
-&gt;First'a
-&gt;First'a
firstMappend =mappend</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 935
typeFirstMappend =
First'String
-&gt;First'String
-&gt;First'String
-&gt;Bool
typeFstId=
First'String-&gt;Bool
main::IO()
main= do
quickCheck (monoidAssoc ::FirstMappend )
quickCheck (monoidLeftIdentity ::FstId)
quickCheck (monoidRightIdentity ::FstId)
Our expected output demonstrates a diÔ¨Äerent Monoid for
Optional /Maybewhich is getting the first success and holding
onto it, where any exist. This could be seen, with a bit of
hand-waving, as being a disjunctive (‚Äúor‚Äù) Monoid instance.
Prelude&gt; First' (Only 1) <code>mappend</code> First' Nada
First' {getFirst' = Only 1}
Prelude&gt; First' Nada <code>mappend</code> First' Nada
First' {getFirst' = Nada}
Prelude&gt; First' Nada <code>mappend</code> First' (Only 2)
First' {getFirst' = Only 2}</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 936
Prelude&gt; First' (Only 1) <code>mappend</code> First' (Only 2)
First' {getFirst' = Only 1}
15.13 Semigroup
Mathematicians play with algebras like that creepy kid you
knew in grade school who would pull legs oÔ¨Ä of insects. Some-
times, they glue legs onto insects too, but in the case where
we‚Äôre going from Monoid toSemigroup , we‚Äôre pulling a leg oÔ¨Ä.
In this case, the leg is our identity. To get from a monoid
to a semigroup, we simply no longer furnish nor require an
identity. The core operation remains binary and associative.
With this, our definition of Semigroup is:
classSemigroup awhere
(&lt;&gt;)::a-&gt;a-&gt;a
And we‚Äôre left with one law:
(a&lt;&gt;b)&lt;&gt;c=a&lt;&gt;(b&lt;&gt;c)
Semigroup still provides a binary associative operation, one
that typically joins two things together (as in concatenation or
summation), but doesn‚Äôt have an identity value. In that sense,
it‚Äôs a weaker algebra.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 937
Not yet part of base As of GHC 8, the Semigroup typeclass
is part of basebut not part of Prelude . You need to import
Data.Semigroup to use its operations. Keep in mind that it de-
fines its own more general version of (&lt;&gt;)which only requires
aSemigroup constraint rather than a Monoid constraint.
You can import the NonEmpty datatype we are about to discuss
into your REPL by importing Data.List.NonEmpty .
NonEmpty, a useful datatype
One useful datatype that can‚Äôt have a Monoid instance but does
have a Semigroup instance is the NonEmpty list type. It is a list
datatype that can never be an empty list:
dataNonEmpty a=a:|[a]
deriving (Eq,Ord,Show)
-- some instances from the
-- real module elided
Here:|is an infix data constructor that takes two (type)
arguments. It‚Äôs a product of aand[a]. It guarantees that we
always have at least one value of type ùëé, which [a]does not
guarantee as any list might be empty.
Note that although :|is not alphanumeric, as most of the
other data constructors you‚Äôre used to seeing are, it is a name
for an infix data constructor. Data constructors with only</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 938
nonalphanumeric symbols and that begin with a colon are
infix by default; those with alphanumeric names are prefix by
default:
-- Prefix, works.
dataP=
PrefixIntString
-- Infix, works.
dataQ=
Int:!!:String
Since that data constructor is symbolic rather than alphanu-
meric, it can‚Äôt be used as a prefix:
dataR=
:!!:IntString
Using it as a prefix will cause a syntax error:
parse error on input ‚Äò:!!:‚Äô
Failed, modules loaded: none.
On the other hand, an alphanumeric data constructor can‚Äôt
be used as an infix:
dataS=
IntPrefixString</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 939
It will cause another error:
Not in scope: type constructor or class ‚ÄòPrefix‚Äô
A data constructor of that name is in scope;
did you mean DataKinds?
Failed, modules loaded: none.
Let‚Äôs return to the main point, which is NonEmpty . Because
NonEmpty isa productof twoarguments, wecould‚Äôvealso written
it as:
newtype NonEmpty a=
NonEmpty (a, [a])
deriving (Eq,Ord,Show)
We can‚Äôt write a Monoid forNonEmpty because it has no identity
value by design! There is no empty list to serve as an identity
for any operation over a NonEmpty list, yet there is still a binary
associative operation: two NonEmpty lists can still be concate-
nated. A type with a canonical binary associative operation but
no identity value is a natural fit for Semigroup . Here is a brief
example of using NonEmpty from the semigroups library with the
semigroup mappend (as of GHC 8.0.1, Semigroup andNonEmpty are
both in basebut not in Prelude ):
-- you may need to install <code>semigroups</code>
Prelude&gt; import Data.List.NonEmpty as N</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 940
Prelude N&gt; import Data.Semigroup as S
Prelude N S&gt; 1 :| [2, 3]
1 :| [2,3]
Prelude N S&gt; :t 1 :| [2, 3]
1 :| [2, 3] :: Num a =&gt; NonEmpty a
Prelude N S&gt; :t (&lt;&gt;)
(&lt;&gt;) :: Semigroup a =&gt; a -&gt; a -&gt; a
Prelude N S&gt; let xs = 1 :| [2, 3]
Prelude N S&gt; let ys = 4 :| [5, 6]
Prelude N S&gt; xs &lt;&gt; ys
1 :| [2,3,4,5,6]
Prelude N S&gt; N.head xs
1
Prelude N S&gt; N.length (xs &lt;&gt; ys)
6
Beyond this, you use NonEmpty as you would a list, but what
you‚Äôve gained is being explicit that having zero values is not
valid for your use-case. The datatype helps you enforce this
constraint by not letting you construct a NonEmpty unless you
have at least one value.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 941
15.14 Strength can be weakness
When Haskellers talk about the strength of an algebra, they
usually mean the number of operations it provides which in
turn expands what you can do with any given instance of that
algebra without needing to know specifically what type you
are working with.
The reason we cannot and do not want to make all of our
algebras as big as possible is that there are datatypes which
are very useful representationally, but which do not have the
ability to satisfy everything in a larger algebra that could work
fine if you removed an operation or law. This becomes a seri-
ous problem if NonEmpty is the right datatype for something in
the domain you‚Äôre representing. If you‚Äôre an experienced pro-
grammer, think carefully. How many times have you meant
for a list to never be empty? To guarantee this and make the
types more informative, we use types like NonEmpty .
The problem is that NonEmpty has no identity value for the
combining operation ( mappend ) inMonoid. So, we keep the as-
sociativity but drop the identity value and its laws of left and
right identity. This is what introduces the need for and idea
ofSemigroup from a datatype.
The most obvious way to see that a monoid is stronger than
a semigroup is to observe that it has a strict superset of the op-
erations and laws that Semigroup provides. Anything which is a
monoid is by definition alsoa semigroup. It is to be hoped that</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 942
Semigroup will be made a superclass of Monoid in an upcoming
version of GHC.
classSemigroup a=&gt;Monoidawhere
...
Earlier we reasoned about the inverse relationship between
operations permitted over a type and the number of types that
can satisfy. We can see this relationship between the number
of operations and laws an algebra demands and the number
of datatypes that can provide a law abiding instance of that
algebra.
In the following example, ùëécan be anything in the universe,
but there are no operations over it ‚Äî we can only return the
same value.
id::a-&gt;a
‚Ä¢Number of types: Infinite ‚Äî universally quantified so
it can be any type the expression applying the function
wants.
‚Ä¢Number of operations: one, if you can call it an operation,
referencing the value you were passed.
Withincùëénow has all the operations from Num, which lets
us do more. But that also means it‚Äôs now a finite set of types</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 943
that can satisfy the Numconstraint rather than being strictly any
type in the universe:
inc::Numa=&gt;a-&gt;a
‚Ä¢Number of types: anything that implements Num. Zero to
many.
‚Ä¢Number of operations: 7 methods in Num
In the next example we know it‚Äôs an Integer , which gives us
many more operations than just a Numinstance:
somethingInt ::Int-&gt;Int
‚Ä¢Number of types: one ‚Äî Int.
‚Ä¢Number of operations: considerably more than 7. In ad-
dition to Num,Inthas instances of Bounded ,Enum,Eq,Integral ,
Ord,Read,Real, andShow. On top of that, you can write ar-
bitrary functions that pattern match on concrete types
and return arbitrary values in that same type as the re-
sult. Polymorphism isn‚Äôt only useful for reusing code;
it‚Äôs also useful for expressing intent through parametricity
so that people reading the code know what we meant to
accomplish.
WhenMonoid is too strong or more than we need, we can use
Semigroup . If you‚Äôre wondering what‚Äôs weaker than Semigroup ,</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 944
the usual next step is removing the associativity requirement,
giving you a magma. It‚Äôs not likely to come up in day to day
Haskell, but you can sound cool at programming conferences
for knowing what‚Äôs weaker than a semigroup so pocket that
one for the pub.
15.15 Chapter exercises
Semigroup exercises
Given a datatype, implement the Semigroup instance. Add
Semigroup constraints to type variables where needed. Use the
Semigroup class from the semigroups library (or from baseif you
are on GHC 8) or write your own. When we use (&lt;&gt;), we mean
the infix mappend from the Semigroup typeclass.
Note We‚Äôre not always going to derive every instance you
may want or need in the datatypes we provide for exercises.
We expect you to know what you need and to take care of it
yourself by this point.
1.Validate allof your instances with QuickCheck. Since
Semigroup ‚Äôs only law is associativity, that‚Äôs the only prop-
erty you need to reuse. Keep in mind that you‚Äôll poten-
tially need to import the modules for Monoid andSemigroup
and to avoid naming conflicts for the (&lt;&gt;)depending on
your version of GHC.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 945
dataTrivial =Trivial deriving (Eq,Show)
instance Semigroup Trivial where
_ &lt;&gt; _ = undefined
instance Arbitrary Trivial where
arbitrary =returnTrivial
semigroupAssoc ::(Eqm,Semigroup m)
=&gt;m-&gt;m-&gt;m-&gt;Bool
semigroupAssoc a b c=
(a&lt;&gt;(b&lt;&gt;c))==((a&lt;&gt;b)&lt;&gt;c)
typeTrivAssoc =
Trivial -&gt;Trivial -&gt;Trivial -&gt;Bool
main::IO()
main=
quickCheck (semigroupAssoc ::TrivAssoc )
2.newtype Identity a=Identity a
3.dataTwoa b=Twoa b
Hint: Ask for another Semigroup instance.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 946
4.dataThreea b c=Threea b c
5.dataFoura b c d =Foura b c d
6.newtype BoolConj =
BoolConj Bool
What it should do:
Prelude&gt; (BoolConj True) &lt;&gt; (BoolConj True)
BoolConj True
Prelude&gt; (BoolConj True) &lt;&gt; (BoolConj False)
BoolConj False
7.newtype BoolDisj =
BoolDisj Bool
What it should do:
Prelude&gt; (BoolDisj True) &lt;&gt; (BoolDisj True)
BoolDisj True
Prelude&gt; (BoolDisj True) &lt;&gt; (BoolDisj False)
BoolDisj True
8.dataOra b=
Fsta
|Sndb</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 947
TheSemigroup forOrshould have the following behavior.
We can think of this as having a ‚Äústicky‚Äù Sndvalue where
it‚Äôll hold onto the first Sndvalue when and if one is passed
as an argument. This is similar to the First' Monoid you
wrote earlier.
Prelude&gt; Fst 1 &lt;&gt; Snd 2
Snd 2
Prelude&gt; Fst 1 &lt;&gt; Fst 2
Fst 2
Prelude&gt; Snd 1 &lt;&gt; Fst 2
Snd 1
Prelude&gt; Snd 1 &lt;&gt; Snd 2
Snd 1
9.newtype Combine a b=
Combine { unCombine ::(a-&gt;b) }
What it should do:
Prelude&gt; let f = Combine $ \n -&gt; Sum (n + 1)
Prelude&gt; let g = Combine $ \n -&gt; Sum (n - 1)
Prelude&gt; unCombine (f &lt;&gt; g) $ 0
Sum {getSum = 0}
Prelude&gt; unCombine (f &lt;&gt; g) $ 1
Sum {getSum = 2}</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 948
Prelude&gt; unCombine (f &lt;&gt; f) $ 1
Sum {getSum = 4}
Prelude&gt; unCombine (g &lt;&gt; f) $ 1
Sum {getSum = 2}
Hint: This function will eventually be applied to a single
value of type ùëé. But you‚Äôll have multiple functions that can
produce a value of type ùëè. How do we combine multiple
values so we have a single ùëè? This one will probably be
tricky! Remember that the type of the value inside of
Combine is that of a function . The type of functions should
already have an Arbitrary instance that you can reuse for
testing this instance.
10.newtype Compa=
Comp{ unComp ::(a-&gt;a) }
Hint: We can do something that seems a little more spe-
cific and natural to functions now that the input and out-
put types are the same.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 949
11.-- Look familiar?
dataValidation a b=
Failure a|Success b
deriving (Eq,Show)
instance Semigroup a=&gt;
Semigroup (Validation a b)where
(&lt;&gt;)=undefined
Given this code:
main= do
letfailure ::String
-&gt;Validation StringInt
failure =Failure
success ::Int
-&gt;Validation StringInt
success =Success
print$success 1&lt;&gt;failure &quot;blah&quot;
print$failure &quot;woot&quot;&lt;&gt;failure &quot;blah&quot;
print$success 1&lt;&gt;success 2
print$failure &quot;woot&quot;&lt;&gt;success 2
You should get this output:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 950
Prelude&gt; main
Success 1
Failure &quot;wootblah&quot;
Success 1
Success 2
Monoid exercises
Given a datatype, implement the Monoid instance. Add Monoid
constraints to type variables where needed. For the datatypes
you‚Äôve already implemented Semigroup instances for, you need
to figure out what the identity value is.
1.Again, validate allof your instances with QuickCheck.
Example scaÔ¨Äold is provided for the Trivial type.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 951
dataTrivial =Trivial deriving (Eq,Show)
instance Semigroup Trivial where
(&lt;&gt;)=undefined
instance MonoidTrivial where
mempty=undefined
mappend =(&lt;&gt;)
typeTrivAssoc =
Trivial -&gt;Trivial -&gt;Trivial -&gt;Bool
main::IO()
main= do
letsa=semigroupAssoc
mli=monoidLeftIdentity
mlr=monoidRightIdentity
quickCheck (sa ::TrivAssoc )
quickCheck (mli ::Trivial -&gt;Bool)
quickCheck (mlr ::Trivial -&gt;Bool)
2.newtype Identity a=
Identity aderiving Show
3.dataTwoa b=Twoa bderiving Show</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 952
4.newtype BoolConj =
BoolConj Bool
What it should do:
Prelude&gt; (BoolConj True) <code>mappend</code> mempty
BoolConj True
Prelude&gt; mempty <code>mappend</code> (BoolConj False)
BoolConj False
5.newtype BoolDisj =
BoolDisj Bool
What it should do:
Prelude&gt; (BoolDisj True) <code>mappend</code> mempty
BoolDisj True
Prelude&gt; mempty <code>mappend</code> (BoolDisj False)
BoolDisj False
6.newtype Combine a b=
Combine { unCombine ::(a-&gt;b) }
What it should do:
Prelude&gt; let f = Combine $ \n -&gt; Sum (n + 1)
Prelude&gt; unCombine (mappend f mempty) $ 1
Sum {getSum = 2}</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 953
7.Hint: We can do something that seems a little more spe-
cific and natural to functions now that the input and out-
put types are the same.
newtype Compa=
Comp(a-&gt;a)
8.This next exercise will involve doing something that will
feel a bit unnatural still and you may find it difficult. If you
get it and you haven‚Äôt done much FP or Haskell before,
get yourself a nice beverage. We‚Äôre going to toss you
the instance declaration so you don‚Äôt churn on a missing
Monoid constraint you didn‚Äôt know you needed.
newtype Mems a=
Mem{
runMem::s-&gt;(a,s)
}
instance Monoida=&gt;Monoid(Mems a)where
mempty=undefined
mappend =undefined
Given the following code:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 954
f'=Mem$\s-&gt;(&quot;hi&quot;, s+1)
main= do
letrmzero=runMem mempty 0
rmleft=runMem (f' &lt;&gt;mempty) 0
rmright =runMem (mempty &lt;&gt;f')0
print$rmleft
print$rmright
print$(rmzero ::(String,Int))
print$rmleft==runMem f' 0
print$rmright ==runMem f' 0
A correct Monoid forMemshould, given the above code, get
the following output:
Prelude&gt; main
(&quot;hi&quot;,1)
(&quot;hi&quot;,1)
(&quot;&quot;,0)
True
True
Make certain your instance has output like the above, this
is sanity-checking the Monoid identity laws for you! It‚Äôs not
a proof and it‚Äôs not even as good as property testing, but
it‚Äôll catch the most common mistakes people make.</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 955
It‚Äôs not a trick and you don‚Äôt need a Monoid forùë†. Yes, such
aMonoid can and does exist. Hint: chain the ùë†values from
one function to the other. You‚Äôll want to check the identity
laws as a common first attempt will break them.
15.16 Definitions
1.Amonoid is a set that is closed under an associative binary
operation and has an identity element. Closed is the posh
mathematical way of saying its type is:
mappend ::m-&gt;m-&gt;m
Such that your arguments and output will always inhabit
the same type (set).
2.Asemigroup is a set that is closed under an associative
binary operation ‚Äî and nothing else.
3.Laws are rules about how an algebra or structure should
behave. These are needed in part to make abstraction over
the commonalities of diÔ¨Äerent instantiations of the same
sort of algebra possible and practical . This is critical to
having abstractions which aren‚Äôt unpleasantly surprising.
4.Analgebra is variously:</p>
<p>CHAPTER 15. MONOID, SEMIGROUP 956
a)School algebra, such as that taught in primary and
secondary school. This usually entails the balancing
of polynomial equations and learning how functions
and graphs work.
b)The study of number systems and operations within
them. This will typically entail a particular area such
as groups or rings. This is what mathematicians com-
monly mean by ‚Äúalgebra.‚Äù This is sometimes disam-
biguated by being referred to as abstract algebra.
c)A third and final way algebra is used is to refer to a
vector space over a field with a multiplication.
When Haskellers refer to algebras, they‚Äôre usually talking
about a somewhat informal notion of operations over
a type and its laws, such as with semigroups, monoids,
groups, semirings, and rings.
15.17 Follow-up resources
1.Algebraic structure; Simple English Wikipedia
2.Haskell Monoids and Their Uses; Dan Piponi</p>
<p>Chapter 16
Functor
Lifting is the ‚Äùcheat
mode‚Äù of type tetris.
Michael Neale
957</p>
<p>CHAPTER 16. FUNCTOR 958
16.1 Functor
In the last chapter on Monoid , we saw what it means to talk about
an algebra and turn that into a typeclass. This chapter and
the two that follow, on Applicative andMonad, will be similar.
Each of these algebras is more powerful than the last, but the
general concept here will remain the same: we abstract out
a common pattern, make certain it follows some laws, give it
an awesome name, and wonder how we ever lived without it.
Monadsort of steals the Haskell spotlight, but you can do more
withFunctor andApplicative than many people realize. Also,
understanding Functor andApplicative is important to a deep
understanding of Monad.
This chapter is all about Functor , andFunctor is all about a
pattern of mapping over structure. We saw fmapway back in
the chapter on lists and noted that it worked just the same as
map, but we alsosaid back then that the diÔ¨Äerence is that you
can use fmapwith structures that aren‚Äôt lists . Now we will begin
to see what that means.
The great logician Rudolf Carnap appears to have been the
first person to use the word functor in the 1930s. He invented
the word to describe grammatical function words and logical
operations over sentences or phrases. Functors are combina-
tors: they take a sentence or phrase as input and produce a
sentence or phrase as an output, with some logical operation
applied to the whole. For example, negation is a functor in</p>
<p>CHAPTER 16. FUNCTOR 959
this sense because when negation is applied to a sentence, ùê¥,
it produces the negated version, ¬¨ùê¥, as an output. It lifts the
concept of negation over the entire sentence or phrase struc-
ture without changing the internal structure. (Yes, in English
the negation word often appears inside the sentence, not on
the outside, but he was a logician and unconcerned with how
normal humans produced such pedestrian things as spoken
sentences. In logic, the negation operator is typically written
as a prefix, as above.)
This chapter will include:
‚Ä¢the return of the higher-kinded types;
‚Ä¢fmaps galore, and not only on lists;
‚Ä¢no more digressions about dusty logicians;
‚Ä¢words about typeclasses and constructor classes;
‚Ä¢puns based on George Clinton music, probably.
16.2 What‚Äôs a functor?
A functor is a way to apply a function over or around some
structure that we don‚Äôt want to alter. That is, we want to apply
the function to the value that is ‚Äúinside‚Äù some structure and
leave the structure alone. That‚Äôs why it is most common to
introduce functor by way of fmapping over lists, as we did</p>
<p>CHAPTER 16. FUNCTOR 960
back in the lists chapter. The function gets applied to each
value inside the list, and the list structure remains. A good way
to relate ‚Äúnot altering the structure‚Äù to lists is that the length
of the list after mapping a function over it will always be the
same. No elements are removed or added, only transformed.
The typeclass Functor generalizes this pattern so that we can
use that basic idea with many types of structure, not just lists.
Functor is implemented in Haskell with a typeclass, just like
Monoid . Other means of implementing it are possible, but this
is the most convenient way to do so. The definition of the
Functor typeclass looks like this:
classFunctor fwhere
fmap::(a-&gt;b)-&gt;f a-&gt;f b
Now let‚Äôs dissect this a bit:
classFunctor fwhere
[1] [2] [3] [4]
fmap::(a-&gt;b)-&gt;f a-&gt;f b
[5] [ 6] [ 7] [8]
1.classis the keyword to begin the definition of a typeclass.
2.Functor is the name of the typeclass we are defining.</p>
<p>CHAPTER 16. FUNCTOR 961
3.Typeclasses in Haskell usually refer to a type. The letters
themselves, as with type variables in type signatures, do
not mean anything special. ùëìis a conventional letter to
choose when referring to types that have functorial struc-
ture. The ùëìmust be the same ùëìthroughout the typeclass
definition.
4.Thewherekeyword ends the declaration of the typeclass
name and associated types. After the wherethe operations
provided by the typeclass are listed.
5.We begin the declaration of an operation named fmap.
6.The argument a -&gt; b is any Haskell function of that type
(remembering that it could be an (a -&gt; a) function for
this purpose).
7.The argument f ais aFunctorùëìthat takes a type argument
ùëé. That is, the ùëìis a type that has an instance of the Functor
typeclass.
8.The return value is f b. It is the sameùëìfromf a, while
the type argument ùëèpossibly but not necessarily refers to a
diÔ¨Äerent type.
Before we delve into the details of how this typeclass works,
let‚Äôs see fmapin action so you get a feel for what‚Äôs going on first.</p>
<p>CHAPTER 16. FUNCTOR 962
16.3 There‚Äôs a whole lot of fmapgoin‚Äô
round
We have seen fmapbefore but we haven‚Äôt used it much except
for with lists. With lists, it seems to do the same thing as map:
Prelude&gt; map (\x -&gt; x &gt; 3) [1..6]
[False,False,False,True,True,True]
Prelude&gt; fmap (\x -&gt; x &gt; 3) [1..6]
[False,False,False,True,True,True]
Listis, of course, one type that implements the typeclass
Functor , but it seems unremarkable when it just does the same
thing as map. However, Listisn‚Äôt the only type that implements
Functor , andfmapcan apply a function over or around any of
those functorial structures, while mapcannot:
Prelude&gt; map (+1) (Just 1)
Couldn't match expected type ‚Äò[b]‚Äô
with actual type ‚ÄòMaybe a0‚Äô
Relevant bindings include
it :: [b] (bound at 16:1)
In the second argument of ‚Äòmap‚Äô,
namely ‚Äò(Just 1)‚Äô</p>
<p>CHAPTER 16. FUNCTOR 963
In the expression: map (+ 1) (Just 1)
Prelude&gt; fmap (+1) (Just 1)
Just 2
Intriguing! What else?
--with a tuple!
Prelude&gt; fmap (10/) (4, 5)
(4,2.0)
--with Either!
Prelude&gt; let rca = Right &quot;Chris Allen&quot;
Prelude&gt; fmap (++ &quot;, Esq.&quot;) rca
Right &quot;Chris Allen, Esq.&quot;
We can see how the type of fmapspecializes to diÔ¨Äerent
types here:</p>
<p>CHAPTER 16. FUNCTOR 964
typeEe=Eithere
typeCe=Constant e
typeI=Identity
-- Functor f =&gt;
fmap::(a-&gt;b)-&gt;f a-&gt;f b
::(a-&gt;b)-&gt;[ ] a-&gt;[ ] b
::(a-&gt;b)-&gt;Maybea-&gt;Maybeb
::(a-&gt;b)-&gt;Ee a-&gt;Ee b
::(a-&gt;b)-&gt;(e,) a-&gt;(e,) b
::(a-&gt;b)-&gt;Ia-&gt;Ib
::(a-&gt;b)-&gt;Ce a-&gt;Ce b
If you are using GHC 8 or newer, you can also see this for
yourself in your REPL by doing this:
Prelude&gt; :set -XTypeApplications
Prelude&gt; :type fmap @Maybe
fmap @Maybe ::
(a -&gt; b) -&gt; Maybe a -&gt; Maybe b
Prelude&gt; :type fmap @(Either _)
fmap @(Either _) ::
(a -&gt; b) -&gt; Either t a -&gt; Either t b
You may have noticed in the tuple and Either examples that
the first arguments (labeled ùëíin the above chart) are ignored</p>
<p>CHAPTER 16. FUNCTOR 965
byfmap. We‚Äôll talk about why that is in just a bit. Let‚Äôs first turn
our attention to what makes a functor. Later we‚Äôll come back
to longer examples and expand on this considerably.
16.4 Let‚Äôs talk about ùëì, baby
As we said above, the ùëìin the typeclass definition for Functor
must be the same ùëìthroughout the entire definition, and it
must refer to a type that implements the typeclass. This sec-
tion details the practical ramifications of those facts.
The first thing we know is that our ùëìhere must have the kind</p>
<ul>
<li>-&gt; * . We talked about higher-kinded types in previous chap-
ters, and we recall that a type constant or a fully applied type
has the kind *. A type with kind * -&gt; * is awaiting application
to a type constant of kind *.
We know that the ùëìin ourFunctor definition must be kind *
-&gt; *for a couple of reasons, which we will first describe and
then demonstrate:
1.Each argument (and result) in the type signature for a
function must be a fully applied (and inhabitable, modulo
Void, etc.) type. Each argument must have the kind *.
2.The type ùëìwas applied to a single argument in two dif-
ferent places: f aandf b. Since f aandf bmust each
have the kind *,ùëìby itself must be kind * -&gt; * .</li>
</ul>
<p>CHAPTER 16. FUNCTOR 966
It‚Äôs easier to see what these mean in practice by demonstrat-
ing with lots of code, so let‚Äôs tear the roof oÔ¨Ä this sucker.
Shining star come into view
Every argument to the type constructor of -&gt;must be of kind
*. We can verify this simply by querying kind of the function
type constructor for ourselves:
Prelude&gt; :k (-&gt;)
(-&gt;) :: * -&gt; * -&gt; *
Each argument and result of every function must be a type
constant, not a type constructor. Given that knowledge, we
can know something about Functor from the type of fmap:
classFunctor fwhere
fmap::(a-&gt;b)-&gt;f a-&gt;f b
--has kind: * -&gt; * -&gt; *
The type signature of fmaptells us that the ùëìintroduced
by the class definition for Functor mustaccept a single type
argument and thus be of kind * -&gt; *. We can determine this
even without knowing anything about the typeclass, which
we‚Äôll demonstrate with some meaningless typeclasses:</p>
<p>CHAPTER 16. FUNCTOR 967
classSumthin awhere
s::a-&gt;a
classElsewhere
e::b-&gt;f (g a b c)
classBiffywhere
slayer::e a b
-&gt;(a-&gt;c)
-&gt;(b-&gt;d)
-&gt;e c d
Let‚Äôs deconstruct the previous couple of examples:
classSumthin awhere
s::a-&gt;a
-- [1] [1]
1.The argument and result type are both ùëé. There‚Äôs nothing
else, so ùëéhas kind *.
classElsewhere
e::b-&gt;f (g a b c)
-- [1] [2] [3]
1.Thisùëè, likeùëéin the previous example, stands alone as the
first argument to (-&gt;), so it is kind *.</p>
<p>CHAPTER 16. FUNCTOR 968
2.Hereùëìis the outermost type constructor for the second
argument (the result type) of (-&gt;). It takes a single argu-
ment, the type g a b c wrapped in parentheses. Thus, ùëì
has kind * -&gt; * .
3.Andùëîis applied to three arguments ùëé,ùëè, andùëê. That means
it is kind * -&gt; * -&gt; * -&gt; * , where:
-- using :: to denote kind signature
g:: * -&gt; * -&gt; * -&gt; *
-- a, b, and c are each kind *
g:: * -&gt; * -&gt; * -&gt; *
ga b c (g a b c)
classBiffywhere
slayer::e a b
-- [1]
-&gt;(a-&gt;c)
-- [2] [3]
-&gt;(b-&gt;d)
-&gt;e c d
1.First,ùëíis an argument to (-&gt;)so the application of its
arguments must result in kind *. Given that, and knowing</p>
<p>CHAPTER 16. FUNCTOR 969
there are two arguments, ùëéandùëè, we can determine ùëíis
kind* -&gt; * -&gt; * .
2.Thisùëéis an argument to a function that takes no argu-
ments itself, so it‚Äôs kind *
3.The story for ùëêis identical to ùëé, just in another spot of the
same function.
The kind checker is going to fail on the next couple of
examples:
classImpishvwhere
impossibleKind ::v-&gt;v a
classAlsoImp vwhere
nope::v a-&gt;v
Remember that the name of the variable before the where
in a typeclass definition binds the occurrences of that name
throughout the definition. GHC will notice that our ùë£some-
times has a type argument and sometimes not, and it will call
our bluÔ¨Ä if we attempt to feed it this nonsense:
‚Äòv‚Äô is applied to too many type arguments
In the type ‚Äòv -&gt; v a‚Äô
In the class declaration for ‚ÄòImpish‚Äô</p>
<p>CHAPTER 16. FUNCTOR 970
Expecting one more argument to ‚Äòv‚Äô
Expected a type, but ‚Äòv‚Äô has kind ‚Äòk0 -&gt; *‚Äô
In the type ‚Äòv a -&gt; v‚Äô
In the class declaration for ‚ÄòAlsoImp‚Äô
Just as GHC has type inference, it also has kind inference.
And just as it does with types, it can not only infer the kinds
but also validate that they‚Äôre consistent and make sense.
Exercises: Be Kind
Given a type signature, determine the kinds of each type vari-
able:
1.What‚Äôs the kind of ùëé?
a-&gt;a
2.What are the kinds of ùëèandùëá? (Theùëáis capitalized on
purpose!)
a-&gt;b a-&gt;T(b a)
3.What‚Äôs the kind of ùëê?
ca b-&gt;c b a</p>
<p>CHAPTER 16. FUNCTOR 971
A shining star for you to see
So, what if our type isn‚Äôt higher kinded? Let‚Äôs try it with a type
constant and see what happens:
-- functors1.hs
dataFixMePls =
FixMe
|Pls
deriving (Eq,Show)
instance Functor FixMePls where
fmap=
error
&quot;it doesn't matter, it won't compile&quot;
Notice there are no type arguments anywhere ‚Äî everything
is one shining (kind) star! And if we load this file from GHCi,
we‚Äôll get the following error:
Prelude&gt; :l functors1.hs
[1 of 1] Compiling Main
( functors1.hs, interpreted )
functors1.hs:8:18:
The first argument of ‚ÄòFunctor‚Äô</p>
<p>CHAPTER 16. FUNCTOR 972
should have kind ‚Äò* -&gt; <em>‚Äô,
but ‚ÄòFixMePls‚Äô has kind ‚Äò</em>‚Äô
In the instance declaration for
‚ÄòFunctor FixMePls‚Äô
Failed, modules loaded: none.
In fact, asking for a Functor forFixMePls doesn‚Äôt really make
sense. To see why this doesn‚Äôt make sense, consider the types
involved:
-- Functor is:
fmap::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
-- If we replace f with FixMePls
(a-&gt;b)-&gt;FixMePls a-&gt;FixMePls b
-- But FixMePls doesn't take
-- type arguments, so this is
-- really more like:
(FixMePls -&gt;FixMePls )
-&gt;FixMePls
-&gt;FixMePls
There‚Äôs no type constructor ùëìin there! The maximally
polymorphic version of this is:
(a-&gt;b)-&gt;a-&gt;b</p>
<p>CHAPTER 16. FUNCTOR 973
So in fact, not having a type argument means this is:
($)::(a-&gt;b)-&gt;a-&gt;b
Without a type argument, this is mere function application.
Functor is function application
We just saw how trying to make a Functor instance for a type
constant means you have function application. But, in fact,
fmapis a specific sort of function application. Let‚Äôs look at the
types:
fmap::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
There is also an infix operator for fmap. If you‚Äôre using an
older version of GHC, you may need to import Data.Functor
in order to use it in the REPL. Of course, it has the same type
as the prefix fmap:
-- &lt;$&gt; is the infix alias for fmap:
(&lt;$&gt;)::Functor f
=&gt;(a-&gt;b)
-&gt;f a
-&gt;f b
Notice something?</p>
<p>CHAPTER 16. FUNCTOR 974
(&lt;$&gt;)::Functor f
=&gt;(a-&gt;b)-&gt;f a-&gt;f b
($)::(a-&gt;b)-&gt;a-&gt;b
Functor is a typeclass for function application ‚Äúover‚Äù, or
‚Äúthrough‚Äù, some structure fthat we want to ignore and leave
untouched. We‚Äôll explain ‚Äúleave untouched‚Äù in more detail
later when we talk about the Functor laws.
A shining star for you to see what your ùëìcan
truly be
Let‚Äôs resume our exploration of why we need a higher-kinded
ùëì.
If we add a type argument to the datatype from above, we
makeFixMePls into a type constructor, and this will work:</p>
<p>CHAPTER 16. FUNCTOR 975
-- functors2.hs
dataFixMePls a=
FixMe
|Plsa
deriving (Eq,Show)
instance Functor FixMePls where
fmap=
error
&quot;it doesn't matter, it won't compile&quot;
Now it‚Äôll compile!
Prelude&gt; :l code/functors2.hs
[1 of 1] Compiling Main
Ok, modules loaded: Main.
But wait, we don‚Äôt need the error anymore! Let‚Äôs fix that
Functor instance:</p>
<p>CHAPTER 16. FUNCTOR 976
-- functors3.hs
dataFixMePls a=
FixMe
|Plsa
deriving (Eq,Show)
instance Functor FixMePls where
fmap_FixMe=FixMe
fmap f ( Plsa)=Pls(f a)
Let‚Äôs see how our instance lines up with the type of fmap:
fmap::Functor f
=&gt;(a-&gt;b)-&gt;f a-&gt;f b
fmap f ( Plsa)=Pls(f a)
-- (a -&gt; b) f a f b
Whileùëìis used in the type of fmapto represent the Functor ,
by convention, it is also conventionally used in function def-
initions to name an argument that is itself a function. Don‚Äôt let
the names fool you into thinking the ùëìin ourFixMePls instance
is the same ùëìas in the Functor typeclass definition.
Now our code is happy-making!
Prelude&gt; :l code/functors3.hs</p>
<p>CHAPTER 16. FUNCTOR 977
[1 of 1] Compiling Main
Ok, modules loaded: Main.
Prelude&gt; fmap (+1) (Pls 1)
Pls 2
Notice the function gets applied over and inside of the
structure. This is how Haskell coders lift big heavy functions
over abstract structure!
Okay, let‚Äôs make another mistake for the sake of being ex-
plicit. What if we change the type of our Functor instance from
FixMePls toFixMePls a ?
-- functors4.hs
dataFixMePls a=
FixMe
|Plsa
deriving (Eq,Show)
instance Functor (FixMePls a)where
fmap_FixMe=FixMe
fmap f ( Plsa)=Pls(f a)
Notice we didn‚Äôt change the type; it still only takes one
argument. But now that argument is part of the ùëìstructure. If
we load this ill-conceived code:</p>
<p>CHAPTER 16. FUNCTOR 978
Prelude&gt; :l functors4.hs
[1 of 1] Compiling Main
functors4.hs:8:19:
The first argument of ‚ÄòFunctor‚Äô
should have kind ‚Äò* -&gt; <em>‚Äô,
but ‚ÄòFixMePls a‚Äô has kind ‚Äò</em>‚Äô
In the instance declaration for
‚ÄòFunctor (FixMePls a)‚Äô
Failed, modules loaded: none.
We get the same error as earlier, because applying the type
constructor gave us something of kind <em>from the original kind
of</em> -&gt; * .
Typeclasses and constructor classes
You may have initially paused on the type constructor ùëìin
the definition of Functor having kind * -&gt; * ‚Äî this is quite
natural! In fact, earlier versions of Haskell didn‚Äôt have a facility
for expressing typeclasses in terms of higher-kinded types
at all. This was developed by Mark P. Jones1while he was
working on an implementation of Haskell called Gofer. This
work generalized typeclasses from being usable only with
types of kind *(also called type constants ) to being usable with</p>
<p>CHAPTER 16. FUNCTOR 979
higher-kinded types, called type constructors , as well.
In Haskell, the two use cases have been merged such that
we don‚Äôt call out constructor classes as being separate from
typeclasses, but we think it‚Äôs useful to highlight that something
significant has happened here. Now we have a means of talking
about the contents of types independently from the type that
structures those contents. That‚Äôs why we can have something
likefmapthat allows us to alter the contents of a value without
altering the structure (a list, or a Just) around the value.
16.5 Functor Laws
Instances of the Functor typeclass should abide by two basic
laws. Understanding these laws is critical for understanding
Functor and writing typeclass instances that are composable
and easy to reason about.
Identity
The first law is the law of identity:
fmapid==id
If wefmapthe identity function, it should have the same
result as passing our value to identity. We shouldn‚Äôt be chang-
1A system of constructor classes: overloading and implicit higher-order polymor-
phism
http://www.cs.tufts.edu/~nr/cs257/archive/mark-jones/fpca93.pdf</p>
<p>CHAPTER 16. FUNCTOR 980
ing any of the outer structure ùëìthat we‚Äôre mapping over by
mapping id. That‚Äôs why it‚Äôs the same as id. If we didn‚Äôt return
a new value in the a -&gt; b function mapped over the structure,
then nothing should‚Äôve changed:
Prelude&gt; fmap id &quot;Hi Julie&quot;
&quot;Hi Julie&quot;
Prelude&gt; id &quot;Hi Julie&quot;
&quot;Hi Julie&quot;
Try it out on a few diÔ¨Äerent structures and check for your-
self.
Composition
The second law for Functor is the law of composition:
fmap(f.g)==fmap f.fmap g
This concerns the composability of fmap. If we compose
two functions, ùëìandùëî, andfmapthat over some structure, we
should get the same result as if we fmapped them and then
composed them:
Prelude&gt; fmap ((+1) . (*2)) [1..5]
[3,5,7,9,11]
Prelude&gt; fmap (+1) . fmap (*2) $ [1..5]
[3,5,7,9,11]</p>
<p>CHAPTER 16. FUNCTOR 981
If an implementation of fmapdoesn‚Äôt do that, it‚Äôs a broken
functor.
Structure preservation
Both of these laws touch on the essential rule that functors
must be structure preserving.
All we‚Äôre allowed to know in the type about our instance of
Functor implemented by ùëìis that it implements Functor :
fmap::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
Theùëìis constrained by the typeclass Functor , but that is all
we know about its type from this definition. As we‚Äôve seen with
typeclass-constrained polymorphism, this still allows it to be
any type that has an instance of Functor . The core operation
that this typeclass provides for these types is fmap. Because the
ùëìpersists through the type of fmap, whatever the type is, we
know it must be a type that can take an argument, as in f aand
f band that it will be the ‚Äústructure‚Äù we‚Äôre lifting the function
over when we apply it to the value inside.
16.6 The Good, the Bad, and the Ugly
We‚Äôll get a better picture of what it means for Functor instances
to be law-abiding or law-breaking by walking through some</p>
<p>CHAPTER 16. FUNCTOR 982
examples. We start by definining a type constructor with one
argument:
dataWhoCares a=
ItDoesnt
|Mattera
|WhatThisIsCalled
deriving (Eq,Show)
This datatype only has one data constructor containing a
value we could fmapover, and that is Matter. The others are
nullary so there is no value to work with inside the structure;
there is only structure.
Here we see a law-abiding instance:
instance Functor WhoCares where
fmap_ItDoesnt =ItDoesnt
fmap_WhatThisIsCalled =
WhatThisIsCalled
fmap f ( Mattera)=Matter(f a)
Our instance must follow the identity law or else it‚Äôs not a
valid functor. That law dictates that fmap id (Matter _) must
nottouchMatter ‚Äî that is, it must be identical to id (Matter _) .
Functor is a way of lifting over structure (mapping) in such a
manner that you don‚Äôt have to care about the structure because
you‚Äôre not allowed to touch the structure anyway.</p>
<p>CHAPTER 16. FUNCTOR 983
Let us next consider a law-breaking instance:
instance Functor WhoCares where
fmap_ItDoesnt =WhatThisIsCalled
fmap fWhatThisIsCalled =ItDoesnt
fmap f ( Mattera)=Matter(f a)
Nowwecontemplatewhatitmeanstoleavethestructureun-
touched. In this instance, we‚Äôve made our structure ‚Äî not the
values wrapped or contained within the structure ‚Äî change
by making ItDoesnt andWhatThisIsCalled do a little dosey-do.
It becomes rapidly apparent why this isn‚Äôt kosher at all.
Prelude&gt; fmap id ItDoesnt
WhatThisIsCalled
Prelude&gt; fmap id WhatThisIsCalled
ItDoesnt
Prelude&gt; fmap id ItDoesnt == id ItDoesnt
False
Prelude&gt; :{
*Main| fmap id WhatThisIsCalled ==
*Main| id WhatThisIsCalled
*Main| :}
False
This certainly does not abide by the identity law. It is not a
validFunctor instance.</p>
<p>CHAPTER 16. FUNCTOR 984
The law won But what if you dowant a function that can
change the value andthe structure?
We‚Äôve got wonderful news for you: that exists! It‚Äôs a plain
old function. Write one. Write many! The point of Functor is
to reify and be able to talk about cases where we want to reuse
functions in the presence of more structure and be transpar-
entlyoblivious to that additional structure. We already saw that
Functor is in some sense a special sort of function application,
but since it is special , we want to preserve the things about
it that make it diÔ¨Äerent and more powerful than ordinary
function application. So, we stick to the laws.
Later in this chapter, we will talk about a sort of opposite,
where you can transform the structure but leave the type ar-
gument alone. This has a special name too, but there isn‚Äôt a
widely agreed upon typeclass.
Composition should just work
All right, now that we‚Äôve seen how we can make a Functor in-
stance violate the identity law, let‚Äôs take a look at how we abide
by ‚Äî and break! ‚Äî the composition law. You may recall from
above that the law looks like this:
fmap (f . g) == fmap f . fmap g
Technically this follows from fmap id == id , but it‚Äôs worth
calling out so that we can talk about composition. This law</p>
<p>CHAPTER 16. FUNCTOR 985
says composing two functions lifted separately should pro-
duce the same result as if we composed the functions ahead
of time and then lifted the composed function all together.
Maintaining this property is about preserving composability
of our code and preventing our software from doing unpleas-
antly surprising things. We will now consider another invalid
Functor instance to see why this is bad news:
dataCountingBad a=
Heisenberg Inta
deriving (Eq,Show)
-- super NOT okay
instance Functor CountingBad where
fmap f ( Heisenberg n a)=
-- (a -&gt; b) f a =
Heisenberg (n+1) (f a)
-- f b
Well, what did we do here? CountingBad has one type argu-
ment, but Heisenberg has two arguments. If you look at how
that lines up with the type of fmap, you get a hint of why this
isn‚Äôt going to work out well. What part of our fmaptype does
theùëõrepresenting the Intargument to Heisenberg belong to?
We can load this horribleness up in the REPL and see that
composing two fmaps here does not produce the same results,</p>
<p>CHAPTER 16. FUNCTOR 986
so the composition law doesn‚Äôt hold:
Prelude&gt; let u = &quot;Uncle&quot;
Prelude&gt; let oneWhoKnocks = Heisenberg 0 u
Prelude&gt; fmap (++&quot; Jesse&quot;) oneWhoKnocks
Heisenberg 1 &quot;Uncle Jesse&quot;
Prelude&gt; let f = ((++&quot; Jesse&quot;).(++&quot; lol&quot;))
Prelude&gt; fmap f oneWhoKnocks
Heisenberg 1 &quot;Uncle lol Jesse&quot;
So far it seems OK, but what if we compose the two con-
catenation functions separately?
Prelude&gt; let j = (++ &quot; Jesse&quot;)
Prelude&gt; let l = (++ &quot; lol&quot;)
Prelude&gt; fmap j . fmap l $ oneWhoKnocks
Heisenberg 2 &quot;Uncle lol Jesse&quot;
Or to make it look more like the law:
Prelude&gt; let f = (++&quot; Jesse&quot;)
Prelude&gt; let g = (++&quot; lol&quot;)
Prelude&gt; fmap (f . g) oneWhoKnocks
Heisenberg 1 &quot;Uncle lol Jesse&quot;
Prelude&gt; fmap f . fmap g $ oneWhoKnocks
Heisenberg 2 &quot;Uncle lol Jesse&quot;
We can clearly see that</p>
<p>CHAPTER 16. FUNCTOR 987
fmap (f . g) == fmap f . fmap g
does not hold. So how do we fix it?
dataCountingGood a=
Heisenberg Inta
deriving (Eq,Show)
-- Totes cool.
instance Functor CountingGood where
fmap f ( Heisenberg n a)=
Heisenberg (n) (f a)
Stop messing with the IntinHeisenberg . Think of anything
that isn‚Äôt the final type argument of our ùëìinFunctor as being
part of the structure that the functions being lifted should be
oblivious to.
16.7 Commonly used functors
Now that we have a sense of what Functor does for us and
how it‚Äôs meant to work, it‚Äôs time to start working through
some longer examples. This section is nearly all code and
examples with minimal prose explanation. Interacting with
these examples will help you develop an intuition for what‚Äôs
going on with a minimum of fuss.
We begin with a utility function:</p>
<p>CHAPTER 16. FUNCTOR 988
Prelude&gt; :t const
const :: a -&gt; b -&gt; a
Prelude&gt; let replaceWithP = const 'p'
Prelude&gt; replaceWithP 10000
'p'
Prelude&gt; replaceWithP &quot;woohoo&quot;
'p'
Prelude&gt; replaceWithP (Just 10)
'p'
We‚Äôll use it with fmapnow for various datatypes that have
instances:
-- data Maybe a = Nothing | Just a
Prelude&gt; fmap replaceWithP (Just 10)
Just 'p'
Prelude&gt; fmap replaceWithP Nothing
Nothing
-- data [] a = [] | a : [a]
Prelude&gt; fmap replaceWithP [1, 2, 3, 4, 5]
&quot;ppppp&quot;
Prelude&gt; fmap replaceWithP &quot;Ave&quot;
&quot;ppp&quot;</p>
<p>CHAPTER 16. FUNCTOR 989
Prelude&gt; fmap (+1) []
[]
Prelude&gt; fmap replaceWithP []
&quot;&quot;
-- data (,) a b = (,) a b
Prelude&gt; fmap replaceWithP (10, 20)
(10,'p')
Prelude&gt; fmap replaceWithP (10, &quot;woo&quot;)
(10,'p')
Again, we‚Äôll talk about why it skips the first value in the
tuple in a bit. It has to do with the kindedness of tuples and
the kindedness of the ùëìinFunctor .
Now the instance for functions:
Prelude&gt; negate 10
-10
Prelude&gt; let tossEmOne = fmap (+1) negate
Prelude&gt; tossEmOne 10
-9
Prelude&gt; tossEmOne (-10)
11
The functor of functions won‚Äôt be discussed in great detail
until we get to the chapter on Reader, but it should look sort
of familiar:</p>
<p>CHAPTER 16. FUNCTOR 990
Prelude&gt; let tossEmOne' = (+1) . negate
Prelude&gt; tossEmOne' 10
-9
Prelude&gt; tossEmOne' (-10)
11
Now you‚Äôre starting to get into the groove; let‚Äôs see what
else we can do with our fancy new moves.
The functors are stacked and that‚Äôs a fact
We can combine datatypes, as we‚Äôve seen, usually by nesting
them. We‚Äôll be using the tilde character as a shorthand for ‚Äúis
roughly equivalent to‚Äù throughout these examples:
-- lms ~ List (Maybe (String))
Prelude&gt; let n = Nothing
Prelude&gt; let w = Just &quot;woohoo&quot;
Prelude&gt; let ave = Just &quot;Ave&quot;
Prelude&gt; let lms = [ave, n, w]
Prelude&gt; let replaceWithP = const 'p'
Prelude&gt; replaceWithP lms
'p'
Prelude&gt; fmap replaceWithP lms
&quot;ppp&quot;</p>
<p>CHAPTER 16. FUNCTOR 991
Nothing unexpected there, but we notice that lmshas more
than one Functor type.Maybeand List (which includes String)
both have Functor instances. So, are we obligated to fmaponly
to the outermost datatype? No way, mate:
Prelude&gt; (fmap . fmap) replaceWithP lms
[Just 'p',Nothing,Just 'p']
Prelude&gt; let tripFmap = fmap . fmap . fmap
Prelude&gt; tripFmap replaceWithP lms
[Just &quot;ppp&quot;,Nothing,Just &quot;pppppp&quot;]
Let‚Äôs review in detail:
-- lms ~ List (Maybe String)
Prelude&gt; let ave = Just &quot;Ave&quot;
Prelude&gt; let n = Nothing
Prelude&gt; let w = Just &quot;woohoo&quot;
Prelude&gt; let lms = [ave, n, w]
Prelude&gt; replaceWithP lms
'p'
Prelude&gt; :t replaceWithP lms
replaceWithP lms :: Char
-- In:</p>
<p>CHAPTER 16. FUNCTOR 992
replaceWithP lms
-- replaceWithP's input type is:
List (Maybe String)
-- The output type is Char
-- So applying
replaceWithP
-- to
lms
-- accomplishes
List (Maybe String) -&gt; Char
The output type of replaceWithP is always the same.
If we do this:
Prelude&gt; fmap replaceWithP lms
&quot;ppp&quot;
-- fmap is going to leave the list
-- structure intact around our result:
Prelude&gt; :t fmap replaceWithP lms
fmap replaceWithP lms :: [Char]</p>
<p>CHAPTER 16. FUNCTOR 993
Here‚Äôs the X-ray view:
-- In:
fmap replaceWithP lms
-- replaceWithP's input type is:
Maybe String
-- The output type is Char
-- So applying
fmap replaceWithP
-- to
lms
-- accomplishes:
List (Maybe String) -&gt; List Char
-- List Char ~ String
What if we lift twice?
Keep on stacking them up:
Prelude&gt; (fmap . fmap) replaceWithP lms
[Just 'p',Nothing,Just 'p']</p>
<p>CHAPTER 16. FUNCTOR 994
Prelude&gt; :t (fmap . fmap) replaceWithP lms
(fmap . fmap) replaceWithP lms
:: [Maybe Char]
And the X-ray view:
-- In:
(fmap . fmap) replaceWithP lms
-- replaceWithP's input type is:
-- String aka List Char or [Char]
-- The output type is Char
-- So applying
(fmap . fmap) replaceWithP
-- to
lms
-- accomplishes
List (Maybe String) -&gt; List (Maybe Char)
Wait, how does that even typecheck? It may not seem obvi-
ous at first how (fmap . fmap) could typecheck. We‚Äôre going to</p>
<p>CHAPTER 16. FUNCTOR 995
ask you to work through the types. You might prefer to write
it out with pen and paper, as Julie does, or type it all out in a
text editor, as Chris does. We‚Äôll help you out by providing the
type signatures. Since the two fmapfunctions being composed
could have diÔ¨Äerent types, we‚Äôll make the type variables for
each function unique. Start by substituting the type of each
fmapfor each of the function types in the (.)signature:
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
-- fmap fmap
fmap::Functor f=&gt;(m-&gt;n)-&gt;f m-&gt;f n
fmap::Functor g=&gt;(x-&gt;y)-&gt;g x-&gt;g y
It might also be helpful to query the type of (fmap . fmap)
to get an idea of what your end type should look like (modulo
diÔ¨Äerent type variables).
Lift me baby one more time
We have another layer we can lift over if we wish:
Prelude&gt; let tripFmap = fmap . fmap . fmap
Prelude&gt; tripFmap replaceWithP lms
[Just &quot;ppp&quot;,Nothing,Just &quot;pppppp&quot;]
Prelude&gt; :t tripFmap replaceWithP lms
(fmap . fmap . fmap) replaceWithP lms</p>
<p>CHAPTER 16. FUNCTOR 996
:: [Maybe [Char]]
And the X-ray view:
-- In
(fmap . fmap . fmap) replaceWithP lms
-- replaceWithP's input type is:
-- Char
-- because we lifted over
-- the [] of [Char]
-- The output type is Char
-- So applying
(fmap . fmap . fmap) replaceWithP
-- to
lms
-- accomplishes
List (Maybe String) -&gt; List (Maybe String)
So, we see there‚Äôs a pattern.</p>
<p>CHAPTER 16. FUNCTOR 997
The real type of thing going down
We saw the pattern above, but for clarity we‚Äôll summarize here
before moving on:
Prelude&gt; fmap replaceWithP lms
&quot;ppp&quot;
Prelude&gt; (fmap . fmap) replaceWithP lms
[Just 'p',Nothing,Just 'p']
Prelude&gt; let tripFmap = fmap . fmap . fmap
Prelude&gt; tripFmap replaceWithP lms
[Just &quot;ppp&quot;,Nothing,Just &quot;pppppp&quot;]
Let‚Äôs summarize the types, too, to validate our understand-
ing:</p>
<p>CHAPTER 16. FUNCTOR 998
-- replacing the type synonym String
-- with the underlying type [Char]
-- intentionally
replaceWithP' ::[Maybe[Char]]-&gt;Char
replaceWithP' =replaceWithP
[Maybe[Char]]-&gt;[Char]
[Maybe[Char]]-&gt;[MaybeChar]
[Maybe[Char]]-&gt;[Maybe[Char]]
Pause for a second and make sure you‚Äôre understanding
everything we‚Äôve done so far. If not, play with it until it starts
to feel comfortable.
Get on up and get down
We‚Äôll work through the same idea, but with more funky struc-
ture to lift over:
-- lmls ~ List (Maybe (List String))
Prelude&gt; let ha = Just [&quot;Ha&quot;, &quot;Ha&quot;]
Prelude&gt; let lmls = [ha, Nothing, Just []]
Prelude&gt; (fmap . fmap) replaceWithP lmls
[Just 'p',Nothing,Just 'p']</p>
<p>CHAPTER 16. FUNCTOR 999
Prelude&gt; let tripFmap = fmap . fmap . fmap
Prelude&gt; tripFmap replaceWithP lmls
[Just &quot;pp&quot;,Nothing,Just &quot;&quot;]
Prelude&gt; (tripFmap.fmap) replaceWithP lmls
[Just [&quot;pp&quot;,&quot;pp&quot;],Nothing,Just []]
See if you can trace the changing result types as we did
above.
One more round for the P-Funkshun
For those who like their funk uncut, here‚Äôs another look at the
changing types that result from lifting over multiple layers of
functorial structure, with a slightly higher resolution. We start
this time from a source file:</p>
<p>CHAPTER 16. FUNCTOR 1000
moduleReplaceExperiment where
replaceWithP ::b-&gt;Char
replaceWithP =const'p'
lms::[Maybe[Char]]
lms=[Just&quot;Ave&quot;,Nothing,Just&quot;woohoo&quot; ]
-- Just making the argument more specific
replaceWithP' ::[Maybe[Char]]-&gt;Char
replaceWithP' =replaceWithP
What happens if we lift it?
-- Prelude&gt; :t fmap replaceWithP
-- fmap replaceWithP :: Functor f
-- =&gt; f a -&gt; f Char
liftedReplace ::Functor f=&gt;f a-&gt;fChar
liftedReplace =fmap replaceWithP
But we can assert a more specific type for liftedReplace !
liftedReplace' ::[Maybe[Char]]-&gt;[Char]
liftedReplace' =liftedReplace</p>
<p>CHAPTER 16. FUNCTOR 1001
The[]around Char is the ùëìoff Char, or the structure we
lifted over. The ùëìoff ais the outermost []in [Maybe [Char]].
So,ùëìis instantiated to []when we make the type more specific,
whether by applying it to a value of type [Maybe [Char]] or by
means of explicitly writing liftedReplace' .
Stay on the scene like an fmapmachine
What if we lift it twice?
-- Prelude&gt; :t (fmap . fmap) replaceWithP
-- (fmap . fmap) replaceWithP
-- :: (Functor f1, Functor f)
-- =&gt; f (f1 a) -&gt; f (f1 Char)
twiceLifted ::(Functor f1,Functor f)=&gt;
f (f1 a) -&gt;f (f1Char)
twiceLifted =(fmap.fmap) replaceWithP
-- Making it more specific
twiceLifted' ::[Maybe[Char]]
-&gt;[MaybeChar]
twiceLifted' =twiceLifted
-- f ~ []
-- f1 ~ Maybe
Thrice?</p>
<p>CHAPTER 16. FUNCTOR 1002
-- Prelude&gt; let rWP = replaceWithP
-- Prelude&gt; :t (fmap . fmap . fmap) rWP
-- (fmap . fmap . fmap) replaceWithP
-- :: (Functor f2, Functor f1, Functor f)
-- =&gt; f (f1 (f2 a)) -&gt; f (f1 (f2 Char))
thriceLifted ::
(Functor f2,Functor f1,Functor f)
=&gt;f (f1 (f2 a)) -&gt;f (f1 (f2 Char))
thriceLifted =
(fmap.fmap.fmap) replaceWithP
-- More specific or &quot;concrete&quot;
thriceLifted' ::[Maybe[Char]]
-&gt;[Maybe[Char]]
thriceLifted' =thriceLifted
-- f ~ []
-- f1 ~ Maybe
-- f2 ~ []
Now we can print the results from our expressions and
compare them:</p>
<p>CHAPTER 16. FUNCTOR 1003
main::IO()
main= do
putStr&quot;replaceWithP' lms: &quot;
print (replaceWithP' lms)
putStr&quot;liftedReplace lms: &quot;
print (liftedReplace lms)
putStr&quot;liftedReplace' lms: &quot;
print (liftedReplace' lms)
putStr&quot;twiceLifted lms: &quot;
print (twiceLifted lms)
putStr&quot;twiceLifted' lms: &quot;
print (twiceLifted' lms)
putStr&quot;thriceLifted lms: &quot;
print (thriceLifted lms)
putStr&quot;thriceLifted' lms: &quot;
print (thriceLifted' lms)
Be sure to type all this into a file, load it in GHCi, run main
to see what output results. Then, modify the types and code-</p>
<p>CHAPTER 16. FUNCTOR 1004
based ideas and guesses of what should and shouldn‚Äôt work.
Forming hypotheses, creating experiments based on them
or modifying existing experiments, and validating them is a
critical part of becoming comfortable with abstractions like
Functor !
Exercises: Heavy Lifting
Addfmap, parentheses, and function composition to the expres-
sion as needed for the expression to typecheck and produce
the expected result. It may not always need to go in the same
place, so don‚Äôt get complacent.
1.a=(+1)$read&quot;[1]&quot;::[Int]
Expected result
Prelude&gt; a
[2]
2.b=(++&quot;lol&quot;) (Just[&quot;Hi,&quot;,&quot;Hello&quot;])
Prelude&gt; b
Just [&quot;Hi,lol&quot;,&quot;Hellolol&quot;]
3.c=(*2) (\x-&gt;x-2)</p>
<p>CHAPTER 16. FUNCTOR 1005
Prelude&gt; c 1
-2
4.d=
((return '1'++).show)
(\x-&gt;[x,1..3])
Prelude&gt; d 0
&quot;1[0,1,2,3]&quot;
5.e::IOInteger
e= letioi=readIO&quot;1&quot;::IOInteger
changed =read (&quot;123&quot;++) show ioi
in(*3) changed
Prelude&gt; e
3693
16.8 Transforming the unapplied type
argument
We‚Äôveseen that ùëìmustbeahigher-kindedtypeandthat Functor
instances must abide by two laws, and we‚Äôve played around
with some basic fmapping. We know that the goal of fmapping
is to leave the outer structure untouched while transforming
the type arguments inside.</p>
<p>CHAPTER 16. FUNCTOR 1006
Way back in the beginning, we noticed that when we fmap
over a tuple, it only transforms the second argument (the ùëè).
We saw a similar thing when we fmapped over an Either value,
and we said we‚Äôd come back to this topic. Then we saw another
hint of it above in the Heisenberg example. Now the time has
come to talk about what happens to the other type arguments
(if any) when we can only tranform the innermost.
We‚Äôll start with a couple of canonical types:
dataTwoa b=
Twoa b
deriving (Eq,Show)
dataOra b=
Firsta
|Secondb
deriving (Eq,Show)
You may recognize these as (,)andEither recapitulated, the
generic product and sum types, from which any combination
ofandandormay be made. But these are both kind * -&gt; *
-&gt; *, which isn‚Äôt compatible with Functor , so how do we write
Functor instances for them?
These wouldn‚Äôt work because TwoandOrhave the wrong
kind:</p>
<p>CHAPTER 16. FUNCTOR 1007
instance Functor Twowhere
fmap=undefined
instance Functor Orwhere
fmap=undefined
We know that we can partially apply functions, and we‚Äôve
seen previously that we can do this:
Prelude&gt; :k Either
Either :: * -&gt; * -&gt; *
Prelude&gt; :k Either Integer
Either Integer :: * -&gt; *
Prelude&gt; :k Either Integer String
Either Integer String :: *
That has the eÔ¨Äect of applying out some of the arguments,
reducing the kindedness of the type. Previously, we‚Äôve demon-
strated this by applying the type constructor to concrete types;
however, you can also apply it to a type variable that represents
a type constant to produce the same eÔ¨Äect.
So to fix the kind incompatibility for our TwoandOrtypes,
we apply one of the arguments of each type constructor, giving
us kind * -&gt; * :</p>
<p>CHAPTER 16. FUNCTOR 1008
-- we use 'a' for clarity, so you
-- can see more readily which type
-- was applied out but the letter
-- doesn't matter.
instance Functor (Twoa)where
fmap=undefined
instance Functor (Ora)where
fmap=undefined
These will pass the typechecker already, but we still need
to write the implementations of fmapfor both, so let‚Äôs proceed.
First we‚Äôll turn our attention to Two:
instance Functor (Twoa)where
fmap f ( Twoa b)=Two$(f a) (f b)
This won‚Äôt fly, because the ùëéis part of the functorial struc-
ture (the ùëì). We‚Äôre not supposed to touch anything in the ùëì
referenced in the type of fmap, so we can‚Äôt apply the function
(named ùëìin ourfmapdefinition) to the ùëébecause the ùëéis now
untouchable.</p>
<p>CHAPTER 16. FUNCTOR 1009
fmap::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
-- here, f is (Two a) because
classFunctor fwhere
fmap::(a-&gt;b)-&gt;f a-&gt;f b
instance Functor (Twoa)where
-- remember, names don't mean
-- anything beyond their relationships
-- to each other.
::(a-&gt;b)-&gt;(Twoz) a-&gt;(Twoz) b
So to fix our Functor instance, we have to leave the left value
(it‚Äôs part of the structure of ùëì) inTwoalone, and have our func-
tion only apply to the innermost value, in this case named
ùëè:
instance Functor (Twoa)where
fmap f ( Twoa b)=Twoa (f b)
Then with Or, we‚Äôre dealing with the independent possibility
of two diÔ¨Äerent values and types, but the same basic constraint
applies:</p>
<p>CHAPTER 16. FUNCTOR 1010
instance Functor (Ora)where
fmap_(Firsta)=Firsta
fmap f ( Secondb)=Second(f b)
We‚Äôve applied out the first argument, so now it‚Äôs part of the
ùëì. The function we‚Äôre mapping around that structure can only
transform the innermost argument.
16.9 QuickChecking Functor instances
We know the Functor laws are the following:
fmapid =id
fmap(p.q)=(fmap p) .(fmap q)
We can turn those into the following QuickCheck properties:</p>
<p>CHAPTER 16. FUNCTOR 1011
functorIdentity ::(Functor f,Eq(f a))=&gt;
f a
-&gt;Bool
functorIdentity f=
fmap id f ==f
functorCompose ::(Eq(f c),Functor f)=&gt;
(a-&gt;b)
-&gt;(b-&gt;c)
-&gt;f a
-&gt;Bool
functorCompose f g x=
(fmap g (fmap f x)) ==(fmap (g .f) x)
As long as we provided concrete instances, we can now run
these to test them.
Prelude&gt; :{
*Main| let f :: [Int] -&gt; Bool
*Main| f x = functorIdentity x
*Main| :}
Prelude&gt; quickCheck f
+++ OK, passed 100 tests.
Prelude&gt; let c = functorCompose (+1) (*2)
Prelude&gt; let li x = c (x :: [Int])</p>
<p>CHAPTER 16. FUNCTOR 1012
Prelude&gt; quickCheck li
+++ OK, passed 100 tests.
Groovy.
Making QuickCheck generate functions too
QuickCheck happens to oÔ¨Äer the ability to generate functions.
There‚Äôs a typeclass called CoArbitrary that covers the function
argument type, whereas the (related) Arbitrary typeclass is used
for the function result type. If you‚Äôre curious about this, take
a look at the Function module in the QuickCheck library to see
how functions are generated from a datatype that represents
patterns in function construction.</p>
<p>CHAPTER 16. FUNCTOR 1013
{-# LANGUAGE ViewPatterns #-}
importTest.QuickCheck
importTest.QuickCheck.Function
functorCompose' ::(Eq(f c),Functor f)=&gt;
f a
-&gt;Funa b
-&gt;Funb c
-&gt;Bool
functorCompose' x (Fun_f) (Fun_g)=
(fmap (g .f) x)==(fmap g .fmap f$x)
There are a couple things going on here. One is that we
needed to import a new module from QuickCheck . Another
is that we‚Äôre pattern matching on the Funvalue that we‚Äôre
askingQuickCheck to generate. The underlying Funtype is es-
sentially a product of the weird function type and an ordi-
nary Haskell function generated from the weirdo. The weirdo
QuickCheck -specific concrete function is a function represented
by a datatype which can be inspected and recursed. We only
want the second part, the ordinary Haskell function, so we‚Äôre
pattern-matching that one out.
Prelude&gt; type IntToInt = Fun Int Int
Prelude&gt; :{</p>
<p>CHAPTER 16. FUNCTOR 1014
*Main| type IntFC =
*Main| [Int]
*Main| -&gt; IntToInt
*Main| -&gt; IntToInt
*Main| -&gt; Bool
*Main| :}
Prelude&gt; let fc' = functorCompose'
Prelude&gt; quickCheck (fc' :: IntFC)
+++ OK, passed 100 tests.
Noteofwarning, youcan‚Äôtprintthose Funvalues, so verboseCheck
will curse Socrates and spin in a circle if you try it.
16.10 Exercises: Instances of Func
Implement Functor instances for the following datatypes. Use
theQuickCheck properties we showed you to validate them.
1.newtype Identity a=Identity a
2.dataPaira=Paira a
3.dataTwoa b=Twoa b
4.dataThreea b c=Threea b c
5.dataThree'a b=Three'a b b</p>
<p>CHAPTER 16. FUNCTOR 1015
6.dataFoura b c d =Foura b c d
7.dataFour'a b=Four'a a a b
8.Can you implement one for this type? Why? Why not?
dataTrivial =Trivial
Doingtheseexercisesis critical tounderstandinghow Functor
works, do not skip past them!
16.11 Ignoring possibilities
We‚Äôve already touched on the MaybeandEither functors. Now
we‚Äôll examine in a bit more detail what those do for us. As
the title of this section suggests, the Functor instances for these
datatypes are handy for times you intend to ignore the left
cases, which are typically your error or failure cases. Because
fmapdoesn‚Äôt touch those cases, you can map your function
right to the values that you intend to work with and ignore
those failure cases.
Maybe
Let‚Äôs start with some ordinary pattern matching on Maybe:</p>
<p>CHAPTER 16. FUNCTOR 1016
incIfJust ::Numa=&gt;Maybea-&gt;Maybea
incIfJust (Justn)=Just$n+1
incIfJust Nothing =Nothing
showIfJust ::Showa
=&gt;Maybea
-&gt;MaybeString
showIfJust (Justs)=Just$show s
showIfJust Nothing =Nothing
Well, that‚Äôs boring, and there‚Äôs some redundant structure.
For one thing, they have the Nothing case in common:
someFunc Nothing =Nothing
Then they‚Äôre applying some function to the value if it‚Äôs a
Just:
someFunc (Justx)=Just$someOtherFunc x
What happens if we use fmap?</p>
<p>CHAPTER 16. FUNCTOR 1017
incMaybe ::Numa=&gt;Maybea-&gt;Maybea
incMaybe m=fmap (+1) m
showMaybe ::Showa
=&gt;Maybea
-&gt;MaybeString
showMaybe s=fmap show s
That appears to have cleaned things up a bit. Does it still
work?
Prelude&gt; incMaybe (Just 1)
Just 2
Prelude&gt; incMaybe Nothing
Nothing
Prelude&gt; showMaybe (Just 9001)
Just &quot;9001&quot;
Prelude&gt; showMaybe Nothing
Nothing
Yeah,fmaphas no reason to concern itself with the Nothing
‚Äî there‚Äôs no value there for it to operate on, so this all seems
to be working properly.
But we can abstract this a bit more. For one thing, we can
eta-reduce these functions. That is, we can rewrite them with-
out naming the arguments:</p>
<p>CHAPTER 16. FUNCTOR 1018
incMaybe'' ::Numa=&gt;Maybea-&gt;Maybea
incMaybe'' =fmap (+1)
showMaybe'' ::Showa
=&gt;Maybea
-&gt;MaybeString
showMaybe'' =fmap show
And they don‚Äôt even really have to be specific to Maybe!fmap
works for all datatypes with a Functor instance! We can query
the type of the expressions in GHCi and see for ourselves the
more generic type:
Prelude&gt; :t fmap (+1)
fmap (+1)
:: (Functor f, Num b) =&gt; f b -&gt; f b
Prelude&gt; :t fmap show
fmap show
:: (Functor f, Show a) =&gt; f a -&gt; f String
With that, we can rewrite them as much more generic func-
tions:</p>
<p>CHAPTER 16. FUNCTOR 1019
-- ``lifted'' because they've been
-- lifted over some structure f
liftedInc ::(Functor f,Numb)
=&gt;f b-&gt;f b
liftedInc =fmap (+1)
liftedShow ::(Functor f,Showa)
=&gt;f a-&gt;fString
liftedShow =fmap show
And they have the same behavior as always:
Prelude&gt; liftedInc (Just 1)
Just 2
Prelude&gt; liftedInc Nothing
Nothing
Prelude&gt; liftedShow (Just 1)
Just &quot;1&quot;
Prelude&gt; liftedShow Nothing
Nothing
Making them more polymorphic in the type of the functo-
rial structure means they‚Äôre more reusable now:
Prelude&gt; liftedInc [1..5]</p>
<p>CHAPTER 16. FUNCTOR 1020
[2,3,4,5,6]
Prelude&gt; liftedShow [1..5]
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
Exercise: Possibly
Write a Functor instance for a datatype identical to Maybe. We‚Äôll
use our own datatype because Maybealready has a Functor in-
stance and we cannot make a duplicate one.
dataPossibly a=
LolNope
|Yeppers a
deriving (Eq,Show)
instance Functor Possibly where
fmap=undefined
If it helps, you‚Äôre basically writing the following function:
applyIfJust ::(a-&gt;b)
-&gt;Maybea
-&gt;Maybeb</p>
<p>CHAPTER 16. FUNCTOR 1021
Either
TheMaybetype solves some problems for Haskellers, but it
doesn‚Äôt solve all of them. As we saw in a previous chapter,
sometimes we want to preserve the reason whya computation
failed rather than only the information thatit failed. And for
that, we use Either .
By this point, you know that Either has aFunctor instance
inbasefor grateful programmers to use. So let‚Äôs put it to use.
We‚Äôll stick to the same pattern we used for demonstrating
Maybe, for the sake of clarity:
incIfRight ::Numa
=&gt;Eithere a
-&gt;Eithere a
incIfRight (Rightn)=Right$n+1
incIfRight (Lefte)=Lefte
showIfRight ::Showa
=&gt;Eithere a
-&gt;EithereString
showIfRight (Rights)=Right$show s
showIfRight (Lefte)=Lefte
Once again we can simplify these using fmapso we don‚Äôt
have to address the case of leaving the error value alone:</p>
<p>CHAPTER 16. FUNCTOR 1022
incEither ::Numa
=&gt;Eithere a
-&gt;Eithere a
incEither m=fmap (+1) m
showEither ::Showa
=&gt;Eithere a
-&gt;EithereString
showEither s=fmap show s
And again we can eta-contract to drop the obvious argu-
ment:
incEither' ::Numa
=&gt;Eithere a
-&gt;Eithere a
incEither' =fmap (+1)
showEither' ::Showa
=&gt;Eithere a
-&gt;EithereString
showEither' =fmap show
And once againwe are confronted with functions that really
didn‚Äôt need to be specific to Either at all:</p>
<p>CHAPTER 16. FUNCTOR 1023
-- f ~ Either e
liftedInc ::(Functor f,Numb)
=&gt;f b-&gt;f b
liftedInc =fmap (+1)
liftedShow ::(Functor f,Showa)
=&gt;f a-&gt;fString
liftedShow =fmap show
Take a few moments to play around with this and note how
it works.
Short Exercise
1.Write a Functor instance for a datatype identical to Either .
We‚Äôll use our own datatype because Either has aFunctor
instance.
dataSuma b=
Firsta
|Secondb
deriving (Eq,Show)
instance Functor (Suma)where
fmap=undefined</p>
<p>CHAPTER 16. FUNCTOR 1024
Your hint for this one is that you‚Äôre writing the following
function.
applyIfSecond ::(a-&gt;b)
-&gt;(Sume) a
-&gt;(Sume) b
2.Why is a Functor instance that applies the function only to
First,Either ‚ÄôsLeft, impossible? We covered this earlier.
16.12 A somewhat surprising functor
There‚Äôs a datatype named ConstorConstant ‚Äî you‚Äôll see both
names depending on which library you use. Constant has a
validFunctor , but the behavior of the Functor instance may
surprise you a bit. First, let‚Äôs look at the constfunction , and
then we‚Äôll look at the datatype:
Prelude&gt; :t const
const :: a -&gt; b -&gt; a
Prelude&gt; let a = const 1
Prelude&gt; a 1
1
Prelude&gt; a 2
1
Prelude&gt; a 3
1</p>
<p>CHAPTER 16. FUNCTOR 1025
Prelude&gt; a &quot;blah&quot;
1
Prelude&gt; a id
1
Withasimilarconceptinmind, thereisthe Constant datatype.
Constant looks like this:
newtype Constant a b=
Constant { getConstant ::a }
deriving (Eq,Show)
One thing we notice about this type is that the type param-
eterùëèis aphantom type. It has no corresponding witness at
the value/term level. This is a concept and tactic we‚Äôll explore
more later, but for now we can see how it echoes the function
const:
Prelude&gt; Constant 2
Constant {getConstant = 2}
Despite ùëèbeing a phantom type, though, Constant is kind*
-&gt; * -&gt; * , and that is not a valid Functor . So how do we get one?
Well, there‚Äôs only one thing we can do with a type constructor,
just as with functions: apply it. So we dohave aFunctor for
Constant a , but not Constant alone. It has to be Constant a and
notConstant a b because Constant a b would be kind *.
Let‚Äôs look at the implementation of Functor forConstant :</p>
<p>CHAPTER 16. FUNCTOR 1026
instance Functor (Constant m)where
fmap_(Constant v)=Constant v
Looks like identity right? Let‚Äôs use this in the REPL and run
it through the Functor laws:
Prelude&gt; const 2 (getConstant (Constant 3))
2
Prelude&gt; fmap (const 2) (Constant 3)
Constant {getConstant = 3}
Prelude&gt; let gc = getConstant
Prelude&gt; let c = Constant 3
Prelude&gt; gc $ fmap (const 2) c
3
Prelude&gt; gc $ fmap (const &quot;blah&quot;) c
3
When you fmaptheconstfunction over the Constant type,
the first argument to constis never used because the partially
applied constis itself never used. The first type argument to
Constant ‚Äôs type constructor is in the part of the structure that
Functor skips over. The second argument to the Constant type
constructor is the phantom type variable ùëèwhich has no value
or term-level witness in the datatype. Since there are no values
of the type the Functor is supposed to be mapping, we have</p>
<p>CHAPTER 16. FUNCTOR 1027
nothing we‚Äôre allowed to apply the function to, so we never
use the constexpressions.
But does this adhere to the Functor laws?
-- Testing identity
Prelude&gt; getConstant (id (Constant 3))
3
Prelude&gt; getConstant (fmap id (Constant 3))
3
-- Composition of the const function
Prelude&gt; ((const 3) . (const 5)) 10
3
Prelude&gt; ((const 5) . (const 3)) 10
5
-- Composition
Prelude&gt; let fc = fmap (const 3)
Prelude&gt; let fc' = fmap (const 5)
Prelude&gt; let separate = fc . fc'
Prelude&gt; let c = const 3
Prelude&gt; let c' = const 5
Prelude&gt; let fused = fmap (c . c')
Prelude&gt; let cw = Constant &quot;WOOHOO&quot;
Prelude&gt; getConstant $ separate $ cw
&quot;WOOHOO&quot;</p>
<p>CHAPTER 16. FUNCTOR 1028
Prelude&gt; let cdr = Constant &quot;Dogs rule&quot;
Prelude&gt; getConstant $ fused $ cdr
&quot;Dogs rule&quot;
(Constant a) is* -&gt; * which you need for the Functor , but
now you‚Äôre mapping over that ùëè, and not the ùëé.
This is a mere cursory check, not a proof that this is a valid
Functor . Most assurances of correctness that programmers use
exist on a gradient and aren‚Äôt proper proofs. Despite seeming
a bit pointless, Constant is a lawful Functor .
16.13 More structure, more functors
At times the structure of our types may require that we also
have aFunctor instance for an intermediate type layer. We‚Äôll
demonstrate this using this datatype:
dataWrapf a=
Wrap(f a)
deriving (Eq,Show)
Notice that our ùëéhere is an argument to the ùëì. So how are
we going to write a Functor instance for this?
instance Functor (Wrapf)where
fmap f ( Wrapfa)=Wrap(f fa)</p>
<p>CHAPTER 16. FUNCTOR 1029
This won‚Äôt work because there‚Äôs this ùëìthat we‚Äôre not hop-
ping over, and ùëé(the value fmapshould be applying the function
to) is an argument to that ùëì‚Äî the function can‚Äôt apply to that
ùëìthat is wrapping ùëé.
instance Functor (Wrapf)where
fmap f ( Wrapfa)=Wrap(fmap f fa)
Here we don‚Äôt know what type ùëìis and it could be anything,
but it needs to be a type that has a Functor instance so that we
canfmapover it. So we add a constraint:
instance Functor f
=&gt;Functor (Wrapf)where
fmap f ( Wrapfa)=Wrap(fmap f fa)
And if we load up the final instance, we can use this wrapper
type:
Prelude&gt; fmap (+1) (Wrap (Just 1))
Wrap (Just 2)
Prelude&gt; fmap (+1) (Wrap [1, 2, 3])
Wrap [2,3,4]
It should work for any Functor . If we pass it something that
isn‚Äôt?</p>
<p>CHAPTER 16. FUNCTOR 1030
Prelude&gt; let n = 1 :: Integer
Prelude&gt; fmap (+1) (Wrap n)
Couldn't match expected type ‚Äòf b‚Äô
with actual type ‚ÄòInteger‚Äô
Relevant bindings include
it :: Wrap f b (bound at <interactive>:8:1)
In the first argument of ‚ÄòWrap‚Äô, namely ‚Äòn‚Äô
In the second argument of ‚Äòfmap‚Äô,
namely ‚Äò(Wrap n)‚Äô
The number by itself doesn‚Äôt oÔ¨Äer the additional structure
needs for Wrapto work as a Functor . It‚Äôs expecting to be able to
fmapover some ùëìindependent of an ùëéand this isn‚Äôt the case
with any type constant such as Integer .
16.14 IO Functor
We‚Äôve seen the IOtype in the modules and testing chapters
already, but we weren‚Äôt doing much with it save to print text
or ask for string input from the user. The IOtype will get
a full chapter of its own later in the book. It is an abstract
datatype; there are no data constructors that you‚Äôre permitted
to pattern match on, so the typeclasses IOprovides are the</p>
<p>CHAPTER 16. FUNCTOR 1031
only way you can work with values of type IO a. One of the
simplest provided is Functor .
-- getLine :: IO String
-- read :: Read a =&gt; String -&gt; a
getInt::IOInt
getInt=fmap read getLine
Inthas aReadinstance, and fmapliftsreadover the IOtype. A
way you can read getLine here is that it‚Äôs not a String , but rather
away to obtain a string .IOdoesn‚Äôt guarantee that eÔ¨Äects will
be performed, but it does mean that they couldbe performed.
Here the side eÔ¨Äect is needing to block and wait for user input
via the standard input stream the OS provides:
Prelude&gt; getInt
10
10
We type 10 and hit enter. GHCi prints IOvalues unless the
type isIO (), in which case it hides the Unitvalue because it‚Äôs
meaningless:
Prelude&gt; fmap (const ()) getInt
10</p>
<p>CHAPTER 16. FUNCTOR 1032
The ‚Äú10‚Äù in the GHCi session above is from typing 10 and
hitting enter. GHCi isn‚Äôt printing any result after that because
we‚Äôre replacing the Intvalue we read from a String. That
information is getting dropped on the floor because we applied
const () to the contents of the IO Int . If we ignore the presence
of IO, it‚Äôs as if we did this:
Prelude&gt; let getInt = 10 :: Int
Prelude&gt; const () getInt
()
GHCi as a matter of convenience and design, will not print
any value of type IO ()on the assumption that the IO action
you evaluated was evaluated for eÔ¨Äects and because the unit
value cannot communicate anything. We can use the return
function (seen earlier, explained later) to lift a unit value in IO
and reproduce this behavior of GHCi‚Äôs:
Prelude&gt; return 1 :: IO Int
1
Prelude&gt; ()
()
Prelude&gt; return () :: IO ()
Prelude&gt;
What if we want to do something more useful? We can fmap
any function we want over IO:</p>
<p>CHAPTER 16. FUNCTOR 1033
Prelude&gt; fmap (+1) getInt
10
11
Prelude&gt; fmap (++ &quot; and me too!&quot;) getLine
hello
&quot;hello and me too!&quot;
Wecanalso use dosyntaxtodo whatwe‚Äôredoingwith Functor
here:
meTooIsm ::IOString
meTooIsm = do
input&lt;-getLine
return (input ++&quot;and me too!&quot; )
bumpIt::IOInt
bumpIt= do
intVal&lt;-getInt
return (intVal +1)
But iffmap f suffices for what you‚Äôre doing, that‚Äôs usually
shorter and clearer. It‚Äôs perfectly all right and quite common
to start with a more verbose form of some expression and
then clean it up after you‚Äôve got something that works.</p>
<p>CHAPTER 16. FUNCTOR 1034
16.15 What if we want to do something
diÔ¨Äerent?
We talked about Functor as a means of lifting functions over
structure so that we may transform only the contents, leaving
the structure alone. What if we wanted to transform only the
structure and leave the type argument to that structure or type
constructor alone? With this, we‚Äôve arrived at natural transfor-
mations . We can attempt to put together a type to express what
we want:
nat::(f-&gt;g)-&gt;f a-&gt;g a
This type is impossible because we can‚Äôt have higher-kinded
types as argument types to the function type. What‚Äôs the
problem, though? It looks like the type signature for fmap,
doesn‚Äôt it? Yet ùëìandùëîinf -&gt; g are higher-kinded types. They
must be, because they are the same ùëìandùëîthat, later in the
type signature, are taking arguments. But in those places they
are applied to their arguments and so have kind *.
So we make a modest change to fix it.
{-# LANGUAGE RankNTypes #-}
typeNatf g=forall a .f a-&gt;g a</p>
<p>CHAPTER 16. FUNCTOR 1035
So in a sense, we‚Äôre doing the opposite of what a Functor does.
We‚Äôre transforming the structure, preserving the values as they
were. We won‚Äôt explain it fully here, but the quantification of
ùëéin the right-hand side of the declaration allows us to obligate
all functions of this type to be oblivious to the contents of
the structures ùëìandùëîin much the same way that the identity
function cannot do anything but return the argument it was
given.
Syntactically, it lets us avoid talking about ùëéin the type of
Nat‚Äî which is what we want, we shouldn‚Äôt haveany specific
information about the contents of ùëìandùëîbecause we‚Äôre sup-
posed to be only performing a structural transformation, not
a fold.
If you try to elide the ùëéfrom the type arguments without
quantifying it separately, you‚Äôll get an error:
Prelude&gt; type Nat f g = f a -&gt; g a
Not in scope: type variable ‚Äòa‚Äô
Wecanaddthequantifier, butifweforgettoturnon RankNTypes
(orRank2Types ), it won‚Äôt work:
Prelude&gt; :{
*Main| type Nat f g =
*Main| forall a . f a -&gt; g a
*Main| :}</p>
<p>CHAPTER 16. FUNCTOR 1036
Illegal symbol '.' in type
Perhaps you intended to use RankNTypes or a
similar language extension to enable
explicit-forall syntax:
forall <tvs>. <type>
If we turn on RankNTypes , it works fine:
Prelude&gt; :set -XRank2Types
Prelude&gt; :{
*Main| type Nat f g =
*Main| forall a . f a -&gt; g a
*Main| :}
Prelude&gt;
To see an example of what the quantification prevents, con-
sider the following:</p>
<p>CHAPTER 16. FUNCTOR 1037
typeNatf g=forall a .f a-&gt;g a
-- This'll work
maybeToList ::NatMaybe[]
maybeToList Nothing =[]
maybeToList (Justa)=[a]
-- This will not work, not allowed.
degenerateMtl ::NatMaybe[]
degenerateMtl Nothing =[]
degenerateMtl (Justa)=[a+1]
What if we use a version of Natthat mentions ùëéin the type?</p>
<p>CHAPTER 16. FUNCTOR 1038
moduleBadNatwhere
typeNatf g a=f a-&gt;g a
-- This'll work
maybeToList ::NatMaybe[]a
maybeToList Nothing =[]
maybeToList (Justa)=[a]
-- But this will too if we tell it
-- 'a' is Num a =&gt; a
degenerateMtl ::Numa=&gt;NatMaybe[]a
degenerateMtl Nothing =[]
degenerateMtl (Justa)=[a+1]
That last example should notwork and is not a good way to
think about natural transformation. Part of software is being
precise and when we talk about natural transformations we‚Äôre
saying as much about what we don‚Äôtwant as we are about what
wedowant. In this case, the invariant we want to preserve is
that the function cannot do anything mischievous with the
values. If you want to transform the values, write a plain old
fold!
We‚Äôre going to return to the topic of natural transformations</p>
<p>CHAPTER 16. FUNCTOR 1039
in the next chapter, so cool your jets for now.
16.16 Functors are unique to a datatype
In Haskell, Functor instances will be unique for a given datatype.
We saw that this isn‚Äôt true for Monoid; however, we use new-
types to preserve the unique pairing of an instance to a type.
ButFunctor instances will be unique for a datatype, in part
because of parametricity, in part because arguments to type
constructors are applied in order of definition. In a hypothet-
ical not-Haskell language, the following might be possible:
dataTuplea b=
Tuplea b
deriving (Eq,Show)
-- this is impossible in Haskell
instance Functor (Tuple?b)where
fmap f ( Tuplea b)=Tuple(f a) b
There are essentially two ways to address this. One is to flip
the arguments to the type constructor; the other is to make a
new datatype using a Flipnewtype:</p>
<p>CHAPTER 16. FUNCTOR 1040
{-# LANGUAGE FlexibleInstances #-}
moduleFlipFunctor where
dataTuplea b=
Tuplea b
deriving (Eq,Show)
newtype Flipf a b=
Flip(f b a)
deriving (Eq,Show)
-- this works, goofy as it looks.
instance Functor (FlipTuplea)where
fmap f ( Flip(Tuplea b))=
Flip$Tuple(f a) b
Prelude&gt; fmap (+1) (Flip (Tuple 1 &quot;blah&quot;))
Flip (Tuple 2 &quot;blah&quot;)
However, Flip Tuple a b is a distinct type from Tuple a b
even if it‚Äôs only there to provide for diÔ¨Äerent Functor instance
behavior.</p>
<p>CHAPTER 16. FUNCTOR 1041
16.17 Chapter exercises
Determine if a valid Functor can be written for the datatype
provided.
1.dataBool=
False|True
2.dataBoolAndSomethingElse a=
False'a|True'a
3.dataBoolAndMaybeSomethingElse a=
Falsish |Truisha
4.Use the kinds to guide you on this one, don‚Äôt get too hung
up on the details.
newtype Muf=InF{ outF::f (Muf) }
5.Again, follow the kinds and ignore the unfamiliar parts
importGHC.Arr
dataD=
D(ArrayWordWord)IntInt
Rearrange the arguments to the type constructor of the
datatype so the Functor instance works.</p>
<p>CHAPTER 16. FUNCTOR 1042
1.dataSuma b=
Firsta
|Secondb
instance Functor (Sume)where
fmap f ( Firsta)=First(f a)
fmap f ( Secondb)=Secondb
2.dataCompany a b c=
DeepBlue a c
|Something b
instance Functor (Company e e')where
fmap f ( Something b)=Something (f b)
fmap_(DeepBlue a c)=DeepBlue a c
3.dataMorea b=
La b a
|Rb a b
deriving (Eq,Show)
instance Functor (Morex)where
fmap f ( La b a') =L(f a) b (f a')
fmap f ( Rb a b') =Rb (f a) b'</p>
<p>CHAPTER 16. FUNCTOR 1043
Keeping in mind that it should result in a Functor that does
the following:
Prelude&gt; fmap (+1) (L 1 2 3)
L 2 2 4
Prelude&gt; fmap (+1) (R 1 2 3)
R 1 3 3
WriteFunctor instances for the following datatypes.
1.dataQuanta b=
Finance
|Deska
|Bloorb
2.No, it‚Äôs not interesting by itself.
dataKa b=
Ka</p>
<p>CHAPTER 16. FUNCTOR 1044
3.{-# LANGUAGE FlexibleInstances #-}
newtype Flipf a b=
Flip(f b a)
deriving (Eq,Show)
newtype Ka b=
Ka
-- should remind you of an
-- instance you've written before
instance Functor (FlipKa)where
fmap=undefined
4.dataEvilGoateeConst a b=
GoatyConst b
-- You thought you'd escaped the goats
-- by now didn't you? Nope.
No, it doesn‚Äôt do anything interesting. No magic here or
in the previous exercise. If it works, you succeeded.
5.Do you need something extra to make the instance work?</p>
<p>CHAPTER 16. FUNCTOR 1045
dataLiftItOut f a=
LiftItOut (f a)
6.dataParappa f g a=
DaWrappa (f a) (g a)
7.Don‚Äôt ask for more typeclass instances than you need. You
can let GHC tell you what to do.
dataIgnoreOne f g a b =
IgnoringSomething (f a) (g b)
8.dataNotorious g o a t =
Notorious (g o) (g a) (g t)
9.You‚Äôll need to use recursion.
dataLista=
Nil
|Consa (Lista)
10.A tree of goats forms a Goat-Lord, fearsome poly-creature.</p>
<p>CHAPTER 16. FUNCTOR 1046
dataGoatLord a=
NoGoat
|OneGoat a
|MoreGoats (GoatLord a)
(GoatLord a)
(GoatLord a)
-- A VERITABLE HYDRA OF GOATS
11.You‚Äôll use an extra functor for this one, although your so-
lution might do it monomorphically without using fmap.
Keep in mind that you will probably not be able to vali-
date this one in the usual manner. Do your best to make
it work.2
dataTalkToMe a=
Halt
|PrintStringa
|Read(String-&gt;a)
16.18 Definitions
1.Higher-kinded polymorphism is polymorphism which has
a type variable abstracting over types of a higher kind.
Functor is an example of higher-kinded polymorphism
because the kind of the ùëìparameter to Functor is* -&gt; *.
2Thanks to Andraz Bajt for inspiring this exercise.</p>
<p>CHAPTER 16. FUNCTOR 1047
Another example of higher-kinded polymorphism would
be a datatype having a parameter to the type constructor
which is of a higher kind, such as the following:
dataWeirdf a=Weird(f a)
Where the kinds of the types involved are:
a:: *
f:: * -&gt; *
Weird::(* -&gt; *)-&gt; * -&gt; *
Here both Weirdandùëìare higher kinded, with Weirdbeing
an example of higher-kinded polymorphism.
2.Functor is a mapping between categories. In Haskell, this
manifests as a typeclass that generalizes the concept of map:
it takes a function (a -&gt; b) and lifts it into a diÔ¨Äerent type.
This conventionally implies some notion of a function
which can be applied to a value with more structure than
the unlifted function was originally designed for. The
additional structure is represented by the use of a higher-
kinded type ùëì, introduced by the definition of the Functor
typeclass.</p>
<p>CHAPTER 16. FUNCTOR 1048
f ::a-&gt;b
-- ``more structure''
fmapf::f a-&gt;f b
-- f is applied to a single argument,
-- and so is kind * -&gt; *
One should be careful not to confuse this intuition for
it necessarily being exclusively about containers or data
structures. There‚Äôs a Functor of functions and many exotic
types will have a lawful Functor instance.
3.Let‚Äôs talk about lifting. Because most of the rest of the
book deals with applicatives and monads of various fla-
vors, we‚Äôre going to be lifting a lot, but what do we mean?
When Carnap first described functors in the context of
linguistics, he didn‚Äôt really talk about it as lifting anything,
and mathematicians have followed in his footsteps, fo-
cusing on mapping and the production of outputs from
certain types of inputs. Very mathematical of them, and
yet Haskellers use the lifting metaphor often (as we do, in
this book).
There are a couple of ways people commonly think about
it. One is that we can lift a function into a context. Another</p>
<p>CHAPTER 16. FUNCTOR 1049
is that we lift a function over some layer of structure to
apply it. The eÔ¨Äect is the same:
Prelude&gt; fmap (+1) $ Just 1
Just 2
Prelude&gt; fmap (+1) [1, 2, 3]
[2,3,4]
In the first case, we lift that function into a Maybecontext
in order to apply it; in the second case, into a list con-
text. It can be helpful to think of it in terms of lifting the
function into the context, because it‚Äôs the context we‚Äôve
lifted the function into that determines how the function
will get applied (to one value or, recursively, to many, for
example). The context is the datatype, the definition of
the datatype, and the Functor instance we have for that
datatype. It‚Äôs also the contexts that determine what hap-
pens when we try to apply a function to an ùëéthat isn‚Äôt
there:
Prelude&gt; fmap (+1) []
[]
Prelude&gt; fmap (+1) Nothing
Nothing
But we often speak more casually about lifting over, as in
fmaplifts a function overa data constructor. This works,</p>
<p>CHAPTER 16. FUNCTOR 1050
too, if you think of the data constructor as a layer of struc-
ture. The function hops over that layer and applies to
what‚Äôs inside, if anything.
More precisely, lifting means applying a type constructor
to a type, as in taking an ùëétype variable and applying an
ùëìtype constructor to it to get an f a. Keeping this def-
inition in mind will be helpful. Remember to follow the
typesrather than getting too caught up in the web of a
metaphor.
4.George Clinton is one of the most important innovators of
funk music. Clinton headed up the bands Parliament and
Funkadelic, whose collective style of music is known as
P-Funk; the two bands have fused into a single apotheosis
of booty-shaking rhythm. The Parliament album Mother-
ship Connection is one of the most famous and influential
albums in rock history. Not a Functor , but you can pretend
the album is mapping your consciousness from the real
world into the category of funkiness if that helps.
16.19 Follow-up resources
1.Haskell Wikibook; The Functor class.
https://en.wikibooks.org/wiki/Haskell/The_Functor_class</p>
<p>CHAPTER 16. FUNCTOR 1051
2.Mark P. Jones; A system of constructor classes: overload-
ing and implicit higher-order polymorphism.
3.Gabriel Gonzalez; The functor design pattern.</p>
<p>Chapter 17
Applicative
‚Ä¶the images I most
connect to, historically
speaking, are in black and
white. I see more in black
and white ‚Äì I like the
abstraction of it.
Mary Ellen Mark
1052</p>
<p>CHAPTER 17. APPLICATIVE 1053
17.1 Applicative
In the previous chapters, we‚Äôve seen two common algebras
that are used as typeclasses. Monoid gives us a means of mashing
two values of the same type together. Functor , on the other
hand, is for function application oversome structure we don‚Äôt
want to have to think about. Monoid‚Äôs core operation, mappend ,
smashes the structures together ‚Äî when you mappend two lists,
they become one list, so the structures themselves have been
joined. However, the core operation of Functor ,fmap, applies a
function to a value that is within some structure while leaving
that structure unaltered.
We come now to Applicative . Applicatives are monoidal
functors. No, no, stay with us. The Applicative typeclass allows
for function application lifted over structure (like Functor ). But
withApplicative the function we‚Äôre applying is also embed-
ded in some structure. Because the function andthe value
it‚Äôs being applied to both have structure, we have to smash
those structures together. So, Applicative involves monoids
and functors. And that‚Äôs a pretty powerful thing.
In this chapter, we will:
‚Ä¢define and explore the Applicative typeclass and its core
operations;
‚Ä¢demonstrate why applicatives are monoidal functors;</p>
<p>CHAPTER 17. APPLICATIVE 1054
‚Ä¢make the usual chitchat about laws and instances;
‚Ä¢do a lot of lifting;
‚Ä¢give you some Validation .
17.2 Defining Applicative
The first thing you‚Äôre going to notice about this typeclass dec-
laration is that the ùëìthat represents the structure, similar to
Functor , is itself constrained by the Functor typeclass:
classFunctor f=&gt;Applicative fwhere
pure::a-&gt;f a
(&lt;<em>&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
So, every type that can have an Applicative instance must
also have a Functor instance.
Thepurefunction does a simple and very boring thing:
it lifts something into functorial (applicative) structure. You
can think of this as being a bare minimum bit of structure or
structural identity . Identity for what, you‚Äôll see later when we go
over the laws. The more interesting operation of this typeclass
is&lt;</em>&gt;. This is an infix function called ‚Äòapply‚Äô or sometimes
‚Äòap,‚Äô or sometimes ‚Äòtie fighter‚Äô when we‚Äôre feeling particularly
zippy.
If we compare the types of &lt;*&gt;andfmap, we see the similar-
ity:</p>
<p>CHAPTER 17. APPLICATIVE 1055
-- fmap
(&lt;$&gt;)::Functor f
=&gt;(a-&gt;b)-&gt;f a-&gt;f b
(&lt;*&gt;)::Applicative f
=&gt;f (a-&gt;b)-&gt;f a-&gt;f b
The diÔ¨Äerence is the ùëìrepresenting functorial structure
that is on the outside of our function in the second definition.
We‚Äôll see good examples of what that means in practice in a
moment.
Along with these core functions, the Control.Applicative li-
brary provides some other convenient functions: liftA,liftA2 ,
andliftA3 :</p>
<p>CHAPTER 17. APPLICATIVE 1056
liftA::Applicative f=&gt;
(a-&gt;b)
-&gt;f a
-&gt;f b
liftA2::Applicative f=&gt;
(a-&gt;b-&gt;c)
-&gt;f a
-&gt;f b
-&gt;f c
liftA3::Applicative f=&gt;
(a-&gt;b-&gt;c-&gt;d)
-&gt;f a
-&gt;f b
-&gt;f c
-&gt;f d
If you‚Äôre looking at the type of liftAand thinking, but that‚Äôs
fmap, you are correct. It is basically the same as fmaponly with
anApplicative typeclass constraint instead of a Functor one.
Since all applicatives are also functors, though, this is a distinc-
tion without much significance.
Similarly you can see that liftA2 andliftA3 arefmapbut with
functions involving more arguments. It can be a little difficult</p>
<p>CHAPTER 17. APPLICATIVE 1057
to wrap one‚Äôs head around how those will work in practice, so
we‚Äôll want to look next at some examples to start developing a
sense of what applicatives can do for us.
17.3 Functor vs. Applicative
We‚Äôve already said that applicatives are monoidal functors,
so what we‚Äôve already learned about Monoid andFunctor is rele-
vant to our understanding of Applicative . We‚Äôve already seen
some examples of what this means in practice, but we want to
develop a stronger intuition for the relationship.
Let‚Äôs review the diÔ¨Äerence between fmapand&lt;<em>&gt;:
fmap::(a-&gt;b)-&gt;f a-&gt;f b
(&lt;</em>&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
The diÔ¨Äerence is we now have an ùëìin front of our function
(a -&gt; b) . The increase in power it introduces is profound. For
one thing, any Applicative also has a Functor and not merely
by definition ‚Äî you can define a Functor in terms of a pro-
videdApplicative instance. Proving it is outside the scope of
the current book, but this follows from the laws of Functor
andApplicative (we‚Äôll get to the applicative laws later in this
chapter):
fmapf x=pure f&lt;*&gt;x</p>
<p>CHAPTER 17. APPLICATIVE 1058
How might we demonstrate this? You‚Äôll need to import
Control.Applicative if you‚Äôre using GHC 7.8 or older to test this
example:
Prelude&gt; fmap (+1) [1, 2, 3]
[2,3,4]
Prelude&gt; pure (+1) &lt;*&gt; [1..3]
[2,3,4]
Keeping in mind that pure has type Applicative f =&gt; a -&gt; f
a, we can think of it as a means of embedding a value of any
type in the structure we‚Äôre working with:
Prelude&gt; pure 1 :: [Int]
[1]
Prelude&gt; pure 1 :: Maybe Int
Just 1
Prelude&gt; pure 1 :: Either a Int
Right 1
Prelude&gt; pure 1 :: ([a], Int)
([],1)
The left type is handled diÔ¨Äerently from the right in the
final two examples for the same reason as here:
Prelude&gt; fmap (+1) (4, 5)
(4,6)</p>
<p>CHAPTER 17. APPLICATIVE 1059
The left type is part of the structure, and the structure is
not transformed by the function application.
17.4 Applicative functors are monoidal
functors
First let us notice something:
($)::(a-&gt;b)-&gt;a-&gt;b
(&lt;$&gt;)::(a-&gt;b)-&gt;f a-&gt;f b
(&lt;<em>&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
We already know $to be something of a do-nothing infix
function which exists to give the right-hand side more prece-
dence and thus avoid parentheses. For our present purposes
it acts as a nice proxy for ordinary function application in its
type.
When we get to &lt;$&gt;, the alias for fmap, we notice the first
change is that we‚Äôre now lifting our (a -&gt; b) over the ùëìwrapped
around our value and applying the function to that value.
Then as we arrive at apor&lt;</em>&gt;, theApplicative apply method,
our function is now also embedded in the functorial structure.
Now we get to the monoidal in ‚Äúmonoidal functor‚Äù:</p>
<p>CHAPTER 17. APPLICATIVE 1060
::f (a-&gt;b)-&gt;f a-&gt;f b
-- The two arguments to our function are:
f(a-&gt;b)
-- and
fa
If we imagine that we can apply (a -&gt; b) toùëéand get ùëè,
ignoring the functorial structure, we still have a problem as we
need to return f b. When we were dealing with fmap, we had
only one bit of structure, so it was left unchanged. Now we
have two bits of structure of type ùëìthat we need to deal with
somehow before returning a value of type f b. We can‚Äôt simply
leave them unchanged; we must unite them somehow. Now,
they will be definitely the same type, because the ùëìmust be
the same type throughout. In fact, if we separate the structure
parts from the function parts, maybe we‚Äôll see what we need:
::f (a-&gt;b)-&gt;f a-&gt;f b
f f f
(a-&gt;b) a b
Didn‚Äôt we have something earlier that can take two values
of one type and return one value of the same type? Provided</p>
<p>CHAPTER 17. APPLICATIVE 1061
theùëìis a type with a Monoid instance, then we have a good way
to make them play nice together:
mappend ::Monoida=&gt;a-&gt;a-&gt;a
So, with Applicative , we have a Monoid for our structure and
function application for our values!
mappend ::f f f
$ :: (a-&gt;b) a b
(&lt;*&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
-- plus Functor fmap to be able to map
-- over the f to begin with.
So in a sense, we‚Äôre bolting a Monoid onto aFunctor to be able
to deal with functions embedded in additional structure. In
another sense, we‚Äôre enriching function application with the
very structure we were previously mapping over with Functor .
Let‚Äôs consider a few familiar examples to examine what this
means:</p>
<h1>CHAPTER 17. APPLICATIVE 1062
-- List
[(*2), (<em>3)]&lt;</em>&gt;[4,5]</h1>
<p>[2<em>4,2</em>5,3<em>4,3</em>5]
-- reduced
[8,10,12,15]
So what was (a -&gt; b) enriched with in f (a -&gt; b) -&gt; f a -&gt;
f b? In this case, ‚Äúlist-ness‚Äù. Although the actual application
of each (a -&gt; b) to a value of type ùëéis quite ordinary, we now
have a list of functions rather than a single function as would
be the case if it was the list Functor .
But lists aren‚Äôt the only structure we can enrich our func-
tions with ‚Äî not even close! The structure bit can also be Maybe:</p>
<h1>CHAPTER 17. APPLICATIVE 1063
Just(<em>2)&lt;</em>&gt;Just2</h1>
<h1>Just4
Just(<em>2)&lt;</em>&gt;Nothing</h1>
<h1>Nothing
Nothing &lt;*&gt;Just2</h1>
<h1>Nothing
Nothing &lt;*&gt;Nothing</h1>
<p>Nothing
WithMaybe, the ordinary functor is mapping over the pos-
sibility of a value‚Äôs nonexistence. With the Applicative , now
the function also might not be provided. We‚Äôll see a couple
of nice, long examples of how this might happen ‚Äî how you
could end up not even providing a function to apply ‚Äî in a
bit, not just with Maybe, but with Either and a new type called
Validation as well.</p>
<p>CHAPTER 17. APPLICATIVE 1064
Show me the monoids
Recall that the Functor instance for the two-tuple ignores the
first value inside the tuple:
Prelude&gt; fmap (+1) (&quot;blah&quot;, 0)
(&quot;blah&quot;,1)
Butthe Applicative forthetwo-tupledemonstratesthemonoid
inApplicative nicely for us. In fact, if you call :infoon(,)in
your REPL you‚Äôll notice something:
Prelude&gt; :info (,)
data (,) a b = (,) a b
-- Defined in ‚ÄòGHC.Tuple‚Äô
...
instance Monoid a
=&gt; Applicative ((,) a)
-- Defined in ‚ÄòGHC.Base‚Äô
...
instance (Monoid a, Monoid b)
=&gt; Monoid (a, b)
For the Applicative instance of two-tuple, we don‚Äôt need a
Monoid for the ùëèbecause we‚Äôre using function application to
produce the ùëè. However, for the first value in the tuple, we
still need the Monoid because we have two values and need to
somehow turn that into one value of the same type:</p>
<p>CHAPTER 17. APPLICATIVE 1065
Prelude&gt; (&quot;Woo&quot;, (+1)) &lt;<em>&gt; (&quot; Hoo!&quot;, 0)
(&quot;Woo Hoo!&quot;, 1)
Notice that for the ùëévalue, we didn‚Äôt apply any function,
but they have combined themselves as if by magic; that‚Äôs due
to theMonoid instance for the ùëévalues. The function in the ùëè
position of the left tuple has been applied to the value in the ùëè
position of the right tuple to produce a result. That function
application is why we don‚Äôt need a Monoid instance on the ùëè.
Let‚Äôs look at more such examples. Pay careful attention to
how the ùëévalues in the tuples are combined:
Prelude&gt; import Data.Monoid
Prelude&gt; (Sum 2, (+1)) &lt;</em>&gt; (Sum 0, 0)
(Sum {getSum = 2},1)
Prelude&gt; (Product 3, (+9))&lt;<em>&gt;(Product 2, 8)
(Product {getProduct = 6},17)
Prelude&gt; (All True, (+1))&lt;</em>&gt;(All False, 0)
(All {getAll = False},1)
It doesn‚Äôt really matter whatMonoid , but we need some way
of combining or choosing our values.
Tuple Monoid and Applicative side by side
Squint if you can‚Äôt see it.</p>
<p>CHAPTER 17. APPLICATIVE 1066
instance (Monoida,Monoidb)
=&gt;Monoid(a,b)where
mempty=(mempty, mempty)
(a, b) <code>mappend</code> (a',b') =
(a <code>mappend</code> a', b <code>mappend</code> b')
instance Monoida
=&gt;Applicative ((,) a) where
pure x=(mempty, x)
(u, f)&lt;*&gt;(v, x)=
(u <code>mappend</code> v, f x)
Maybe Monoid and Applicative
While applicatives are monoidal functors, be careful about
making assumptions based on this. For one thing, Monoid and
Applicative instances aren‚Äôt required or guaranteed to have the
same monoid of structure, and the functorial part may change
the way it behaves. Nevertheless, you might be able to see the
implicit monoid in how the Applicative pattern matches on
theJustandNothing cases and compare that with this Monoid :</p>
<p>CHAPTER 17. APPLICATIVE 1067
instance Monoida=&gt;Monoid(Maybea)where
mempty=Nothing
mappend m Nothing =m
mappend Nothing m=m
mappend ( Justa) (Justa')=
Just(mappend a a')
instance Applicative Maybewhere
pure=Just
Nothing &lt;<em>&gt; _ = Nothing
_ &lt;</em>&gt;Nothing =Nothing
Justf&lt;*&gt;Justa=Just(f a)
Later we‚Äôll see some examples of how diÔ¨Äerent Monoid in-
stances can give diÔ¨Äerent results for applicatives. For now,
recognize that the monoidal bit may not be what you recog-
nize as the canonical mappend of that type, because some types
can have multiple monoids.
17.5 Applicative in use
Bynowitshouldcomeasnosurprisethatmanyofthedatatypes
we‚Äôve been working with in the past two chapters also have
Applicative instances. Since we are already so familiar with list
andMaybe, those examples will be a good place to start. Later</p>
<p>CHAPTER 17. APPLICATIVE 1068
in the chapter, we will be introducing some new types, so just
hang onto your hats.
List Applicative
We‚Äôll start with the list Applicative because it‚Äôs a clear way to
get a sense of the pattern. Let‚Äôs start by specializing the types:
-- f ~ []
(&lt;<em>&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
(&lt;</em>&gt;)::[ ] (a-&gt;b)-&gt;[ ] a-&gt;[ ] b
-- more syntactically typical
(&lt;<em>&gt;)::[(a-&gt;b)]-&gt;[a]-&gt;[b]
pure::a-&gt;f a
pure::a-&gt;[ ] a
Or, again, if you have GHC 8 or newer, you can do this:
Prelude&gt; :set -XTypeApplications
Prelude&gt; :type (&lt;</em>&gt;) @[]
(&lt;*&gt;) @[] :: [a -&gt; b] -&gt; [a] -&gt; [b]
Prelude&gt; :type pure @[]
pure @[] :: a -&gt; [a]</p>
<p>CHAPTER 17. APPLICATIVE 1069
What‚Äôs the List applicative do?
Previously with list Functor , we were mapping a single function
over a plurality of values:
Prelude&gt; fmap (2^) [1, 2, 3]
[2,4,8]
Prelude&gt; fmap (^2) [1, 2, 3]
[1,4,9]
With the list Applicative , we are mapping a plurality of func-
tions over a plurality of values:
Prelude&gt; [(+1), (<em>2)] &lt;</em>&gt; [2, 4]
[3,5,4,8]
We can see how this makes sense given that:
(&lt;*&gt;)::Applicative f
=&gt;f (a-&gt;b)-&gt;f a-&gt;f b
f~[]
listApply ::[(a-&gt;b)]-&gt;[a]-&gt;[b]
listFmap ::(a-&gt;b)-&gt;[a]-&gt;[b]</p>
<p>CHAPTER 17. APPLICATIVE 1070
Theùëìstructure that is wrapped around our function in the
listApply function is itself a list. Therefore, our a -&gt; b from
Functor has become a listofa -&gt; b .
Now what happened with that expression we tested? Some-
thing like this:
[(+1), (<em>2)]&lt;</em>&gt;[2,4]==[3,5,4,8]
[3,5,4,8]
-- [1] [2] [3] [4]
1.The first item in the list, 3, is the result of (+1) being applied
to 2.
2.5 is the result of applying (+1) to 4.
3.4 is the result of applying (*2) to 2.
4.8 is the result of applying (*2) to 4.
More visually:
[(+1), (<em>2)]&lt;</em>&gt;[2,4]
[ (+1)2, (+1)4, (*2)2, (*2)4]
It maps each function value from the first list over the sec-
ond list, applies the operations, and returns one list. The fact</p>
<p>CHAPTER 17. APPLICATIVE 1071
that it doesn‚Äôt return two lists or a nested list or some other
configuration in which both structures are preserved is the
monoidal part; the reason we don‚Äôt have a list of functions
concatenated with a list of values is the function application
part.
We can see this relationship more readily if we use the
tuple constructor with the list Applicative . We‚Äôll use the infix
operator for fmapto map the tuple constructor over the first list.
This embeds an unapplied function (the tuple data constructor
in this case) into some structure (a list, in this case), and returns
a list of partially applied functions. The (infix) applicative will
then apply one list of operations to the second list, monoidally
appending the two lists:
Prelude&gt; (,) &lt;$&gt; [1, 2] &lt;<em>&gt; [3, 4]
[(1,3),(1,4),(2,3),(2,4)]
You might think of it this way:
Prelude&gt; (,) &lt;$&gt; [1, 2] &lt;</em>&gt; [3, 4]
-- fmap the (,) over the first list
[(1, ), (2, )] &lt;*&gt; [3, 4]
-- then we apply the first list
-- to the second
[(1,3),(1,4),(2,3),(2,4)]</p>
<p>CHAPTER 17. APPLICATIVE 1072
TheliftA2 function gives us another way to write this, too:
Prelude&gt; liftA2 (,) [1, 2] [3, 4]
[(1,3),(1,4),(2,3),(2,4)]
Let‚Äôs look at a few more examples of the same pattern:
Prelude&gt; (+) &lt;$&gt; [1, 2] &lt;<em>&gt; [3, 5]
[4,6,5,7]
Prelude&gt; liftA2 (+) [1, 2] [3, 5]
[4,6,5,7]
Prelude&gt; max &lt;$&gt; [1, 2] &lt;</em>&gt; [1, 4]
[1,4,2,4]
Prelude&gt; liftA2 max [1, 2] [1, 4]
[1,4,2,4]
If you‚Äôre familiar with Cartesian products1, this probably
looks a lot like one, but with functions.
We‚Äôre going to run through some more examples, to give
you a little more context for when these functions can become
useful. Thefollowingexampleswilluseafunctioncalled lookup
that we‚Äôll briefly demonstrate:
Prelude&gt; :t lookup
lookup :: Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b
1The Cartesian product is the product of two sets that results in all the ordered pairs
(tuples) of the elements of those sets.</p>
<p>CHAPTER 17. APPLICATIVE 1073
Prelude&gt; let l = lookup 3 [(3, &quot;hello&quot;)]
Prelude&gt; l
Just &quot;hello&quot;
Prelude&gt; fmap length $ l
Just 5
Prelude&gt; let c (x:xs) = toUpper x:xs
Prelude&gt; fmap c $ l
Just &quot;Hello&quot;
So,lookup searches inside a list of tuples for a value that
matches the input and returns the paired value wrapped inside
aMaybecontext.
It‚Äôs worth pointing out here that if you‚Äôre working with
Mapdata structures instead of lists of tuples, you can import
Data.Map and use a Mapversion of lookup along with fromList to
accomplish the same thing with that data structure:
Prelude&gt; let m = fromList [(3, &quot;hello&quot;)]
Prelude&gt; fmap c $ Data.Map.lookup 3 m
Just &quot;Hello&quot;
That may seem trivial at the moment, but Mapis a frequently
used data structure, so it‚Äôs worth mentioning.
Nowthatwehavevalueswrappedina Maybecontext, perhaps
we‚Äôd like to apply some functions to them. This is where we
want applicative operations. Although it‚Äôs more likely that
we‚Äôd have functions fetching data from somewhere else rather</p>
<p>CHAPTER 17. APPLICATIVE 1074
than having it all listed in our code file, we‚Äôll go ahead and
define some values in a source file for convenience:
importControl.Applicative
fx=
lookup x [ ( 3,&quot;hello&quot;)
, (4,&quot;julie&quot;)
, (5,&quot;kbai&quot;)]
gy=
lookup y [ ( 7,&quot;sup?&quot;)
, (8,&quot;chris&quot;)
, (9,&quot;aloha&quot;)]
hz=
lookup z [( 2,3), (5,6), (7,8)]
mx=
lookup x [( 4,10), (8,13), (1,9001)]
Now we want to look things up and add them together. We‚Äôll
start with some operations over these data:
Prelude&gt; f 3
Just &quot;hello&quot;
Prelude&gt; g 8
Just &quot;chris&quot;</p>
<p>CHAPTER 17. APPLICATIVE 1075
Prelude&gt; (++) &lt;$&gt; f 3 &lt;<em>&gt; g 7
Just &quot;hellosup?&quot;
Prelude&gt; (+) &lt;$&gt; h 5 &lt;</em>&gt; m 1
Just 9007
Prelude&gt; (+) &lt;$&gt; h 5 &lt;<em>&gt; m 6
Nothing
So we first fmapthose functions over the value inside the first
Maybecontext, if it‚Äôs a Justvalue, making it a partially applied
function wrapped in a Maybecontext. Then we use the tie-
fighter to apply that to the second value, again wrapped in a
Maybe. If either value is a Nothing , we get Nothing .
We can again do the same thing with liftA2 :
Prelude&gt; liftA2 (++) (g 9) (f 4)
Just &quot;alohajulie&quot;
Prelude&gt; liftA2 (^) (h 5) (m 4)
Just 60466176
Prelude&gt; liftA2 (</em>) (h 5) (m 4)
Just 60
Prelude&gt; liftA2 (<em>) (h 1) (m 1)
Nothing
Your applicative context can also sometimes be IO:
(++)&lt;$&gt;getLine &lt;</em>&gt;getLine
(,)&lt;$&gt;getLine &lt;*&gt;getLine</p>
<p>CHAPTER 17. APPLICATIVE 1076
Try it. Now try using fmapto get the length of the resulting
string of the first example.
Exercises: Lookups
In the following exercises you will need to use the following
terms to make the expressions typecheck:
1.pure
2.(&lt;$&gt;)
-- or fmap
3.(&lt;*&gt;)
Make the following expressions typecheck.
1.added::MaybeInteger
added=
(+3) (lookup 3$zip [1,2,3] [4,5,6])
2.y::MaybeInteger
y=lookup3$zip [1,2,3] [4,5,6]
z::MaybeInteger
z=lookup2$zip [1,2,3] [4,5,6]
tupled::Maybe(Integer,Integer)
tupled=(,) y z</p>
<p>CHAPTER 17. APPLICATIVE 1077
3.importData.List (elemIndex )
x::MaybeInt
x=elemIndex 3[1,2,3,4,5]
y::MaybeInt
y=elemIndex 4[1,2,3,4,5]
max'::Int-&gt;Int-&gt;Int
max'=max
maxed::MaybeInt
maxed=max' x y
4.xs=[1,2,3]
ys=[4,5,6]
x::MaybeInteger
x=lookup3$zip xs ys
y::MaybeInteger
y=lookup2$zip xs ys
summed::MaybeInteger
summed=sum$(,) x y</p>
<p>CHAPTER 17. APPLICATIVE 1078
Identity
TheIdentity type here is a way to introduce structure without
changing the semantics of what you‚Äôre doing. We‚Äôll see it used
with these typeclasses that involve function application around
and over structure, but this type itself isn‚Äôt very interesting, as
it has no semantic flavor.
Specializing the types
Here is what the type will look like when our structure is
Identity :
-- f ~ Identity
-- Applicative f =&gt;
typeId=Identity
(&lt;<em>&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
(&lt;</em>&gt;)::Id(a-&gt;b)-&gt;Ida-&gt;Idb
pure::a-&gt;f a
pure::a-&gt;Ida
Why would we use Identity just to introduce some struc-
ture? What is the meaning of all this?
Prelude&gt; let xs = [1, 2, 3]</p>
<p>CHAPTER 17. APPLICATIVE 1079
Prelude&gt; let xs' = [9, 9, 9]
Prelude&gt; const &lt;$&gt; xs &lt;<em>&gt; xs'
[1,1,1,2,2,2,3,3,3]
Prelude&gt; let mkId = Identity
Prelude&gt; const &lt;$&gt; mkId xs &lt;</em>&gt; mkId xs'
Identity [1,2,3]
Having this extra bit of structure around our values lifts the
constfunction, from mapping over the lists to mapping over
theIdentity . We have to go over an ùëìstructure to apply the
function to the values inside. If our ùëìis the list, constapplies to
the values inside the list, as we saw above. If the ùëìisIdentity ,
thenconsttreats the lists inside the Identity structure as single
values, not structure containing values.
Exercise: Identity Instance
Write an Applicative instance for Identity .</p>
<p>CHAPTER 17. APPLICATIVE 1080
newtype Identity a=Identity a
deriving (Eq,Ord,Show)
instance Functor Identity where
fmap=undefined
instance Applicative Identity where
pure=undefined
(&lt;*&gt;)=undefined
Constant
This is not so diÔ¨Äerent from the Identity type, except this
not only provides structure it also acts like the constfunction.
It sort of throws away a function application. If this seems
confusing, it‚Äôs because it is. However, it is also something that,
likeIdentity has real use cases, and you will see it in other
people‚Äôs code. It can be difficult to get used to using it yourself,
but we keep trying.
This datatype is like the constfunction in that it takes two
arguments but one of them gets discarded. In the case of the
datatype, we have to map our function over the argument
that gets discarded. So there is no value to map over, and the
function application doesn‚Äôt happen.</p>
<p>CHAPTER 17. APPLICATIVE 1081
Specializing the types
All right, so here‚Äôs what the types will look like:
-- f ~ Constant e
typeC=Constant
(&lt;<em>&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
(&lt;</em>&gt;)::Ce (a-&gt;b)-&gt;Ce a-&gt;Ce b
pure::a-&gt;f a
pure::a-&gt;Ce a
And here are some examples of how it works. These are,
yes, a bit contrived, but showing you real code with this in it
would probably make it much harder for you to see what‚Äôs
going on:
Prelude&gt; let f = Constant (Sum 1)
Prelude&gt; let g = Constant (Sum 2)
Prelude&gt; f &lt;<em>&gt; g
Constant {getConstant = Sum {getSum = 3}
Prelude&gt; Constant undefined &lt;</em>&gt; g
Constant (Sum {getSum =
*** Exception: Prelude.undefined
Prelude&gt; pure 1
1</p>
<p>CHAPTER 17. APPLICATIVE 1082
Prelude&gt; pure 1 :: Constant String Int
Constant {getConstant = &quot;&quot;}
It can‚Äôt do anything because it can only hold onto the one
value. The function doesn‚Äôt exist, and the ùëèis a ghost. So you
use this when whatever you want to do involves throwing away
a function application. We know it seems somewhat crazy, but
we promise there are really times real coders do this in real
code. Pinky swear.
Exercise: Constant Instance
Write an Applicative instance for Constant .
newtype Constant a b=
Constant { getConstant ::a }
deriving (Eq,Ord,Show)
instance Functor (Constant a)where
fmap=undefined
instance Monoida
=&gt;Applicative (Constant a)where
pure=undefined
(&lt;*&gt;)=undefined</p>
<p>CHAPTER 17. APPLICATIVE 1083
Maybe Applicative
WithMaybe, we‚Äôre doing something a bit diÔ¨Äerent from above.
We saw previously how to use fmapwithMaybe, but here our
function is also embedded in a Maybestructure. Therefore,
whenùëìisMaybe, we‚Äôre saying the function itself might not exist,
because we‚Äôre allowing the possibility of the function to be
applied being a Nothing case.
Specializing the types
Here‚Äôs what the type looks like when we‚Äôre using Maybeas our
ùëìstructure:
-- f ~ Maybe
typeM=Maybe
(&lt;<em>&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
(&lt;</em>&gt;)::M(a-&gt;b)-&gt;Ma-&gt;Mb
pure::a-&gt;f a
pure::a-&gt;Ma
Are you ready to validate some persons? Yes. Yes, you are.</p>
<p>CHAPTER 17. APPLICATIVE 1084
Using the Maybe Applicative
Consider the following example where we validate our inputs
to create a value of type Maybe Person , where the Maybeis because
our inputs might be invalid:
validateLength ::Int
-&gt;String
-&gt;MaybeString
validateLength maxLen s =
if(length s) &gt;maxLen
thenNothing
elseJusts
newtype Name=
NameStringderiving (Eq,Show)
newtype Address =
Address Stringderiving (Eq,Show)
mkName::String-&gt;MaybeName
mkNames=
fmapName$validateLength 25s
mkAddress ::String-&gt;MaybeAddress
mkAddress a=
fmapAddress $validateLength 100a</p>
<p>CHAPTER 17. APPLICATIVE 1085
Now we‚Äôll make a smart constructor for a Person :
dataPerson=
PersonNameAddress
deriving (Eq,Show)
mkPerson ::String
-&gt;String
-&gt;MaybePerson
mkPerson n a=
casemkName n of
Nothing -&gt;Nothing
Justn'-&gt;
casemkAddress a of
Nothing -&gt;Nothing
Justa'-&gt;
Just$Personn' a'
The problem here is while we‚Äôve successfully leveraged fmap
fromFunctor in the simpler cases of mkName andmkAddress , we
can‚Äôt really make that work here with mkPerson . Let‚Äôs investigate
why:
Prelude&gt; :t fmap Person (mkName &quot;Babe&quot;)
fmap Person (mkName &quot;Babe&quot;)
:: Maybe (Address -&gt; Person)</p>
<p>CHAPTER 17. APPLICATIVE 1086
This has worked so far for the first argument to the Person
constructor that we‚Äôre validating, but we‚Äôve hit a roadblock.
Can you see the problem?
Prelude&gt; :{
*Main| fmap (fmap Person (mkName &quot;Babe&quot;))
*Main| (mkAddress &quot;old macdonald's&quot;)
*Main| :}
Couldn't match expected type ‚ÄòAddress -&gt; b‚Äô
with actual type
‚ÄòMaybe (Address -&gt; Person)‚Äô
Possible cause: ‚Äòfmap‚Äô is applied to too
many arguments
In the first argument of ‚Äòfmap‚Äô, namely
‚Äò(fmap Person (mkName &quot;Babe&quot;))‚Äô
In the expression:
fmap (fmap Person (mkName &quot;Babe&quot;)) v
The problem is that our (a -&gt; b) is now hiding inside Maybe.
Let‚Äôs look at the type of fmapagain:
fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
Maybeis definitely a Functor , but that‚Äôs not really going to
help us here. We need to be able to map a function embedded
in ourùëì.Applicative gives us what we need here!</p>
<p>CHAPTER 17. APPLICATIVE 1087
(&lt;<em>&gt;)::Applicative f
=&gt;f (a-&gt;b)-&gt;f a-&gt;f b
Now let‚Äôs see if we can wield this new toy:
Prelude&gt; let s = &quot;old macdonald's&quot;
Prelude&gt; let addy = mkAddress s
Prelude&gt; let b = mkName &quot;Babe&quot;
Prelude&gt; let person = fmap Person b
Prelude&gt; person &lt;</em>&gt; addy
Just (Person (Name &quot;Babe&quot;)
(Address &quot;old macdonald's&quot;))
Nice, right? A little ugly though. Using the infix alias for
fmapcalled&lt;$&gt;cleans it up a bit, at least to Haskellers‚Äô eyes:
Prelude&gt; Person &lt;$&gt; mkName &quot;Babe&quot; &lt;*&gt; addy
Just (Person (Name &quot;Babe&quot;)
(Address &quot;old macdonald's&quot;))
We still use fmap(via&lt;$&gt;) here for the first lifting over Maybe;
after that our (a -&gt; b) is hiding in the ùëìwhereùëì=Maybe, so we
have to start using Applicative to keep mapping over that.
We can now use a much shorter definition of mkPerson !</p>
<p>CHAPTER 17. APPLICATIVE 1088
mkPerson ::String
-&gt;String
-&gt;MaybePerson
mkPerson n a=
Person&lt;$&gt;mkName n &lt;*&gt;mkAddress a
As an additional bonus, this is now far less annoying to
extend if we added new fields as well.
Breaking down that example
We‚Äôre going to give the Functor andApplicative instances for
Maybethe same treatment we gave folds. This will be a bit long.
It is possible that some of this will seem like too much detail;
read it to whatever depth you feel you need to. It will sit here,
patiently waiting to see if you ever need to come back and
read it more closely.
Maybe Functor and the Name constructor</p>
<p>CHAPTER 17. APPLICATIVE 1089
instance Functor Maybewhere
fmap_Nothing =Nothing
fmap f ( Justa) =Just(f a)
instance Applicative Maybewhere
pure=Just
Nothing &lt;<em>&gt; _ = Nothing
_ &lt;</em>&gt;Nothing =Nothing
Justf&lt;*&gt;Justa=Just(f a)
TheApplicative instance is not exactly the same as the in-
stance in base, but that‚Äôs for simplification. For your purposes,
it produces the same results.
First the function and datatype definitions for our functor
write-up for how we‚Äôre using the validateLength function with
NameandAddress :</p>
<p>CHAPTER 17. APPLICATIVE 1090
validateLength ::Int
-&gt;String
-&gt;MaybeString
validateLength maxLen s =
if(length s) &gt;maxLen
thenNothing
elseJusts
newtype Name=
NameStringderiving (Eq,Show)
newtype Address =
Address Stringderiving (Eq,Show)
mkName::String-&gt;MaybeName
mkNames=fmapName$validateLength 25s
mkAddress ::String-&gt;MaybeAddress
mkAddress a=
fmapAddress $validateLength 100a
Now we‚Äôre going to start filling in the definitions and ex-
panding them equationally like we did in the chapter on folds.
First we apply mkName to the value &quot;babe&quot; so thatùë†is bound
to that string:</p>
<p>CHAPTER 17. APPLICATIVE 1091
mkNames=
fmapName$validateLength 25s
mkName&quot;babe&quot;=
fmapName$validateLength 25&quot;babe&quot;
Now we need to figure out what validateLength is about since
that has to be evaluated before we know what fmapis mapping
over. Here we‚Äôre applying it to 25 and ‚Äùbabe‚Äù, evaluating the
length of the string ‚Äùbabe‚Äù, and then determining which branch
in the if-then-else wins:
validateLength ::Int
-&gt;String
-&gt;MaybeString
validateLength 25&quot;babe&quot;=
if(length &quot;babe&quot;)&gt;25
thenNothing
elseJust&quot;babe&quot;
if4&gt;25
thenNothing
elseJust&quot;babe&quot;
-- 4 isn't greater than 25, so:
validateLength 25&quot;babe&quot;=
Just&quot;babe&quot;</p>
<p>CHAPTER 17. APPLICATIVE 1092
Now we‚Äôre going to replace validateLength applied to 25 and
‚Äùbabe‚Äù with what it evaluated to, then figure out what the fmap
NameoverJust &quot;babe&quot; business is about:
mkName&quot;babe&quot;=
fmapName$Just&quot;babe&quot;
fmapName$Just&quot;babe&quot;
Keeping in mind the type of fmapfromFunctor , we see the
data constructor Nameis the function (a -&gt; b) we‚Äôre mapping
over some functorial ùëì. In this case, ùëìisMaybe. Theùëéinùëì ùëéis
String :
(a-&gt;b)-&gt;f a-&gt;f b
:tName ::(String-&gt;Name)
:tJust&quot;babe&quot;::MaybeString
typeM=Maybe
(a-&gt;b)-&gt;f a -&gt;f b
(String-&gt;Name)-&gt;MString-&gt;MName
Since we know we‚Äôre dealing with the Functor instance for
Maybe, we can inline thatfunction‚Äôs definition too!</p>
<p>CHAPTER 17. APPLICATIVE 1093
fmap_Nothing =Nothing
fmapf (Justa) =Just(f a)
-- We have (Just &quot;babe&quot;) so
-- skipping Nothing case
-- fmap _ Nothing = Nothing
fmapf (Justa) =
Just(f a)
fmapName(Just&quot;babe&quot;)=
Just(Name&quot;babe&quot;)
mkName&quot;babe&quot;=fmapName$Just&quot;babe&quot;
mkName&quot;babe&quot;=Just(Name&quot;babe&quot;)
-- f b
Maybe Applicative and Person
dataPerson=
PersonNameAddress
deriving (Eq,Show)
First we‚Äôll be using the Functor to map the Person data con-
structor over the Maybe Name value. Unlike NameandAddress ,
Person takes two arguments rather than one.</p>
<p>CHAPTER 17. APPLICATIVE 1094
Person
&lt;$&gt;Just(Name&quot;babe&quot;)
&lt;*&gt;Just(Address &quot;farm&quot;)
fmapPerson(Just(Name&quot;babe&quot;))
:tPerson::Name-&gt;Address -&gt;Person
:tJust(Name&quot;babe&quot;)::MaybeName
(a-&gt;b)-&gt;f a-&gt;f b
(Name-&gt;Address -&gt;Person)
a-&gt;b
-&gt;MaybeName-&gt;Maybe(Address -&gt;Person)
f a f b</p>
<p>CHAPTER 17. APPLICATIVE 1095
fmap_Nothing =Nothing
fmapf (Justa) =Just(f a)
fmapPerson(Just(Name&quot;babe&quot;))
f::Person
a::Name&quot;babe&quot;
-- We skip this pattern match
-- because we have Just
-- fmap _ Nothing = Nothing
fmapf ( Justa) =
Just(f a)
fmapPerson(Just(Name&quot;babe&quot;))=
Just(Person(Name&quot;babe&quot;))
The problem is Person (Name &quot;babe&quot;) is awaiting another ar-
gument, the address, so it‚Äôs a partially applied function. That‚Äôs
our(a -&gt; b) in the type of Applicative ‚Äôs(&lt;*&gt;). Theùëìwrapping
our(a -&gt; b) is theMaybewhich results from us possibly not hav-
ing had an ùëéto map over to begin with, resulting in a Nothing
value:</p>
<p>CHAPTER 17. APPLICATIVE 1096
-- Person is awaiting another argument
:tJust(Person(Name&quot;babe&quot;))
::Maybe(Address -&gt;Person)
:tJust(Address &quot;farm&quot;)::MaybeAddress
-- We want to apply the partially
-- applied (Person &quot;babe&quot;) inside the
-- 'Just' to the &quot;farm&quot; inside the Just.
Just(Person(Name&quot;babe&quot;))
&lt;<em>&gt;Just(Address &quot;farm&quot;)
So, since the function we want to map is inside the same
structure as the value we want to apply it to, we need the
Applicative (&lt;</em>&gt;) . In the following, we remind you of what the
type looks like and how the type specializes to this application:
f(a-&gt;b)-&gt;f a-&gt;f b
typeM=Maybe
typeAddy=Address
M(Addy-&gt;Person)-&gt;MAddy-&gt;MPerson
f( a-&gt;b )-&gt;f a-&gt;f b</p>
<p>CHAPTER 17. APPLICATIVE 1097
We know we‚Äôre using the Maybe Applicative , so we can go
ahead and inline the definition. Reminder that this version of
theApplicative instance is simplified from the one in GHC, so
please don‚Äôt email us to tell us our instance is wrong:
instance Applicative Maybewhere
pure=Just
Nothing &lt;<em>&gt; _ = Nothing
_ &lt;</em>&gt;Nothing =Nothing
Justf&lt;*&gt;Justa=Just(f a)
We know we can ignore the Nothing cases because our func-
tion isJust, our value is Just...and our cause is just! Just‚Ä¶kid-
ding.
If we fill in our partially applied Person constructor for ùëì,
and our Address value for ùëé, it‚Äôs not too hard to see how the
final result fits.</p>
<p>CHAPTER 17. APPLICATIVE 1098
-- Neither function nor value are Nothing,
-- so we skip these two cases
-- Nothing &lt;<em>&gt; _ = Nothing
-- _ &lt;</em>&gt; Nothing = Nothing
Justf&lt;<em>&gt;Justa=Just(f a)
Just(Person(Name&quot;babe&quot;))
&lt;</em>&gt;Just(Address &quot;farm&quot;)=
Just(Person(Name&quot;babe&quot;)
(Address &quot;farm&quot;))
Before we moooove on
dataCow=Cow{
name::String
, age ::Int
, weight ::Int
}deriving (Eq,Show)
noEmpty ::String-&gt;MaybeString
noEmpty &quot;&quot;=Nothing
noEmpty str=Juststr
noNegative ::Int-&gt;MaybeInt
noNegative n|n&gt;=0=Justn
|otherwise =Nothing</p>
<p>CHAPTER 17. APPLICATIVE 1099
-- Validating to get rid of empty
-- strings, negative numbers
cowFromString ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
cowFromString name' age' weight' =
casenoEmpty name' of
Nothing -&gt;Nothing
Justnammy-&gt;
casenoNegative age' of
Nothing -&gt;Nothing
Justagey-&gt;
casenoNegative weight' of
Nothing -&gt;Nothing
Justweighty -&gt;
Just(Cownammy agey weighty)
cowFromString is‚Ä¶bad. You can probably tell. But by the use
of Applicative, it can be improved!</p>
<p>CHAPTER 17. APPLICATIVE 1100
-- you'll need to import this if
-- you have GHC &lt;7.10
importControl.Applicative
cowFromString' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
cowFromString' name' age' weight' =
Cow&lt;$&gt;noEmpty name'
&lt;<em>&gt;noNegative age'
&lt;</em>&gt;noNegative weight'
Or if we want other Haskellers to think we‚Äôre really cool
and hip:
cowFromString'' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
cowFromString'' name' age' weight' =
liftA3Cow(noEmpty name')
(noNegative age')
(noNegative weight')</p>
<p>CHAPTER 17. APPLICATIVE 1101
So, we‚Äôre taking advantage of the Maybe Applicative here.
What does that look like? First we‚Äôll use the infix syntax for
fmap,&lt;$&gt;, and apply &lt;<em>&gt;:
Prelude&gt; let cow1 = Cow &lt;$&gt; noEmpty &quot;Bess&quot;
Prelude&gt; :t cow1
cow1 :: Maybe (Int -&gt; Int -&gt; Cow)
Prelude&gt; let cow2 = cow1 &lt;</em>&gt; noNegative 1
Prelude&gt; :t cow2
cow2 :: Maybe (Int -&gt; Cow)
Prelude&gt; let cow3 = cow2 &lt;*&gt; noNegative 2
Prelude&gt; :t cow3
cow3 :: Maybe Cow
Then with liftA3 :
Prelude&gt; let cow1 = liftA3 Cow
Prelude&gt; :t cow1
cow1 :: Applicative f
=&gt; f String -&gt; f Int -&gt; f Int -&gt; f Cow</p>
<p>CHAPTER 17. APPLICATIVE 1102
Prelude&gt; let cow2 = cow1 (noEmpty &quot;blah&quot;)
Prelude&gt; :t cow2
cow2 :: Maybe Int -&gt; Maybe Int -&gt; Maybe Cow
Prelude&gt; let cow3 = cow2 (noNegative 1)
Prelude&gt; :t cow3
cow3 :: Maybe Int -&gt; Maybe Cow
Prelude&gt; let cow4 = cow3 (noNegative 2)
Prelude&gt; :t cow4
cow4 :: Maybe Cow
So, from a simplified point of view, Applicative is really just
a way of saying:</p>
<p>CHAPTER 17. APPLICATIVE 1103
-- we fmap'd my function over some
-- functorial <code>f'' or it already -- was in </code>f'' somehow
-- f ~ Maybe
cow1::Maybe(Int-&gt;Int-&gt;Cow)
cow1=fmapCow(noEmpty &quot;Bess&quot;)
-- and we hit a situation where want to map
-- f (a -&gt; b)
-- not just (a -&gt; b)
(&lt;<em>&gt;)::Applicative f
=&gt;f (a-&gt;b)-&gt;f a-&gt;f b
-- over some f a
-- to get an f b
cow2::Maybe(Int-&gt;Cow)
cow2=cow1&lt;</em>&gt;noNegative 1
As a result, you may be able to imagine yourself saying, ‚ÄúI
want to do something kinda like an fmap, but my function is
embedded in the functorial structure too, not only the value I
want to apply my function to.‚Äù This is a basic motivation for
Applicative .
With the Applicative instance for Maybe, what we‚Äôre doing is</p>
<p>CHAPTER 17. APPLICATIVE 1104
enriching functorial application with the additional proviso
that, ‚ÄúI may not have a function at all.‚Äù
We can see this in the following specialization of the apply
function (&lt;<em>&gt;):
(&lt;</em>&gt;)::Applicative f
=&gt;f (a-&gt;b)-&gt;f a-&gt;f b
f~Maybe
typeM=Maybe
maybeApply ::M(a-&gt;b)-&gt;Ma-&gt;Mb
maybeFmap ::(a-&gt;b)-&gt;Ma-&gt;Mb
-- maybeFmap is just fmap's type
-- specialized to Maybe
You can test these specializations (more concrete versions)
of the types:</p>
<p>CHAPTER 17. APPLICATIVE 1105
maybeApply ::Maybe(a-&gt;b)
-&gt;Maybea
-&gt;Maybeb
maybeApply =(&lt;<em>&gt;)
maybeMap ::(a-&gt;b)
-&gt;Maybea
-&gt;Maybeb
maybeMap =fmap
If you make any mistakes, the compiler will let you know:
maybeMapBad ::(a-&gt;b)
-&gt;Maybea
-&gt;f b
maybeMapBad =fmap
Couldn't match type ‚Äòf1‚Äô with ‚ÄòMaybe‚Äô
‚Äòf1‚Äô is a rigid type variable bound by
an expression type signature:
(a1 -&gt; b1) -&gt; Maybe a1 -&gt; f1 b1
Exercise: Fixer Upper
Given the function and values provided, use (&lt;$&gt;)fromFunctor ,
(&lt;</em>&gt;)andpurefrom the Applicative typeclass to fill in missing
bits of the broken code to make it work.</p>
<p>CHAPTER 17. APPLICATIVE 1106
1.const&lt;$&gt;Just&quot;Hello&quot; &lt;<em>&gt;&quot;World&quot;
2.(,,,)Just90
&lt;</em>&gt;Just10Just&quot;Tierness&quot; [1,2,3]
17.6 Applicative laws
After examining the law, test each of the expressions in the
REPL.
1.Identity
Here is the definition of the identity law:
pureid&lt;*&gt;v=v
To see examples of this law, evaluate these expressions.</p>
<p>CHAPTER 17. APPLICATIVE 1107
pureid&lt;<em>&gt;[1..5]
pureid&lt;</em>&gt;Just&quot;Hello Applicative&quot;
pureid&lt;<em>&gt;Nothing
pureid&lt;</em>&gt;Left&quot;Error'ish&quot;
pureid&lt;<em>&gt;Right8001
-- ((-&gt;) a) has an instance
pureid&lt;</em>&gt;(+1)$2
As you may recall, Functor has a similar identity law, and
comparing them directly might help you see what‚Äôs hap-
pening:
id[1..5]
fmapid [1..5]
pureid&lt;*&gt;[1..5]
The identity law states that all three of those should be
equal. You can test them for equality in your REPL or you
could write a simple test to get the answer. So, what‚Äôs pure</p>
<p>CHAPTER 17. APPLICATIVE 1108
doing for us? It‚Äôs embedding our idfunction into some
structure so that we can use applyinstead of fmap.
2.Composition
Here is the definition of the composition law for applica-
tives:
pure(.)&lt;<em>&gt;u&lt;</em>&gt;v&lt;<em>&gt;w=
u&lt;</em>&gt;(v&lt;*&gt;w)
You may find the syntax a bit unusual and difficult to
read here. This is similar to the law of composition for
Functor . It is the law stating that the result of composing
our functions first and then applying them and the re-
sult of applying the functions first then composing them
should be the same. We‚Äôre using the composition opera-
tor as a prefix instead of the more usual infix, and using
purein order to embed that operator into the appropriate
structure so that it can work with apply.</p>
<p>CHAPTER 17. APPLICATIVE 1109
pure (.)
&lt;<em>&gt;[(+1)]
&lt;</em>&gt;[(<em>2)]
&lt;</em>&gt;[1,2,3]
[(+1)]&lt;<em>&gt;([(<em>2)]&lt;</em>&gt;[1,2,3])
pure (.)
&lt;</em>&gt;Just(+1)
&lt;<em>&gt;Just(<em>2)
&lt;</em>&gt;Just1
Just(+1)
&lt;</em>&gt;(Just(<em>2)&lt;</em>&gt;Just1)
This law is meant to ensure that there are no surprises
resulting from composing your function applications.
3.Homomorphism
Ahomomorphism is a structure-preserving map between
two algebraic structures. The eÔ¨Äect of applying a func-
tion that is embedded in some structure to a value that is
embedded in some structure should be the same as ap-
plying a function to a value without aÔ¨Äecting any outside
structure:</p>
<p>CHAPTER 17. APPLICATIVE 1110
puref&lt;<em>&gt;pure x=pure (f x)
That‚Äôs the statement of the law. Here‚Äôs how it looks in
practice:
pure(+1)&lt;</em>&gt;pure1
pure((+1)1)
Those two lines of code should give you the same result.
In fact, the result you see for those should be indistin-
guishable from the result of:
(+1)1
Because the structure that pureis providing there isn‚Äôt
meaningful. So you can think of this law as having to do
with the monoidal part of the applicative deal: the result
should be the result of the function application without
doing anything other than combining the structure bits.
Just as we saw how fmapis really just a special type of
function application that ignores a context or surround-
ing structure, applicative is also function application that
preserves structure. However, with applicative, since the
function being applied alsohas structure, the structures
have to be monoidal and come together in some fashion.</p>
<p>CHAPTER 17. APPLICATIVE 1111
pure(+1)&lt;<em>&gt;pure1::MaybeInt
pure((+1)1)::MaybeInt
Those two results should again be the same, but this time
the structure is being provided by Maybe, so will the result
of:
(+1)1
be equal this time around?
Here are a couple more examples to try out:
pure(+1)&lt;</em>&gt;pure1::[Int]
pure(+1)&lt;<em>&gt;pure1::EitheraInt
The general idea of the homomorphism law is that apply-
ing the function doesn‚Äôt change the structure around the
values.
4.Interchange
We begin again by looking at the definition of the inter-
change law:
u&lt;</em>&gt;pure y=pure ($y)&lt;*&gt;u</p>
<p>CHAPTER 17. APPLICATIVE 1112
It might help to break that down a bit. To the left of &lt;<em>&gt;
must always be a function embedded in some structure.
In the above definition, ùë¢represents a function embedded
in some structure:
Just(+2)&lt;</em>&gt;pure2
-- u &lt;<em>&gt; pure y
-- equals
Just4
The right side of the definition might be a bit less obvious.
By sectioning the $function application operator with
theùë¶, we create an environment in which the ùë¶is there,
awaiting a function to apply to it. Let‚Äôs try lining up the
types again and see if that clears this up:
pure($2)&lt;</em>&gt;Just(+2)
-- Remember, ($ 2) can become more concrete
($2)::Numa=&gt;(a-&gt;b)-&gt;b
Just(+2)::Numa=&gt;Maybe(a-&gt;a)
If you‚Äôre a bit confused by ($ 2), keep in mind that this
is sectioning the dollar-sign operator and applying the
second argument only, not the first. As a result, the type
changes in the following manner:</p>
<p>CHAPTER 17. APPLICATIVE 1113
-- These are the same
($2)
\f-&gt;f$2
($)::(a-&gt;b)-&gt;a-&gt;b
($2)::(a-&gt;b) -&gt;b
Then concreting the types of Applicative ‚Äôs methods:
mPure::a-&gt;Maybea
mPure=pure
embed::Numa=&gt;Maybe((a-&gt;b)-&gt;b)
embed=mPure ($2)
mApply::Maybe((a-&gt;b)-&gt;b)
-&gt;Maybe(a-&gt;b)
-&gt;Maybe b
mApply=(&lt;*&gt;)
myResult =pure ($2) <code>mApply</code> Just(+2)
-- myResult == Just 4
Then translating the types side by side, with diÔ¨Äerent
letters for some of the type variables to avoid confusion</p>
<p>CHAPTER 17. APPLICATIVE 1114
when comparing the original type with the more concrete
form:
(&lt;<em>&gt;)::Applicative f
=&gt;f (x-&gt;y)
-&gt;f x
-&gt;f y
mApply::Maybe((a-&gt;b)-&gt;b)
-&gt;Maybe(a-&gt;b)
-&gt;Maybe b
f ~Maybe
x <del>(a-&gt;b)
y ~ b
(x-&gt;y)</del>(a-&gt;b)-&gt;b
According to the interchange law, this should be true:
(Just(+2)&lt;</em>&gt;pure2)
==(pure ($2)&lt;*&gt;Just(+2))
And you can see why that should be true, because despite
the weird syntax, the two functions are doing the same
job. Here are some more examples for you to try out:</p>
<p>CHAPTER 17. APPLICATIVE 1115
[(+1), (<em>2)]&lt;</em>&gt;pure1
pure($1)&lt;<em>&gt;[(+1), (<em>2)]
Just(+3)&lt;</em>&gt;pure1
pure($1)&lt;</em>&gt;Just(+3)
EveryApplicative instance you write should obey those four
laws. This keeps your code composable and free of unpleasant
surprises.
17.7 You knew this was coming
Property testing the Applicative laws! You should have got the
gist of how to write properties based on laws, so we‚Äôre going to
use a library this time. Conal Elliott has a nice library called
checkers on Hackage and Github which provides some nice
properties and utilities for QuickCheck .
After installing checkers , we can reuse the existing proper-
ties for validating Monoids andFunctor s to revisit what we did
previously.</p>
<p>CHAPTER 17. APPLICATIVE 1116
moduleBadMonoid where
importData.Monoid
importTest.QuickCheck
importTest.QuickCheck.Checkers
importTest.QuickCheck.Classes
dataBull=
Fools
|Twoo
deriving (Eq,Show)
instance Arbitrary Bullwhere
arbitrary =
frequency [ ( 1, return Fools)
, (1, return Twoo) ]
instance MonoidBullwhere
mempty=Fools
mappend _ _ =Fools
instance EqPropBullwhere(=-=)=eq
main::IO()
main=quickBatch (monoid Twoo)</p>
<p>CHAPTER 17. APPLICATIVE 1117
There are some diÔ¨Äerences here worth noting. One is that
we don‚Äôt have to define the Monoid laws asQuickCheck properties
ourselves; they are already bundled into a TestBatch called
monoid . Another is that we need to define EqProp for our custom
datatype. This is straightforward because checkers exports a
function called eqwhich reuses the pre-existing Eqinstance
for the datatype. Finally, we‚Äôre passing a value of our type
tomonoid so it knows which Arbitrary instance to use to get
random values ‚Äî note it doesn‚Äôt usethis value for anything.
Then we can run mainto kick it oÔ¨Ä and see how it goes:
Prelude&gt; main
monoid:
left identity:
*** Failed! Falsifiable (after 1 test):
Twoo
right identity:
*** Failed! Falsifiable (after 2 tests):
Twoo
associativity: +++ OK, passed 500 tests.
As we expect, it was able to falsify left and right identity for
Bull. Now let‚Äôs test a pre-existing Applicative instance, such
as list or Maybe. The type for the TestBatch which validates
Applicative instances is a bit gnarly, so please bear with us:</p>
<p>CHAPTER 17. APPLICATIVE 1118
applicative
::(Showa,Show(m a),Show(m (a-&gt;b))
,Show(m (b-&gt;c)),Applicative m
,CoArbitrary a,EqProp(m a)
,EqProp(m b),EqProp(m c)
,Arbitrary a,Arbitrary b
,Arbitrary (m a)
,Arbitrary (m (a-&gt;b))
,Arbitrary (m (b-&gt;c)))
=&gt;m (a, b, c) -&gt;TestBatch
First, a trick for managing functions like this. We know it‚Äôs
going to want Arbitrary instances for the Applicative structure,
functions (from ùëétoùëè,ùëètoùëê) embedded in that structure, and
that it wants EqProp instances. That‚Äôs all well and good, but we
can ignore that.
m (a, b, c) -&gt;TestBatch
We just care about m (a, b, c) -&gt; TestBatch . We could pass
an actual value giving us our Applicative structure and three
values which could be of diÔ¨Äerent type, but don‚Äôt have to
be. We could also pass a bottom with a type assigned to let it
know what to randomly generate for validating the Applicative
instance.
Prelude&gt; let xs = [(&quot;b&quot;, &quot;w&quot;, 1)]</p>
<p>CHAPTER 17. APPLICATIVE 1119
Prelude&gt; quickBatch $ applicative xs
applicative:
identity: +++ OK, passed 500 tests.
composition: +++ OK, passed 500 tests.
homomorphism: +++ OK, passed 500 tests.
interchange: +++ OK, passed 500 tests.
functor: +++ OK, passed 500 tests.
Note that it defaulted the 1 :: Num a =&gt; a in order to not
have an ambiguous type. We would‚Äôve had to specify that
outside of GHCi. In the following example we‚Äôll use a bottom
to fire the typeclass dispatch:
Prelude&gt; type SSI = (String, String, Int)
Prelude&gt; :{
*Main| let trigger :: [SSI]
*Main| trigger = undefined
*Main| :}
Prelude&gt; quickBatch (applicative trigger)
applicative:
identity: +++ OK, passed 500 tests.
composition: +++ OK, passed 500 tests.
homomorphism: +++ OK, passed 500 tests.
interchange: +++ OK, passed 500 tests.
functor: +++ OK, passed 500 tests.</p>
<p>CHAPTER 17. APPLICATIVE 1120
Again, it‚Äôs not evaluating the value you pass it. That value
is just to let it know what types to use.
17.8 ZipList Monoid
The default monoid of lists in the GHC Prelude is concatena-
tion, but there is another way to monoidally combine lists.
Whereas the default list mappend ends up doing the following:
[1,2,3]&lt;&gt;[4,5,6]
-- changes to
[1,2,3]++[4,5,6]
[1,2,3,4,5,6]
TheZipList monoid combines the values of the two lists
as parallel sequences using a monoid provided by the values
themselves to get the job done:</p>
<p>CHAPTER 17. APPLICATIVE 1121
[1,2,3]&lt;&gt;[4,5,6]
-- changes to
[
1&lt;&gt;4
,2&lt;&gt;5
,3&lt;&gt;6
]
This should remind you of functions like zipandzipWith .
To make the above example work, you can assert a type like
Sum Integer for theNumvalues to get a Monoid .
Prelude&gt; import Data.Monoid
Prelude&gt; 1 &lt;&gt; 2
No instance for (Num a0) arising
from a use of ‚Äòit‚Äô
The type variable ‚Äòa0‚Äô is ambiguous
Note: there are several potential
instances:
... some blather that mentions Num ...
Prelude&gt; 1 &lt;&gt; (2 :: Sum Integer)
Sum {getSum = 3}</p>
<p>CHAPTER 17. APPLICATIVE 1122
Prelude doesn‚Äôt provide this Monoid for us, so we must define
it ourselves.
moduleApl1where
importControl.Applicative
importData.Monoid
importTest.QuickCheck
importTest.QuickCheck.Checkers
importTest.QuickCheck.Classes
Some unfortunate orphan instances follow. Try to avoid
these in code you‚Äôre going to keep or release.</p>
<p>CHAPTER 17. APPLICATIVE 1123
-- this isn't going to work properly
instance Monoida
=&gt;Monoid(ZipList a)where
mempty =ZipList []
mappend =liftA2 mappend
instance Arbitrary a
=&gt;Arbitrary (ZipList a)where
arbitrary =ZipList &lt;$&gt;arbitrary
instance Arbitrary a
=&gt;Arbitrary (Suma)where
arbitrary =Sum&lt;$&gt;arbitrary
instance Eqa
=&gt;EqProp(ZipList a)where
(=-=)=eq
If we fire this up in the REPL, and test for its validity as a
Monoid , it‚Äôll fail.
Prelude&gt; let zl = ZipList [1 :: Sum Int]
Prelude&gt; quickBatch $ monoid zl
monoid:
left identity:</p>
<p>CHAPTER 17. APPLICATIVE 1124
*** Failed! Falsifiable (after 3 tests):
ZipList [ Sum {getSum = -1} ]
right identity:
*** Failed! Falsifiable (after 4 tests):
ZipList [ Sum {getSum = -1}
, Sum {getSum = 3}
, Sum {getSum = 2} ]
associativity: +++ OK, passed 500 tests.
The problem is that the empty ZipList is thezeroand not
theidentity !
Zero vs. Identity
-- Zero
n<em>0==0
-- Identity
n</em>1==n
So how do we get an identity for ZipList ?
Sum1<code>mappend</code> ??? -&gt;Sum1
instance Monoida
=&gt;Monoid(ZipList a)where
mempty =pure mempty
mappend =liftA2 mappend</p>
<p>CHAPTER 17. APPLICATIVE 1125
You‚Äôll find out what the puredoes here when you write the
Applicative forZipList yourself.
List Applicative Exercise
Implement the list Applicative . Writing a minimally complete
Applicative instance calls for writing the definitions of both
pureand&lt;<em>&gt;. We‚Äôre going to provide a hint as well. Use the
checkers library to validate your Applicative instance.
dataLista=
Nil
|Consa (Lista)
deriving (Eq,Show)
Remember what you wrote for the list Functor :
instance Functor Listwhere
fmap=undefined
Writing the list Applicative is similar.
instance Applicative Listwhere
pure=undefined
(&lt;</em>&gt;)=undefined
Expected result:</p>
<p>CHAPTER 17. APPLICATIVE 1126
Prelude&gt; let f = Cons (+1) (Cons (<em>2) Nil)
Prelude&gt; let v = Cons 1 (Cons 2 Nil)
Prelude&gt; f &lt;</em>&gt; v
Cons 2 (Cons 3 (Cons 2 (Cons 4 Nil)))
In case you get stuck, use the following functions and hints.
append::Lista-&gt;Lista-&gt;Lista
appendNilys=ys
append(Consx xs) ys =
Consx$xs <code>append</code> ys
fold::(a-&gt;b-&gt;b)-&gt;b-&gt;Lista-&gt;b
fold_bNil =b
foldf b (Consh t)=f h (fold f b t)
concat' ::List(Lista)-&gt;Lista
concat' =fold append Nil
-- write this one in terms
-- of concat' and fmap
flatMap ::(a-&gt;Listb)
-&gt;Lista
-&gt;Listb
flatMap f as=undefined</p>
<p>CHAPTER 17. APPLICATIVE 1127
Use the above and try using flatMap andfmapwithout explic-
itly pattern matching on cons cells. You‚Äôll still need to handle
theNilcases.
flatMap is less strange than it would initially seem. It‚Äôs basi-
cally ‚Äúfmap, then smush.‚Äù
Prelude&gt; fmap (\x -&gt; [x, 9]) [1, 2, 3]
[[1,9],[2,9],[3,9]]
Prelude&gt; let toMyList = foldr Cons Nil
Prelude&gt; let xs = toMyList [1, 2, 3]
Prelude&gt; let c = Cons
Prelude&gt; let f x = x <code>c</code> (9 <code>c</code> Nil)
Prelude&gt; flatMap f xs
Cons 1 (Cons 9 (Cons 2
(Cons 9 (Cons 3 (Cons 9 Nil)))))
Applicative instances, unlike Functor s, are not guaranteed to
have a unique implementation for a given datatype.
ZipList Applicative Exercise
Implement the ZipList Applicative . Use the checkers library to
validate your Applicative instance. We‚Äôre going to provide the
EqProp instance and explain the weirdness in a moment.</p>
<p>CHAPTER 17. APPLICATIVE 1128
dataLista=
Nil
|Consa (Lista)
deriving (Eq,Show)
take'::Int-&gt;Lista-&gt;Lista
take'=undefined
instance Functor Listwhere
fmap=undefined
instance Applicative Listwhere
pure=undefined
(&lt;*&gt;)=undefined
newtype ZipList' a=
ZipList' (Lista)
deriving (Eq,Show)
instance Eqa=&gt;EqProp(ZipList' a)where
xs=-=ys=xs' <code>eq</code> ys'
wherexs'= let(ZipList' l)=xs
intake'3000l
ys'= let(ZipList' l)=ys
intake'3000l</p>
<p>CHAPTER 17. APPLICATIVE 1129
instance Functor ZipList' where
fmap f ( ZipList' xs)=
ZipList' $fmap f xs
instance Applicative ZipList' where
pure=undefined
(&lt;<em>&gt;)=undefined
The idea is to align a list of functions with a list of values
and apply the first function to the first value and so on. The
instance should work with infinite lists. Some examples:
Prelude&gt; let zl' = ZipList'
Prelude&gt; let z = zl' [(+9), (<em>2), (+8)]
Prelude&gt; let z' = zl' [1..3]
Prelude&gt; z &lt;</em>&gt; z'
ZipList' [10,4,11]
Prelude&gt; let z' = zl' (repeat 1)
Prelude&gt; z &lt;</em>&gt; z'
ZipList' [10,2,9]
Note that the second z'was an infinite list. Check Prelude
for functions that can give you what you need. One starts
with the letter z, the other with the letter r. You‚Äôre looking
for inspiration from these functions, not to be able to directly
reusethemasyou‚Äôreusingacustom Listtype, nottheprovided
Prelude list type.</p>
<p>CHAPTER 17. APPLICATIVE 1130
Explaining and justifying the weird EqProp The good news is
it‚ÄôsEqProp that has the weird ‚Äúcheck only the first 3,000 values‚Äù
semantics instead of making the Eqinstance weird. The bad
news is this is a byproduct of testing for equality between infi-
nite lists‚Ä¶that is, you can‚Äôt. If you use a typical EqProp instance,
the test for homomorphism in your Applicative instance will
chase the infinite lists forever. Since QuickCheck is already an
exercise in ‚Äúgood enough‚Äù validity checking, we could choose
to feel justified in this. If you don‚Äôt believe us try running the
following in your REPL:
repeat 1 == repeat 1
Either and Validation Applicative
Yep, here we go again with the types:
Specializing the types
-- f ~ Either e
typeE=Either
(&lt;<em>&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
(&lt;</em>&gt;)::Ee (a-&gt;b)-&gt;Ee a-&gt;Ee b
pure::a-&gt;f a
pure::a-&gt;Ee a</p>
<p>CHAPTER 17. APPLICATIVE 1131
Either versus Validation
Often the interesting part of an Applicative is the monoid. One
byproduct of this is that just as you can have more than one
validMonoid for a given datatype, unlike Functor ,Applicative
can have more than one valid and lawful instance for a given
datatype.
The following is a brief demonstration of Either :
Prelude&gt; pure 1 :: Either e Int
Right 1
Prelude&gt; Right (+1) &lt;<em>&gt; Right 1
Right 2
Prelude&gt; Right (+1) &lt;</em>&gt; Left &quot;:(&quot;
Left &quot;:(&quot;
Prelude&gt; Left &quot;:(&quot; &lt;<em>&gt; Right 1
Left &quot;:(&quot;
Prelude&gt; Left &quot;:(&quot; &lt;</em>&gt; Left &quot;sadface.png&quot;
Left &quot;:(&quot;
We‚Äôvecoveredthebenefitsof Either alreadyandwe‚Äôveshown
you what the Maybe Applicative can clean up, so we won‚Äôt be-
labor those points. There‚Äôs an alternative to Either, called
Validation , that diÔ¨Äers only in the Applicative instance:</p>
<p>CHAPTER 17. APPLICATIVE 1132
dataValidation err a=
Failure err
|Success a
deriving (Eq,Show)
One thing to realize is that this is identical to theEither
datatype and there is even a pair of total functions which can
go between Validation andEither values interchangeably. Re-
member when we mentioned natural transformations? Both
of these functions are natural transformations:
validToEither ::Validation e a
-&gt;Eithere a
validToEither (Failure err)=Lefterr
validToEither (Success a)=Righta
eitherToValid ::Eithere a
-&gt;Validation e a
eitherToValid (Lefterr)=Failure err
eitherToValid (Righta)=Success a
eitherToValid .validToEither ==id
validToEither .eitherToValid ==id
Howdoes Validation diÔ¨Äer? Principallyinwhatthe Applicative
instance does with errors. Rather than just short-circuiting</p>
<p>CHAPTER 17. APPLICATIVE 1133
when it has two error values, it‚Äôll use the Monoid typeclass to
combine them. Often this‚Äôll just be a list or set of errors but
you can do whatever you want.
dataErrors=
DividedByZero
|StackOverflow
|MooglesChewedWires
deriving (Eq,Show)
success =Success (+1)
&lt;<em>&gt;Success 1
success ==Success 2
failure =Success (+1)
&lt;</em>&gt;Failure [StackOverflow ]
failure ==Failure [StackOverflow ]
failure' =Failure [StackOverflow ]
&lt;*&gt;Success (+1)
failure' ==Failure [StackOverflow ]</p>
<p>CHAPTER 17. APPLICATIVE 1134
failures =
Failure [MooglesChewedWires ]
&lt;*&gt;Failure [StackOverflow ]
failures ==
Failure [MooglesChewedWires
,StackOverflow ]
With the value failures , we see what distinguishes Either
andValidation : we can now preserve allfailures that occurred,
not just the first one.
Exercise: Variations on Either
Validation has the same representation as Either , but it can be
diÔ¨Äerent. The Functor will behave the same, but the Applicative
willbediÔ¨Äerent. Seeaboveforanideaofhow Validation should
behave. Use the checkers library.
dataValidation e a=
Failure e
|Success a
deriving (Eq,Show)</p>
<p>CHAPTER 17. APPLICATIVE 1135
-- same as Either
instance Functor (Validation e)where
fmap=undefined
-- This is different
instance Monoide=&gt;
Applicative (Validation e)where
pure=undefined
(&lt;<em>&gt;)=undefined
17.9 Chapter Exercises
Given a type that has an instance of Applicative , specialize the
types of the methods. Test your specialization in the REPL.
One way to do this is to bind aliases of the typeclass methods
to more concrete types that have the type we told you to fill
in.
1.-- Type
[]
-- Methods
pure::a-&gt; ?a
(&lt;</em>&gt;):: ?(a-&gt;b)-&gt; ?a-&gt; ?b</p>
<p>CHAPTER 17. APPLICATIVE 1136
2.-- Type
IO
-- Methods
pure::a-&gt; ?a
(&lt;<em>&gt;):: ?(a-&gt;b)-&gt; ?a-&gt; ?b
3.-- Type
(,) a
-- Methods
pure::a-&gt; ?a
(&lt;</em>&gt;):: ?(a-&gt;b)-&gt; ?a-&gt; ?b
4.-- Type
(-&gt;) e
-- Methods
pure::a-&gt; ?a
(&lt;*&gt;):: ?(a-&gt;b)-&gt; ?a-&gt; ?b
Write instances for the following datatypes. Confused?
Write out what the type should be. Use the checkers library
to validate the instances.
1.dataPaira=Paira aderiving Show</p>
<p>CHAPTER 17. APPLICATIVE 1137
2.This should look familiar.
dataTwoa b=Twoa b
3.dataThreea b c=Threea b c
4.dataThree'a b=Three'a b b
5.dataFoura b c d =Foura b c d
6.dataFour'a b=Four'a a a b
Combinations
Remember the vowels and stops exercise in the folds chapter?
Write the function to generate the possible combinations of
three input lists using liftA3 fromControl.Applicative .
importControl.Applicative (liftA3)
stops::String
stops=&quot;pbtdkg&quot;
vowels::String
vowels=&quot;aeiou&quot;
combos::[a]-&gt;[b]-&gt;[c]-&gt;[(a, b, c)]
combos=undefined</p>
<p>CHAPTER 17. APPLICATIVE 1138
17.10 Definitions
1.Applicative can be thought of characterizing monoidal
functors in Haskell. For a Haskeller‚Äôs purposes, it‚Äôs a way
to functorially apply a function which is embedded in
structure ùëìof the same type as the value you‚Äôre mapping
it over.
fmap::(a-&gt;b)-&gt;f a-&gt;f b
(&lt;*&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
17.11 Follow-up resources
1.Tony Morris; Nick Partridge; Validation library
http://hackage.haskell.org/package/validation
2.Conor McBride; Ross Paterson; Applicative Programming
with EÔ¨Äects
http://staff.city.ac.uk/~ross/papers/Applicative.html
3.Jeremy Gibbons; Bruno C. d. S. Oliveira; Essence of the
Iterator Pattern
4.Ross Paterson; Constructing Applicative Functors
http://staff.city.ac.uk/~ross/papers/Constructors.html</p>
<p>CHAPTER 17. APPLICATIVE 1139
5.Sam Lindley; Philip Wadler; Jeremy Yallop; Idioms are
oblivious, arrows are meticulous, monads are promiscu-
ous.
Note: Idiom means applicative functor and is a useful
search term for published work on applicative functors.</p>
<p>Chapter 18
Monad
There is nothing so
practical as a good theory
Phil Wadler, quoting Kurt
Lewin
1140</p>
<p>CHAPTER 18. MONAD 1141
18.1 Monad
Finally we come to one of the most talked about structures in
Haskell: the monad. Monads are not, strictly speaking, neces-
sary to Haskell. Although the current Haskell standard does
use monad for constructing and transforming IOactions, older
implementations of Haskell did not. Monads are powerful
and fun, but they do not define Haskell. Rather, monads are
defined in terms of Haskell.
Monads are applicative functors, but they have something
special about them that makes them diÔ¨Äerent from and more
powerful than either &lt;*&gt;orfmapalone. In this chapter, we
‚Ä¢defineMonad, its operations and laws;
‚Ä¢look at several examples of monads in practice;
‚Ä¢write the Monadinstances for various types;
‚Ä¢address some misinformation about monads.
18.2 Sorry ‚Äî a monad is not a burrito
Well, then what the heck is a monad?1
1Section title with all due respect and gratitude to Mark Jason Dominus, whose
blog post, ‚ÄúMonads are like burritos‚Äù is a classic of its genre. http://blog.plover.com/prog/
burritos.html</p>
<p>CHAPTER 18. MONAD 1142
As we said above, a monad is an applicative functor with
some unique features that make it a bit more powerful than
either alone. A functor maps a function over some structure;
an applicative maps a function that is contained in some struc-
ture over some other structure and then combines the two
layers of structure like mappend . So you can think of monads
as another way of applying functions over structure, with a
couple of additional features. We‚Äôll get to those features in a
moment. For now, let‚Äôs check out the typeclass definition and
core operations.
If you are using GHC 7.10 or newer, you‚Äôll see an Applicative
constraint in the definition of Monad, as it should be:
classApplicative m=&gt;Monadmwhere
(&gt;&gt;=)::m a-&gt;(a-&gt;m b)-&gt;m b
(&gt;&gt;)::m a-&gt;m b-&gt;m b
return::a-&gt;m a
We‚Äôre going to explore this in some detail. Let‚Äôs start with
the typeclass constraint on ùëö.
Applicative m
Older versions of GHC did not have Applicative as a superclass
ofMonad. Given that Monadis stronger than Applicative , and
Applicative is stronger than Functor , you can derive Applicative
andFunctor in terms of Monad, just as you can derive Functor in</p>
<p>CHAPTER 18. MONAD 1143
terms of Applicative . What does this mean? It means you can
writefmapusing monadic operations and it works:
fmapf xs=xs&gt;&gt;=return.f
Try it for yourself:
Prelude&gt; fmap (+1) [1..3]
[2,3,4]
Prelude&gt; [1..3] &gt;&gt;= return . (+1)
[2,3,4]
Thishappenstobealaw, notaconvenience. Functor ,Applicative ,
andMonadinstances over a given type should have the same
core behavior.
We‚Äôll explore the relationship between these classes more
completely in a bit, but as part of understanding the typeclass
definition above, it‚Äôs important to understand this chain of
dependency:
Functor -&gt;Applicative -&gt;Monad
Whenever you‚Äôve implemented an instance of Monadfor a
type you necessarily have an Applicative and aFunctor as well.</p>
<p>CHAPTER 18. MONAD 1144
Core operations
TheMonadtypeclass defines three core operations, although
you only need to define &gt;&gt;=for a minimally complete Monad
instance. Let‚Äôs look at all three:
(&gt;&gt;=)::m a-&gt;(a-&gt;m b)-&gt;m b
(&gt;&gt;)::m a-&gt;m b-&gt;m b
return::a-&gt;m a
We can dispense with the last of those, return: it‚Äôs just the
same as pure. All it does is take a value and return it inside
your structure, whether that structure is a list or JustorIO. We
talked about it a bit, and used it, back in the Modules chapter,
and we covered purein theApplicative chapter, so there isn‚Äôt
much else to say about it.
Thenextoperator, &gt;&gt;, doesn‚ÄôthaveanofficialEnglish-language
name, but we like to call it Mr. Pointy. Some people do re-
fer to it as the sequencing operator, which we must admit is
more informative than Mr. Pointy. Mr. Pointy sequences
two actions while discarding any resulting value of the first
action. Applicative has a similar operator as well, although we
didn‚Äôt talk about it in that chapter. We will see examples of
this operator in the upcoming section on dosyntax.
Finally, the big bind! The&gt;&gt;=operator is called bindand is
‚Äî or, at least, comprises ‚Äî what makes Monadspecial.</p>
<p>CHAPTER 18. MONAD 1145
The novel part of Monad
Conventionallywhenweusemonads, weusethebindfunction,
&gt;&gt;=. Sometimes we use it directly, sometimes indirectly via do
syntax. The question we should ask ourselves is, what‚Äôs unique
toMonad‚Äî at least from the point of view of types?
We already saw that it‚Äôs not return ; that‚Äôs another name for
purefromApplicative .
We also noted (and will see more clearly soon) that it also
isn‚Äôt&gt;&gt;which has a counterpart in Applicative .
And it also isn‚Äôt &gt;&gt;=, at least not in its entirety. The type of
&gt;&gt;=is visibly similar to that of fmapand&lt;<em>&gt;, which makes sense
since monads are applicative functors. For the sake of making
this maximally similar, we‚Äôre going to change the ùëöofMonad
toùëì:
fmap::Functor f
=&gt;(a-&gt;b)-&gt;f a-&gt;f b
&lt;</em>&gt; :: Applicative f
=&gt;f (a-&gt;b)-&gt;f a-&gt;f b
&gt;&gt;= :: Monadf
=&gt;f a-&gt;(a-&gt;f b)-&gt;f b
OK, so bind is quite similar to &lt;*&gt;andfmapbut with the first
two arguments flipped. Still, the idea of mapping a function
over a value while bypassing its surrounding structure is not
unique to Monad.</p>
<p>CHAPTER 18. MONAD 1146
We can demonstrate this by fmapping a function of type (a
-&gt; m b) to make it more like &gt;&gt;=, and it will work. Nothing will
stop us. We will continue using the tilde to represent rough
equivalence between two things:
-- If b == f b
fmap::Functor f
=&gt;(a-&gt;f b)-&gt;f a-&gt;f (f b)
Let‚Äôs demonstrate this idea with list as our structure:
Prelude&gt; let andOne x = [x, 1]
Prelude&gt; andOne 10
[10,1]
Prelude&gt; :t fmap andOne [4, 5, 6]
fmap andOne [4, 5, 6] :: Num t =&gt; [[t]]
Prelude&gt; fmap andOne [4, 5, 6]
[[4,1],[5,1],[6,1]]
But, lo! We knew from our types that we‚Äôd end up with
anf (f b) ‚Äî that is, an extra layer of structure, and now we
have a result of nested lists. What if we wanted Num a =&gt; [a]
instead of nested lists? We want a single layer of ùëìstructure,
but our mapped function has itself generated more structure !</p>
<p>CHAPTER 18. MONAD 1147
After mapping a function that generates additional monadic
structure in its return type, we want a way to discard one layer
of that structure.
So how do we accomplish that? Well, we saw how to do
what we want with lists very early on in this book:
Prelude&gt; concat $ fmap andOne [4, 5, 6]
[4,1,5,1,6,1]
The type of concat , fully generalized:
concat::Foldable t=&gt;t [a]-&gt;[a]
-- we can assert a less general type
-- for our purposes here
concat::[[a]]-&gt;[a]
Monad, in a sense, is a generalization of concat! The unique
part ofMonadis the following function:
importControl.Monad (join)
join::Monadm=&gt;m (m a) -&gt;m a
-- compare
concat:: [[a]] -&gt;[a]</p>
<p>CHAPTER 18. MONAD 1148
It‚Äôs somewhat novel that we can inject more structure via
our function application, where applicatives and fmaps have to
leave the structure untouched. Allowing the function itself to
alter the structure is something we‚Äôve not seen in Functor and
Applicative , and we‚Äôll explore the ramifications of that ability
more, especially when we start talking about the Maybemonad.
But we caninject more structure with a standard fmapif we
wish, as we saw above. However, the ability to flatten those two
layers of structure into one is what makes Monadspecial. And
it‚Äôs by putting that joinfunction together with the mapping
function that we get bind, also known as &gt;&gt;=.
So how do we get bind?
The answer is the exercise Writebindin terms of fmapand
join.
Fear is the mind-killer, friend. You can do it.
-- keep in mind this is (&gt;&gt;=) flipped
bind::Monadm=&gt;(a-&gt;m b)-&gt;m a-&gt;m b
bind=undefined
WhatMonadis not
SinceMonadis somewhat abstract and a little slippery, many
people talk about it from one or two perspectives that they feel
most comfortable with. Quite often, they address what Monad</p>
<p>CHAPTER 18. MONAD 1149
is from the perspective of the IO Monad .IOdoes have a Monad
instance, and it is a very common use of monads. However,
understanding monads only through that instance leads to
limited intuitions for what monads are and can do, and to a
lesser extent, a wrong notion of what IOis all about.
A monad is not:
1.Impure. Monadic functions are pure functions. IOis an ab-
stract datatype that allows for impure, or eÔ¨Äectful, actions,
and it has a Monadinstance. But there‚Äôs nothing impure
about monads.
2.An embedded language for imperative programming. Si-
mon Peyton-Jones, one of the lead developers and re-
searchers of Haskell and its implementation in GHC, has
famously said, ‚ÄúHaskell is the world‚Äôs finest imperative
programming language,‚Äù and he was talking about the
way monads handle eÔ¨Äectful programming. While mon-
ads are often used for sequencing actions in a way that
looks like imperative programming, there are commuta-
tive monads that do not order actions. We‚Äôll see one a few
chapters down the line when we talk about Reader .
3.A value. The typeclass describes a specific relationship be-
tween elements in a domain and defines some operations
over them. When we refer to something as ‚Äúa monad,‚Äù</p>
<p>CHAPTER 18. MONAD 1150
we‚Äôre using that the same way we talk about ‚Äúa monoid,‚Äù
or ‚Äúa functor.‚Äù None of those are values.
4.About strictness. The monadic operations of bindand
return are nonstrict. Some operations can be made strict
within a specific instance. We‚Äôll talk more about this later
in the book.
Using monads also doesn‚Äôt require knowing math. Or cate-
gory theory. It does not require mystical trips to the tops of
mountains or starving oneself in a desert somewhere.
TheMonadtypeclass is generalized structure manipulation
withsomelawstomakeitsensible. Justlike Functor andApplicative .
We sort of hate to diminish the mystique, but that‚Äôs all there is
to it.
Monadalso lifts!
TheMonadclass also includes a set of liftfunctions that are the
same as the ones we already saw in Applicative . They don‚Äôt
do anything diÔ¨Äerent, but they are still around because some
libraries used them before applicatives were discovered, so
theliftMset of functions still exists to maintain compatibil-
ity. So, you may still see them sometimes. We‚Äôll take a short
tour of them, comparing them directly to their applicative
counterparts:</p>
<p>CHAPTER 18. MONAD 1151
liftA::Applicative f
=&gt;(a-&gt;b)-&gt;f a-&gt;f b
liftM::Monadm
=&gt;(a1-&gt;r)-&gt;m a1-&gt;m r
As you may recall, that is fmapwith a diÔ¨Äerent typeclass
constraint. If you‚Äôd like to see examples of how it works, we
encourage you to write fmapfunctions in your REPL and take
turns replacing the fmapwithliftAorliftM.
But that‚Äôs not all we have:
liftA2::Applicative f
=&gt;(a-&gt;b-&gt;c)
-&gt;f a
-&gt;f b
-&gt;f c
liftM2::Monadm
=&gt;(a1-&gt;a2-&gt;r)
-&gt;m a1
-&gt;m a2
-&gt;m r
Aside from the numbering these appear the same. Let‚Äôs try
them out:
Prelude&gt; liftA2 (,) (Just 3) (Just 5)</p>
<p>CHAPTER 18. MONAD 1152
Just (3,5)
Prelude&gt; liftM2 (,) (Just 3) (Just 5)
Just (3,5)
You may remember way back in Lists, we talked about a
function called zipWith .zipWith isliftA2 orliftM2 specialized
to lists:
Prelude&gt; :t zipWith
zipWith :: (a -&gt; b -&gt; c)
-&gt; [a] -&gt; [b] -&gt; [c]
Prelude&gt; zipWith (+) [3, 4] [5, 6]
[8,10]
Prelude&gt; liftA2 (+) [3, 4] [5, 6]
[8,9,9,10]
Well, the types are the same, but the behavior diÔ¨Äers. The
diÔ¨Äering behavior has to do with which list monoid is being
used.
All right. Then we have the threes:</p>
<p>CHAPTER 18. MONAD 1153
liftA3::Applicative f
=&gt;(a-&gt;b-&gt;c-&gt;d)
-&gt;f a-&gt;f b
-&gt;f c-&gt;f d
liftM3::Monadm
=&gt;(a1-&gt;a2-&gt;a3-&gt;r)
-&gt;m a1-&gt;m a2
-&gt;m a3-&gt;m r
And, coincidentally, there is also a zipWith3 function. Let‚Äôs
see what happens:
Prelude&gt; :t zipWith3
zipWith3 :: (a -&gt; b -&gt; c -&gt; d) -&gt;
[a] -&gt; [b] -&gt; [c] -&gt; [d]
Prelude&gt; liftM3 (,,) [1, 2] [3] [5, 6]
[(1,3,5),(1,3,6),(2,3,5),(2,3,6)]
Prelude&gt; zipWith3 (,,) [1, 2] [3] [5, 6]
[(1,3,5)]
Again, using a diÔ¨Äerent monoid gives us a diÔ¨Äerent set of
results.
We wanted to introduce these functions here because they
will come up in some later examples in the chapter, but they
aren‚Äôt especially pertinent to Monad, and we saw the gist of them</p>
<p>CHAPTER 18. MONAD 1154
in the previous chapter. So, let‚Äôs turn our attention back to
monads, shall we?
18.3 Do syntax and monads
We introduced dosyntax in the Modules chapter. We were
using it within the context of IOas syntactic sugar that allowed
us to easily sequence actions by feeding the result of one action</p>
<div style="break-before: page; page-break-before: always;"></div><p>as the input value to the next. While dosyntax works with
any monad ‚Äî not just IO‚Äî it is most commonly seen when
usingIO. This section is going to talk about why dois sugar and
demonstrate what the joinofMonadcan do for us. We will be
using the IO Monad to demonstrate here, but later on we‚Äôll see
some examples of dosyntax without IO.
To begin, let‚Äôs look at some correspondences:
(<em>&gt;) :: Applicative f =&gt; f a -&gt; f b -&gt; f b
(&gt;&gt;) :: Monad m =&gt; m a -&gt; m b -&gt; m b
For our purposes, (</em>&gt;)and(&gt;&gt;)are the same thing: sequenc-
ing functions, but with two diÔ¨Äerent constraints. They should
in all cases do the same thing:
Prelude&gt; putStrLn &quot;Hello, &quot; &gt;&gt; putStrLn &quot;World!&quot;
Hello,
World!</p>
<p>CHAPTER 18. MONAD 1155
Prelude&gt; putStrLn &quot;Hello, &quot; <em>&gt; putStrLn &quot;World!&quot;
Hello,
World!
Not observably diÔ¨Äerent. Good enough for government
work!
We can see what dosyntax looks like after the compiler
desugars it for us by manually transforming it ourselves:
importControl.Applicative ((</em>&gt;))
sequencing ::IO()
sequencing = do
putStrLn &quot;blah&quot;
putStrLn &quot;another thing&quot;
sequencing' ::IO()
sequencing' =
putStrLn &quot;blah&quot;&gt;&gt;
putStrLn &quot;another thing&quot;
sequencing'' ::IO()
sequencing'' =
putStrLn &quot;blah&quot;*&gt;
putStrLn &quot;another thing&quot;</p>
<p>CHAPTER 18. MONAD 1156
You should have had the same results for each of the above.
We can do the same with the variable binding that dosyntax
includes:
binding ::IO()
binding = do
name&lt;-getLine
putStrLn name
binding' ::IO()
binding' =
getLine &gt;&gt;=putStrLn
Instead of naming the variable and passing that as an argu-
ment to the next function, we use &gt;&gt;=which passes it directly.
Whenfmapalone isn‚Äôt enough
Note that if you try to fmap putStrLn overgetLine , it won‚Äôt do
anything. Try typing this into your REPL:
Prelude&gt; putStrLn &lt;$&gt; getLine
You‚Äôve used getLine , so when you hit enter it should await
your input. Type something in, hit enter again and see what
happens.</p>
<p>CHAPTER 18. MONAD 1157
Whatever input you gave it didn‚Äôt print, although it seems
like it should have due to the putStrLn being mapped over the
getLine . We evaluated the IOaction that requests input, but not
the one that prints it. So, what happened?
Well, let‚Äôs start with the types. The type of what you tried
to do is this:
Prelude&gt; :t putStrLn &lt;$&gt; getLine
putStrLn &lt;$&gt; getLine :: IO (IO ())
We‚Äôre going to break it down a little bit so that we‚Äôll under-
stand why this didn‚Äôt work. First, getLine performs I/O to get
aString :
getLine ::IOString
AndputStrLn takes a String argument, performs I/O, and
returns nothing interesting ‚Äî parents of children with an
allowance can sympathize:
putStrLn ::String-&gt;IO()
What is the type of fmapas it concerns putStrLn andgetLine ?</p>
<p>CHAPTER 18. MONAD 1158
-- The type we start with
&lt;$&gt; ::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
-- Our (a -&gt; b) is putStrLn
(a -&gt;b )
putStrLn ::String-&gt;IO()
Thatùëègets specialized to the type IO (), which is going to
jam another IOactioninside of the I/O that getLine performs.
Perhaps this looks familiar from our demonstration of what
happens when you use fmapto map a function with type (a -&gt;
m b)instead of (a -&gt; b) ‚Äî that is what‚Äôs happening here. This
is what is happening with our types:
f::Functor f=&gt;fString-&gt;f (IO())
fx=putStrLn &lt;$&gt;x
g::(String-&gt;b)-&gt;IOb
gx=x&lt;$&gt;getLine
putStrLn &lt;$&gt;getLine ::IO(IO())
Okay...so, which IOis which, and why does it ask for input
but not print what we typed in?</p>
<p>CHAPTER 18. MONAD 1159
-- [1] [2] [3]
h::IO(IO())
h=putStrLn &lt;$&gt;getLine
1.This outermost IOstructure represents the eÔ¨Äects getLine
must perform to get you a String that the user typed in.
2.This inner IOstructure represents the eÔ¨Äects that would
be performed ifputStrLn was evaluated.
3.The unit here is the unit that putStrLn returns.
One of the strengths of Haskell is that we can refer to, com-
pose, and map over eÔ¨Äectful computations without perform-
ing them or bending over backwards to make that pattern
work. For a simpler example of how we can wait to evalu-
ateIOactions (or any computation in general), consider the
following:
Prelude&gt; let printOne = putStrLn &quot;1&quot;
Prelude&gt; let printTwo = putStrLn &quot;2&quot;
Prelude&gt; let twoActions = (printOne, printTwo)
Prelude&gt; :t twoActions
twoActions :: (IO (), IO ())
With that tuple of two IOactions defined, we can now grab
one and evaluate it:</p>
<p>CHAPTER 18. MONAD 1160
Prelude&gt; fst twoActions
1
Prelude&gt; snd twoActions
2
Prelude&gt; fst twoActions
1
Note that we are able to evaluate IOactions multiple times.
This will be significant later.
Back to our conundrum of why we can‚Äôt fmap putStrLn over
getLine . Perhaps you‚Äôve already figured out what we need to do.
We need to join those two IOlayers together. To get what we
want, we need the unique thing that MonadoÔ¨Äers:join. Watch
it work:
Prelude&gt; import Control.Monad (join)
Prelude&gt; join $ putStrLn &lt;$&gt; getLine
blah
blah
Prelude&gt; :t join $ putStrLn &lt;$&gt; getLine
join $ putStrLn &lt;$&gt; getLine :: IO ()
Whatjoindidhereis mergetheeÔ¨Äectsof getLine andputStrLn
into a single IOaction. This merged IOaction performs the
eÔ¨Äects in the order determined by the nesting of the IOactions.
As it happens, the cleanest way to express ordering in a lambda</p>
<p>CHAPTER 18. MONAD 1161
calculus without bolting on something unpleasant is through
nesting of expressions or lambdas.
That‚Äôs right. We still haven‚Äôt left the lambda calculus behind.
Monadic sequencing and dosyntax seem on the surface to
be very far removed from that. But they aren‚Äôt. As we said,
monadic actions are still pure, and the sequencing operations
we use here are ways of nesting lambdas. Now, IOis a bit dif-
ferent, as it does allow for side eÔ¨Äects, but since those eÔ¨Äects
are constrained within the IOtype, all the rest of it is still a
pure lambda calculus.
Sometimes it is valuable to suspend or otherwise not per-
form an I/O action until some determination is made, so types
likeIO (IO ()) aren‚Äôt necessarily invalid, but you should be
aware of what‚Äôs needed to make this example work.
Let‚Äôsgetbacktodesugaring dosyntaxwithournow-enriched
understanding of what monads do for us:</p>
<p>CHAPTER 18. MONAD 1162
bindingAndSequencing ::IO()
bindingAndSequencing = do
putStrLn &quot;name pls:&quot;
name&lt;-getLine
putStrLn ( &quot;y helo thar: &quot; ++name)
bindingAndSequencing' ::IO()
bindingAndSequencing' =
putStrLn &quot;name pls:&quot; &gt;&gt;
getLine &gt;&gt;=
\name-&gt;
putStrLn ( &quot;y helo thar: &quot; ++name)
As the nesting intensifies, you can see how dosyntax can
make things a bit cleaner and easier to read:
twoBinds ::IO()
twoBinds = do
putStrLn &quot;name pls:&quot;
name&lt;-getLine
putStrLn &quot;age pls:&quot;
age&lt;-getLine
putStrLn ( &quot;y helo thar: &quot;
++name++&quot; who is: &quot;
++age++&quot; years old.&quot; )</p>
<p>CHAPTER 18. MONAD 1163
twoBinds' ::IO()
twoBinds' =
putStrLn &quot;name pls:&quot; &gt;&gt;
getLine &gt;&gt;=
\name-&gt;
putStrLn &quot;age pls:&quot; &gt;&gt;
getLine &gt;&gt;=
\age-&gt;
putStrLn ( &quot;y helo thar: &quot;
++name++&quot; who is: &quot;
++age++&quot; years old.&quot; )
18.4 Examples of Monaduse
All right, we‚Äôve seen what is diÔ¨Äerent about Monadand seen a
small demonstration of what that does for us. What we need
now is to see how monads work in code, with Monads other than
IO.
List
We‚Äôve been starting oÔ¨Ä our examples of these typeclasses in
use with list examples because they can be quite easy to see
and understand. We will keep this section brief, though, as we
have more exciting things to show you.</p>
<p>CHAPTER 18. MONAD 1164
Specializing the types
This process should be familiar to you by now:
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b)-&gt;m b
(&gt;&gt;=)::[ ] a-&gt;(a-&gt;[ ] b)-&gt;[ ] b
-- or more syntactically common
(&gt;&gt;=)::[a]-&gt;(a-&gt;[b])-&gt;[b]
-- same as pure
return::Monadm=&gt;a-&gt;m a
return:: a-&gt;[ ] a
return:: a-&gt;[a]
Excellent. It‚Äôs like fmapexcept the order of arguments is
flipped and we can now generate more list (or an empty list)
inside of our mapped function. Let‚Äôs take it for a spin.
Example of the List Monadin use
Let‚Äôs start with a function and identify how the parts fit with
our monadic types:</p>
<p>CHAPTER 18. MONAD 1165
twiceWhenEven ::[Integer]-&gt;[Integer]
twiceWhenEven xs= do
x&lt;-xs
ifeven x
then[x<em>x, x</em>x]
else[x<em>x]
Thex &lt;- xs line binds individual values out of the list input,
like a list comprehension, giving us an ùëé. Theif-then-else is
oura -&gt; m b . It takes the individual ùëévalues that have been
bound out of our m aand can generate more values, thereby
increasing the size of the list.
Them athat is our first input will be the argument we pass
to it below:
Prelude&gt; twiceWhenEven [1..3]
[1,4,4,9]
Now try this:
twiceWhenEven ::[Integer]-&gt;[Integer]
twiceWhenEven xs= do
x&lt;-xs
ifeven x
then[x</em>x, x*x]
else[]</p>
<p>CHAPTER 18. MONAD 1166
And try giving it the same input as above (for easy compar-
ison). Was the result what you expected? Keep playing around
with this, forming hypotheses about what will happen and
why and testing them in the REPL to develop an intuition for
how monads are working on a simple example. The examples
in the next sections are longer and more complex.
Maybe Monad
Now we come to a more exciting demonstration of what we
can do with our newfound power.
Specializing the types
It is the season for examining the types:
-- type M = Maybe
-- m ~ Maybe
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b)-&gt;m b
(&gt;&gt;=)::
Maybea-&gt;(a-&gt;Maybeb)-&gt;Maybeb
-- same as pure
return::Monadm=&gt;a-&gt;m a
return:: a-&gt;Maybea</p>
<p>CHAPTER 18. MONAD 1167
There should have been nothing surprising there, so let‚Äôs
get to the meat of the matter.
Using the Maybe Monad
This example looks like the one from the Applicative chapter,
but it‚Äôs diÔ¨Äerent. We encourage you to compare the two, al-
though we‚Äôve been explicit about what exactly is happening
here. You developed some intutions above for dosyntax and
the listMonad; here we‚Äôll be quite explicit about what‚Äôs happen-
ing, and by the time we get to the Either demonstration below,
it should be clear. Let‚Äôs get started:
dataCow=Cow{
name::String
, age ::Int
, weight ::Int
}deriving (Eq,Show)
noEmpty ::String-&gt;MaybeString
noEmpty &quot;&quot;=Nothing
noEmpty str=Juststr
noNegative ::Int-&gt;MaybeInt
noNegative n|n&gt;=0=Justn
|otherwise =Nothing</p>
<p>CHAPTER 18. MONAD 1168
-- if Cow's name is Bess, must be under 500
weightCheck ::Cow-&gt;MaybeCow
weightCheck c=
letw=weight c
n=name c
in ifn==&quot;Bess&quot;&amp;&amp;w&gt;499
thenNothing
elseJustc
mkSphericalCow ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow name' age' weight' =
casenoEmpty name' of
Nothing -&gt;Nothing
Justnammy-&gt;
casenoNegative age' of
Nothing -&gt;Nothing
Justagey-&gt;
casenoNegative weight' of
Nothing -&gt;Nothing
Justweighty -&gt;
weightCheck
(Cownammy agey weighty)</p>
<p>CHAPTER 18. MONAD 1169
Prelude&gt; mkSphericalCow &quot;Bess&quot; 5 499
Just (Cow {name = &quot;Bess&quot;, age = 5, weight = 499})
Prelude&gt; mkSphericalCow &quot;Bess&quot; 5 500
Nothing
First, we‚Äôll clean it up with dosyntax, then we‚Äôll see why we
can‚Äôt do this with Applicative :
-- Do syntax isn't just for IO.
mkSphericalCow' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow' name' age' weight' = do
nammy&lt;-noEmpty name'
agey&lt;-noNegative age'
weighty &lt;-noNegative weight'
weightCheck ( Cownammy agey weighty)
And this works as expected.
Prelude&gt; mkSphericalCow' &quot;Bess&quot; 5 500
Nothing
Prelude&gt; mkSphericalCow' &quot;Bess&quot; 5 499
Just (Cow {name = &quot;Bess&quot;, age = 5, weight = 499})</p>
<p>CHAPTER 18. MONAD 1170
Can we write it with (&gt;&gt;=)? Sure!
-- Stack up the nested lambdas.
mkSphericalCow'' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow'' name' age' weight' =
noEmpty name' &gt;&gt;=
\nammy-&gt;
noNegative age' &gt;&gt;=
\agey-&gt;
noNegative weight' &gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)
So why can‚Äôt we do this with Applicative ? Because our
weightCheck function depends on the prior existence of a Cow
value and returns more monadic structure in its return type
Maybe Cow .
If your dosyntax looks like this:</p>
<p>CHAPTER 18. MONAD 1171
doSomething = do
a&lt;-f
b&lt;-g
c&lt;-h
pure (a, b, c)
You can rewrite it using Applicative . On the other hand, if
you have something like this:
doSomething' n= do
a&lt;-f n
b&lt;-g a
c&lt;-h b
pure (a, b, c)
You‚Äôre going to need Monadbecause ùëîand‚Ñéare producing
monadic structure based on values that can only be obtained
by depending on values generated from monadic structure.
You‚Äôll need jointo crunch the nesting of monadic structure
back down. If you don‚Äôt believe us, try translating doSomething'
toApplicative : so no resorting to &gt;&gt;=orjoin.
Here‚Äôs some code to kick that around:
f::Integer -&gt;MaybeInteger
f0=Nothing
fn=Justn</p>
<p>CHAPTER 18. MONAD 1172
g::Integer -&gt;MaybeInteger
gi=
ifeven i
thenJust(i+1)
elseNothing
h::Integer -&gt;MaybeString
hi=Just(&quot;10191&quot; ++show i)
doSomething' n= do
a&lt;-f n
b&lt;-g a
c&lt;-h b
pure (a, b, c)
The long and short of it:
1.With the Maybe Applicative , eachMaybecomputation fails
or succeeds independently of each other. You‚Äôre lifting
functions that are also JustorNothing overMaybevalues.
2.With the Maybe Monad , computations contributing to the
final result can choose to return Nothing based on previous
computations.</p>
<p>CHAPTER 18. MONAD 1173
Exploding a spherical cow
We said we‚Äôd be quite explicit about what‚Äôs happening in the
above, so let‚Äôs do this thing. Let‚Äôs get in the guts of this code
and how binding over Maybevalues works.
For once, this example instance is what‚Äôs in GHC‚Äôs base
library at time of writing:
instance MonadMaybewhere
return x =Justx
(Justx)&gt;&gt;=k=k x
Nothing &gt;&gt;= _ = Nothing
mkSphericalCow'' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow'' name' age' weight' =
noEmpty name' &gt;&gt;=
\nammy-&gt;
noNegative age' &gt;&gt;=
\agey-&gt;
noNegative weight' &gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)</p>
<p>CHAPTER 18. MONAD 1174
And what happens if we pass it some arguments?
-- Proceeding outermost to innermost.
mkSphericalCow'' &quot;Bess&quot;5499=
noEmpty &quot;Bess&quot;&gt;&gt;=
\nammy-&gt;
noNegative 5&gt;&gt;=
\agey-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)
-- &quot;Bess&quot; /= &quot;&quot;, so skipping this pattern
-- noEmpty &quot;&quot; = Nothing
noEmpty &quot;Bess&quot;=Just&quot;Bess&quot;
So we produced the value Just &quot;Bess&quot; ; however, nammywill
be theString and not also the Maybestructure because &gt;&gt;=passes
ùëéto the function it binds over the monadic value, not ùëöùëé. Here
we‚Äôll use the Maybe Monad instance to examine why:</p>
<p>CHAPTER 18. MONAD 1175
instance MonadMaybewhere
return x =Justx
(Justx)&gt;&gt;=k=k x
Nothing &gt;&gt;= _ = Nothing
noEmpty &quot;Bess&quot;&gt;&gt;=\nammy-&gt;
(restofthe computation)
-- noEmpty &quot;Bess&quot; evaluated
-- to Just &quot;Bess&quot;. So the first
-- Just case matches.
(Just&quot;Bess&quot;)&gt;&gt;=\nammy-&gt; ...
(Justx)&gt;&gt;=k=k x
-- k is \nammy et al.
-- x is &quot;Bess&quot; by itself.
Sonammyis bound to ‚ÄùBess‚Äù, and the following is the whole ùëò:
&quot;Bess&quot;-&gt;
noNegative 5&gt;&gt;=
\agey-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)</p>
<p>CHAPTER 18. MONAD 1176
Then how does the age check go?
mkSphericalCow'' &quot;Bess&quot;5499=
noEmpty &quot;Bess&quot;&gt;&gt;=
&quot;Bess&quot;-&gt;
noNegative 5&gt;&gt;=
\agey-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cow&quot;Bess&quot;agey weighty)
-- 5 &gt;= 0 is true, so we get Just 5
noNegative 5|5&gt;=0=Just5
|otherwise =Nothing
Again, although noNegative returns Just 5 , thebindfunction
will pass 5 on:</p>
<p>CHAPTER 18. MONAD 1177
mkSphericalCow'' &quot;Bess&quot;5499=
noEmpty &quot;Bess&quot;&gt;&gt;=
&quot;Bess&quot;-&gt;
noNegative 5&gt;&gt;=
\5-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cow&quot;Bess&quot;5weighty)
-- 499 &gt;= 0 is true, so we get Just 499
noNegative 499|499&gt;=0=Just499
|otherwise =Nothing
Passing 499 on:
mkSphericalCow'' &quot;Bess&quot;5499=
noEmpty &quot;Bess&quot;&gt;&gt;=
&quot;Bess&quot;-&gt;
noNegative 5&gt;&gt;=
\5-&gt;
noNegative 499&gt;&gt;=
\499-&gt;
weightCheck ( Cow&quot;Bess&quot;5499)</p>
<p>CHAPTER 18. MONAD 1178
weightCheck (Cow&quot;Bess&quot;5499)=
let499=weight ( Cow&quot;Bess&quot;5499)
&quot;Bess&quot;=name (Cow&quot;Bess&quot;5499)
-- fyi, 499 &gt; 499 is False.
in if&quot;Bess&quot;==&quot;Bess&quot;&amp;&amp;499&gt;499
thenNothing
elseJust(Cow&quot;Bess&quot;5499)
So in the end, we return Just (Cow &quot;Bess&quot; 5 499) .
Fail fast, like an overfunded startup
But what if we had failed? We‚Äôll dissect the following compu-
tation:
Prelude&gt; mkSphericalCow'' &quot;&quot; 5 499
Nothing
And how do the guts fall when we explode this poor bovine?</p>
<p>CHAPTER 18. MONAD 1179
mkSphericalCow'' &quot;&quot;5499=
noEmpty &quot;&quot;&gt;&gt;=
\nammy-&gt;
noNegative 5&gt;&gt;=
\agey-&gt;
noNegative 499&gt;&gt;=
\weighty -&gt;
weightCheck ( Cownammy agey weighty)
-- &quot;&quot; == &quot;&quot;, so we get the Nothing case
noEmpty &quot;&quot;=Nothing
-- noEmpty str = Just str
After we‚Äôve evaluated noEmpty &quot;&quot; and gotten a Nothing value,
we use(&gt;&gt;=). How does that go?</p>
<p>CHAPTER 18. MONAD 1180
instance MonadMaybewhere
return x =Justx
(Justx)&gt;&gt;=k=k x
Nothing &gt;&gt;= _ = Nothing
-- noEmpty &quot;&quot; := Nothing
Nothing &gt;&gt;=
\nammy-&gt;
-- Just case doesn't match, so skip it.
-- (Just x) &gt;&gt;= k = k x
-- This is what we're doing.
Nothing &gt;&gt;= _ = Nothing
So it turns out that the bindfunction will drop the entire
rest of the computation on the floor the moment anyof the
functions participating in the Maybe Monad actions produce a
Nothing value:
mkSphericalCow'' &quot;&quot;5499=
Nothing &gt;&gt;=-- NOPE.
In fact, you can demonstrate to yourself that that stuÔ¨Ä never
gets used with bottom , but does with a Justvalue:</p>
<p>CHAPTER 18. MONAD 1181
Prelude&gt; Nothing &gt;&gt;= undefined
Nothing
Prelude&gt; Just 1 &gt;&gt;= undefined
*** Exception: Prelude.undefined
But why do we use the Maybe Applicative andMonad? Because
this:
mkSphericalCow' ::String
-&gt;Int
-&gt;Int
-&gt;MaybeCow
mkSphericalCow' name' age' weight' = do
nammy&lt;-noEmpty name'
agey&lt;-noNegative age'
weighty &lt;-noNegative weight'
weightCheck ( Cownammy agey weighty)
is a lot nicer than case matching the Nothing case over and
over just so we can say Nothing -&gt; Nothing a million times. Life
is too short for repetition when computers lovetaking care of
repetition.
Either
Whew. Let‚Äôs all be thankful that cow was full of Maybevalues
and not tripe. Moving along, we‚Äôre going to demonstrate use</p>
<p>CHAPTER 18. MONAD 1182
of theEither Monad , step back a bit, and let your intuitions and
what you learned about Maybeguide you through.
Specializing the types
As always, we present the types:
-- m ~ Either e
(&gt;&gt;=)::Monadm
=&gt; m a
-&gt;(a-&gt; m b)
-&gt; m b
(&gt;&gt;=)::Eithere a
-&gt;(a-&gt;Eithere b)
-&gt;Eithere b
-- same as pure
return::Monadm=&gt;a-&gt; m aq
return:: a-&gt;Eithere a
Why do we keep doing this? To remind you that the types
always show you the way, once you‚Äôve figured them out.
Using the Either Monad
Use what you know to go carefully through this code and
follow the types. First, we define our datatypes:</p>
<p>CHAPTER 18. MONAD 1183
moduleEitherMonad where
-- years ago
typeFounded =Int
-- number of programmers
typeCoders=Int
dataSoftwareShop =
Shop{
founded ::Founded
, programmers ::Coders
}deriving (Eq,Show)
dataFoundedError =
NegativeYears Founded
|TooManyYears Founded
|NegativeCoders Coders
|TooManyCoders Coders
|TooManyCodersForYears Founded Coders
deriving (Eq,Show)
Let‚Äôs bring some functions now:</p>
<p>CHAPTER 18. MONAD 1184
validateFounded
::Int
-&gt;EitherFoundedError Founded
validateFounded n
|n&lt;0=Left$NegativeYears n
|n&gt;500=Left$TooManyYears n
|otherwise =Rightn
-- Tho, many programmers <em>are</em> negative.
validateCoders
::Int
-&gt;EitherFoundedError Coders
validateCoders n
|n&lt;0=Left$NegativeCoders n
|n&gt;5000=Left$TooManyCoders n
|otherwise =Rightn</p>
<p>CHAPTER 18. MONAD 1185
mkSoftware
::Int
-&gt;Int
-&gt;EitherFoundedError SoftwareShop
mkSoftware years coders = do
founded &lt;-validateFounded years
programmers &lt;-validateCoders coders
ifprogrammers &gt;div founded 10
thenLeft$
TooManyCodersForYears
founded programmers
elseRight$Shopfounded programmers
Note that Either always short-circuits on the firstthing to
have failed. It mustbecause in the Monad, later values can depend
on previous ones:
Prelude&gt; mkSoftware 0 0
Right (Shop {founded = 0, programmers = 0})
Prelude&gt; mkSoftware (-1) 0
Left (NegativeYears (-1))
Prelude&gt; mkSoftware (-1) (-1)
Left (NegativeYears (-1))
Prelude&gt; mkSoftware 0 (-1)</p>
<p>CHAPTER 18. MONAD 1186
Left (NegativeCoders (-1))
Prelude&gt; mkSoftware 500 0
Right (Shop {founded = 500, programmers = 0})
Prelude&gt; mkSoftware 501 0
Left (TooManyYears 501)
Prelude&gt; mkSoftware 501 501
Left (TooManyYears 501)
Prelude&gt; mkSoftware 100 5001
Left (TooManyCoders 5001)
Prelude&gt; mkSoftware 0 500
Left (TooManyCodersForYears 0 500)
So, there is no MonadforValidation .Applicative andMonadin-
stances must have the same behavior. This is usually expressed
in the form:
importControl.Monad (ap)
(&lt;*&gt;)==ap
This is a way of saying the Applicative apply for a type must
not change behavior if derived from the Monadinstance‚Äôs bind</p>
<p>CHAPTER 18. MONAD 1187
operation.
-- Keeping in mind
(&lt;<em>&gt;)::Applicative f
=&gt;f (a-&gt;b)-&gt;f a-&gt;f b
ap::Monadm
=&gt;m (a-&gt;b)-&gt;m a-&gt;m b
Then deriving Applicative (&lt;</em>&gt;) from the stronger instance:
ap::(Monadm)=&gt;m (a-&gt;b)-&gt;m a-&gt;m b
apm m'= do
x&lt;-m
x'&lt;-m'
return (x x')
The problem is you can‚Äôt make a MonadforValidation that
accumulates the errors like the Applicative does. Instead, any
Monadinstance for Validation would be identical to Either ‚ÄôsMonad
instance.
Short Exercise: Either Monad
Implement the Either Monad .</p>
<p>CHAPTER 18. MONAD 1188
dataSuma b=
Firsta
|Secondb
deriving (Eq,Show)
instance Functor (Suma)where
fmap=undefined
instance Applicative (Suma)where
pure=undefined
(&lt;*&gt;)=undefined
instance Monad(Suma)where
return=pure
(&gt;&gt;=)=undefined
18.5 Monad laws
TheMonadtypeclass has laws, as the other typeclasses do. These
laws exist, as with all the other typeclass laws, to ensure that
your code does nothing surprising or harmful. If the Monad
instance you write for your type abides by these laws, then
your monads should work as you want them to. To write your
own instance, you only have to define a &gt;&gt;=operation, but you
want your binding to be as predictable as possible.</p>
<p>CHAPTER 18. MONAD 1189
Identity laws
Monadhas two identity laws:
-- right identity
m&gt;&gt;=return =m
-- left identity
returnx&gt;&gt;=f=f x
Basically both of these laws are saying that return should be
neutral and not perform any computation. We‚Äôll line them up
with the type of &gt;&gt;=to clarify what‚Äôs happening:
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b)-&gt;m b
-- [1] [2] [3]
First, right identity:
return::a-&gt;m a
m&gt;&gt;=return =m
-- [1] [2] [3]
Theùëödoes represent an m aandm b, respectively, so the
structure is there even if it‚Äôs not apparent from the way the
law is written.</p>
<p>CHAPTER 18. MONAD 1190
And left identity:
-- applying return to x gives us an
-- m a value to start
return x &gt;&gt;=f=f x
-- [1] [2] [3]
Likepure,return shouldn‚Äôt change any of the behavior of the
rest of the function; it is only there to put things into structure
when we need to, and the existence of the structure should
not aÔ¨Äect the computation.
Associativity
The law of associativity is not so diÔ¨Äerent from other laws of
associativity we have seen. It does look a bit diÔ¨Äerent because
of the nature of &gt;&gt;=:
(m&gt;&gt;=f)&gt;&gt;=g=m&gt;&gt;=(\x-&gt;f x&gt;&gt;=g)
Regrouping the functions should not have any impact on
the final result, same as the associativity of Monoid . The syntax
there, in which, for the right side of the equals sign, we had to
pass in an ùë•argument might seem confusing at first. So, let‚Äôs
look at it more carefully.
This side looks the way we expect it to:</p>
<p>CHAPTER 18. MONAD 1191
(m&gt;&gt;=f)&gt;&gt;=g
But remember that (&gt;&gt;=)allows the result value of one func-
tion to be passed as input to the next, like function application
but with our value at the left and successive functions proceed-
ing to the right. Remember this code?
getLine &gt;&gt;=putStrLn
The IO action for getLine is evaluated first, then putStrLn is
passed the input string that resulted from running getLine ‚Äôs
eÔ¨Äects. This left-to-right is partly down to the history of IOin
Haskell ‚Äî it‚Äôs so the ‚Äúorder‚Äù of the code reads top to bottom.
We‚Äôll explain this more later in the book.
When we reassociate them, we need to apply ùëìso thatùëîhas
an input value of type m ato start the whole thing oÔ¨Ä. So, we
pass in the argument ùë•via an anonymous function:
m&gt;&gt;=(\x-&gt;f x&gt;&gt;=g)
And bada bing, now nothing can slow this roll.
We‚Äôre doing that thing again
Out of mercy, we‚Äôll be using checkers (not Nixon‚Äôs dog) again.
The argument the Monad TestBatch wants is identical to the
Applicative , a tuple of three value types embedded in the struc-
tural type.</p>
<p>CHAPTER 18. MONAD 1192
Prelude&gt; quickBatch (monad [(1, 2, 3)])
monad laws:
left identity: +++ OK, passed 500 tests.
right identity: +++ OK, passed 500 tests.
associativity: +++ OK, passed 500 tests.
Going forward we‚Äôll be using this to validate Monadinstances.
Let‚Äôs write a bad Monadto see what it can catch for us.
BadMonads and their denizens
We‚Äôre going to write an invalid Monad(andFunctor ). You could
pretend it‚Äôs Identity with an integer thrown in which gets in-
cremented on each fmapor bind.
moduleBadMonad where
importTest.QuickCheck
importTest.QuickCheck.Checkers
importTest.QuickCheck.Classes</p>
<p>CHAPTER 18. MONAD 1193
dataCountMe a=
CountMe Integer a
deriving (Eq,Show)
instance Functor CountMe where
fmap f ( CountMe i a)=
CountMe (i+1) (f a)
instance Applicative CountMe where
pure=CountMe 0
CountMe n f&lt;*&gt;CountMe n' a=
CountMe (n+n') (f a)
instance MonadCountMe where
return=pure
CountMe n a&gt;&gt;=f=
letCountMe _b=f a
inCountMe (n+1) b</p>
<p>CHAPTER 18. MONAD 1194
instance Arbitrary a
=&gt;Arbitrary (CountMe a)where
arbitrary =
CountMe &lt;$&gt;arbitrary &lt;*&gt;arbitrary
instance Eqa=&gt;EqProp(CountMe a)where
(=-=)=eq
main= do
lettrigger ::CountMe (Int,String,Int)
trigger =undefined
quickBatch $functor trigger
quickBatch $applicative trigger
quickBatch $monad trigger
When we run the tests, the Functor andMonadwill fail top
to bottom. The Applicative technically only failed the laws
because Functor did; in the Applicative instance we were using
a proper monoid-of-structure.
Prelude&gt; main
functor:
identity: *** Failed! Falsifiable (after 1 test):
CountMe 0 0
compose: *** Failed! Falsifiable (after 1 test):</p>
<p>CHAPTER 18. MONAD 1195
<function>
<function>
CountMe 0 0
applicative:
identity: +++ OK, passed 500 tests.
composition: +++ OK, passed 500 tests.
homomorphism: +++ OK, passed 500 tests.
interchange: +++ OK, passed 500 tests.
functor: *** Failed! Falsifiable (after 1 test):
<function>
CountMe 0 0
monad laws:
left identity: *** Failed! Falsifiable (after 1 test):
<function>
0
right identity: *** Failed! Falsifiable (after 1 test):
CountMe 0 0
associativity: *** Failed! Falsifiable (after 1 test):
CountMe 0 0
We can reapply the weird, broken increment semantics and
get a broken Applicative as well.</p>
<p>CHAPTER 18. MONAD 1196
instance Applicative CountMe where
pure=CountMe 0
CountMe n f&lt;*&gt;CountMe _a=
CountMe (n+1) (f a)
Now it‚Äôs allbroken.
applicative:
identity:
*** Failed! Falsifiable (after 1 test):
CountMe 0 0
composition:
*** Failed! Falsifiable (after 1 test):
CountMe 0 <function>
CountMe 0 <function>
CountMe 0 0
homomorphism:
*** Failed! Falsifiable (after 1 test):
<function>
0
interchange:
*** Failed! Falsifiable (after 3 tests):
CountMe (-1) <function>
0
Understanding what makes sense structurally for a Functor ,
Applicative , andMonoid can tell you what is potentially an in-</p>
<p>CHAPTER 18. MONAD 1197
valid instance before you‚Äôve written any code. Incidentally,
even if you fix the Functor andApplicative instances, the Monad
instance is not yet fixed.
instance Functor CountMe where
fmap f ( CountMe i a)=CountMe i (f a)
instance Applicative CountMe where
pure=CountMe 0
CountMe n f&lt;*&gt;CountMe n' a=
CountMe (n+n') (f a)
instance MonadCountMe where
return=pure
CountMe _a&gt;&gt;=f=f a
This‚Äôll pass as a valid Functor andApplicative , but it‚Äôs not a
validMonad. The problem is that while puresetting the integer
value to zero is fine for the purposes of the Applicative , but it
violates the right identity law of Monad.
Prelude&gt; CountMe 2 &quot;blah&quot; &gt;&gt;= return
CountMe 0 &quot;blah&quot;
So ourpureis too opinionated. Still a valid Applicative and
Functor , but what if puredidn‚Äôt agree with the Monoid of the</p>
<p>CHAPTER 18. MONAD 1198
structure? The following will pass the Functor laws but it isn‚Äôt a
validApplicative .
instance Functor CountMe where
fmap f ( CountMe i a)=CountMe i (f a)
instance Applicative CountMe where
pure=CountMe 1
CountMe n f&lt;<em>&gt;CountMe n' a=
CountMe (n+n') (f a)
As it happens, if we change the monoid-of-structure to
match the identity such that we have addition and the number
zero, it‚Äôs a valid Applicative again.
instance Applicative CountMe where
pure=CountMe 0
CountMe n f&lt;</em>&gt;CountMe n' a=
CountMe (n+n') (f a)
As you gain experience with these structures, you‚Äôll learn to
identify what might have a valid Applicative but no valid Monad
instance. But how do we fix the Monadinstance? By fixing the
underlying Monoid !</p>
<p>CHAPTER 18. MONAD 1199
instance MonadCountMe where
return=pure
CountMe n a&gt;&gt;=f=
letCountMe n' b=f a
inCountMe (n+n') b
Once our Monadinstance starts summing the counts like the
Applicative did, it works fine! It can be easy at times to acciden-
tally write an invalid Monadthat typechecks, so it‚Äôs important to
useQuickCheck to validate your Monoid ,Functor ,Applicative , and
Monadinstances.
18.6 Application and composition
What we‚Äôve seen so far has been primarily about function
application. We probably weren‚Äôt thinking too much about the
relationship between function application and composition
because with Functor andApplicative it hadn‚Äôt mattered much.
Both concerned functions that looked like the usual (a -&gt; b)
arrangement, so composition ‚Äújust worked‚Äù and that this was
true was guaranteed by the laws of those typeclasses:</p>
<p>CHAPTER 18. MONAD 1200
fmapid=id
-- guarantees
fmapf.fmap g=fmap (f .g)
Which means composition under functors just works:
Prelude&gt; fmap ((+1) . (+2)) [1..5]
[4,5,6,7,8]
Prelude&gt; fmap (+1) . fmap (+2) $ [1..5]
[4,5,6,7,8]
WithMonadthe situation seems less neat at first. Let‚Äôs attempt
to define composition for monadic functions in a simple way:
mcomp::Monadm=&gt;
(b-&gt;m c)
-&gt;(a-&gt;m b)
-&gt;a-&gt;m c
mcompf g a=f (g a)
If we try to load this, we‚Äôll get an error like this:
Couldn't match expected type ‚Äòb‚Äô
with actual type ‚Äòm b‚Äô
‚Äòb‚Äô is a rigid type variable bound</p>
<p>CHAPTER 18. MONAD 1201
by the type signature for
mcomp :: Monad m =&gt;
(b -&gt; m c)
-&gt; (a -&gt; m b)
-&gt; a -&gt; m c
at kleisli.hs:21:9
Relevant bindings include
g :: a -&gt; m b (bound at kleisli.hs:22:8)
f :: b -&gt; m c (bound at kleisli.hs:22:6)
mcomp :: (b -&gt; m c)
-&gt; (a -&gt; m b)
-&gt; a -&gt; m c
(bound at kleisli.hs:22:1)
In the first argument of ‚Äòf‚Äô, namely ‚Äò(g a)‚Äô
In the expression: f (g a)
Failed, modules loaded: none.
Well, that didn‚Äôt work. That error message is telling us that
ùëìis expecting a ùëèfor its first argument, but ùëîis passing an m b
toùëì. So, how do we apply a function in the presence of some
context that we want to ignore? We use fmap. That‚Äôs going to
give us an m (m c) instead of an m c, so we‚Äôll want to jointhose
two monadic structures.</p>
<p>CHAPTER 18. MONAD 1202
mcomp::Monadm=&gt;
(b-&gt;m c)
-&gt;(a-&gt;m b)
-&gt;a-&gt;m c
mcompf g a=join (f &lt;$&gt;(g a))
But using joinandfmaptogether means we can go ahead
and use (&gt;&gt;=).
mcomp'' ::Monadm=&gt;
(b-&gt;m c)
-&gt;(a-&gt;m b)
-&gt;a-&gt;m c
mcomp'' f g a=g a&gt;&gt;=f
You don‚Äôt need to write anything special to make monadic
functions compose (as long as the monadic contexts are the
sameMonad) because Haskell has it covered: what you want is
Kleisli composition . Don‚Äôt sweat the strange name; it‚Äôs not as
weird as it sounds. As we saw above, what we need is function
composition written in terms of &gt;&gt;=to allow us to deal with
the extra structure, and that‚Äôs what the Kleisli fish gives us.
Let‚Äôs remind ourselves of the types of ordinary function
composition and &gt;&gt;=:</p>
<p>CHAPTER 18. MONAD 1203
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b)-&gt;m b
To get Kleisli composition oÔ¨Ä the ground, we have to flip
some arguments around to make the types work:
importControl.Monad
-- the order is flipped to match &gt;&gt;=
(&gt;=&gt;)
::Monadm
=&gt;(a-&gt;m b)-&gt;(b-&gt;m c)-&gt;a-&gt;m c
See any similarities to something you know yet?
(&gt;=&gt;)
::Monadm
=&gt;(a-&gt;m b)-&gt;(b-&gt;m c)-&gt;a-&gt;m c
flip(.)
::(a-&gt;b)-&gt;(b-&gt;c)-&gt;a-&gt;c
It‚Äôs function composition with monadic structure hanging
oÔ¨Ä the functions we‚Äôre composing. Let‚Äôs see an example!</p>
<p>CHAPTER 18. MONAD 1204
importControl.Monad ((&gt;=&gt;))
sayHi::String-&gt;IOString
sayHigreeting = do
putStrLn greeting
getLine
readM::Reada=&gt;String-&gt;IOa
readM=return.read
getAge::String-&gt;IOInt
getAge=sayHi&gt;=&gt;readM
askForAge ::IOInt
askForAge =
getAge&quot;Hello! How old are you? &quot;
We used return composed with readto turn it into some-
thing that provides monadic structure after being bound over
the output of sayHi. We needed the Kleisli composition opera-
tor to stitch sayHiandreadMtogether:</p>
<p>CHAPTER 18. MONAD 1205
sayHi::String-&gt;IOString
readM::Reada=&gt;String-&gt;IOa
-- [1] [2] [3]
(a-&gt;m b)
String-&gt;IOString
-- [4] [5] [6]
-&gt;(b-&gt;m c)
String-&gt;IOa
-- [7] [8] [9]
-&gt;a-&gt;m c
String IOa
1.The first type is the type of the input to sayHi,String .
2.TheIOthatsayHiperforms in order to present a greeting
and receive input.
3.TheString input from the user that sayHireturns.
4.TheString thatreadMexpects as an argument and which
sayHiwill produce.
5.TheIO readM returns into. Note that return/pure produce
IOvalues which perform no I/O.</p>
<p>CHAPTER 18. MONAD 1206
6.TheIntthatreadMreturns.
7.The original, initial String inputsayHiexpects so it knows
how to greet the user and ask for their age.
8.The final combined IOaction which performs all eÔ¨Äects
necessary to produce the final result.
9.The value inside of the final IOaction; in this case, this is
theIntvalue that readMreturned.
18.7 Chapter Exercises
WriteMonadinstancesforthefollowingtypes. Usethe QuickCheck
properties we showed you to validate your instances.
1.Welcome to the Nope Monad , where nothing happens and
nobody cares.
dataNopea=
NopeDotJpg
-- We're serious. Write it anyway.
2.dataPhhhbbtttEither b a=
Lefta
|Rightb</p>
<p>CHAPTER 18. MONAD 1207
3.Write a Monadinstance for Identity .
newtype Identity a=Identity a
deriving (Eq,Ord,Show)
instance Functor Identity where
fmap=undefined
instance Applicative Identity where
pure=undefined
(&lt;*&gt;)=undefined
instance MonadIdentity where
return=pure
(&gt;&gt;=)=undefined
4.This one should be easier than the Applicative instance
was. Remember to use the Functor thatMonadrequires, then
see where the chips fall.
dataLista=
Nil
|Consa (Lista)
Write the following functions using the methods provided
byMonadandFunctor . Using stuÔ¨Ä like identity and composition
is fine, but it has to typecheck with types provided.</p>
<p>CHAPTER 18. MONAD 1208
1.j::Monadm=&gt;m (m a) -&gt;m a
Expecting the following behavior:
Prelude&gt; j [[1, 2], [], [3]]
[1,2,3]
Prelude&gt; j (Just (Just 1))
Just 1
Prelude&gt; j (Just Nothing)
Nothing
Prelude&gt; j Nothing
Nothing
2.l1::Monadm=&gt;(a-&gt;b)-&gt;m a-&gt;m b
3.l2::Monadm
=&gt;(a-&gt;b-&gt;c)-&gt;m a-&gt;m b-&gt;m c
4.a::Monadm=&gt;m a-&gt;m (a-&gt;b)-&gt;m b
5.You‚Äôll need recursion for this one.
meh::Monadm
=&gt;[a]-&gt;(a-&gt;m b)-&gt;m [b]
6.Hint: reuse ‚Äúmeh‚Äù
flipType ::(Monadm)=&gt;[m a]-&gt;m [a]</p>
<p>CHAPTER 18. MONAD 1209
18.8 Definition
1.Monad is a typeclass reifying an abstraction that is com-
monly used in Haskell. Instead of an ordinary function of
typeùëétoùëè, you‚Äôre functorially applying a function which
produces more structure itself and using jointo reduce
the nested structure that results.
fmap::(a-&gt;b)-&gt;f a-&gt;f b
(&lt;*&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
(=&lt;&lt;)::(a-&gt;f b)-&gt;f a-&gt;f b
2.Amonadic function is one which generates more structure
after having been lifted over monadic structure. Contrast
the function arguments to fmapand(&gt;&gt;=)in:
fmap::(a-&gt;b)-&gt;f a-&gt;f b
(&gt;&gt;=)::m a-&gt;(a-&gt;m b)-&gt;m b
The significant diÔ¨Äerence is that the result is m band re-
quiresjoining the result after lifting the function over ùëö.
What does this mean? That depends on the Monadinstance.
The distinction can be seen with ordinary function com-
position and Kleisli composition as well:</p>
<p>CHAPTER 18. MONAD 1210
(.)
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
(&gt;=&gt;)
::Monadm
=&gt;(a-&gt;m b)-&gt;(b-&gt;m c)-&gt;a-&gt;m c
3.bindis unfortunately a somewhat overloaded term. You
first saw it used early in the book with respect to binding
variables to values, such as with the following:
letx=2inx+2
Where ùë•is a variable bound to 2. However, when we‚Äôre
talking about a Monadinstance typically bind will refer
to having used &gt;&gt;=to lift a monadic function over the
structure. The distinction being:
-- lifting (a -&gt; b) over f in f a
fmap::(a-&gt;b)-&gt;f a-&gt;f b
-- binding (a -&gt; m b) over m in m a
(&gt;&gt;=)::m a-&gt;(a-&gt;m b)-&gt;m b
You‚Äôll sometimes see us talk about the use of the bind
do-notation &lt;-or(&gt;&gt;=)as ‚Äúbinding over.‚Äù When we do, we</p>
<p>CHAPTER 18. MONAD 1211
mean that we lifted a monadic function and we‚Äôll even-
tuallyjoinor smush the structure back down when we‚Äôre
done monkeying around in the Monad.Don‚Äôtpanic if we‚Äôre a
little casual about describing the use of &lt;-as having bound
over/out some ùëéout ofm a.
18.9 Follow-up resources
1.What a Monad is not
https://wiki.haskell.org/What_a_Monad_is_not
2.Gabriel Gonzalez; How to desugar Haskell code
3.Stephen Diehl; What I wish I knew when Learning Haskell
http://dev.stephendiehl.com/hask/#monads
4.Stephen Diehl; Monads Made Difficult
http://www.stephendiehl.com/posts/monads.html
5.Brent Yorgey; Typeclassopedia
https://wiki.haskell.org/Typeclassopedia</p>
<p>Chapter 19
Applying structure
I often repeat repeat
myself, I often repeat
repeat. I don‚Äôt don‚Äôt know
why know why, I simply
know that I I I am am
inclined to say to say a lot
a lot this way this way- I
often repeat repeat
myself, I often repeat
repeat.
Jack Prelutsky
1212</p>
<p>CHAPTER 19. MONADS GONE WILD 1213
19.1 Applied structure
We thought you‚Äôd like to see Monoid,Functor ,Applicative , and
Monadin the wild as it were. Since we‚Äôd like to finish this book
before we have grandchildren, this will notbe accompanied
by the painstaking explanations and exercise regime you‚Äôve
experienced up to this point. Don‚Äôt understand something?
Figure it out! We‚Äôll do our best to leave a trail of breadcrumbs
for you to follow up on the code we show you. Consider this a
breezy survey of how Haskellers write code when they think
no one is looking and a pleasant break from your regularly
scheduled exercises. The code demonstrated will not always
include all necessary context to make it run, so don‚Äôt expect
to be able to load the snippets in GHCi and have them work.
If you don‚Äôt have a lot of previous programming experience
and some of the applications are difficult for you to follow,
you might prefer to return to this chapter at a later time, once
you start trying to read and use Haskell libraries for practical
projects.
19.2Monoid
Monoids are everywhere once you recognize the pattern and
start looking for them, but we‚Äôve tried to choose a few good
examples to illustrate typical use-cases.</p>
<p>CHAPTER 19. MONADS GONE WILD 1214
Templating content in Scotty
Here the scotty web framework‚Äôs ‚ÄúHello, World‚Äù example uses
mconcat to inject the parameter ‚Äúword‚Äù into the HTML page
returned:
{-# LANGUAGE OverloadedStrings #-}
importWeb.Scotty
importData.Monoid (mconcat)
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
html
(mconcat
[&quot;<h1>Scotty, &quot;
, beam
,&quot; me up!</h1>&quot; ])
If you‚Äôre interested in following up on this example, you
can find this example and a tutorial on the scotty Github repos-
itory.</p>
<p>CHAPTER 19. MONADS GONE WILD 1215
Concatenating connection parameters
The next example is from Aditya Bhargava‚Äôs ‚ÄúMaking A Web-
site With Haskell,‚Äù a blog post that walks you through several
steps for, well, making a simple website in Haskell. It also uses
thescotty web framework.
Here we‚Äôre using foldrandMonoid to concatenate connection
parameters for connecting to the database:
runDb::SqlPersist (ResourceT IO) a
-&gt;IOa
runDbquery= do
letconnStr =
foldr ((k,v) t -&gt;
t&lt;&gt;(encodeUtf8 $
k&lt;&gt;&quot;=&quot;&lt;&gt;v&lt;&gt;&quot; &quot;))
&quot;&quot;params
runResourceT
.withPostgresqlConn connStr
$runSqlConn query
If you‚Äôre interested in following up on this, this blog post
is one of many that shows you step by step how to use scotty ,
although many of them breeze through each step without a
great deal of explanation. It will be easier to understand scotty
in detail once you‚Äôve worked through monad transformers, but</p>
<p>CHAPTER 19. MONADS GONE WILD 1216
if you‚Äôd like to start playing around with some basic projects,
you may want to try them out.
Concatenating key configurations
The next example is going to be a bit meatier than the two
previous ones.
xmonad is a windowing system for X11 written in Haskell.
The configuration language is Haskell ‚Äî the binary that runs
your WM is compiled from your personal configuration. The
following is an example of using mappend to combine the default
configuration‚Äôs key mappings and a modification of those keys:</p>
<p>CHAPTER 19. MONADS GONE WILD 1217
importXMonad
importXMonad.Actions.Volume
importData.Map.Lazy (fromList )
importData.Monoid (mappend)
main= do
xmonad def { keys =
\c-&gt;fromList [
((0, xK_F6),
lowerVolume 4&gt;&gt;return()),
((0, xK_F7),
raiseVolume 4&gt;&gt;return())
] <code>mappend</code> keys defaultConfig c
}
The type of keysis a function:
keys:: !(XConfig Layout
-&gt;Map(ButtonMask ,KeySym) (X()))
You don‚Äôt need to get too excited about the exclamation
point right now; it‚Äôs the syntax for a nifty thing called a strictness
annotation , which makes a field in a product strict. That is, you
won‚Äôt be able to construct the record or product that contains
the value without also forcing that field to weak head normal
form. We‚Äôll explain this in more detail later in the book.</p>
<p>CHAPTER 19. MONADS GONE WILD 1218
The gist of the mainabove is that it allows your keymapping
to be based on the current configuration of your environment.
Whenever you type a key, xmonad will pass the current config to
yourkeysfunction in order to determine what (if any) action it
should take based on that. We‚Äôre using the Monoid here to add
new keyboard shortcuts for lowering and raising the volume
with F6 and F7. The monoid of the keysfunctions is combining
all of the key maps each function produces when applied to
theXConfig to produce a final canonical key map.
Say what?
This is a Monoid instance we hadn‚Äôt covered in the Monoid
chapter, so let‚Äôs take a look at it now:
instance Monoidb
=&gt;Monoid(a-&gt;b)
-- Defined in ‚ÄòGHC.Base‚Äô
This, friends, is the Monoid of functions.
But how does it work? First, let‚Äôs set up some very trivial
functions for demonstration:
Prelude&gt; import Data.Monoid
Prelude&gt; let f = const (Sum 1)
Prelude&gt; let g = const (Sum 2)
Prelude&gt; f 9001
Sum {getSum = 1}
Prelude&gt; g 9001</p>
<p>CHAPTER 19. MONADS GONE WILD 1219
Sum {getSum = 2}
Query the types of those functions and see how you think
they will match up to the Monoid instance above.
We know that whatever arguments we give to ùëìandùëî, they
will always return their first arguments, which are Summonoids.
So if we mappend ùëìandùëî, they‚Äôre going to ignore whatever argu-
ment we tried to apply them to and use the Monoid to combine
the results:
Prelude&gt; (f &lt;&gt; g) 9001
Sum {getSum = 3}
So this Monoid instance allows to mappend the results of two
function applications:
(a-&gt;b)&lt;&gt;(a-&gt;b)
Just as long as the ùëèhas aMonoid instance.
We‚Äôre going to oÔ¨Äer a few more examples that will get you
closer to what the particular use of mappend in thexmonad ex-
ample is doing. We mentioned Data.Map back in the Testing
chapter. It gives us ordered pairs of keys and values:
Prelude&gt; import qualified Data.Map as M
Prelude M&gt; :t M.fromList
M.fromList :: Ord k =&gt; [(k, a)] -&gt; Map k a</p>
<p>CHAPTER 19. MONADS GONE WILD 1220
Prelude M&gt; let f = M.fromList [('a', 1)]
Prelude M&gt; let g = M.fromList [('b', 2)]
Prelude M&gt; :t f
f :: Num a =&gt; Map Char a
Prelude M&gt; import Data.Monoid
Prelude M Data.Monoid&gt; f &lt;&gt; g
fromList [('a',1),('b',2)]
Prelude M Data.Monoid&gt; :t (f &lt;&gt; g)
(f &lt;&gt; g) :: Num a =&gt; Map Char a
Prelude M Data.Monoid&gt; mappend f g
fromList [('a',1),('b',2)]
Prelude M Data.Monoid&gt; f <code>mappend</code> g
fromList [('a',1),('b',2)]
-- but note what happens here:
Prelude&gt; f &lt;&gt; g
fromList [('a',1)]
So, returning to the xmonad configuration we started with.
Thekeysfield is a function which, given an XConfig , produces a
keymapping. It uses the monoid of functions to combine the
pre-existing function that generates the keymap to produce as
many maps as you have mappended functions, then combine
all the key maps into one.
This part:</p>
<p>CHAPTER 19. MONADS GONE WILD 1221
&gt;&gt;return()
says that the key assignment is performing some eÔ¨Äects and
only performing some eÔ¨Äects. Functions have to reduce to
some result, but sometimes their only purpose is to perform
someeÔ¨Äectsandyoudon‚Äôtwanttodoanythingwiththe‚Äúresult‚Äù
of evaluating the terms.
As we‚Äôve said and other people have noted as well, monoids
areeverywhere ‚Äî not just in Haskell but in all of programming.
19.3 Functor
There‚Äôs a reason we chose that Michael Neale quotation for
theFunctor chapter epigraph: lifting really is the cheat mode.
fmapis ubiquitous in Haskell, for all sorts of applications, but
we‚Äôve picked a couple that we found especially demonstrative
of why it‚Äôs so handy.
Lifting over IO
Herewe‚Äôretakingafunctionthatdoesn‚ÄôtperformI/O, addUTCTime ,
partially applying it to the oÔ¨Äset we‚Äôre going to add to the sec-
ond argument, then mapping it over the IOaction that gets us
the current time:</p>
<p>CHAPTER 19. MONADS GONE WILD 1222
importData.Time.Clock
offsetCurrentTime ::NominalDiffTime
-&gt;IOUTCTime
offsetCurrentTime offset=
fmap (addUTCTime (offset <em>24</em>3600))$
getCurrentTime
Context for the above:
1.NominalDiffTime is a newtype of Picoand has a Numinstance,
that‚Äôs why the arithmetic works.
addUTCTime ::NominalDiffTime
-&gt;UTCTime
-&gt;UTCTime
2.getCurrentTime ::IOUTCTime
3.fmap‚Äôs type got specialized.
fmap::(UTCTime -&gt;UTCTime)
-&gt;IOUTCTime
-&gt;IOUTCTime
Here we‚Äôre lifting some data conversion stuÔ¨Ä over the fact
that the UUID library has to touch an outside resource (ran-
dom number generation) to give us a random identifier. The</p>
<p>CHAPTER 19. MONADS GONE WILD 1223
UUID library used is named uuidon Hackage. The Textpack-
age used is named‚Ä¶ text:
import Data.Text (Text)
import qualified Data.Text asT
import qualified Data.UUID asUUID
import qualified Data.UUID.V4 asUUIDv4
textUuid ::IOText
textUuid =
fmap (T.pack.UUID.toString)
UUIDv4.nextRandom
1.nextRandom ::IOUUID
2.toString ::UUID-&gt;String
3.pack::String-&gt;Text
4.fmap::(UUID-&gt;Text)
-&gt;IOUUID
-&gt;IOText
Lifting over web app monads
Frequently when you write web applications, you‚Äôll have a
custom datatype to describe the web application which is also</p>
<p>CHAPTER 19. MONADS GONE WILD 1224
aMonad. It‚Äôs a Monadbecause your ‚Äúapp context‚Äù will have a
type parameter to describe what result was produced in the
course of a running web application. Often these types will
abstract out the availability of a request or other configuration
data with a Reader (explained in a later chapter), as well as the
performance of eÔ¨Äects via IO. In the following example, we‚Äôre
lifting over AppHandler andMaybe:
userAgent ::AppHandler (MaybeUserAgent )
userAgent =
(fmap.fmap) userAgent' getRequest
userAgent' ::Request -&gt;MaybeUserAgent
userAgent' req=
getHeader &quot;User-Agent&quot; req
We need the Functor here because while we can pattern
match on the Maybevalue, an AppHandler isn‚Äôt something we can
pattern match on. It‚Äôs a convention in this web framework
library, snap, to make a type alias for your web application type.
It usually looks like this:
typeAppHandler =Handler AppApp
The underlying infrastructure for snapis more complicated
than we can cover to any depth here, but suffice to say there
are a few things floating around:</p>
<p>CHAPTER 19. MONADS GONE WILD 1225
1.HTTP request which triggered the processing currently
occurring.
2.The current (possibly empty or default) response that will
be returned to the client when the handlers and middle-
ware are done.
3.A function for updating the request timeout.
4.A helper function for logging.
5.And a fair bit more than this.
The issue here is that your AppHandler is meant to be slotted
into a web application which requires the reading in of con-
figuration, initialization of a web server, and the sending of a
request to get everything in motion. This is essentially a bunch
of functions waiting for arguments ‚Äî waiting for something
to do. It doesn‚Äôt make sense to do all that yourself every time
you want a value that can only be obtained in the course of
the web application doing its thing. Accordingly, our Functor
is letting us write functions over structure which handles all
this work. It‚Äôs like we‚Äôre saying, ‚Äúhere‚Äôs a function, apply it to a
thing that resulted from an HTTP request coming down the
pipe, if one comes along.‚Äù</p>
<p>CHAPTER 19. MONADS GONE WILD 1226
19.4Applicative
Applicative is somewhat new to Haskell, but it‚Äôs useful enough,
particularlywithparsers, thatit‚Äôseasytofindexamples. There‚Äôs
a whole chapter on parsers coming up later, but we thought
these examples were mostly comprehensible even without
that context.
hgrev
This is an example from Luke Hoersten‚Äôs hgrevproject. The
example in the README is a bit dense, but uses Monoid and
Applicative to combine parsers of command line arguments:
jsonSwitch ::Parser(a-&gt;a)
jsonSwitch =
infoOption $(hgRevStateTH jsonFormat)
$long&quot;json&quot;
&lt;&gt;short'J'
&lt;&gt;help
&quot;Display JSON version information&quot;
parserInfo ::ParserInfo (a-&gt;a)
parserInfo =
info (helper &lt;*&gt;verSwitch &lt;*jsonSwitch)
fullDesc</p>
<p>CHAPTER 19. MONADS GONE WILD 1227
You might be wondering what the &lt;<em>operator is. It‚Äôs an-
other operator from the Applicative typeclass. It allows you to
sequence actions, discarding the result of the second argument.
Does this look familiar?
Prelude&gt; :t (&lt;</em>)
(&lt;<em>) :: Applicative f =&gt; f a -&gt; f b -&gt; f a
Prelude&gt; :t const
const :: a -&gt; b -&gt; a
Basically the (&lt;</em>)operator (like its sibling, (*&gt;), and the
monadic operator, &gt;&gt;) is useful when you‚Äôre emitting eÔ¨Äects.
In this case, you‚Äôve done something with eÔ¨Äects and want to
discard any value that resulted.
More parsing
Here we‚Äôre using Applicative to lift the data constructor for the
Payload type over the Parser returned by requesting a value by
key out of a JSON object, which is basically an association of
text keys to further more JSON values which may be strings,
numbers, arrays, or more JSON objects:</p>
<p>CHAPTER 19. MONADS GONE WILD 1228
parseJSON ::Value-&gt;Parsera
(.:)::FromJSON a
=&gt;Object
-&gt;Text
-&gt;Parsera
instance FromJSON Payload where
parseJSON ( Objectv)=
Payload &lt;$&gt;v.:&quot;from&quot;
&lt;<em>&gt;v.:&quot;to&quot;
&lt;</em>&gt;v.:&quot;subject&quot;
&lt;<em>&gt;v.:&quot;body&quot;
&lt;</em>&gt;v.:&quot;offset_seconds&quot;
parseJSON v =typeMismatch &quot;Payload&quot; v
This is the same as the JSON but for CSV1data:
parseRecord ::Record-&gt;Parsera
1CSV stands for comma-separated values, a common, though not entirely standard-
ized file format.</p>
<p>CHAPTER 19. MONADS GONE WILD 1229
instance FromRecord Release where
parseRecord v
|V.length v ==5=Release &lt;$&gt;v.!0
&lt;<em>&gt;v.!1
&lt;</em>&gt;v.!2
&lt;<em>&gt;v.!3
&lt;</em>&gt;v.!4
|otherwise =mzero
This one uses liftA2 to lift the tuple data constructor over
parseKey andparseValue to give key-value pairings. You can see
the(&lt;*)operator in there again as well, along with the infix
operator for fmapand=&lt;&lt;as well:</p>
<p>CHAPTER 19. MONADS GONE WILD 1230
instance Deserializeable ShowInfoResp where
parser=
e2err=&lt;&lt;convertPairs
.HM.fromList &lt;$&gt;parsePairs
where
parsePairs ::Parser[(Text,Text)]
parsePairs =
parsePair <code>sepBy</code> endOfLine
parsePair =
liftA2 (,) parseKey parseValue
parseKey =
takeTill ( ==':')&lt;*kvSep
kvSep=string&quot;: &quot;
parseValue =takeTill isEndOfLine
This one instance is a virtual cornucopia of applications
of the previous chapters and we believe it demonstrates how
much cleaner and more readable these can make your code.
And now for something diÔ¨Äerent
This next example is also using an applicative, but this is a bit
diÔ¨Äerent than the above examples. We‚Äôll spend more time</p>
<p>CHAPTER 19. MONADS GONE WILD 1231
explaining this one, as this pattern for writing utility functions
is common:
moduleWeb.Shipping.Utils ((&lt;||&gt;))where
importControl.Applicative (liftA2)
(&lt;||&gt;)::(a-&gt;Bool)
-&gt;(a-&gt;Bool)
-&gt;a
-&gt;Bool
(&lt;||&gt;)=liftA2 ( ||)
At first glance, this doesn‚Äôt seem too hard to understand,
but some examples will help you develop an understanding
of what‚Äôs going on. We start with the operator for boolean
disjunction, (||), which is an or:
Prelude&gt; True || False
True
Prelude&gt; False || False
False
Prelude&gt; (2 &gt; 3) || (3 == 3)
True
And now we want to be able to keep that as an infix operator
but lift it over some context, so we use liftA2 :</p>
<p>CHAPTER 19. MONADS GONE WILD 1232
Prelude&gt; import Control.Applicative
Prelude&gt; let (&lt;||&gt;) = liftA2 (||)
Andwe‚Äôllmakesometrivialfunctionsagainforthepurposes
of demonstration:
Prelude&gt; let f 9001 = True; f _ = False
Prelude&gt; let g 42 = True; g _ = False
Prelude&gt; :t f
f :: (Eq a, Num a) =&gt; a -&gt; Bool
Prelude&gt; f 42
False
Prelude&gt; f 9001
True
Prelude&gt; g 42
True
Prelude&gt; g 9001
False
We can compose the two functions ùëìandùëîto take one input
and give one summary result like this:
Prelude&gt; (\n -&gt; f n || g n) 0
False
Prelude&gt; (\n -&gt; f n || g n) 9001
True
Prelude&gt; :t (\n -&gt; f n || g n)</p>
<p>CHAPTER 19. MONADS GONE WILD 1233
(\n -&gt; f n || g n)
:: (Eq a, Num a) =&gt; a -&gt; Bool
But we have to pass in that argument ùëõin order to do it that
way. Our utility function gives us a cleaner way:
Prelude&gt; (f &lt;||&gt; g) 0
False
Prelude&gt; (f &lt;||&gt; g) 9001
True
It‚Äôs parallel application of the functions against an argument.
That application produces two values, so we monoidally com-
bine the two values so that we have a single value to return.
We‚Äôve set up an environment so that two (a -&gt; Bool) functions
that don‚Äôt have an ùëéargument yet can return a result based on
those two Boolvalues when the combined function is eventu-
ally applied against an ùëé.
19.5Monad
BecauseeÔ¨ÄectfulprogrammingisconstrainedinHaskellthrough
the use of IO, andIOhas an instance of Monad, examples of Monad
in practical Haskell code are everywhere. We tried to find
some examples that illustrate diÔ¨Äerent interesting use cases.</p>
<p>CHAPTER 19. MONADS GONE WILD 1234
Opening a network socket
Here we‚Äôre using dosyntax for IO‚ÄôsMonadin order to bind a
socket handle from the socket smart constructor, connect it
to an address, then return the handle for reading and writing.
This example is from haproxy-haskell by Michael Xavier. See
thenetwork library on Hackage for use and documentation:
importNetwork.Socket
openSocket ::FilePath -&gt;IOSocket
openSocket p= do
sock&lt;-socketAF_UNIX
Stream
defaultProtocol
connect sock sockAddr
return sock
wheresockAddr =
SockAddrUnix .encodeString $p
This isn‚Äôt too unlike anything you saw in previous chapters,
at least since we built the hangman game. The next example
is a bit richer.</p>
<p>CHAPTER 19. MONADS GONE WILD 1235
Binding over failure in initialization
Michael Xavier‚Äôs Seraph is a process monitor and has a main
entry point which is typical of more developed libraries and
applications. The outermost MonadisIO, but the monad trans-
former variant of Either , calledEitherT , is used to bind over the
possibility of failure in constructing an initialization function.
This possibility of failure centers on being able to pull up a
correct configuration:</p>
<p>CHAPTER 19. MONADS GONE WILD 1236
main::IO()
main= do
initAndFp &lt;-runEitherT $ do
fp&lt;-tryHead NoConfig =&lt;&lt;lift getArgs
initCfg &lt;-load' fp
return (initCfg, fp)
either bail (uncurry boot) initAndFp
where
boot initCfg fp =
void$runMVC mempty
oracleModel (core initCfg fp)
bailNoConfig =
errorExit &quot;Please pass a config&quot;
bail (InvalidConfig e)=
errorExit
(&quot;Invalid config &quot; ++show e)
load' fp =
hoistEither
.fmapLInvalidConfig
=&lt;&lt;lift (load fp)
If you found that very dense and difficult to follow at this
point, we‚Äôd encourage you to have another look at it after we‚Äôve
covered monad transformers.</p>
<p>CHAPTER 19. MONADS GONE WILD 1237
19.6 An end-to-end example: URL
shortener
In this section, we‚Äôre going to walk through an entire program,
beginning to end.2There are some pieces we are not going to
explain thoroughly; however, this is something you can build
and work with if you‚Äôre interested in doing so.
First, the .cabal file for the project:
name: shawty
version: 0.1.0.0
synopsis: URI shortener
description: Please see README.md
homepage: http://github.com/
license: BSD3
license-file: LICENSE
author: Chris Allen
maintainer: cma@bitemyapp.com
copyright: 2015, Chris Allen
category: Web
build-type: Simple
cabal-version: &gt;=1.10
executable shawty
2The code in this example can be found here: https://github.com/bitemyapp/
shawty-prime/blob/master/app/Main.hs</p>
<p>CHAPTER 19. MONADS GONE WILD 1238
hs-source-dirs: app
main-is: Main.hs
ghc-options: -threaded
build-depends: base
, bytestring
, hedis
, mtl
, network-uri
, random
, scotty
, semigroups
, text
, transformers
default-language: Haskell2010
And the project layout:
$ tree
.
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Setup.hs
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Main.hs
‚îú‚îÄ‚îÄ shawty.cabal
‚îî‚îÄ‚îÄ stack.yaml</p>
<p>CHAPTER 19. MONADS GONE WILD 1239
You may choose to use Stack or not. That is how we got the
template for the project in place. If you‚Äôd like to learn more,
check out Stack‚Äôs Github repo3and the Stack video tutorial4
we worked on together. The code following from this point is
inMain.hs .
We need to start our program oÔ¨Ä with a language extension:
{-# LANGUAGE OverloadedStrings #-}
OverloadedStrings is a way to make String literals polymor-
phic, the way numeric literals are polymorphic over the Num
typeclass. String literals are not ordinarily polymorphic; String
is a concrete type. Using OverloadedStrings allows us to use
String literals as TextandByteString values.
Brief aside about polymorphic literals
We mentioned that the integral number literals in Haskell
are typed Num a =&gt; a by default. Now that we have another
example to work with, it‚Äôs worth examining how they work
under the hood, so to speak. First, let‚Äôs look at a typeclass from
a module in base:
Prelude&gt; import Data.String
3Stack Github repo https://github.com/commercialhaskell/stack
4The video Stack mega-tutorial! The whole video is long, but covers a lot of abnormal
use cases. Use the time stamps to jump to what you need to learn. https://www.youtube.
com/watch?v=sRonIB8ZStw&amp;feature=youtu.be</p>
<p>CHAPTER 19. MONADS GONE WILD 1240
Prelude&gt; :info IsString
class IsString a where
fromString :: String -&gt; a
-- Defined in ‚ÄòData.String‚Äô
instance IsString [Char]
-- Defined in ‚ÄòData.String‚Äô
Then we may notice something in NumandFractional :
classNumawhere
-- irrelevant bits elided
fromInteger ::Integer -&gt;a
classNuma=&gt;Fractional awhere
-- elision again
fromRational ::Rational -&gt;a
OK, and what about our literals?
Prelude&gt; :set -XOverloadedStrings
Prelude&gt; :t 1
1 :: Num a =&gt; a
Prelude&gt; :t 1.0
1.0 :: Fractional a =&gt; a
Prelude&gt; :t &quot;blah&quot;
&quot;blah&quot; :: IsString a =&gt; a</p>
<p>CHAPTER 19. MONADS GONE WILD 1241
The basic design is that the underlying representation is
concrete, butGHCautomaticallywrapsitin fromString /fromInteger /fromRational .
So it‚Äôs as if:
{-# LANGUAGE OverloadedStrings #-}
&quot;blah&quot;::Text
==fromString ( &quot;blah&quot;::String)
1::Int
==fromInteger ( 1::Integer)
2.5::Double
==fromRational ( 2.5::Rational )
Librarieslike textandbytestring provideinstancesfor IsString
in order to perform the conversion. Assuming you have those
libraries installed, you can kick it around a little. Note that,
due to the monomorphism restriction, the following will work
in the REPL but would not work if we loaded it from a source
file (because it would default to a concrete type; we‚Äôve seen
this a couple times earlier in the book):
Prelude&gt; :set -XOverloadedStrings
Prelude&gt; let a = &quot;blah&quot;
Prelude&gt; a</p>
<p>CHAPTER 19. MONADS GONE WILD 1242
&quot;blah&quot;
Prelude&gt; :t a
a :: Data.String.IsString a =&gt; a
Then you can make it a TextorByteString value:
Prelude&gt; import Data.Text (Text)
Prelude&gt; :{
*Main| import Data.ByteString (ByteString)
*Main| :}
Prelude&gt; let t = &quot;blah&quot; :: Text
Prelude&gt; let bs = &quot;blah&quot; :: ByteString
Prelude&gt; t == bs
Couldn't match expected type ‚ÄòText‚Äô with
actual type ‚ÄòByteString‚Äô
In the second argument of ‚Äò(==)‚Äô,
namely ‚Äòbs‚Äô
In the expression: t == bs
OverloadedStrings is a convenience that originated in the
desire of working Haskell programmers to use String literals
forTextandByteString values. It‚Äôs not too big a deal, but it
can be nice and saves you manually wrapping each literal in
fromString .</p>
<p>CHAPTER 19. MONADS GONE WILD 1243
Back to the show
Next, the module name must be Mainas that is required for
anything exporting a mainexecutable to be invoked when the
program runs. We follow the OverloadedStrings extension with
our imports:
moduleMainwhere
importControl.Monad (replicateM )
importControl.Monad.IO.Class (liftIO)
import qualified Data.ByteString.Char8
asBC
importData.Text.Encoding
(decodeUtf8 ,encodeUtf8 )
import qualified Data.Text.Lazy asTL
import qualified Database.Redis asR
importNetwork.URI (URI,parseURI )
import qualified System.Random asSR
importWeb.Scotty
Where we import something ‚Äúqualified (‚Ä¶) as (‚Ä¶)‚Äù we are
doing two things. Qualifying the import means that we can
only refer to values in the module with the full module path,
and we use asto give the module that we want in scope a name.
For example, Data.ByteString.Char8.pack is a fully qualified ref-</p>
<p>CHAPTER 19. MONADS GONE WILD 1244
erence to pack. We qualify the import so that we don‚Äôt import
declarations that would conflict with bindings that already
exist in Prelude . By specifying a name using as, we can give the
value a shorter, more convenient name. Where we import the
module name followed by parentheses, such as with replicateM
orliftIO , we are saying we only want to import the functions
or values of that name and nothing else. In the case of import
Web.Scotty , we are importing everything Web.Scotty exports. An
unqualified and unspecific import should be avoided except in
those cases where the provenance of the imported functions
will be obvious, or when the import is a toolkit you must use
all together, such as scotty .
Next we need to generate our shortened URLs that will refer
to the links people post to the service. We will make a String
of the characters we want to select from:
alphaNum ::String
alphaNum =['A'..'Z']++['0'..'9']
Now we need to pick random elements from alphaNum . The
general idea here should be familiar from the hangman game.
First, we find the length of the list to determine a range to
select from, then get a random number in that range, using IO
to handle the randomness:</p>
<p>CHAPTER 19. MONADS GONE WILD 1245
randomElement ::String-&gt;IOChar
randomElement xs= do
letmaxIndex ::Int
maxIndex =length xs -1
-- Right of arrow is IO Int,
-- so randomDigit is Int
randomDigit &lt;-SR.randomRIO ( 0, maxIndex)
return (xs !!randomDigit)
Next, we apply randomElement toalphaNum to get a single ran-
domletterornumberfromouralphabet. Thenweuse replicateM
7to repeat this action 7 times, giving a list of 7 random letters
or numbers:
shortyGen ::IO[Char]
shortyGen =
replicateM 7(randomElement alphaNum)
For additional fun, see what replicateM 2 [1, 3] does and
whether you can figure out why. Compare it to the Prelude
function, replicate .
You may have noticed a mention of Redis in our imports
and wondered what was up. If you‚Äôre not already familiar with
it, Redis is in-memory, key-value data storage. The details
of how Redis works are well beyond the scope of this book
and they‚Äôre not very important here. Redis can be convenient</p>
<p>CHAPTER 19. MONADS GONE WILD 1246
for some common use cases like caching, or when you want
persistence without a lot of ceremony, as was the case here.
You will need to install and have Redis running in order for
the project to work; otherwise, the web server will throw an
error upon failing to connect to Redis.
This next bit is a function whose arguments are our con-
nection to Redis ( R.Connection ), the key we are setting in Redis,
and the value we are setting the key to. We also perform side
eÔ¨Äects in IOto getEither R.Reply R.Status as a result. The key
in this case is the randomly generated URI we created, and
the value is the URL the user wants the shortener to provide
at that address:
saveURI ::R.Connection
-&gt;BC.ByteString
-&gt;BC.ByteString
-&gt;IO(EitherR.ReplyR.Status)
saveURI conn shortURI uri =
R.runRedis conn $R.set shortURI uri
The next function, getURI , takes the connection to Redis and
the shortened URI key in order to get the URI associated with
that short URL and show users where they‚Äôre headed:</p>
<p>CHAPTER 19. MONADS GONE WILD 1247
getURI ::R.Connection
-&gt;BC.ByteString
-&gt;IO(EitherR.Reply
(MaybeBC.ByteString ))
getURIconn shortURI =
R.runRedis conn $R.get shortURI
Next some basic templating functions for returning output
to the web browser:
linkShorty ::String-&gt;String
linkShorty shorty=
concat
[&quot;&lt;a href= &quot;&quot;
, shorty
,&quot;&quot;&gt;Copy and paste your short URL</a>&quot;
]
The final output to scotty has to be a Textvalue, so we‚Äôre
concatenating lists of Textvalues to produce responses to the
browser:</p>
<p>CHAPTER 19. MONADS GONE WILD 1248
-- TL.concat :: [TL.Text] -&gt; TL.Text
shortyCreated ::Showa
=&gt;a
-&gt;String
-&gt;TL.Text
shortyCreated resp shawty =
TL.concat [ TL.pack (show resp)
,&quot; shorty is: &quot;
,TL.pack (linkShorty shawty)
]
shortyAintUri ::TL.Text-&gt;TL.Text
shortyAintUri uri=
TL.concat
[ uri
,&quot; wasn't a url,&quot;
,&quot; did you forget http://?&quot;
]
shortyFound ::TL.Text-&gt;TL.Text
shortyFound tbs=
TL.concat
[&quot;&lt;a href= &quot;&quot;
, tbs,&quot;&quot;&gt;&quot;
, tbs,&quot;</a>&quot;]</p>
<p>CHAPTER 19. MONADS GONE WILD 1249
Now we get to the bulk of web-appy bits in the form of our
application. We‚Äôll enumerate the application in chunks, but
they‚Äôre all in one appfunction:
app::R.Connection
-&gt;ScottyM ()
apprConn= do
-- [1]
get&quot;/&quot;$ do
-- [2]
uri&lt;-param&quot;uri&quot;
-- [3]
1.Redis connection that should‚Äôve been fired up before the
web server started.
2.getis a function that takes a RoutePattern , an action that
returns an HTTP response, and adds the route to the
Scotty server it‚Äôs embedded in. As you might suspect,
RoutePattern has anIsString instance so that the pattern
can be a String literal. The top-level route is expressed as
‚Äù/‚Äù, i.e., likegoingto https://google.com/ orhttps://bitemyapp.
com/. That final /character is what‚Äôs being expressed.
3.Theparamfunction is a means of getting‚Ä¶parameters.</p>
<p>CHAPTER 19. MONADS GONE WILD 1250
param::Parsable a
=&gt;Data.Text.Internal .Lazy.Text
-&gt;ActionM a
It‚Äôs sort of like Read, but it‚Äôs parsing a value of the type
you ask for. The paramfunction can find arguments via
URL path captures (see below with :short), HTML form
inputs, or query parameters. The first argument to param
is the ‚Äúname‚Äù or key for the input. We cannot explain the
entirety of HTTP and HTML here, but the following are
means of getting a param with the key name:
a)URL path capture
get&quot;/user/:name/view&quot; $ do
-- requesting the URL /user/Blah/view
-- would make name = &quot;Blah&quot;
-- such as:
-- http://localhost:3000/user/Blah/view
b)HTML input form. Here the name attribute for the
input field is ‚Äùname‚Äù.</p>
<form>
Name:<br>
<input type="text" name="name">
</form>
<p>CHAPTER 19. MONADS GONE WILD 1251
c)Query parameters for URIs are pairings of keys and
values following a question mark.
http://localhost:3000/?name=Blah
You can define more than one by using ampersand to
separate the key value pairs.
/?name=Blah&amp;state=Texas
Now for the next chunk of the appfunction:
letparsedUri ::MaybeURI
parsedUri =
parseURI ( TL.unpack uri)
caseparsedUri of
-- [1]
Just_ -&gt; do
shawty&lt;-liftIO shortyGen
-- [2]
letshorty=BC.pack shawty
-- [3]</p>
<p>CHAPTER 19. MONADS GONE WILD 1252
uri'=
encodeUtf8 ( TL.toStrict uri)
-- [4]
resp&lt;-
liftIO (saveURI rConn shorty uri')
-- [5]
html (shortyCreated resp shawty)
-- [6]
Nothing -&gt;text (shortyAintUri uri)
-- [7]
1.We test that the user gave us a valid URI by using the
network-uri library‚Äôs parseURI function. We don‚Äôt really
care about the datatype it got wrapped in, so when we
check if it‚Äôs JustorNothing , we drop it on the floor.
2.TheMonadhere is ActionM (an alias of ActionT ), which is a
datatype representing code that handles web requests
and returns responses. You can perform IOactions in
thisMonad, but you have to lift the IOaction over the addi-
tional structure. Conventionally, one uses MonadIO as a sort
of auto-lift for IOactions, but you could do it manually.
We won‚Äôt demonstrate this here. We will explain monad
transformers in a later chapter so that ActionT will be less
mysterious.</p>
<p>CHAPTER 19. MONADS GONE WILD 1253
3.ConvertingtheshortcodefortheURIintoa Char8ByteString
for storage in Redis.
4.Converting the URI the user provided from a lazy Text
value into a strict Textvalue, then encoding as a UTF-8 (a
common Unicode format) ByteString for storage in Redis.
5.Again using liftIO so that we can perform an IOaction
inside a scotty ActionM . In this case, we‚Äôre saving the short
code and the URI in Redis so that we can look things up
with the short code as a key, then get the URI back as a
value if it has been stored in the past.
6.The templated response we return when we successfully
saved the short code for the URI. This gives the user a
shortened URI to share.
7.Error response in case the user gave us a URI that wasn‚Äôt
valid.
The second handler handles requests to a shortened URI
and returns the unshortened URL to follow:</p>
<p>CHAPTER 19. MONADS GONE WILD 1254
get&quot;/:short&quot; $ do
-- [1]
short&lt;-param&quot;short&quot;
-- [2]
uri&lt;-liftIO (getURI rConn short)
-- [3]
caseuriof
Leftreply-&gt;
text (TL.pack (show reply))
-- [4] [5]
RightmbBS-&gt; case mbBSof
-- [6]
Nothing -&gt;text&quot;uri not found&quot;
-- [7]
Justbs-&gt;html (shortyFound tbs)
-- [8]
wheretbs::TL.Text
tbs=
TL.fromStrict
(decodeUtf8 bs)
-- [9]
1.This is the URL path capture we mentioned earlier, such
that requesting /blahfrom the server will cause it to get
the key ‚Äúblah‚Äù from Redis and, if there‚Äôs a value stored in</p>
<p>CHAPTER 19. MONADS GONE WILD 1255
that key, return that URI in the response. To do that in a
web browser or with curl/wget, you‚Äôd point your client at
http://localhost:3000/blah to test it.
2.Same parameter fetching as before. This time we expect
it to be part of the path capture rather than a query argu-
ment.
3.Lifting an IOaction inside ActionM again, this time to get
the short code as the lookup key from Redis.
4.Lefthere (in the Either we get back from Redis) signifies
some kind of failure, usually an error.
5.Textresponse returning an error in case we got Leftso that
the user knows what the error was, taking advantage of
Redis having Showable errors to render it in the response.
6.Happy path.
7.Just because an error didn‚Äôt happen doesn‚Äôt mean the key
was in the database.
8.Wefetchakeythatexistsinthedatabase, getthe ByteString
out of the Justdata constructor and render the URI in the
success template to show the user the URI we stored.
9.Going in the opposite direction we went in before ‚Äî de-
coding the ByteString on the assumption it‚Äôs encoded as</p>
<p>CHAPTER 19. MONADS GONE WILD 1256
UTF-8, then converting from a strict Textvalue to a lazy
Textvalue.
Now we come to the mainevent.mainreturns IO ()and acts as
the entry point for our web server when we start the executable.
We begin by invoking scotty 3000 , a helper function from the
scotty framework which, given a port to run on and a scotty
application, will listen for requests and respond to them:
main::IO()
main= do
rConn&lt;-R.connect R.defaultConnectInfo
scotty3000(app rConn)
And that is the entirety of this URL shortener. We have a
couple of exercises based on this code, and we encourage you
to come back to it after we‚Äôve covered monad transformers as
well and see how your comprehension is growing.
Exercise
In the URL shortener, an important step was omitted. We‚Äôre
not checking if we‚Äôre overwriting an existing short code, which
is entirely possible despite them being randomly generated.
We can calculate the odds of this by examining the cardinality
of the values.</p>
<p>CHAPTER 19. MONADS GONE WILD 1257
-- alphaNum = ['A'..'Z'] ++ ['0'..'9']
-- shortyGen =
-- replicateM 7 (randomElement alphaNum)
lengthalphaNum ^7==78364164096
So, the problem is, what if we accidentally clobber a previ-
ously generated short URI? There are a few ways of solving
this. One is to check to see if the short URI already exists in the
database before saving it and throwing an error if it does. This
is going to be vanishingly unlikely to happen unless you‚Äôve
suddenly become a very popular URI shortening service, but
it‚Äôd prevent the loss of any data. Your exercise is to devise
some means of making this less likely. The easiest way would
be to simply make the short codes long enough that you‚Äôd
need to run a computer until the heat death of the universe
to get a collision, but you should try throwing an error in the
first handler we showed you first.
19.7 That‚Äôs a wrap!
We hope this chapter gave you some idea of how Haskellers
use the typeclasses we‚Äôve been talking about in real code, to
handle various types of problems. In the next two chapters,
we‚Äôll be looking at Foldable andTraversable , two typeclasses
with some interesting properties that rely on these four alge-</p>
<p>CHAPTER 19. MONADS GONE WILD 1258
braic structures (monoid, functor, applicative, and monad),
so we encourage you to take some time to explore some of
the uses we‚Äôve demonstrated here. Consider going back to
anything you didn‚Äôt understand very well the first time you
went through those chapters.
19.8 Follow-up resources
1.The case of the mysterious explosion in space; Bryan
O‚ÄôSullivan; Explains how GHC handles string literals.</p>
<p>Chapter 20
Foldable
You gotta know when to
hold ‚Äôem, know when to
fold ‚Äôem, know when to
walk away, know when to
run.
Kenny Rogers
1259</p>
<p>CHAPTER 20. FOLDABLE 1260
20.1 Foldable
This typeclass has been appearing in type signatures at least
since Chapter 3, but for your purposes in those early chapters,
we said you could think of a Foldable thing as a list. As you
saw in the chapter on folds, lists are certainly foldable data
structures. But it is also true that lists are not the only foldable
data structures, so this chapter will expand on the idea of
catamorphisms and generalize it to many datatypes.
A list fold is a way to reduce the values inside a list to one
summary value by recursively applying some function. It is
sometimes difficult to appreciate that, as filtering and mapping
functions may be implemented in terms of a fold and yet
return an entirely new list! The new list is the summary value
of the old list after being reduced, or transformed, by function
application.
The folding function is always dependent on some Monoid
instance. The folds we wrote previously mostly relied on
implicit monoidal operations. As we‚Äôll see in this chapter,
generalizing catamorphisms to other datatypes depends on
understanding the monoids for those structures and, in some
cases, making them explicit.
This chapter will cover:
‚Ä¢theFoldable class and its core operations;
‚Ä¢the monoidal nature of folding;</p>
<p>CHAPTER 20. FOLDABLE 1261
‚Ä¢standard operations derived from folding.
20.2 The Foldable class
The Hackage documentation for the Foldable typeclass de-
scribes it as being a, ‚Äúclass of data structures that can be folded
to a summary value.‚Äù The folding operations that we‚Äôve seen
previously fit neatly into that definition, but this typeclass in-
cludes many operations. We‚Äôre going to go through the full
definition a little at a time. The definition in the library begins:
classFoldable twhere
{-# MINIMAL foldMap | foldr #-}
TheMINIMAL annotation on the typeclass tells you that a
minimally complete definition of the typeclass will define
foldMap orfoldrfor a datatype. As it happens, foldMap andfoldr
can each be implemented in terms of the other, and the other
operations included in the typeclass can be implemented in
terms of either of them. As long as at least one is defined,
you have a working instance of Foldable . Some methods in the
typeclass have default implementations that can be overridden
when needed. This is in case there‚Äôs a more efficient way to
do something that‚Äôs specific to your datatype.
If you query the info about the typeclass in GHCi, the first
line of the definition includes the kind signature for ùë°:</p>
<p>CHAPTER 20. FOLDABLE 1262
class Foldable (t :: * -&gt; *) where
Thatùë°should be a higher-kinded type is not surprising: lists
are higher-kinded types. We need ùë°to be a type constructor
for the same reasons we did with Functor , and we will see that
the eÔ¨Äects are very similar. Types that take more than one
type argument, such as tuples and Either , will necessarily have
their first type argument included as part of their structure.
Please note that you will need to use GHC 7.10 or later ver-
sions for all the examples in this chapter to work. Also, while
thePrelude as of GHCi 7.10 includes many changes related to
theFoldable typeclass, not all of Foldable is in the Prelude . To
follow along with the examples in the chapter, you may need
to import Data.Foldable andData.Monoid (for some of the Monoid
newtypes).
20.3 Revenge of the monoids
One thing we did not talk about when we covered folds pre-
viously is the importance of monoids. Folding necessarily
implies a binary associative operation that has an identity
value. The first two operations defined in Foldable make this
explicit:</p>
<p>CHAPTER 20. FOLDABLE 1263
classFoldable (t:: * -&gt; * )where
fold::Monoidm=&gt;t m-&gt;m
foldMap ::Monoidm
=&gt;(a-&gt;m)-&gt;t a-&gt;m
Whilefoldallows you to combine elements inside a Foldable
structure using the Monoid defined for those elements, foldMap
first maps each element of the structure to a Monoid and then
combines the results using that instance of Monoid .
Thesemightseemalittleweirduntilyourealizethat Foldable
is requiring that you make the implicit Monoid visible in folding
operations. Let‚Äôs take a look at a very basic foldroperation
and see how it compares to foldandfoldMap :
Prelude&gt; foldr (+) 0 [1..5]
15
The binary associative operation for that fold is (+), so we‚Äôve
specified it without thinking of it as a monoid. The fact that
the numbers in our list have other possible monoids is not
relevant once we‚Äôve specified which operation to use.
We can already see from the type of foldthat it‚Äôs not going to
work the same as foldr, because it doesn‚Äôt take a function for its
first argument. But we also can‚Äôt just fold up a list of numbers,
because the foldfunction doesn‚Äôt have a Monoid specified:
Prelude&gt; fold (+) [1, 2, 3, 4, 5]</p>
<p>CHAPTER 20. FOLDABLE 1264
-- error message resulting from incorrect
-- number of arguments
Prelude&gt; fold [1, 2, 3, 4, 5]
-- error message resulting from not having
-- an instance of Monoid
So, what we need to do to make foldwork is specify a Monoid
instance:
Prelude&gt; let xs = map Sum [1..5]
Prelude&gt; fold xs
Sum {getSum = 15}
Or, less tediously:
Prelude&gt; :{
*Main| let xs :: Sum Integer
*Main| xs = [1, 2, 3, 4, 5]
*Main| :}
Prelude&gt; fold xs
Sum {getSum = 15}
Prelude&gt; :{
*Main| let xs :: Product Integer
*Main| xs = [1, 2, 3, 4, 5]
*Main| :}
Prelude&gt; fold xs</p>
<p>CHAPTER 20. FOLDABLE 1265
Product {getProduct = 120}
In some cases, the compiler can identify and use the stan-
dardMonoid for a type, without us being explicit:
Prelude&gt; foldr (++) &quot;&quot; [&quot;hello&quot;, &quot; julie&quot;]
&quot;hello julie&quot;
Prelude&gt; fold [&quot;hello&quot;, &quot; julie&quot;]
&quot;hello julie&quot;
The default Monoid instance for lists gives us what we need
without having to specify it.
And now for something diÔ¨Äerent
Let‚Äôs turn our attention now to foldMap . Unlike fold,foldMap has
a function as its first argument. Unlike foldr, the first (function)
argument of foldMap must explicitly map each element of the
structure to a Monoid :
Prelude&gt; foldMap Sum [1, 2, 3, 4]
Sum {getSum = 10}
Prelude&gt; foldMap Product [1, 2, 3, 4]
Product {getProduct = 24}
Prelude&gt; foldMap All [True, False, True]
All {getAll = False}</p>
<p>CHAPTER 20. FOLDABLE 1266
Prelude&gt; foldMap Any [(3 == 4), (9 &gt; 5)]
Any {getAny = True}
Prelude&gt; let xs = [Just 1, Nothing, Just 5]
Prelude&gt; foldMap First xs
First {getFirst = Just 1}
Prelude&gt; foldMap Last xs
Last {getLast = Just 5}
In the above examples, the function being applied is a data
constructor. The data constructor identifies the Monoid instance
‚Äî themappend ‚Äî for those types. It already contains enough
information to allow foldMap to reduce the collection of values
to one summary value.
However, foldMap can also have a function to map that is
diÔ¨Äerent from the Monoid it‚Äôs using:
Prelude&gt; let xs = map Product [1..3]
Prelude&gt; foldMap (*5) xs
Product {getProduct = 750}
-- 5 * 10 * 15
750
Prelude&gt; let xs = map Sum [1..3]
Prelude&gt; foldMap (*5) xs
Sum {getSum = 30}</p>
<p>CHAPTER 20. FOLDABLE 1267
-- 5 + 10 + 15
30
It can map the function to each value first and then use the
Monoid instance to reduce them to one value. Compare this to
foldrin which the function has the Monoid instance baked in:
Prelude&gt; foldr (<em>) 5 [1, 2, 3]
-- (1 * (2 * (3 * 5)))
30
In fact, due to the way foldrworks, declaring a Monoid in-
stance that is diÔ¨Äerent from what is implied in the folding
function doesn‚Äôt change the final result:
Prelude&gt; let sumXs = map Sum [2..4]
Prelude&gt; foldr (</em>) 3 sumXs
Sum {getSum = 72}
Prelude&gt; let productXs = map Product [2..4]
Prelude&gt; foldr (*) 3 productXs
Product {getProduct = 72}
However, it is worth pointing out that if what you‚Äôre trying
to fold only contains one value, declaring a Monoid instance
won‚Äôt change the behavior of foldMap either:
Prelude&gt; let fm = foldMap (*5)
Prelude&gt; fm (Just 100) :: Product Integer</p>
<p>CHAPTER 20. FOLDABLE 1268
Product {getProduct = 500}
Prelude&gt; fm (Just 5) :: Sum Integer
Sum {getSum = 25}
With only one value, it doesn‚Äôt need the Monoid instance.
Specifying the Monoid instance is necessary to satisfy the type-
checker, but with only one value, there is nothing to mappend .
It just applies the function. It will use the mempty value from
the declared Monoid instance, though, in cases where what you
are trying to fold is empty:
Prelude&gt; fm Nothing :: Sum Integer
Sum {getSum = 0}
Prelude&gt; fm Nothing :: Product Integer
Product {getProduct = 1}
So, what we‚Äôve seen so far is that Foldable is a way of general-
izing catamorphisms ‚Äî folding ‚Äî to diÔ¨Äerent datatypes, and
at least in some cases, it forces you to think about the monoid
you‚Äôre using to combine values.
20.4 Demonstrating Foldable instances
As we said above, a minimal Foldable instance must have either
foldrorfoldMap . Any of the other functions in this typeclass
can be derived from one or the other of those. With that said,</p>
<p>CHAPTER 20. FOLDABLE 1269
let‚Äôs turn our attention to implementing Foldable instances for
diÔ¨Äerent types.
Identity
We‚Äôll kick things oÔ¨Ä by writing a Foldable instance for Identity :
dataIdentity a=
Identity a
We‚Äôre only obligated to write foldrorfoldMap , but we‚Äôll write
both plus foldlso you have the gist of it.
instance Foldable Identity where
foldr f z ( Identity x)=f x z
foldl f z ( Identity x)=f z x
foldMap f ( Identity x)=f x
Withfoldrandfoldl, we‚Äôre doing basically the same thing,
but with the arguments swapped. We didn‚Äôt need to do any-
thing special for foldMap .
It may seem strange to think of folding one value. When
we‚Äôve talked about catamorphisms previously, we‚Äôve focused
on how they can reduce a bunch of values down to one sum-
mary value. In the case of this Identity catamorphism, though,</p>
<p>CHAPTER 20. FOLDABLE 1270
the point is less to reduce the values inside the structure to
one value and more to consume, or use, the value:
Prelude&gt; foldr (<em>) 1 (Identity 5)
5
Prelude&gt; foldl (</em>) 5 (Identity 5)
25
Prelude&gt; let fm = foldMap (*5)
Prelude&gt; type PI = Product Integer
Prelude&gt; fm (Identity 100) :: PI
Product {getProduct = 500}
Maybe
Thisoneisalittlemoreinterestingbecause, unlikewith Identity ,
we have to account for the Nothing cases. When the Maybevalue
that we‚Äôre folding is Nothing , we need to be able to return some
‚Äúzero‚Äù value, while doing nothing with the folding function
but also disposing of the Maybestructure. For foldrandfoldl,
that zero value is the start value provided:
Prelude&gt; foldr (+) 1 Nothing
1
On the other hand, for foldMap we use the Monoid‚Äôs identity
value as our zero:</p>
<p>CHAPTER 20. FOLDABLE 1271
Prelude&gt; let fm = foldMap (+1)
Prelude&gt; fm Nothing :: Sum Integer
Sum {getSum = 0}
When the value is a Justvalue, though, we need to apply
the folding function to the value and, again, dispose of the
structure:
Prelude&gt; foldr (+) 1 (Just 3)
4
Prelude&gt; fm $ Just 3 :: Sum Integer
Sum {getSum = 4}
So, let‚Äôs look at the instance. We‚Äôll use a fake Maybetype
again, to avoid conflict with the Maybe instance that already
exists:
instance Foldable Optional where
foldr_zNada=z
foldr f z ( Yepx)=f x z
foldl_zNada=z
foldl f z ( Yepx)=f z x
foldMap _Nada=mempty
foldMap f ( Yepa)=f a</p>
<p>CHAPTER 20. FOLDABLE 1272
Note that if you don‚Äôt tell it what Monoid you mean, it will
complain about the type being ambiguous:
Prelude&gt; foldMap (+1) Nada
No instance for (Num a0) arising
from a use of ‚Äòit‚Äô
The type variable ‚Äòa0‚Äô is ambiguous
(... blah blah who cares ...)
So, we need to assert a type that has a Monoid for this to work:
Prelude&gt; import Data.Monoid
Prelude&gt; foldMap (+1) Nada :: Sum Int
Sum {getSum = 0}
Prelude&gt; foldMap (+1) Nada :: Product Int
Product {getProduct = 1}
Prelude&gt; foldMap (+1) (Just 1) :: Sum Int
Sum {getSum = 2}
With aNadavalue and a declared type of Sum Int (giving us
ourMonoid ),foldMap gave us Sum 0because that was the mempty or
identity for Sum. Similarly with NadaandProduct , we got Product
1because that was the identity for Product .</p>
<p>CHAPTER 20. FOLDABLE 1273
20.5 Some basic derived operations
TheFoldable typeclass includes some other operations that
we haven‚Äôt covered in this context yet. Some of these, such
aslength, were previously defined for use with lists, but their
types have been generalized now to make them useful with
other types of data structures. Below are descriptions, type
signatures, and examples for several of these:
-- | List of elements of a structure,
-- from left to right.
toList::t a-&gt;[a]
Prelude&gt; toList (Just 1)
[1]
Prelude&gt; let xs = [Just 1, Just 2, Just 3]
Prelude&gt; map toList xs
[[1],[2],[3]]
Prelude&gt; concatMap toList xs
[1,2,3]
Prelude&gt; let xs = [Just 1, Just 2, Nothing]
Prelude&gt; concatMap toList xs
[1,2]
Prelude&gt; toList (1, 2)
[2]</p>
<p>CHAPTER 20. FOLDABLE 1274
Why doesn‚Äôt it put the 1 in the list? For the same reason that
fmapdoesn‚Äôt apply a function to the 1.
-- | Test whether the structure is empty.
null::t a-&gt;Bool
Notice that nullreturns TrueonLeftandNothing values, just
as it does on empty lists and so forth:
Prelude&gt; null (Left 3)
True
Prelude&gt; null []
True
Prelude&gt; null Nothing
True
Prelude&gt; null (1, 2)
False
Prelude&gt; let xs = [Just 1, Just 2, Nothing]
Prelude&gt; fmap null xs
[False,False,True]
The next one, length , returns a count of how many ùëévalues
inhabit the t a. In a list, that could be multiple ùëévalues due to
the definition of that datatype. It‚Äôs important to note, though,
that for tuples, the first argument (as well as the leftmost, or
outermost, type arguments of datatypes such as Maybeand
Either ) is part of the ùë°here, not part of the ùëé.</p>
<p>CHAPTER 20. FOLDABLE 1275
-- | Returns the size/length of a finite
-- structure as an 'Int'.
length::t a-&gt;Int
Prelude&gt; length (1, 2)
1
Prelude&gt; let xs = [(1, 2), (3, 4), (5, 6)]
Prelude&gt; length xs
3
Prelude&gt; fmap length xs
[1,1,1]
Prelude&gt; fmap length Just [1, 2, 3]
1
The last example looks strange, we know. But if you run
it in your REPL, you‚Äôll see it returns the result we promised.
Why? And why does this
Prelude&gt; length $ Just [1, 2, 3]
1
return the same result?
TheùëéofJust a in the last case above is a list. There is only
one list.</p>
<p>CHAPTER 20. FOLDABLE 1276
Prelude&gt; let xs = [Just 1, Just 2, Just 3]
Prelude&gt; fmap length xs
[1,1,1]
Prelude&gt; let xs = [Just 1, Just 2, Nothing]
Prelude&gt; fmap length xs
[1,1,0]
-- | Does the element occur
-- in the structure?
elem::Eqa=&gt;a-&gt;t a-&gt;Bool
We‚Äôve used Either in the following example set to demon-
strate the behavior of Foldable functions with Leftvalues. As
we saw with Functor , you can‚Äôt map over the left data construc-
tor, because the left type argument is part of the structure. In
the following example set, that means that elemcan‚Äôt see inside
theLeftconstructor to whatever the value is, so the result will
beFalse, even if the value matches:
Prelude&gt; elem 2 (Just 3)
False
Prelude&gt; elem True (Left False)
False
Prelude&gt; elem True (Left True)
False
Prelude&gt; elem True (Right False)
False</p>
<p>CHAPTER 20. FOLDABLE 1277
Prelude&gt; elem True (Right True)
True
Prelude&gt; let xs = [Right 1,Right 2,Right 3]
Prelude&gt; fmap (elem 3) xs
[False,False,True]
-- | The largest element
-- of a non-empty structure.
maximum ::Orda=&gt;t a-&gt;a
-- | The least element
-- of a non-empty structure.
minimum ::Orda=&gt;t a-&gt;a
Here, notice that LeftandNothing (and similar) values are
empty for the purposes of these functions:
Prelude&gt; maximum [10, 12, 33, 5]
33
Prelude&gt; let xs = [Just 2, Just 10, Just 4]
Prelude&gt; fmap maximum xs
[2,10,4]
Prelude&gt; fmap maximum (Just [3, 7, 10, 2])
Just 10</p>
<p>CHAPTER 20. FOLDABLE 1278
Prelude&gt; minimum &quot;julie&quot;
'e'
Prelude&gt; fmap minimum (Just &quot;julie&quot;)
Just 'e'
Prelude&gt; let xs = map Just &quot;jul&quot;
Prelude&gt; xs
[Just 'j',Just 'u',Just 'l']
Prelude&gt; fmap minimum xs
&quot;jul&quot;
Prelude&gt; let xs = [Just 4, Just 3, Nothing]
Prelude&gt; fmap minimum xs
[4,3,*** Exception:
minimum: empty structure
Prelude&gt; minimum (Left 3)
*** Exception: minimum: empty structure
We‚Äôve seen sumandproduct before, and they do what their
names suggest: return the sum and product of the members
of a structure:
sum::(Foldable t,Numa)=&gt;t a-&gt;a
product ::(Foldable t,Numa)=&gt;t a-&gt;a
And now for some examples:</p>
<p>CHAPTER 20. FOLDABLE 1279
Prelude&gt; sum (7, 5)
5
Prelude&gt; fmap sum [(7, 5), (3, 4)]
[5,4]
Prelude&gt; fmap sum (Just [1, 2, 3, 4, 5])
Just 15
Prelude&gt; product Nothing
1
Prelude&gt; fmap product (Just [])
Just 1
Prelude&gt; fmap product (Right [1, 2, 3])
Right 6
Exercises: Library Functions
Implement the functions in terms of foldMap orfoldrfrom
Foldable , then try them out with multiple types that have
Foldable instances.
1.This and the next one are nicer with foldMap , butfoldris
fine too.
sum::(Foldable t,Numa)=&gt;t a-&gt;a
2.product ::(Foldable t,Numa)=&gt;t a-&gt;a
3.elem::(Foldable t,Eqa)
=&gt;a-&gt;t a-&gt;Bool</p>
<p>CHAPTER 20. FOLDABLE 1280
4.minimum ::(Foldable t,Orda)
=&gt;t a-&gt;Maybea
5.maximum ::(Foldable t,Orda)
=&gt;t a-&gt;Maybea
6.null::(Foldable t)=&gt;t a-&gt;Bool
7.length::(Foldable t)=&gt;t a-&gt;Int
8.Some say this is all Foldable amounts to.
toList::(Foldable t)=&gt;t a-&gt;[a]
9.Hint: use foldMap .
-- | Combine the elements
-- of a structure using a monoid.
fold::(Foldable t,Monoidm)=&gt;t m-&gt;m
10.DefinefoldMap in terms of foldr.
foldMap ::(Foldable t,Monoidm)
=&gt;(a-&gt;m)-&gt;t a-&gt;m
20.6 Chapter Exercises
WriteFoldable instances for the following datatypes.</p>
<p>CHAPTER 20. FOLDABLE 1281
1.dataConstant a b=
Constant b
2.dataTwoa b=
Twoa b
3.dataThreea b c=
Threea b c
4.dataThree'a b=
Three'a b b
5.dataFour'a b=
Four'a b b b
Thinking cap time. Write a filter function for Foldable types
usingfoldMap .
filterF ::(Applicative f
,Foldable t
,Monoid(f a))
=&gt;(a-&gt;Bool)-&gt;t a-&gt;f a
filterF =undefined
20.7 Follow-up resources
1.Jakub Arnold; Foldable and Traversable.</p>
<p>Chapter 21
Traversable
O, Thou hast damnable
iteration; and art, indeed,
able to corrupt a saint.
Shakespeare
1282</p>
<p>CHAPTER 21. TRAVERSABLE 1283
21.1 Traversable
Functor gives us a way to transform any values embedded in
structure. Applicative gives us a way to transform any val-
ues contained within a structure using a function that is also
embedded in structure. This means that each application pro-
duces the eÔ¨Äect of adding structure which is then applicatively
combined. Foldable gives us a way to process values embedded
in a structure as if they existed in a sequential order, as we‚Äôve
seen ever since we learned about list folding.
Traversable was introduced in the same paper as Applicative
and its introduction to Prelude didn‚Äôt come until the release
of GHC 7.10. However, it was available as part of the base
library before that. Traversable depends on Applicative , and
thusFunctor , and is also superclassed by Foldable .
Traversable allows you to transform elements inside the
structure like a functor, producing applicative eÔ¨Äects along the
way, and lift those potentially multiple instances of applicative
structure outside of the traversable structure. It is commonly
described as a way to traverse a data structure, mapping a
function inside a structure while accumulating the applicative
contexts along the way. This is easiest to see, perhaps, through
liberal demonstration of examples, so let‚Äôs get to it.
In this chapter, we will:
‚Ä¢explain the Traversable typeclass and its canonical func-</p>
<p>CHAPTER 21. TRAVERSABLE 1284
tions;
‚Ä¢explore examples of Traversable in practical use;
‚Ä¢tidy up some code using this typeclass;
‚Ä¢and, of course, write some Traversable instances.
21.2 The Traversable typeclass definition
This is the typeclass definition as it appears in the library
Data.Traversable :
class(Functor t,Foldable t)
=&gt;Traversable twhere
traverse ::Applicative f=&gt;
(a-&gt;f b)
-&gt;t a
-&gt;f (t b)
traverse f =sequenceA .fmap f
traverse maps each element of a structure to an action, eval-
uates the actions from left to right, and collects the results. So,
for example, if you have a list (structure) of IOactions, at the
end you‚Äôd have</p>
<p>CHAPTER 21. TRAVERSABLE 1285
-- | Evaluate each action in the
-- structure from left to right,
-- and collect the results.
sequenceA ::Applicative f
=&gt;t (f a) -&gt;f (t a)
sequenceA =traverse id
{-# MINIMAL traverse | sequenceA #-}
A minimal instance for this typeclass provides an imple-
mentation of either traverse orsequenceA , because as you can
see they can be defined in terms of each other. As with Foldable ,
we can define more than the bare minimum if we can leverage
information specific to our datatype to make the behavior
more efficient. We‚Äôre going to focus on these two functions in
this chapter, though, as those are the most typically useful.
21.3sequenceA
We will start with some examples of sequenceA in action, as it is
the simpler of the two. You can see from the type signature
above that the eÔ¨Äect of sequenceA is flipping two contexts or
structures. It doesn‚Äôt by itself allow you to apply any function
to theùëévalue inside the structure; it only flips the layers of
structure around. Compare these:
Prelude&gt; sum [1, 2, 3]</p>
<p>CHAPTER 21. TRAVERSABLE 1286
6
Prelude&gt; fmap sum [Just 1, Just 2, Just 3]
[1,2,3]
Prelude&gt; (fmap . fmap) sum Just [1, 2, 3]
Just 6
Prelude&gt; fmap product [Just 1, Just 2, Nothing]
[1,2,1]
To these:
Prelude&gt; fmap Just [1, 2, 3]
[Just 1,Just 2,Just 3]
Prelude&gt; sequenceA $ fmap Just [1, 2, 3]
Just [1,2,3]
Prelude&gt; sequenceA [Just 1, Just 2, Just 3]
Just [1,2,3]
Prelude&gt; sequenceA [Just 1, Just 2, Nothing]
Nothing
Prelude&gt; fmap sum $ sequenceA [Just 1, Just 2, Just 3]
Just 6
Prelude&gt; let xs = [Just 3, Just 4, Nothing]
Prelude&gt; fmap product (sequenceA xs)
Nothing
In the first example, using sequenceA flips the structures
around ‚Äî instead of a list of Maybevalues, you get a Maybeof a
list value. In the next two examples, we can lift a function over</p>
<p>CHAPTER 21. TRAVERSABLE 1287
theMaybestructure and apply it to the list that is inside, if we
have aJust a value after applying the sequenceA .
It‚Äôs worth mentioning here that the Data.Maybe module has a
function called catMaybes that oÔ¨Äers a diÔ¨Äerent way of handling
a list of Maybevalues:
Prelude&gt; import Data.Maybe
Prelude&gt; catMaybes [Just 1, Just 2, Just 3]
[1,2,3]
Prelude&gt; catMaybes [Just 1, Just 2, Nothing]
[1,2]
Prelude&gt; let xs = [Just 1, Just 2, Just 3, Nothing]
Prelude&gt; sum $ catMaybes xs
6
Prelude&gt; fmap sum $ sequenceA xs
Nothing
UsingcatMaybes allows you to sum (or otherwise process) the
list ofMaybevalues even if there‚Äôs potentially a Nothing value
lurking within.
21.4traverse
Let‚Äôs look next at the type of traverse :</p>
<p>CHAPTER 21. TRAVERSABLE 1288
traverse
::(Applicative f,Traversable t)
=&gt;(a-&gt;f b)-&gt;t a-&gt;f (t b)
You might notice a similarity between that and the types of
fmapand(=&lt;&lt;)(flip bind):
fmap ::(a-&gt;b)-&gt;f a-&gt;f b
(=&lt;&lt;)::(a-&gt;m b)-&gt;m a-&gt;m b
traverse ::(a-&gt;f b)-&gt;t a-&gt;f (t b)
We‚Äôre still mapping a function over some embedded value(s), like
fmap, but similar to flip bind, that function is itself generating
more structure. However, unlike flip bind, that structure can
be of a diÔ¨Äerent type than the structure we lifted over to apply
the function. And at the end, it will flip the two structures
around, as sequenceA did.
In fact, as we saw in the typeclass definition, traverse isfmap
composed with sequenceA :
traverse f=sequenceA .fmap f
Let‚Äôs look at how that works in practice:
Prelude&gt; fmap Just [1, 2, 3]
[Just 1,Just 2,Just 3]
Prelude&gt; sequenceA $ fmap Just [1, 2, 3]</p>
<p>CHAPTER 21. TRAVERSABLE 1289
Just [1,2,3]
Prelude&gt; sequenceA . fmap Just $ [1, 2, 3]
Just [1,2,3]
Prelude&gt; traverse Just [1, 2, 3]
Just [1,2,3]
We‚Äôll run through some longer examples in a moment, but
the general idea is that anytime you‚Äôre using sequenceA . fmap
f, you can use traverse to achieve the same result in one step.
mapMistraverse
YoumayhaveseenaslightlydiÔ¨Äerentwayofexpressing traverse
before, in the form of mapM.
In versions of GHC prior to 7.10, the type of mapMwas the
following:
mapM::Monadm
=&gt;(a-&gt;m b)-&gt;[a]-&gt;m [b]
-- contrast with
traverse ::Applicative f
=&gt;(a-&gt;f b)-&gt;t a-&gt;f (t b)
We can think of traverse inTraversable as abstracting the []
inmapMto being any traversable data structure and generalizing</p>
<p>CHAPTER 21. TRAVERSABLE 1290
theMonadrequirement to only need an Applicative . This is
valuable as it means we can use this pattern more widely and
with more code. For example, the list datatype is fine for
small pluralities of values but in more performance-sensitive
code, you may want to use a Vector from the vector1library.
Withtraverse , you won‚Äôt have to change your code because
the primary Vector datatype has a Traversable instance and so
should work.
Similarly, the type for sequence in GHC versions prior to
7.10 is a less useful sequenceA :
sequence ::Monadm
=&gt;[m a]
-&gt;m [a]
-- contrast with
sequenceA ::(Applicative f,Traversable t)
=&gt;t (f a)
-&gt;f (t a)
Again we‚Äôre generalizing the list to any Traversable and weak-
ening the Monadrequirement to Applicative .
1http://hackage.haskell.org/package/vector</p>
<p>CHAPTER 21. TRAVERSABLE 1291
21.5 So, what‚Äôs Traversable for?
In a literal sense, anytime you need to flip two type construc-
tors around, or map something and then flip them around,
that‚Äôs probably Traversable :
sequenceA ::Applicative f
=&gt;t (f a) -&gt;f (t a)
traverse ::Applicative f
=&gt;(a-&gt;f b)-&gt;t a-&gt;f (t b)
We‚Äôll kick around some hypothetical functions and values
without bothering to implement them in the REPL to see when
we may want traverse orsequenceA :
Prelude&gt; let f = undefined :: a -&gt; Maybe b
Prelude&gt; let xs = undefined :: [a]
Prelude&gt; :t map f xs
map f xs :: [Maybe b]
But what if we want a value of type Maybe [b] ? The following
will work, but we can do better:
Prelude&gt; :t sequenceA $ map f xs
sequenceA $ map f xs :: Maybe [a]</p>
<p>CHAPTER 21. TRAVERSABLE 1292
It‚Äôs usually better to use traverse whenever we see a sequence
orsequenceA combined with a maporfmap:
Prelude&gt; :t traverse f xs
traverse f xs :: Maybe [b]
Next we‚Äôll start looking at real examples of when you‚Äôd want
to do this.
21.6 Morse code revisited
We‚Äôre going to call back to what we did in the Testing chapter
with the Morse code to look at a nice example of how to use
traverse . Let‚Äôs recall what we had done there:
stringToMorse ::String-&gt;Maybe[Morse]
stringToMorse s=
sequence $fmap charToMorse s
-- what we want to do:
stringToMorse ::String-&gt;Maybe[Morse]
stringToMorse =traverse charToMorse
Normally, you might expect that if you mapped an (a -&gt;
f b)over at a, you‚Äôd end up with t (f b) buttraverse flips
that around. Remember, we had each character conversion
wrapped in a Maybedue to the possibility of getting characters in</p>
<p>CHAPTER 21. TRAVERSABLE 1293
a string that aren‚Äôt translatable into Morse (or, in the opposite
conversion, aren‚Äôt Morse characters):
Prelude&gt; morseToChar &quot;gobbledegook&quot;
Nothing
Prelude&gt; morseToChar &quot;-.-.&quot;
Just 'c'
We can use fromMaybe to remove the Maybelayer:
Prelude&gt; import Data.Maybe
Prelude Data.Maybe&gt; fromMaybe ' ' (morseToChar &quot;-.-.&quot;)
'c'
Prelude&gt; stringToMorse &quot;chris&quot;
Just [&quot;-.-.&quot;,&quot;....&quot;,&quot;.-.&quot;,&quot;..&quot;,&quot;...&quot;]
Prelude&gt; import Data.Maybe
Prelude&gt; fromMaybe [] (stringToMorse &quot;chris&quot;)
[&quot;-.-.&quot;,&quot;....&quot;,&quot;.-.&quot;,&quot;..&quot;,&quot;...&quot;]
We‚Äôll define a little helper for use in the following examples:
Prelude&gt; let morse s = fromMaybe [] (stringToMorse s)
Prelude&gt; :t morse
morse :: String -&gt; [Morse]
Now, if we fmap morseToChar , we get a list of Maybevalues:</p>
<p>CHAPTER 21. TRAVERSABLE 1294
Prelude&gt; fmap morseToChar (morse &quot;chris&quot;)
[Just 'c',Just 'h',Just 'r',Just 'i',Just 's']
We don‚Äôt want catMaybes here because it drops the Nothing
values. What we want here is for any Nothing values to make the
final result Nothing . The function that gives us what we want for
this issequence . We did use sequence in the original version of
thestringToMorse function. sequence is useful for flipping your
types around as well (note the positions of the ùë°andùëö). There
is asequence inPrelude and another, more generic, version in
Data.Traversable :
Prelude&gt; :t sequence
sequence :: (Monad m, Traversable t) =&gt;
t (m a) -&gt; m (t a)
-- more general, can be used with types
-- other than List
Prelude&gt; import Data.Traversable as T
Prelude T&gt; :t T.sequence
T.sequence :: (Traversable t, Monad m)
=&gt; t (m a) -&gt; m (t a)
To use this over a list of Maybe(or other monadic) values, we
need to compose it with fmap:
Prelude&gt; :t (sequence .) . fmap</p>
<p>CHAPTER 21. TRAVERSABLE 1295
(sequence .) . fmap
:: (Monad m, Traversable t) =&gt;
(a1 -&gt; m a) -&gt; t a1 -&gt; m (t a)
Prelude&gt; sequence $ fmap morseToChar (morse &quot;chris&quot;)
Just &quot;chris&quot;
Prelude&gt; sequence $ fmap morseToChar (morse &quot;julie&quot;)
Just &quot;julie&quot;
The weird looking composition, which you‚Äôve possibly also
seen in the form of (join .) . fmap is because fmaptakes two
(not one) arguments, so the expressions aren‚Äôt proper unless
we compose twice to await a second argument for fmapto get
applied to.
-- we want this
(sequence .).fmap=
\f xs-&gt;sequence (fmap f xs)
-- not this
sequence .fmap=
\f-&gt;sequence (fmap f)
This composition of sequence andfmapis so common that
traverse is now a standard Prelude function. Compare the
above to the following:</p>
<p>CHAPTER 21. TRAVERSABLE 1296
*Morse T&gt; traverse morseToChar (morse &quot;chris&quot;)
Just &quot;chris&quot;
*Morse T&gt; traverse morseToChar (morse &quot;julie&quot;)
Just &quot;julie&quot;
So,traverse isjustfmapandthe Traversable versionof sequence
bolted together into one convenient function. sequence is the
unique bit, but you need to do the fmapfirst most of the time,
so you end up using traverse . This is very similar to the way
&gt;&gt;=is justjoincomposed with fmapwherejoinis the bit that is
unique to Monad.
21.7 Axing tedious code
Try to bear with us for a moment and realize that the following
is real but also intentionally fake code. That is, one of the
authors helped somebody with refactoring their code, and
this simplified version is what your author was given. One of
the strengths of Haskell is that we can work in terms of types
without worry about code that actually runs sometimes. This
code is from Alex Petrov:</p>
<p>CHAPTER 21. TRAVERSABLE 1297
-- Thanks for the great example, Alex
dataQuery =Query
dataSomeObj =SomeObj
dataIoOnlyObj =IoOnlyObj
dataErr =Err
-- There's a decoder function that makes
-- some object from String
decodeFn ::String-&gt;EitherErrSomeObj
decodeFn =undefined
-- There's a query, that runs against the
-- DB and returns array of strings
fetchFn ::Query-&gt;IO[String]
fetchFn =undefined
-- an additional &quot;context initializer&quot;,
-- that also has IO
makeIoOnlyObj ::[SomeObj]
-&gt;IO[(SomeObj,IoOnlyObj )]
makeIoOnlyObj =undefined</p>
<p>CHAPTER 21. TRAVERSABLE 1298
-- before
pipelineFn
::Query
-&gt;IO(EitherErr[(SomeObj,IoOnlyObj )])
pipelineFn query= do
a&lt;-fetchFn query
casesequence (map decodeFn a) of
(Lefterr)-&gt;return$Left$err
(Rightres)-&gt; do
a&lt;-makeIoOnlyObj res
return$Righta
The objective was to clean up this code. A few things made
them suspicious:
1.The use of sequence andmap.
2.Manually casing on the result of the sequence and the map.
3.Binding monadically over the Either only to perform an-
other monadic ( IO) action inside of that.
We pared the pipeline function down to this:</p>
<p>CHAPTER 21. TRAVERSABLE 1299
pipelineFn
::Query
-&gt;IO(EitherErr[(SomeObj,IoOnlyObj )])
pipelineFn query= do
a&lt;-fetchFn query
traverse makeIoOnlyObj (mapM decodeFn a)
Thanks to merijn on the IRC channel for helping with this.
We can make it pointfree if we want to:
pipelineFn
::Query
-&gt;IO(EitherErr[(SomeObj,IoOnlyObj )])
pipelineFn =
(traverse makeIoOnlyObj
.mapM decodeFn =&lt;&lt;).fetchFn
And since mapMis justtraverse with a slightly diÔ¨Äerent type:
pipelineFn
::Query
-&gt;IO(EitherErr[(SomeObj,IoOnlyObj )])
pipelineFn =
(traverse makeIoOnlyObj
.traverse decodeFn =&lt;&lt;).fetchFn</p>
<p>CHAPTER 21. TRAVERSABLE 1300
This is the terse, clean style many Haskellers prefer. As we
said back when we first introduced it, pointfree style can help
focus the attention on the functions, rather than the specifics
of the data that are being passed around as arguments. Using
functions like traverse cleans up code by drawing attention to
the ways the types are changing and signaling the program-
mer‚Äôs intent.
21.8 Do all the things
We‚Äôre going to use an HTTP client library named wreq2for
this demonstration so we can make calls to a handy-dandy
website for testing HTTP clients at http://httpbin.org/ . Feel
free to experiment and substitute your own ideas for HTTP
services or websites you could poke and prod.
2http://hackage.haskell.org/package/wreq</p>
<p>CHAPTER 21. TRAVERSABLE 1301
moduleHttpStuff where
importData.ByteString.Lazy hiding(map)
importNetwork.Wreq
-- replace with other websites
-- if desired or needed
urls::[String]
urls=[&quot;http://httpbin.org/ip&quot;
,&quot;http://httpbin.org/bytes/5&quot;
]
mappingGet ::[IO(Response ByteString )]
mappingGet =map get urls
But what if we don‚Äôt want a list of IOactions we can perform
to get a response, but rather one big IOaction that produces a
list of responses? This is where Traversable can be helpful:
traversedUrls ::IO[Response ByteString ]
traversedUrls =traverse get urls
We hope that these examples have helped demonstrate that
Traversable is a useful typeclass. While Foldable seems trivial,
it is a necessary superclass of Traversable , andTraversable , like</p>
<p>CHAPTER 21. TRAVERSABLE 1302
Functor andMonad, is now widely used in everyday Haskell code,
due to its practicality.
Strength for understanding
Traversable is stronger than Functor andFoldable . Because of
this, we can recover the Functor andFoldable instance for a
type from the Traversable , just as we can recover the Functor
andApplicative from the Monad. Here we can use the Identity
type to get something that is essentially just fmapall over again:
Prelude&gt; import Data.Functor.Identity
Prelude&gt; traverse (Identity . (+1)) [1, 2]
Identity [2,3]
Prelude&gt; runIdentity $ traverse (Identity . (+1)) [1, 2]
[2,3]
Prelude&gt; :{
Prelude| let edgeMap f t =
Prelude| runIdentity $ traverse (Identity . f) t
Prelude| :}
Prelude&gt; :t edgeMap
edgeMap :: Traversable t =&gt; (a -&gt; b) -&gt; t a -&gt; t b
Prelude&gt; edgeMap (+1) [1..5]
[2,3,4,5,6]</p>
<p>CHAPTER 21. TRAVERSABLE 1303
UsingConstorConstant , wecanrecoverafoldMappy-looking
Foldable as well:
Prelude&gt; import Data.Monoid
-- from <code>transformers</code>
Prelude&gt; import Data.Functor.Constant
Prelude&gt; let xs = [1, 2, 3, 4, 5] :: [Sum Integer]
Prelude&gt; traverse (Constant . (+1)) xs
Constant (Sum {getSum = 20})
Prelude&gt; :{
Prelude| let foldMap' f t =
Prelude| getConstant $ traverse (Constant . f) t
Prelude| :}
Prelude&gt; :t foldMap'
foldMap' :: (Traversable t, Monoid a)
=&gt; (a1 -&gt; a) -&gt; t a1 -&gt; a
Prelude&gt; :t foldMap
foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m
Doing exercises like this can help strengthen your intuitions
for the relationships of these typeclasses and their canonical
functions. We know it sometimes feels like these things are
pure intellectual exercise, but getting comfortable with ma-
nipulating functions like these is ultimately the key to getting</p>
<p>CHAPTER 21. TRAVERSABLE 1304
comfortable with Haskell. This is how you learn to play type
Tetris with the pros.
21.9 Traversable instances
You knew this was coming.
Either
TheTraversable instance that follows here is identical to the
one in the Data.Traversable module in base, but we‚Äôve added
aFunctor ,Foldable , andApplicative so that you might see a
progression:</p>
<p>CHAPTER 21. TRAVERSABLE 1305
dataEithera b=
Lefta
|Rightb
deriving (Eq,Ord,Show)
instance Functor (Eithera)where
fmap_(Leftx)=Leftx
fmap f ( Righty)=Right(f y)
instance Applicative (Eithere)where
pure =Right
Lefte&lt;<em>&gt; _ = Lefte
Rightf&lt;</em>&gt;r=fmap f r
instance Foldable (Eithera)where
foldMap <em>(Left</em>)=mempty
foldMap f ( Righty)=f y
foldr_z (Left_)=z
foldr f z ( Righty)=f y z
instance Traversable (Eithera)where
traverse _(Leftx)=pure (Leftx)
traverse f ( Righty)=Right&lt;$&gt;f y</p>
<p>CHAPTER 21. TRAVERSABLE 1306
Given what you‚Äôve seen above, this hopefully isn‚Äôt too sur-
prising. We have function application and type-flipping, in an
Either context.
Tuple
As above, we‚Äôve provided a progression of instances, but for
the two-tuple or anonymous product:
instance Functor ((,) a) where
fmap f (x,y) =(x, f y)
instance Monoida
=&gt;Applicative ((,) a) where
pure x=(mempty, x)
(u, f)&lt;*&gt;(v, x)=
(u <code>mappend</code> v, f x)
instance Foldable ((,) a) where
foldMap f ( _, y)=f y
foldr f z ( _, y)=f y z
instance Traversable ((,) a) where
traverse f (x, y) =(,) x&lt;$&gt;f y
Here, we have much the same, but for a tuple context.</p>
<p>CHAPTER 21. TRAVERSABLE 1307
21.10Traversable Laws
Thetraverse function must satisfy the following laws:
1.Naturality
t.traverse f =traverse (t .f)
This law tells us that function composition behaves in
unsurprising ways with respect to a traversed function.
Since a traversed function ùëìis generating the structure
that appears on the ‚Äúoutside‚Äù of the traverse operation,
there‚Äôs no reason we shouldn‚Äôt be able to float a function
over the structure into the traversal itself.
2.Identity
traverse Identity =Identity
This law says that traversing the data constructor of the
Identity type over a value will produce the same result
as just putting the value in Identity . This tells us Identity
represents a structural identity for traversing data. This is
another way of saying that a Traversable instance cannot
add or inject any structure or eÔ¨Äects.
3.Composition
traverse (Compose .fmap g.f)=
Compose .fmap (traverse g) .traverse f</p>
<p>CHAPTER 21. TRAVERSABLE 1308
This law demonstrates how we can collapse sequential
traversals into a single traversal, by taking advantage of
theCompose datatype, which combines structure.
ThesequenceA function must satisfy the following laws:
1.Naturality
t.sequenceA =sequenceA .fmap t
2.Identity
sequenceA .fmapIdentity =Identity
3.Composition
sequenceA .fmapCompose =
Compose .fmap sequenceA .sequenceA
Noneofthisshould‚Äôvebeentoosurprisinggivenwhatyou‚Äôve
seen with traverse .
21.11 Quality Control
Great news! You can QuickCheck your Traversable instances as
well, since they have laws. Conveniently, the checkers library
we‚Äôve been using already has the laws for us. You can add the
following to a module and change the type alias to change
what instances are being tested:</p>
<p>CHAPTER 21. TRAVERSABLE 1309
typeTI=[]
main= do
lettrigger ::TI(Int,Int, [Int])
trigger =undefined
quickBatch (traversable trigger)
21.12 Chapter Exercises
Traversable instances
Write a Traversable instance for the datatype provided, filling
in any required superclasses. Use QuickCheck to validate your
instances.
Identity
Write a Traversable instance for Identity .
newtype Identity a=Identity a
deriving (Eq,Ord,Show)
instance Traversable Identity where
traverse =undefined</p>
<p>CHAPTER 21. TRAVERSABLE 1310
Constant
newtype Constant a b=
Constant { getConstant ::a }
Maybe
dataOptional a=
Nada
|Yepa
List
dataLista=
Nil
|Consa (Lista)
Three
dataThreea b c=
Threea b c
Pair
dataPaira b=
Paira b</p>
<p>CHAPTER 21. TRAVERSABLE 1311
Big
When you have more than one value of type ùëè, you‚Äôll want
to useMonoid andApplicative for the Foldable andTraversable
instances respectively.
dataBiga b=
Biga b b
Bigger
Same as for Big.
dataBiggera b=
Biggera b b b
S
This may be difficult. To make it easier, we‚Äôll give you the
constraints and QuickCheck instances:
{-# LANGUAGE FlexibleContexts #-}
moduleSkiFree where
importTest.QuickCheck
importTest.QuickCheck.Checkers</p>
<p>CHAPTER 21. TRAVERSABLE 1312
dataSn a=S(n a) a deriving (Eq,Show)
instance (Functor n
,Arbitrary (n a)
,Arbitrary a )
=&gt;Arbitrary (Sn a)where
arbitrary =
S&lt;$&gt;arbitrary &lt;<em>&gt;arbitrary
instance (Applicative n
,Testable (nProperty )
,EqPropa )
=&gt;EqProp(Sn a)where
(Sx y)=-=(Sp q)=
(property $(=-=)&lt;$&gt;x&lt;</em>&gt;p)
.&amp;.(y=-=q)
instance Traversable n
=&gt;Traversable (Sn)where
traverse =undefined
main=
sample' (arbitrary ::Gen(S[]Int))</p>
<p>CHAPTER 21. TRAVERSABLE 1313
Instances for Tree
This might be hard. Write the following instances for Tree.
dataTreea=
Empty
|Leafa
|Node(Treea) a (Treea)
deriving (Eq,Show)
instance Functor Treewhere
fmap=undefined
-- foldMap is a bit easier
-- and looks more natural,
-- but you can do foldr too
-- for extra credit.
instance Foldable Treewhere
foldMap =undefined
instance Traversable Treewhere
traverse =undefined
Hints:
1.ForfoldMap , thinkFunctor but with some Monoid thrown in.</p>
<p>CHAPTER 21. TRAVERSABLE 1314
2.Fortraverse , thinkFunctor but with some Functor3thrown
in.
21.13 Follow-up resources
1.Foldable and Traversable; Jakub Arnold.
2.The Essence of the Iterator Pattern; Jeremy Gibbons and
Bruno Oliveira.
3.Applicative Programming with EÔ¨Äects; Conor McBride
and Ross Paterson.
3Not a typo.</p>
<p>Chapter 22
Reader
The tears of the world are
a constant quantity. For
each one who begins to
weep somewhere else
another stops. The same
is true of the laugh.
Samuel Beckett
1315</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1316
22.1 Reader
The last two chapters were focused on some typeclasses that
might still seem strange and difficult to you. The next three
chapters are going to focus on some patterns that might still
seem strange and difficult. Foldable ,Traversable ,Reader,State,
and parser combinators are not strictly necessary to under-
standing and using Haskell. We do have reasons for introduc-
ing them now, but those reasons might not seem clear to you
for a while. If you don‚Äôt quite grasp all of it on the first pass,
that‚Äôs completely fine. Read it through, do your best with the
exercises, come back when you feel like you‚Äôre ready.
Whenwritingapplications, programmersoftenneedtopass
around some information that may be needed intermittently
or universally throughout an entire application. We don‚Äôt want
to simply pass this information as arguments because it would
be present in the type of almost every function. This can make
the code harder to read and harder to maintain. To address
this, we use Reader .
In this chapter, we will:
‚Ä¢examine the Functor ,Applicative , andMonadinstances for
functions;
‚Ä¢learn about the Reader newtype;
‚Ä¢see some examples of using Reader .</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1317
22.2 A new beginning
We‚Äôre going to set this chapter up a bit diÔ¨Äerently from previ-
ous chapters, because we‚Äôre hoping that this will help demon-
strate that what we‚Äôre doing here is not that diÔ¨Äerent from
things you‚Äôve done before. So, we‚Äôre going to start with some
examples. Start a file like this:
importControl.Applicative
boop=(*2)
doop=(+10)
bip::Integer -&gt;Integer
bip=boop.doop
We know that the bipfunction will take one argument be-
cause of the types of boop,doop, and(.). Note that if you do not
specify the types and load it from a file, it will be monomor-
phic by default; if you wish to make bippolymorphic, you
may change its signature but you also need to specify a poly-
morphic type for the two functions it‚Äôs built from. The rest of
the chapter will wait while you verify these things.
When we apply bipto an argument, doopwill be applied to
that argument first, and then the result of that will be passed
as input to boop. So far, nothing new.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1318
We can also write that function composition this way:
bloop::Integer -&gt;Integer
bloop=fmap boop doop
We aren‚Äôt accustomed to fmapping a function over another
function, and you may be wondering what the functorial con-
text here is. By ‚Äúfunctorial context‚Äù we mean the structure
(datatype) that the function is being lifted over in order to
apply to the value inside. For example, a list is a functorial
context we can lift functions over. We say that the function gets
lifted over the structure of the list and applied to or mapped
over the values that are inside the list.
Inbloop, the context is a partially applied function. As in
function composition, fmapcomposes the two functions before
applying them to the argument. The result of the one can then
get passed to the next as input. Using fmaphere lifts the one
partially applied function over the next, in a sense setting up
something like this:
fmapboop doop x ==(*2) ((+10) x)
-- when this x comes along, it's the
-- first necessary argument to (+10)
-- then the result for that is the
-- first necessary argument to (*2)</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1319
This is the Functor of functions. We‚Äôre going to go into more
detail about this soon.
For now, let‚Äôs turn to another set of examples. Put these in
the same file so boopanddoopare still in scope:
bbop::Integer -&gt;Integer
bbop=(+)&lt;$&gt;boop&lt;*&gt;doop
duwop::Integer -&gt;Integer
duwop=liftA2 ( +) boop doop
Now we‚Äôre in an Applicative context. We‚Äôve added another
function to lift over the contexts of our partially applied func-
tions. This time, we still have partially applied functions that
are awaiting application to an argument, but this will work
diÔ¨Äerently than fmapping did. This time, the argument will
get passed to both boopanddoopin parallel, and the results will
be added together.
boopanddoopare each waiting for an input. We can apply
them both at once like this:
Prelude&gt; bbop 3
19
That does something like this:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1320
((+)&lt;$&gt;(<em>2)&lt;</em>&gt;(+10))3
-- First the fmap
(*2)::Numa=&gt;a-&gt;a
(+)::Numa=&gt;a-&gt;a-&gt;a
(+)&lt;$&gt;(*2)::Numa=&gt;a-&gt;a-&gt;a
Mapping a function awaiting two arguments over a function
awaiting one produces a two argument function.
Remember, this is identical to function composition:
(+).(*2)::Numa=&gt;a-&gt;a-&gt;a
With the same result:
Prelude&gt; ((+) . (*2)) 5 3
13
Prelude&gt; ((+) &lt;$&gt; (*2)) 5 3
13
So what‚Äôs happening?</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1321
((+)&lt;$&gt;(*2))53
-- Keeping in mind that this
-- is (.) under the hood
((+).(*2))53
-- f . g = \ x -&gt; f (g x)
((+).(<em>2))==\x-&gt;(+) (2</em>x)
The tricky part here is that even after we apply ùë•, we‚Äôve got
(+)partially applied to the first argument which was doubled
by(*2). There‚Äôs a second argument, and that‚Äôs what will get
added to the first argument that got doubled:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1322
-- The first function to get
-- applied is (<em>2), and the
-- first argument is 5. (<em>2)
-- takes one argument, so we get:
((+).(<em>2))53
(\x-&gt;(+) (2</em>x))53
(\5-&gt;(+) (2</em>5))3
((+)10)3
-- Then it adds 10 and 3
13
Okay, but what about the second bit?
((+)&lt;$&gt;(<em>2)&lt;</em>&gt;(+10))3
-- Wait, what? What happened to the
-- first argument?
((+)&lt;$&gt;(<em>2)&lt;</em>&gt;(+10))::Numb=&gt;b-&gt;b
One of the nice things about Haskell is we can assert a more
concrete type for functions like (&lt;</em>&gt;)and see if the compiler
agrees we‚Äôre putting forth something hypothetically possible.
Let‚Äôs remind ourselves of the type of (&lt;<em>&gt;):
Prelude&gt; :t (&lt;</em>&gt;)</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1323
(&lt;<em>&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
-- in this case, we know f is ((-&gt;) a)
-- so we concretize it thusly
Prelude&gt; :t (&lt;</em>&gt;) :: (a -&gt; a -&gt; b) -&gt; (a -&gt; a) -&gt; (a -&gt; b)
(&lt;<em>&gt;) :: (a -&gt; a -&gt; b) -&gt; (a -&gt; a) -&gt; (a -&gt; b)
The compiler agrees that this is a possible type for (&lt;</em>&gt;).
So how does that work? What‚Äôs happening is we‚Äôre feeding
a single argument to the (<em>2)and(+10)and the two results
form the two arguments to (+):
((+)&lt;$&gt;(<em>2)&lt;</em>&gt;(+10))3
(3</em>2)+(3+10)
6+13
19
We‚Äôd use this when two functions would share the same
input and we want to apply some other function to the result
of those to reach a final result. This happens more than you
might think, and we saw an example of it back in the Abstract
Structure Applied chapter:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1324
moduleWeb.Shipping.Utils ((&lt;||&gt;))where
importControl.Applicative (liftA2)
(&lt;||&gt;)::(a-&gt;Bool)
-&gt;(a-&gt;Bool)
-&gt;a
-&gt;Bool
(&lt;||&gt;)=liftA2 ( ||)
That is the same idea as duwopabove.
Finally, another example:
boopDoop ::Integer -&gt;Integer
boopDoop = do
a&lt;-boop
b&lt;-doop
return (a +b)
This will do precisely the same thing as the Applicative ex-
ample, but this time the context is monadic. This distinction
doesn‚Äôt much matter with this particular function. We assign
the variable ùëéto the partially applied function boop, andùëèto
doop. As soon as we receive an input, it will fill the empty slots
inboopanddoop. The results will be bound to the variables ùëé
andùëèand passed into return .</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1325
So, we‚Äôve seen here that we can have a Functor ,Applicative ,
andMonadfor partially applied functions. In all cases, these
are awaiting application to one argument that will allow both
functions to be evaluated. The Functor of functions is function
composition. The Applicative andMonadchain the argument
forward in addition to the composition (applicatives and mon-
ads are both varieties of functors, so they retain that core
functorial behavior).
This is the idea of Reader. It is a way of stringing functions
together when all those functions are awaiting one input from
a shared environment. We‚Äôre going to get into the details of
how it works, but the important intuition here is that it‚Äôs an-
other way of abstracting out function application and gives us
a way to do computation in terms of an argument that hasn‚Äôt
been supplied yet. We use this most often when we have a con-
stant value that we will obtain from somewhere outside our
program that will be an argument to a whole bunch of func-
tions. Using Reader allows us to avoid passing that argument
around explicitly.
Short Exercise: Warming Up
We‚Äôll be doing something here very similar to what you saw
above, to give you practice and try to develop a feel or intuition
for what is to come. These are similar enough to what you just
saw that you can almost copy and paste, so try not to overthink</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1326
them too much.
First, start a file oÔ¨Ä like this:
importData.Char
cap::[Char]-&gt;[Char]
capxs=map toUpper xs
rev::[Char]-&gt;[Char]
revxs=reverse xs
Two simple functions with the same type, taking the same
type of input. We could compose them, using (.)orfmap:
composed ::[Char]-&gt;[Char]
composed =undefined
fmapped ::[Char]-&gt;[Char]
fmapped =undefined
The output of those two should be identical: one string that
is made all uppercase and reversed, like this:
Prelude&gt; composed &quot;Julie&quot;
&quot;EILUJ&quot;
Prelude&gt; fmapped &quot;Chris&quot;
&quot;SIRHC&quot;</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1327
Now we want to return the results of capandrevboth, as a
tuple, like this:
Prelude&gt; tupled &quot;Julie&quot;
(&quot;JULIE&quot;,&quot;eiluJ&quot;)
-- or
Prelude&gt; tupled' &quot;Julie&quot;
(&quot;eiluJ&quot;,&quot;JULIE&quot;)
We will want to use an Applicative here. The type will look
like this:
tupled::[Char]-&gt;([Char], [Char])
There is no special reason such a function needs to be
monadic, but let‚Äôs do that, too, to get some practice. Do it
one time using dosyntax; then try writing a new version using
(&gt;&gt;=). The types will be the same as the type for tupled .
22.3 This is Reader
As we saw above, functions have Functor ,Applicative , andMonad
instances. Usually when you see or hear the term Reader, it‚Äôll
be referring to the Monadinstance.
We use function composition because it lets us compose two
functions without explicitly having to recognize the argument
that will eventually arrive; the Functor of functions is function</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1328
composition. With the Functor of functions, we are able to map
an ordinary function over another to create a new function
awaiting a final argument. The Applicative andMonadinstances
for the function type give us a way to map a function that is
awaiting an ùëéover another function that is also awaiting an ùëé.
Giving it a name helps us know the what and why of what
we‚Äôre doing: reading an argument from the environment into
functions. It‚Äôll be especially nice for clarity‚Äôs sake later when
we make the ReaderT monad transformer.
Exciting, right? Let‚Äôs back up here and go into more detail
about how Reader works.
22.4 Breaking down the Functor of
functions
If you type :info Functor in your REPL, one of the instances
you might notice is the one for the partially applied type
constructor of functions ((-&gt;) r) :
instance Functor ((-&gt;) r)
This can be a little confusing, so we‚Äôre going to unwind it
until hopefully it‚Äôs a bit more comfortable. First, let‚Äôs see what
we can accomplish with this:
Prelude&gt; fmap (+1) (*2) 3</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1329
7
-- Rearranging a little bit
Prelude&gt; fmap (+1) (*2) $ 3
7
Prelude&gt; (fmap (+1) (*2)) 3
7
This should look familiar:
Prelude&gt; (+1) . (*2) $ 3
7
Prelude&gt; (+2) . (*1) $ 2
4
Prelude&gt; fmap (+2) (*1) $ 2
4
Prelude&gt; (+2) <code>fmap</code> (*1) $ 2
4
Fortunately, there‚Äôs nothing weird going on here. If you
check the implementation of the instance in base, you‚Äôll find
the following:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1330
instance Functor ((-&gt;) r)where
fmap=(.)
Let‚Äôs unravel the types. Remember that (-&gt;)takes two argu-
ments and therefore has kind * -&gt; * -&gt; * . So, we know upfront
that we have to apply one of the type arguments before we
can have a Functor . With the Either Functor , we know that we
will lift over the Either a and if our function will be applied, it
will be applied to the ùëèvalue. With the function type:
data(-&gt;) a b
the same rule applies: you have to lift over the (-&gt;) a and
only transform the ùëèvalue. The ùëéis conventionally called ùëü
forReader in these instances, but a type variable of any other
name smells as sweet. Here, ùëüis the first argument of (a -&gt; b) :</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1331
-- Type constructor of functions
(-&gt;)
-- Fully applied
a-&gt;b
((-&gt;) r)
-- is
r-&gt;
-- so r is the type of the
-- argument to the function
From this, we can determine that ùëü, the argument type for
functions, is part of the structure being lifted over when we lift
over a function, not the value being transformed or mapped
over.
This leaves the result of the function as the value being
transformed. This happens to line up neatly with what func-
tion composition is about:
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c
-- or perhaps
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
Now how does this line up with Functor ?</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1332
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
fmap::Functor f=&gt;(a-&gt;b)-&gt;f a-&gt;f b
We‚Äôll remove the names of the functions and the typeclass
constraint as we can take them for granted from here on out:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1333
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
::(a-&gt;b)-&gt;f a-&gt;f b
-- Changing up the letters
-- without changing the meaning
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
::(b-&gt;c)-&gt;f b-&gt;f c
-- f is ((-&gt;) a)
::(b-&gt;c)
-&gt; (a-&gt;b)
-&gt; (a-&gt;c)
::(b-&gt;c)
-&gt;((-&gt;) a) b
-&gt;((-&gt;) a) c
-- Unroll the prefix notation into infix
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
Bada bing. Functorial lifting for functions.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1334
22.5 But uh, Reader?
Ah yes, right. Reader is a newtype wrapper for the function
type:
newtype Readerr a=
Reader{ runReader ::r-&gt;a }
Theùëüis the type we‚Äôre reading in and ùëéis the result type of
our function.
TheReader newtype has a handy runReader accessor to get
the function out of Reader. Let us prove for ourselves that
this is the same thing, but with a touch of data constructor
jiggery-pokery mixed in. What does the Functor for this look
like compared to function composition?</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1335
instance Functor (Readerr)where
fmap::(a-&gt;b)
-&gt;Readerr a
-&gt;Readerr b
fmap f ( Readerra)=
Reader$\r-&gt;f (ra r)
-- same as (.)
compose ::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
compose f g=\x-&gt;f (g x)
-- see it?
\r-&gt;f (ra r)
\x-&gt;f (g x)
Basically the same thing right? In the Reader functor, rahas
the type r -&gt; a, andfhas the type a -&gt; b. Applying rato the
valueryields a value of type a, which fis then applied to,
yielding a value of type b. Function composition!
We can use the fact that we recognize this as function com-
position to make a slightly diÔ¨Äerent instance for Reader :</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1336
instance Functor (Readerr)where
fmap::(a-&gt;b)
-&gt;Readerr a
-&gt;Readerr b
fmap f ( Readerra)=
Reader$(f.ra)
So what we‚Äôre doing here is basically:
1.Unpack r -&gt; a out ofReader
2.Compose ùëìwith the function we unpacked out of Reader .
3.Put the new function made from the composition back
intoReader .
Without the Reader newtype, we drop steps 1 and 3 and have
function composition.
Exercise: Ask
Implement the following function. If you get stuck, remem-
ber it‚Äôs less complicated than it looks. Write down what you
know. What do you know about the type ùëé? What does the
type simplify to? How many inhabitants does that type have?
You‚Äôve seen the type before.
ask::Readera a
ask=Reader???</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1337
22.6 Functions have an Applicative too
We‚Äôve seen a couple of examples already of the Applicative of
functions and how it works. Now we‚Äôll get into the details.
The first thing we want to do is notice how the types spe-
cialize:
-- Applicative f =&gt;
-- f ~ (-&gt;) r
pure::a-&gt;f a
pure::a-&gt;(r-&gt;a)
(&lt;<em>&gt;)::f (a-&gt;b)
-&gt;f a
-&gt;f b
(&lt;</em>&gt;)::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
As we saw in the Functor instance, the ùëüofReader is part of
theùëìstructure. We have two arguments in this function, and
both of them are functions waiting for the ùëüinput. When that
comes, both functions will be applied to return a final result
ofùëè.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1338
Demonstrating the function Applicative
This example is similar to other demonstrations we‚Äôve done
previously in the book, but this time we‚Äôll be aiming to show
you what specific use the Applicative of functions typically has.
We start with some newtypes for tracking our diÔ¨Äerent String
values:
newtype HumanName =
HumanName String
deriving (Eq,Show)
newtype DogName =
DogName String
deriving (Eq,Show)
newtype Address =
Address String
deriving (Eq,Show)
We do this so that our types are more self-explanatory, to
express intent, and so we don‚Äôt accidentally mix up our inputs.
A type like this:
String-&gt;String-&gt;String
is difficult when:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1339
1.They aren‚Äôt strictly any string value.
2.They aren‚Äôt processed in an identical fashion. You don‚Äôt
handle addresses the same as names.
So make the diÔ¨Äerence explicit.
We‚Äôll make two record types:
dataPerson=
Person{
humanName ::HumanName
, dogName ::DogName
, address ::Address
}deriving (Eq,Show)
dataDog=
Dog{
dogsName ::DogName
, dogsAddress ::Address
}deriving (Eq,Show)
The following are sample data to use. You can modify them
as you‚Äôd like:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1340
pers::Person
pers=
Person(HumanName &quot;Big Bird&quot; )
(DogName &quot;Barkley&quot; )
(Address &quot;Sesame Street&quot; )
chris::Person
chris=Person(HumanName &quot;Chris Allen&quot; )
(DogName &quot;Papu&quot;)
(Address &quot;Austin&quot; )
And here is how we‚Äôd write it with and without Reader :
-- without Reader
getDog::Person-&gt;Dog
getDogp=
Dog(dogName p) (address p)
-- with Reader
getDogR ::Person-&gt;Dog
getDogR =
Dog&lt;$&gt;dogName &lt;*&gt;address
Can‚Äôt see the Reader ? What if we concrete the types a bit?</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1341
(&lt;$-&gt;&gt;)::(a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
(&lt;$-&gt;&gt;)=(&lt;$&gt;)
(&lt;<em>-&gt;&gt;)::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
(&lt;</em>-&gt;&gt;)=(&lt;<em>&gt;)
-- with Reader
getDogR' ::Person-&gt;Dog
getDogR' =
Dog&lt;$-&gt;&gt;dogName &lt;</em>-&gt;&gt;address
What we‚Äôre trying to highlight here is that Reader is not
alwaysReader , sometimes it‚Äôs the ambient Applicative orMonad
associated with the partially applied function type, here that
isr -&gt;.
The pattern of using Applicative in this manner is common,
so there‚Äôs an alternate way to do this using liftA2 :</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1342
importControl.Applicative (liftA2)
-- with Reader, alternate
getDogR' ::Person-&gt;Dog
getDogR' =
liftA2DogdogName address
Here‚Äôs the type of liftA2.
liftA2::Applicative f=&gt;
(a-&gt;b-&gt;c)
-&gt;f a-&gt;f b-&gt;f c
Again, we‚Äôre waiting for an input from elsewhere. Rather
than having to thread the argument through our functions,
we elide it and let the types manage it for us.
Exercise: Reading Comprehension
1.WriteliftA2 yourself. Think about it in terms of abstract-
ing out the diÔ¨Äerence between getDogR andgetDogR' if that
helps.
myLiftA2 ::Applicative f=&gt;
(a-&gt;b-&gt;c)
-&gt;f a-&gt;f b-&gt;f c
myLiftA2 =undefined</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1343
2.Write the following function. Again, it is simpler than it
looks.
asks::(r-&gt;a)-&gt;Readerr a
asksf=Reader???
3.Implement the Applicative forReader .
To write the Applicative instance for Reader, we‚Äôll use an
extension called InstanceSigs . It‚Äôs an extension we need
in order to assert a type for the typeclass methods. You
ordinarily cannot assert type signatures in instances. The
compiler already knows the type of the functions, so it‚Äôs
not usually necessary to assert the types in instances any-
way. We did this for the sake of clarity, to make the Reader
type explicit in our signatures.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1344
-- you'll need this pragma
{-# LANGUAGE InstanceSigs #-}
instance Applicative (Readerr)where
pure::a-&gt;Readerr a
pure a=Reader$ ???
(&lt;<em>&gt;)::Readerr (a-&gt;b)
-&gt;Readerr a
-&gt;Readerr b
(Readerrab)&lt;</em>&gt;(Readerra)=
Reader$\r-&gt; ???
Some instructions and hints.
a)When writing the purefunction for Reader , remember
that what you‚Äôre trying to construct is a function that
takes a value of type ùëü, which you know nothing about,
and return a value of type ùëé. Given that you‚Äôre not
really doing anything with ùëü, there‚Äôs really only one
thing you can do.
b)We got the definition of the apply function started for
you, we‚Äôll describe what you need to do and you write
the code. If you unpack the type of Reader‚Äôs apply
above, you get the following:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1345
&lt;*&gt; ::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
-- contrast this with the type of fmap
fmap::(a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
So what‚Äôs the diÔ¨Äerence? The diÔ¨Äerence is that apply,
unlikefmap, also takes an argument of type ùëü.
Make it so.
22.7 The Monadof functions
Functions also have a Monadinstance. You saw this in the be-
ginning of this chapter, and you perhaps have some intuition
now for how this must work. We‚Äôre going to walk through a
simplified demonstration of how it works before we get to the
types and instance. Feel free to work through this section as
quickly or slowly as you think appropriate to your own grasp
of what we‚Äôve presented so far.
Let‚Äôs start by supposing that we could write a couple of
functions like so:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1346
foo::(Functor f,Numa)=&gt;f a-&gt;f a
foor=fmap (+1) r
bar::Foldable f=&gt;t-&gt;f a-&gt;(t,Int)
barr t=(r, length t)
Now, as it happens in our program, we want to make one
function that will do both ‚Äî increment the values inside our
structure and also tell us the length of the value. We could
write that like this:
froot::Numa=&gt;[a]-&gt;([a],Int)
frootr=(map (+1) r, length r)
Or we could write the same function by combining the
two functions we already had. As it is written above, bartakes
two arguments. We could write a version that takes only one
argument, so that both parts of the tuple apply to the same
argument. That is easy enough to do (notice the change in the
type signature as well):
barOne::Foldable t=&gt;t a-&gt;(t a,Int)
barOner=(r, length r)
That gave us the reduction to one argument that we wanted
but didn‚Äôt increment the values in the list as our foofunction
does. We can add that this way:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1347
barPlus r=(foo r, length r)
But we can also do that more compactly by making (foo r)
the first argument to bar:
frooty::Numa=&gt;[a]-&gt;([a],Int)
frootyr=bar (foo r) r
Now we have an environment in which two functions are
waiting for the same argument to come in. They‚Äôll both apply
to that argument in order to produce a final result.
Let‚Äôs make a small change to make it look a little more
Reader -y:
frooty' ::Numa=&gt;[a]-&gt;([a],Int)
frooty' =\r-&gt;bar (foo r) r
Then we abstract this out so that it‚Äôs not specific to these
functions:
fooBind m k=\r-&gt;k (m r) r
In this very polymorphic version, the type signature will
look like this:
fooBind ::(t2-&gt;t1)
-&gt;(t1-&gt;t2-&gt;t)
-&gt;t2
-&gt;t</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1348
So many ùë°types! That‚Äôs because we can‚Äôt know very much
about those types once our function is that abstract. We can
make it a little more clear by making some substitutions. We‚Äôll
use the ùëüto represent the argument that both of our functions
are waiting on ‚Äî the Reader -y part:
fooBind ::(r-&gt;a)
-&gt;(a-&gt;r-&gt;b)
-&gt;(r-&gt;b)
If we could take the ùëüparts out, we might notice that fooBind
itself looks like a very abstract and simplified version of some-
thing we‚Äôve seen before (overparenthesizing a bit, for clarity):
(&gt;&gt;=) :: Monad m =&gt;
m a -&gt; (a -&gt; (m b)) -&gt; m b
(r -&gt; a) -&gt; (a -&gt; (r -&gt; b)) -&gt; (r -&gt; b)
This is how we get to the Monadof functions. Just as with the
Functor andApplicative instances, the ((-&gt;) r) is our structure
‚Äî theùëöin the type of (&gt;&gt;=). In the next section, we‚Äôll work
forward from the types.
TheMonadinstance
As we noted, the ùëüargument remains part of our (monadic)
structure:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1349
(&gt;&gt;=)::Monadm
=&gt;m a-&gt;(a-&gt;m b) -&gt; m b
(&gt;&gt;=)::
(-&gt;) r a-&gt;(a-&gt;(-&gt;) r b)-&gt;(-&gt;) r b
(&gt;&gt;=)::
(r-&gt;a)-&gt;(a-&gt;r-&gt;b)-&gt;r-&gt;b
return::Monadm=&gt;a-&gt; m a
return:: a-&gt;(-&gt;) r a
return:: a-&gt;r-&gt;a
You may notice that return looks like a function we‚Äôve seen
a lot of in this book.
Let‚Äôs look at it side by side with the Applicative :
(&lt;*&gt;)::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
(&gt;&gt;=)::(r-&gt;a)
-&gt;(a-&gt;r-&gt;b)
-&gt;(r-&gt;b)
Or with the flipped bind:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1350
(&lt;*&gt;)::(r-&gt;a-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
(=&lt;&lt;)::(a-&gt;r-&gt;b)
-&gt;(r-&gt;a)
-&gt;(r-&gt;b)
So you‚Äôve got this ever-present type ùëüfollowing your func-
tions around like a lonely puppy.
Example uses of the Reader type
Remember the earlier example with Person andDog? Here‚Äôs the
same but with the Reader Monad anddosyntax:
-- with Reader Monad
getDogRM ::Person-&gt;Dog
getDogRM = do
name&lt;-dogName
addy&lt;-address
return$Dogname addy
Exercise: Reader Monad
1.Implement the Reader Monad .</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1351
-- Don't forget instancesigs.
instance Monad(Readerr)where
return=pure
(&gt;&gt;=)::Readerr a
-&gt;(a-&gt;Readerr b)
-&gt;Readerr b
(Readerra)&gt;&gt;=aRb=
Reader$\r-&gt; ???
Hint: constrast the type with the Applicative instance and
perform the most obvious change you can imagine to
make it work.
2.Rewrite the monadic getDogRM to use your Reader datatype.
22.8Reader Monad by itself is boring
It can‚Äôt do anything the Applicative cannot.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1352
{-# LANGUAGE NoImplicitPrelude #-}
modulePrettyReader where
flip::(a-&gt;b-&gt;c)-&gt;(b-&gt;a-&gt;c)
flipf a b=f b a
const::a-&gt;b-&gt;a
consta b=a
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;(a-&gt;c)
f.g=\a-&gt;f (g a)
classFunctor fwhere
fmap::(a-&gt;b)-&gt;f a-&gt;f b
classFunctor f=&gt;Applicative fwhere
pure::a-&gt;f a
(&lt;*&gt;)::f (a-&gt;b)-&gt;f a-&gt;f b
classApplicative f=&gt;Monadfwhere
return::a-&gt;f a
(&gt;&gt;=)::f a-&gt;(a-&gt;f b)-&gt;f b</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1353
instance Functor ((-&gt;) r)where
fmap=(.)
instance Applicative ((-&gt;) r)where
pure=const
f&lt;<em>&gt;a=\r-&gt;f r (a r)
instance Monad((-&gt;) r)where
return=pure
m&gt;&gt;=k=flip k&lt;</em>&gt;m
Speaking generally in terms of the algebras alone, you can-
not get a Monadinstance from the Applicative . You can get
anApplicative from the Monad. However, our instances above
aren‚Äôt in terms of an abstract datatype; we know it‚Äôs the type
of functions. Because it‚Äôs not hiding behind a Reader newtype,
we can use flipandapplyto make the Monadinstance. We need
specific type information to augment what the Applicative is
capable of before we can get our Monadinstance.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1354
22.9 You can change what comes below,
but not above
The ‚Äúread-only‚Äù nature of the type argument ùëümeans that you
can swap in a diÔ¨Äerent type or value of ùëüfor functions that
you call, but not for functions that call you. The best way to
demonstrate this is with the withReaderT function which lets
us start a new Reader context with a diÔ¨Äerent argument being
provided:
withReaderT
::(r'-&gt;r)
-- ^ The function to modify
-- the environment.
-&gt;ReaderT r m a
-- ^ Computation to run in the
-- modified environment.
-&gt;ReaderT r' m a
withReaderT f m=
ReaderT $runReaderT m .f
In the next chapter, we‚Äôll see the Statemonad where we can
not only read in a value, but provide a new one which will
change the value carried by the functions that called us, not
only those we called.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1355
22.10 You tend to see ReaderT , notReader
Reader rarely stands alone. Usually it‚Äôs one Monadin a stack of
multiple types providing a Monadinstance such as with a web
application that uses Reader to give you access to context about
the HTTP request. When used in that fashion, it‚Äôs a monad
transformer and we put a letter T after the type to indicate
when we‚Äôre using it as such, so you‚Äôll usually see ReaderT in
production Haskell code rather than Reader .
Further, a Reader ofIntisn‚Äôt all that useful or compelling.
Usually if you have a Reader , it‚Äôs of a record of several (possibly
many) values that you‚Äôre getting out of the Reader .
22.11 Chapter Exercises
A warm-up stretch
These exercises are designed to be a warm-up and get you
using some of the stuÔ¨Ä we‚Äôve learned in the last few chap-
ters. While these exercises comprise code fragments from
real code, they are simplified in order to be discrete exercises.
That will allow us to highlight and practice some of the type
manipulation from Traversable andReader, both of which are
tricky.
The first simplified part is that we‚Äôre going to set up some
toy data; in the real programs these are taken from, the data</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1356
is coming from somewhere else ‚Äî a database, for example.
We just need some lists of numbers. We‚Äôre going to use some
functions from Control.Applicative andData.Maybe , so we‚Äôll im-
port those at the top of our practice file. We‚Äôll call our lists of
toy data by common variable names for simplicity.
moduleReaderPractice where
importControl.Applicative
importData.Maybe
x=[1,2,3]
y=[4,5,6]
z=[7,8,9]
The next thing we want to do is write some functions that
zip those lists together and use lookup to find the value associ-
ated with a specified key in our zipped lists. For demonstration
purposes, it‚Äôs nice to have the outputs be predictable, so we
recommend writing some that are concrete values, as well as
one that can be applied to a variable:
lookup::Eqa=&gt;a-&gt;[(a, b)] -&gt;Maybeb
-- zip x and y using 3 as the lookup key
xs::MaybeInteger
xs=undefined</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1357
-- zip y and z using 6 as the lookup key
ys::MaybeInteger
ys=undefined
-- it's also nice to have one that
-- will return Nothing, like this one
-- zip x and y using 4 as the lookup key
zs::MaybeInteger
zs=lookup4$zip x y
-- now zip x and z using a
-- variable lookup key
z'::Integer -&gt;MaybeInteger
z'n=undefined
Now we want to add the ability to make a Maybe (,) of values
usingApplicative . Have x1make a tuple of xsandys, andx2
make a tuple of of ysandzs. Also, write x3which takes one
input and makes a tuple of the results of two applications of
z'from above.</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1358
x1::Maybe(Integer,Integer)
x1=undefined
x2::Maybe(Integer,Integer)
x2=undefined
x3::Integer
-&gt;(MaybeInteger,MaybeInteger)
x3=undefined
Your outputs from those should look like this:
*ReaderPractice&gt; x1
Just (6,9)
*ReaderPractice&gt; x2
Nothing
*ReaderPractice&gt; x3 3
(Just 9,Just 9)
Next, we‚Äôre going to make some helper functions. Let‚Äôs use
uncurry to allow us to add the two values that are inside a tuple:</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1359
uncurry ::(a-&gt;b-&gt;c)-&gt;(a, b)-&gt;c
-- that first argument is a function
-- in this case, we want it to be addition
-- summed is uncurry with addition as
-- the first argument
summed::Numc=&gt;(c, c)-&gt;c
summed=undefined
And now we‚Äôll make a function similar to some we‚Äôve seen
before that lifts a boolean function over two partially applied
functions:
bolt::Integer -&gt;Bool
-- use &amp;&amp;, &gt;3, &lt;8
bolt=undefined
Finally, we‚Äôll be using fromMaybe in themainexercise, so let‚Äôs
look at that:
fromMaybe ::a-&gt;Maybea-&gt;a
You give it a default value and a Maybevalue. If the Maybe
value is a Just a, it will return the ùëévalue. If the value is a
Nothing , it returns the default value instead:
*ReaderPractice&gt; fromMaybe 0 xs</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1360
6
<em>ReaderPractice&gt; fromMaybe 0 zs
0
Now we‚Äôll cobble together a main, so that in one call we can
execute several things at once.
main::IO()
main= do
print$
sequenceA [ Just3,Just2,Just1]
print$sequenceA [x, y]
print$sequenceA [xs, ys]
print$summed&lt;$&gt;((,)&lt;$&gt;xs&lt;</em>&gt;ys)
print$fmap summed ((,) &lt;$&gt;xs&lt;*&gt;zs)
print$bolt7
print$fmap bolt z
When you run this in GHCi, your results should look like
this:
*ReaderPractice&gt; main
Just [3,2,1]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
Just [6,9]
Just 15
Nothing</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1361
True
[True,False,False]
Next, we‚Äôre going to add one that combines sequenceA and
Reader in a somewhat surprising way (add this to main):
print$sequenceA [( &gt;3), (&lt;8), even] 7
The type of sequenceA is
sequenceA ::(Applicative f,Traversable t)
=&gt;t (f a) -&gt;f (t a)
-- so in this:
sequenceA [(&gt;3), (&lt;8), even] 7
-- f ~ (-&gt;) a and t ~ []
Wehavea Reader fortheApplicative (functions)andatraversable
for the list. Pretty handy. We‚Äôre going to call that function
sequAfor the purposes of the following exercises:
sequA::Integral a=&gt;a-&gt;[Bool]
sequAm=sequenceA [( &gt;3), (&lt;8), even] m
And henceforth let
summed&lt;$&gt;((,)&lt;$&gt;xs&lt;*&gt;ys)</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1362
be known as s'.
OK, your turn. Within the mainabove, write the following
(you can delete everything after donow if you prefer ‚Äî just
remember to use printto be able to print the results of what
you‚Äôre adding):
1.fold the boolean conjunction operator over the list of
results of sequA(applied to some value).
2.applysequAtos'; you‚Äôll need fromMaybe .
3.applybolttoys; you‚Äôll need fromMaybe .
Rewriting Shawty
Remember the URL shortener? Instead of manually passing
the database connection rConnfrommainto the app function
that generates a Scotty app, use ReaderT to make the database
connection available. We know you haven‚Äôt seen the trans-
former variant yet and we‚Äôll explain them soon, but you should
try to do the transformation mechanically. Research as neces-
sary using a search engine. Use this version of the app: https:
//github.com/bitemyapp/shawty-prime/blob/master/app/Main.hs
22.12 Definition
A monad transformer is a special type that takes a monad as
an argument and returns a monad as a result. It allows us to</p>
<p>CHAPTER 22. FUNCTIONS WAITING FOR INPUT 1363
combine two monads into one that shares the behaviors of
both, such as allowing us to add exception handling to a State
monad. It is somewhat common to create a stack of transform-
ers to create one large monad that has features from several
monads, for example, rolling Reader,Either, andIOtogether
to get a monad that captures the behavior of waiting for an
argument that will get passed around to multiple functions
but is likely to come in via some kind of I/O action and has the
possibility of failure we might like to catch. Often this stack
will be given a type alias for convenience.
22.13 Follow-up resources
1.Reader Monad; All About Monads
https://wiki.haskell.org/All_About_Monads
2.Reader Monad; Programming with Monads; Real World
Haskell</p>
<p>Chapter 23
State
Four centuries ago,
Descartes pondered the
mind-body problem:
how can incorporeal
minds interact with
physical bodies? Today,
computing scientists face
their own version of the
mind-body problem:
how can virtual software
interact with the real
world?
Philip Wadler
1364</p>
<p>CHAPTER 23. STATE 1365
23.1 State
What if I need state? In Haskell we have many means of repre-
senting, accessing, and modifying state. We can think of state
as data that exists in addition to the inputs and outputs of our
functions, data that can potentially change after each function
is evaluated.
In this chapter, we will:
‚Ä¢talk about what state means;
‚Ä¢explore some ways of handling state in Haskell;
‚Ä¢generate some more random numbers;
‚Ä¢and examine the Statenewtype and Monadinstance.
23.2 What is state?
The concept of state originates in the circuit and automata
theory that much of computer science and programming be-
gan with. The simplest form of state could be understood as a
light switch. A light switch has two possible states, on or oÔ¨Ä.
That disposition of the light switch, being on or oÔ¨Ä, could be
understood as its state. Similarly, transistors in computers
have binary states of being on or oÔ¨Ä. This is a very low-level
way of seeing it, but this maps onto the state that exists in
computer memory.</p>
<p>CHAPTER 23. STATE 1366
In most imperative programming languages, this stateful-
ness is pervasive, implicit, and not referenced in the types
of your functions. In Haskell, we‚Äôre not allowed to secretly
change some value; all we can do is accept arguments and
return a result. The Statetype in Haskell is a means of express-
ing state that may change in the course of evaluating code
without resort to mutation. The monadic interface for State
is, much as you‚Äôve seen already, more of a convenience than a
strict necessity for working with State.
We have the option to capture the idea and convenience
of a value which potentially changes with each computation
without resorting to mutability. Statecaptures this idea and
cleans up the bookkeeping required. If you need in-place
mutation, then the STtype is what you want, and we address
that briefly in later chapters.
In Haskell, if we use the Statetype and its associated Monad
(for convenience, not strictly necessary), we can have state
which:
1.doesn‚Äôt require IO;
2.is limited only to the data in our Statecontainer;
3.maintains referential transparency;
4.is explicit in the types of our functions.</p>
<p>CHAPTER 23. STATE 1367
There are other means of sharing data within a program
that are designed for diÔ¨Äerent needs than the Statedatatype
itself.Stateis appropriate when you want to express your
program in terms of values that potentially vary with each
evaluation step, which can be read and modified, but don‚Äôt
otherwise have specific operational constraints.
23.3 Random numbers
As we did in the previous chapter, we‚Äôll start with an extended
example. This will help you get an idea of the problem we‚Äôre
trying to solve with the Statedatatype.
We‚Äôll be using the random1library, version 1.1, in this ex-
ample.
First, let‚Äôs give an overview of some of the functions we‚Äôll
be using here. We used the System.Random library back in the
chapter where we built the hangman game, but we‚Äôll be using
some diÔ¨Äerent functions for this example. This is in broad
strokes; it isn‚Äôt meant to go into great detail about how these
generators work.
System.Random is designed to generate pseudorandom values.
You can generate those values through providing a seed value
or by using the system-initialised generator. We‚Äôll be using
the following from that library:
1https://hackage.haskell.org/package/random</p>
<p>CHAPTER 23. STATE 1368
1.One of the types we‚Äôll be seeing here, StdGen , is a datatype
that is a product of two Int32values. So a value of type
StdGen always comprises two Int32values. They are the
seed values used to generate the next random number.
2.mkStdGen has the type:
mkStdGen ::Int-&gt;StdGen
We‚Äôll ignore the implementation at this point because
those details aren‚Äôt important here. The idea is that it takes
anIntargument and maps it into a generator to return a
value of type StdGen , which is a pair of Int32values.
3.nexthas the type:
next::g-&gt;(Int, g)
whereùëîis a value of type StdGen . TheIntthat is first in the
tuple is the pseudorandom number generated from the
StdGen value; the second value is a new StdGen value.
4.random has the type:
random::(RandomGen g,Randoma)
=&gt;g-&gt;(a, g)
This is similar to nextbut allows us to generate random
values that aren‚Äôt numbers. The range generated will be
determined by the type.</p>
<p>CHAPTER 23. STATE 1369
Now, let‚Äôs have a little demonstration of these:
Prelude&gt; import System.Random
Prelude&gt; mkStdGen 0
1 1
Prelude&gt; :t mkStdGen 0
mkStdGen 0 :: StdGen
Prelude&gt; let sg = mkStdGen 0
Prelude&gt; :t next sg
next sg :: (Int, StdGen)
Prelude&gt; next sg
(2147482884,40014 40692)
Prelude&gt; next sg
(2147482884,40014 40692)
We get the same answer twice because the underlying func-
tionthat‚Äôsdecidingthevaluesreturnedispure; thetypedoesn‚Äôt
permit the performance of any eÔ¨Äects to get spooky action.
Define a new version of sgthat provides a diÔ¨Äerent input value
tomkStdGen and see what happens.
So, we have a value called next sg . Now, if we want to use
that to generate the next random number, we need to feed the
StdGen value from that tuple to nextagain. We can use sndto
extract that StdGen value and pass it as an input to next:
Prelude&gt; snd (next sg)
40014 40692</p>
<p>CHAPTER 23. STATE 1370
Prelude&gt; let newSg = snd (next sg)
Prelude&gt; :t newSg
newSg :: StdGen
Prelude&gt; next newSg
(2092764894,1601120196 1655838864)
You‚Äôll keep getting the same results of nextthere, but you
can extract that StdGen value and pass it to nextagain to get a
new tuple:
Prelude&gt; next (snd (next newSg))
(1679949200,1635875901 2103410263)
Now we‚Äôll look at a few examples using random. Because
random can generate values of diÔ¨Äerent types, we need to specify
the type to use:
Prelude&gt; :t random newSg
random newSg :: Random a =&gt; (a, StdGen)
Prelude&gt; random newSg :: (Int, StdGen)
(138890298504988632,439883729 1872071452)
Prelude&gt; random newSg :: (Double, StdGen)
(0.41992072972993366,439883729 1872071452)
Simple enough, but what if we want a number within a
range?</p>
<p>CHAPTER 23. STATE 1371
Prelude&gt; :t randomR
randomR :: (RandomGen g, Random a) =&gt; (a, a) -&gt; g -&gt; (a, g)
Prelude&gt; randomR (0, 3) newSg :: (Int, StdGen)
(1,1601120196 1655838864)
Prelude&gt; randomR (0, 3) newSg :: (Double, StdGen)
(1.259762189189801,439883729 1872071452)
We have to pass the new state of the random number gen-
erator to the nextfunction to get a new value:
Prelude&gt; let rx :: (Int, StdGen); rx = random (snd sg3)
Prelude&gt; rx
(2387576047905147892,1038587761 535353314)
Prelude&gt; snd rx
1038587761 535353314
This chaining of state can get tedious. Addressing this te-
dium is our aim in this chapter.
23.4 The Statenewtype
Stateis defined in a newtype, like Reader in the previous chap-
ter, and that type looks like this:
newtype States a=
State{ runState ::s-&gt;(a, s) }</p>
<p>CHAPTER 23. STATE 1372
It‚Äôs initially a bit strange looking, but you might notice some
similarity to the Reader newtype:
newtype Readerr a=
Reader{ runReader ::r-&gt;a }
We‚Äôve seen several newtypes whose contents are a function,
particularly with our Monoid newtypes ( Sum,Product , etc.). New-
types must have the same underlying representation as the
type they wrap, as the newtype wrapper disappears at compile
time. So the function contained in the newtype must be iso-
morphic to the type it wraps. That is, there must be a way to go
from the newtype to the thing it wraps and back again without
losing information. For example, the following demonstrates
an isomorphism:
typeIsoa b=(a-&gt;b, b-&gt;a)
newtype Suma=Sum{ getSum ::a }
sumIsIsomorphicWithItsContents
::Isoa (Suma)
sumIsIsomorphicWithItsContents =
(Sum, getSum)
Whereas the following do not:</p>
<p>CHAPTER 23. STATE 1373
-- Not an isomorphism, because
-- it might not work.
(a-&gt;Maybeb, b-&gt;Maybea)
-- Not an isomorphism for two reasons.
-- You lose information whenever there
-- was more than one element in [a]. Also,
-- [a] -&gt; a is partial because there
-- might not be any elements.
[a]-&gt;a, a-&gt;[a]
With that in mind, let us look at the Statedata constructor
andrunState record accessor as our means of putting a value
in and taking a value out of the Statetype:
State::(s-&gt;(a, s)) -&gt;States a
runState ::States a-&gt;s-&gt;(a, s)
Stateis a function that takes input state and returns an out-
put value, ùëé, tupled with the new state value. The key is that
the previous state value from each application is chained to
the next one, and this is not an uncommon pattern. Stateis
often used for things like random number generators, solvers,
games, and carrying working memory while traversing a data
structure. The polymorphism means you don‚Äôt have to make
a new state for each possible instantiation of ùë†andùëé.</p>
<p>CHAPTER 23. STATE 1374
Let‚Äôs get back to our random numbers:
Note that random looks an awful lot like Statehere:
random::(Randoma)
=&gt;StdGen-&gt;(a,StdGen)
State{ runState
::s-&gt;(a, s) }
If we look at the type of randomR , once partially applied, it
should also remind you of State:
randomR ::(...)=&gt;(a, a)-&gt;g-&gt;(a, g)
State{ runState :: s-&gt;(a, s) }
23.5 Throw down
Now let us use this kit to generate die such as for a game:</p>
<p>CHAPTER 23. STATE 1375
moduleRandomExample where
importSystem.Random
-- Six-sided die
dataDie=
DieOne
|DieTwo
|DieThree
|DieFour
|DieFive
|DieSix
deriving (Eq,Show)
As you might expect, we‚Äôll be using the random library, and a
simpleDiedatatype to represent a six-sided die.</p>
<p>CHAPTER 23. STATE 1376
intToDie ::Int-&gt;Die
intToDie n=
casenof
1-&gt;DieOne
2-&gt;DieTwo
3-&gt;DieThree
4-&gt;DieFour
5-&gt;DieFive
6-&gt;DieSix
-- Use 'error'
-- <em>extremely</em> sparingly.
x-&gt;
error$
&quot;intToDie got non 1-6 integer: &quot;
++show x
Don‚Äôt use erroroutside of experiments like this, or in cases
where the branch you‚Äôre ignoring is provably impossible. We
do not use the word provably here lightly.2
Now we need to roll the dice:
2Because partial functions are a pain, you should only use an error like this when
the branch that would spawn the error can literally never happen. Unexpected software
failures are often due to things like this. It is also completely unnecessary in Haskell; we
have good alternatives, like using MaybeorEither. The only reason we didn‚Äôt here is to
keep it simple and focus attention on the State Monad .</p>
<p>CHAPTER 23. STATE 1377
rollDieThreeTimes ::(Die,Die,Die)
rollDieThreeTimes = do
lets=mkStdGen 0
(d1, s1) =randomR ( 1,6) s
(d2, s2) =randomR ( 1,6) s1
(d3,_)=randomR ( 1,6) s2
(intToDie d1, intToDie d2, intToDie d3)
This code isn‚Äôt optimal, but it does work. It will produce
the same results every time, because it is free of eÔ¨Äects, but
you can make it produce a new result on a new dice roll if you
modify the start value. Try it a couple of times to see what we
mean. It seems unlikely that this will develop into a gambling
addiction, but in the event it does, the authors disclaim liability
for such.
So, how can we improve our suboptimal code there. With
State, of course!
moduleRandomExample2 where
importControl.Applicative (liftA3)
importControl.Monad (replicateM )
importControl.Monad.Trans.State
importSystem.Random
importRandomExample</p>
<p>CHAPTER 23. STATE 1378
First, we‚Äôll add some new imports. You‚Äôll need transformers
to be installed for the Stateimport to work, but that should
have come with your GHC install, so you should be good to
go.
UsingStatewill allow us to factor out the generation of a
singleDie:
rollDie ::StateStdGenDie
rollDie =state$ do
(n, s)&lt;-randomR ( 1,6)
return (intToDie n, s)
For our purposes, the statefunction is a constructor that
takes aState-like function and embeds it in the Statemonad
transformer. Ignore the transformer part for now ‚Äî we‚Äôll get
there. The state function has the following type:
state::Monadm
=&gt;(s-&gt;(a, s))
-&gt;StateTs m a
Note that we‚Äôre binding the result of randomR out of the State
monad the doblock is in rather than using let. This is still more
verbose than is necessary. We can lift our intToDie function
over the State:</p>
<p>CHAPTER 23. STATE 1379
rollDie' ::StateStdGenDie
rollDie' =
intToDie &lt;$&gt;state (randomR ( 1,6))
State StdGen had a final type argument of Int. We lifted Int
-&gt; Die over it and transformed that final type argument to Die.
We‚Äôll exercise more brevity upfront in the next function:
rollDieThreeTimes'
::StateStdGen(Die,Die,Die)
rollDieThreeTimes' =
liftA3 (,,) rollDie rollDie rollDie
Lifting the three-tuple constructor over three Stateactions
that produce Dievalues when given an initial state to work
with. How does this look in practice?
Prelude&gt; evalState rollDieThreeTimes' (mkStdGen 0)
(DieSix,DieSix,DieFour)
Prelude&gt; evalState rollDieThreeTimes' (mkStdGen 1)
(DieSix,DieFive,DieTwo)
Seems to work fine. Again, the same inputs give us the same
result. What if we want a list of Dieinstead of a tuple?</p>
<p>CHAPTER 23. STATE 1380
-- Seems appropriate?
repeat::a-&gt;[a]
infiniteDie ::StateStdGen[Die]
infiniteDie =repeat&lt;$&gt;rollDie
Does this infiniteDie function do what we want or expect?
What is it repeating?
Prelude&gt; take 6 $ evalState infiniteDie (mkStdGen 0)
[DieSix,DieSix,DieSix,DieSix,DieSix,DieSix]
We already know based on previous inputs that the first 3
values shouldn‚Äôt be identical for a seed value of 0. So what
happened? What happened is we repeated a single die value
‚Äî we didn‚Äôt repeat the state action that produces a die. This is
what we need:
replicateM ::Monadm
=&gt;Int-&gt;m a-&gt;m [a]
nDie::Int-&gt;StateStdGen[Die]
nDien=replicateM n rollDie
And when we use it?
Prelude&gt; evalState (nDie 5) (mkStdGen 0)</p>
<p>CHAPTER 23. STATE 1381
[DieSix,DieSix,DieFour,DieOne,DieFive]
Prelude&gt; evalState (nDie 5) (mkStdGen 1)
[DieSix,DieFive,DieTwo,DieSix,DieFive]
We get precisely what we wanted.
Keep on rolling
In the following example, we keep rolling a single die until we
reach or exceed a sum of 20.
rollsToGetTwenty ::StdGen-&gt;Int
rollsToGetTwenty g=go00g
where
go::Int-&gt;Int-&gt;StdGen-&gt;Int
go sum count gen
|sum&gt;=20=count
|otherwise =
let(die, nextGen) =
randomR ( 1,6) gen
ingo (sum +die)
(count+1) nextGen
Then seeing it in action:
Prelude&gt; rollsToGetTwenty (mkStdGen 0)
5</p>
<p>CHAPTER 23. STATE 1382
Prelude&gt; rollsToGetTwenty (mkStdGen 0)
5
We can also use randomIO , which uses IOto get a new value
each time without needing to create a unique value for the
StdGen :
Prelude&gt; :t randomIO
randomIO :: Random a =&gt; IO a
Prelude&gt; (rollsToGetTwenty . mkStdGen) &lt;$&gt; randomIO
6
Prelude&gt; (rollsToGetTwenty . mkStdGen) &lt;$&gt; randomIO
7
Under the hood, it‚Äôs the same interface and State Monad
driven mechanism, but it‚Äôs mutating a single globally used
StdGen to walk the generator forward on each use. See the
random library source code to see how this works.
Exercises: Roll Your Own
1.Refactor rollsToGetTwenty into having the limit be a func-
tion argument.
rollsToGetN ::Int-&gt;StdGen-&gt;Int
rollsToGetN =undefined
2.Change rollsToGetN to recording the series of die that oc-
curred in addition to the count.</p>
<p>CHAPTER 23. STATE 1383
rollsCountLogged ::Int
-&gt;StdGen
-&gt;(Int, [Die])
rollsCountLogged =undefined
23.6 Write Statefor yourself
Use the datatype definition from the beginning of this chapter,
with the name changed to avoid conflicts in case you have
Stateimported from the libraries transformers ormtl. We‚Äôre
calling it Moi, because we enjoy allusions to famous quotations3;
feel free to change the name if you wish to protest absolute
monarchy, but change them consistently throughout.
newtype Mois a=
Moi{ runMoi ::s-&gt;(a, s) }
State Functor
Implement the Functor instance for State.
instance Functor (Mois)where
fmap::(a-&gt;b)-&gt;Mois a-&gt;Mois b
fmap f ( Moig)= ???
3We are referring to the (possibly apocryphal) quotation attributed to the French
King Louis XIV, ‚ÄúL‚ÄôEtat, c‚Äôest moi.‚Äù For those of you who do not speak French, it means,
‚ÄúI am the State.‚Äù Cheers.</p>
<p>CHAPTER 23. STATE 1384
Prelude&gt; runMoi ((+1) &lt;$&gt; (Moi $ \s -&gt; (0, s))) 0
(1,0)
State Applicative
Write the Applicative instance for State.
instance Applicative (Mois)where
pure::a-&gt;Mois a
pure a= ???
(&lt;<em>&gt;)::Mois (a-&gt;b)
-&gt;Mois a
-&gt;Mois b
(Moif)&lt;</em>&gt;(Moig)=
???
State Monad
Write the Monadinstance for State.</p>
<p>CHAPTER 23. STATE 1385
instance Monad(Mois)where
return=pure
(&gt;&gt;=)::Mois a
-&gt;(a-&gt;Mois b)
-&gt;Mois b
(Moif)&gt;&gt;=g=
???
23.7 Get a coding job with one weird
trick
Some companies will use FizzBuzz4to screen (not so much
test) candidates applying to software positions. The problem
statement goes:
Write a program that prints the numbers from 1 to
100. But for multiples of three print ‚ÄúFizz‚Äù instead of
the number and for the multiples of five print ‚ÄúBuzz‚Äù.
For numbers which are multiples of both three and
five print ‚ÄúFizzBuzz‚Äù.
A typical fizzbuzz solution in Haskell looks something like:
4http://c2.com/cgi/wiki?FizzBuzzTest</p>
<p>CHAPTER 23. STATE 1386
fizzBuzz ::Integer -&gt;String
fizzBuzz n|n <code>mod</code> 15==0=&quot;FizzBuzz&quot;
|n <code>mod</code> 5==0=&quot;Buzz&quot;
|n <code>mod</code> 3==0=&quot;Fizz&quot;
|otherwise =show n
main::IO()
main=
mapM_ (putStrLn .fizzBuzz) [ 1..100]
A fizzbuzz using Stateis a suitable punishment for asking
a software candidate to write this in person after presumably
getting through a couple phone screens. Let‚Äôs look at what a
version with Statemight look like:
importControl.Monad
importControl.Monad.Trans.State
fizzBuzz ::Integer -&gt;String
fizzBuzz n|n <code>mod</code> 15==0=&quot;FizzBuzz&quot;
|n <code>mod</code> 5==0=&quot;Buzz&quot;
|n <code>mod</code> 3==0=&quot;Fizz&quot;
|otherwise =show n</p>
<p>CHAPTER 23. STATE 1387
fizzbuzzList ::[Integer]-&gt;[String]
fizzbuzzList list=
execState (mapM_ addResult list) []
addResult ::Integer -&gt;State<a href="HaskellProgramming/">String</a>
addResult n= do
xs&lt;-get
letresult=fizzBuzz n
put (result :xs)
Note that Stateis a type alias of StateT you imported.
main::IO()
main=
mapM_ putStrLn $
reverse $fizzbuzzList [ 1..100]
The good part here is that we‚Äôre collecting data initially
before dumping the results to standard output via putStrLn .
The bad is that we‚Äôre reversing a list. Reversing singly-linked
lists is not great, even in Haskell, and won‚Äôt terminate on an
infinite list. One of the issues is that we‚Äôre accepting an input
that defines the numbers we‚Äôll use fizzbuzz on linearly from
beginning to end.
There are a couple ways we could handle this. One is to
use a data structure with cheaper appending to the end. Using
(++)recursively can be very slow, so let‚Äôs use something that</p>
<p>CHAPTER 23. STATE 1388
can append in constant time. The counterpart to []which has
this property is the diÔ¨Äerence list5which has O(1) append.
importControl.Monad
importControl.Monad.Trans.State
-- http://hackage.haskell.org/package/dlist
import qualified Data.DList asDL
fizzBuzz ::Integer -&gt;String
fizzBuzz n|n <code>mod</code> 15==0=&quot;FizzBuzz&quot;
|n <code>mod</code> 5==0=&quot;Buzz&quot;
|n <code>mod</code> 3==0=&quot;Fizz&quot;
|otherwise =show n
5https://github.com/spl/dlist</p>
<p>CHAPTER 23. STATE 1389
fizzbuzzList ::[Integer]-&gt;[String]
fizzbuzzList list=
letdlist=
execState (mapM_ addResult list)
DL.empty
-- convert back to normal list
inDL.apply dlist []
addResult ::Integer
-&gt;State(DL.DListString)()
addResult n= do
xs&lt;-get
letresult=fizzBuzz n
-- snoc appends to the end, unlike
-- cons which adds to the front
put (DL.snoc xs result)
main::IO()
main=
mapM_ putStrLn $fizzbuzzList [ 1..100]
We can clean this up further. If you have GHC 7.10 or newer,
mapM_will specify a Foldable type, not only a list:
Prelude&gt; :t mapM_
mapM_ :: (Monad m, Foldable t) =&gt; (a -&gt; m b) -&gt; t a -&gt; m ()</p>
<p>CHAPTER 23. STATE 1390
By letting DList‚ÄôsFoldable instance do the conversion to a
list for us, we can eliminate some code:
fizzbuzzList ::[Integer]
-&gt;DL.DListString
fizzbuzzList list=
execState (mapM_ addResult list) DL.empty
addResult ::Integer
-&gt;State(DL.DListString)()
addResult n= do
xs&lt;-get
letresult=fizzBuzz n
put (DL.snoc xs result)
main::IO()
main=
mapM_ putStrLn $fizzbuzzList [ 1..100]
DList‚ÄôsFoldable instance converts to a list before folding
because of limitations specific to the datatype. You get cheap
appending, but you give up the ability to ‚Äúsee‚Äù what you‚Äôve
built unless you‚Äôre willing to do all the work of building the
structure. We‚Äôll discuss this in more detail in a forthcoming
chapter.</p>
<p>CHAPTER 23. STATE 1391
One thing that may strike you here is that the use of State
was superfluous. That‚Äôs good! It‚Äôs not common you need State
as such in Haskell. You might use a diÔ¨Äerent form of State
calledSTas a selective optimization, but Stateitself is a stylistic
choice that falls out of what the code is telling you. Don‚Äôt
feel compelled to use or not use State. Please frighten some
interviewers with a spooky fizzbuzz. Make something even
weirder than what we‚Äôve shown you here!
Fizzbuzz DiÔ¨Äerently
It‚Äôs an exercise! Rather than changing the underlying data
structure, fix our reversing fizzbuzz by changing the code in
the following way:
fizzbuzzFromTo ::Integer
-&gt;Integer
-&gt;[String]
fizzbuzzFromTo =undefined
Continue to use consing in the construction of the result
list, but have it come out in the right order to begin with by
enumerating the sequence backwards. This sort of tactic is
more commonly how you‚Äôll want to fix your code when you‚Äôre
quashing unnecessary reversals.</p>
<p>CHAPTER 23. STATE 1392
23.8 Chapter exercises
Write the following functions. You‚Äôll want to use your own
Statetype for which you‚Äôve defined the Functor ,Applicative ,
andMonad.
1.Construct a Statewhere the state is also the value you
return.
get::States s
get= ???
Expected output
Prelude&gt; runState get &quot;curryIsAmaze&quot;
(&quot;curryIsAmaze&quot;,&quot;curryIsAmaze&quot;)
2.Construct a Statewhere the resulting state is the argument
provided and the value is defaulted to unit.
put::s-&gt;States()
puts= ???
Prelude&gt; runState (put &quot;blah&quot;) &quot;woot&quot;
((),&quot;blah&quot;)
3.Run the Statewithùë†and get the state that results.</p>
<p>CHAPTER 23. STATE 1393
exec::States a-&gt;s-&gt;s
exec(Statesa) s= ???
Prelude&gt; exec (put &quot;wilma&quot;) &quot;daphne&quot;
&quot;wilma&quot;
Prelude&gt; exec get &quot;scooby papu&quot;
&quot;scooby papu&quot;
4.Run the Statewithùë†and get the value that results.
eval::States a-&gt;s-&gt;a
eval(Statesa)= ???
Prelude&gt; eval get &quot;bunnicula&quot;
&quot;bunnicula&quot;
Prelude&gt; eval get &quot;stake a bunny&quot;
&quot;stake a bunny&quot;
5.Write a function which applies a function to create a new
State.
modify::(s-&gt;s)-&gt;States()
modify=undefined
Should behave like the following:</p>
<p>CHAPTER 23. STATE 1394
Prelude&gt; runState (modify (+1)) 0
((),1)
Prelude&gt; runState (modify (+1) &gt;&gt; modify (+1)) 0
((),2)
You don‚Äôt need to compose them, you can throw away the
result because it returns unit for ùëéanyway.
23.9 Follow-up resources
1.State Monad; All About Monads; Haskell Wiki
https://wiki.haskell.org/All_About_Monads
2.State Monad; Haskell Wiki
https://wiki.haskell.org/State_Monad
3.Understanding Monads; Haskell Wikibook</p>
<p>Chapter 24
Parser combinators
Within a computer,
natural language is
unnatural.
Alan Perlis
1395</p>
<p>CHAPTER 24. PARSER COMBINATORS 1396
24.1 Parser combinators
The word parse comes from the Latin word for parts, and
means to analyze a sentence and label the syntactic role, or part
of speech, of each component. Language teachers once em-
phasized this ability because it forced students to think about
the structure of sentences, the relationships among the parts,
and the connection between the structure and the meaning of
the whole. Diagramming sentences was common because it
made parsing visual and somewhat concrete.
It is now common to represent grammatical structures of
natural languages as trees, so that a sentence such as
Boy plays with dog.
might be thought to have an underlying representation
such as
S(entence)
/ <br />
Boy plays (verb)
(subject) <br />
with (preposition)
<br />
dog (object)
We are not here to become linguists, but parsing in com-
puter science is related to the parsing of natural language</p>
<p>CHAPTER 24. PARSER COMBINATORS 1397
sentences. The core idea of parsing in programming is to
accept serialized input in the form of a sequence of characters
(textual data) or bytes (raw binary data) and turn that into a
value of a structured datatype. Serialized data is data that has
been translated into a format, such as JSON or XML1, that can
be stored or transmitted across a network connection. Parsing
breaks up that chunk of data and allows you to find and process
the parts you care about.
If we wrote a computer program to parse a sentence into
a very simplified model of English grammar, it could look
something like the tree above. Often when we are parsing
things, the structured datatype that results will look something
like a tree. In Haskell, we can sometimes end up having a tree
because recursive types are so easy to express in Haskell.
In this chapter, we will
‚Ä¢use a parsing library to cover the basics of parsing;
‚Ä¢demonstrate the awesome power of parser combinators;
‚Ä¢marshall and unmarshall some JSON data;
‚Ä¢talk about tokenization.
1If you do not know what JSON and XML are yet, try not to get too hung up on that.
All that matters at this point is that they are standard data formats. We‚Äôll look at JSON in
more detail later in the chapter.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1398
24.2 A few more words of introduction
In this chapter, we will not look too deeply into the types of
the parsing libraries we‚Äôre using, learn every sort of parser
there is, or artisanally handcraft all of our parsing functions
ourselves.
These are thoroughly considered decisions. Parsing is a
huge field of research in its own right with connections that
span natural language processing, linguistics, and program-
ming language theory. This topic could easily fill a book in
itself (in fact, it has). The underlying types and typeclasses of
the libraries we‚Äôll be using are complicated. To be sure, if you
enjoy parsing and expect to do it a lot, those are things you‚Äôd
want to learn; they are simply out of the scope of this book.
This chapter takes a diÔ¨Äerent approach than previous chap-
ters. The focus is on enabling you to use Haskell‚Äôs parsing
libraries ‚Äî not to be a master of parsing and writing parsers
in general. This is not the bottom-up approach you may be
accustomed to; by necessity, we‚Äôre working outside-in and
trying to cover what you‚Äôre likely to need. Depending on your
specific interests, you may find this chapter too long or not
nearly long enough.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1399
24.3 Understanding the parsing process
A parser is a function that takes some textual input (it could
be aString , or another datatype such as ByteString orText) and
returns some structure as an output. That structure might
be a tree, for example, or an indexed map of locations in the
parsed data. Parsers analyze structure in conformance with
rules specified in a grammar, whether it‚Äôs a grammar of a
human language, a programming language, or a format such
as JSON.
A parser combinator is a higher-order function that takes
parsers as input and returns a new parser as output. You may
remember our brief discussion of combinators way back in
the lambda calculus chapter. Combinators are expressions
with no free variables.
The standard for what constitutes a combinator with respect
to parser combinators is a little looser. Parsers are functions,
so parser combinators are higher-order functions that can take
parsers as arguments. Usually the argument passing is elided
because the interface of parsers will often be like the State
monad which permits Reader -style implicit argument passing.
Among other things, combinators allow for recursion and for
gluing together parsers in a modular fashion to parse data
according to complex rules.
For computers, parsing is something like reading when
you‚Äôre really young. Perhaps you were taught to trace the</p>
<p>CHAPTER 24. PARSER COMBINATORS 1400
letters with your finger for phonetic pronunciation. Later, you
were able to follow word by word, then you started scanning
with your eyes. Eventually, you learned how to read with
subvocalization.
Since we didn‚Äôt use an analogy for Monad
We‚Äôre going to run through some code now that will demon-
strate the idea of parsing. Let‚Äôs begin by installing the parsing
librarytrifecta ,2then work through a short demonstration of
what it does. We‚Äôll talk more about the design of trifecta in
a while. For now, we‚Äôre going to use it in a state of somewhat
ignorant bliss.
Let‚Äôs put up some code:
moduleLearnParsers where
importText.Trifecta
stop::Parsera
stop=unexpected &quot;stop&quot;
unexpected is a means of throwing errors in parsers like
trifecta which are an instance of the Parsing typeclass. Here
2We‚Äôll be using this version of trifecta
http://hackage.haskell.org/package/trifecta-1.5.2</p>
<p>CHAPTER 24. PARSER COMBINATORS 1401
we‚Äôre using it to make the parser fail for demonstration pur-
poses.
What demonstration purposes?
We‚Äôre glad you asked! The basic idea behind a parser is that
you‚Äôre moving a sort of cursor around a linear stream of text.
It‚Äôssimplesttothinkoftheindividualunitswithinthestreamas
characters or ideographs, though you‚Äôll want to start thinking
of your parsing problems in chunkier terms as you progress.
The idea is that this cursor is a bit like you‚Äôre reading the text
with your finger:
Julie bit Papuchon
^
Then let us say we parsed the word ‚ÄúJulie‚Äù ‚Äî we‚Äôve now
consumed that input, so the cursor will be at ‚Äúbit‚Äù:
Julie bit Papuchon
^
If we weren‚Äôt expecting the word ‚Äúbit,‚Äù our parser could fail
here, and we‚Äôd get an error at the word ‚Äúbit‚Äù like that. However,
if we did parse the word ‚Äúbit‚Äù successfully and thus consumed
that input, it might look something like this:
Julie bit Papuchon
^</p>
<p>CHAPTER 24. PARSER COMBINATORS 1402
The analogy we‚Äôre using here isn‚Äôt perfect. One of the hard-
est problems in writing parsers, especially the parser libraries
themselves, is making it easy to express things the way the
programmer would like, but still have the resulting parser be
fast.
Back to the code
With the cursor analogy in mind, let‚Äôs return to the module
we started.
We‚Äôll first make a little function that only parses one charac-
ter, and then sequence that with stopto make it read that one
character and then die:
-- read a single character '1'
one=char'1'
-- read a single character '1', then die
one'=one&gt;&gt;stop
-- equivalent to char '1' &gt;&gt; stop
Forone', we‚Äôre using the sequencing operator from Monadto
combine two parsers, stopandchar '1' . Given the type of &gt;&gt;:
(&gt;&gt;)::Monadm=&gt;m a-&gt;m b-&gt;m b
it‚Äôs safe to assume that whatever char '1' returns in the
expression</p>
<p>CHAPTER 24. PARSER COMBINATORS 1403
char'1'&gt;&gt;stop
gets thrown away. Critically, any eÔ¨Äect the m aaction had
upon the monadic context remains. The result value of the
parse function gets thrown away, but the eÔ¨Äect of ‚Äúmoving the
cursor‚Äù remains. Another possible eÔ¨Äect is causing the parse
to fail.
A bit like‚Ä¶
State. Plus failure. No seriously, take a look at this definition
of theParser type:
typeParsera=String-&gt;Maybe(a,String)
You can read this as:
1.Await a string value
2.Produce a result which may or may not succeed. (A
Nothing value means the parse failed.)
3.Return a tuple of the value you wanted and whatever‚Äôs
left of the string that you didn‚Äôt consume to produce the
value of type ùëé.
Then remind yourself of what Reader andStatelook like:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1404
newtype Readerr a=
Reader{ runReader ::r-&gt;a }
newtype States a=
State{ runState ::s-&gt;(a, s) }
If you have convinced yourself that Stateis an elaboration
ofReader and that you can see how the Parser type looks sorta
likeState, we can move on.
The idea here with the Parser type is that the Stateis han-
dling the fact that you need to await an eventual text input and
that having parsed something out of that text input results in
a new state of the input stream. It also lets you return a value
independent of the state, while Maybehandles the possibility
of the parser failure.
If we were to look at the underlying pattern of a parsing
function such as char, you can see the State-ish pattern. Please
understand that while this should work as a character-parsing
function, we are simplifying here and this is not what the
source code of any modern parsing library will look like:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1405
-- rudimentary char
-- demo only, this won't work as is.
char::Char-&gt;ParserChar
charc=
Parser$\s-&gt;
casesof
(x:xs)-&gt; ifc==x
then[(c, xs)]
else[]
_ -&gt;[]
We could encode the possibility of failure in that by adding
Maybebut at this point, that isn‚Äôt important because we‚Äôre using
a library that has encoded the possibility of failure for us. It has
also optimized the heck out of charfor us. But we wanted to
show you how the underlying function is the s -&gt;embedded
in theParser data constructor.
Consider the type of a Hutton-Meijer parser:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1406
-- from Text.ParserCombinators.HuttonMeijer
-- polyparse-1.11
typeToken=Char
newtype Parsera=
P([Token]-&gt;[(a, [Token])])
-- Same thing, differently formatted:
typeParser' a=String-&gt;[(a,String)]
This changes things from the previous, less common but
simpler variant, by allowing you to express a range of possibly
valid parses starting from the input provided. This is more
powerful than the Maybevariant, but this design isn‚Äôt used in
popular Haskell parser combinator libraries any longer. Al-
though the underlying implementation has changed dramati-
cally with new discoveries and designs, most parsing libraries
in Haskell are going to have an interface that behaves a bit like
Statein that the act of parsing things has an observable eÔ¨Äect
on one or more bits of state.
If we were talking about State, this means any putto the
Statevalue would be observable to the next action in the same
Monad(you can verify what follows in your REPL by import-
ingControl.Monad.Trans.State ). These examples use the trans-
former variant of State, but if you ignore the T, you should be
able to get the basic idea:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1407
get::Monadm=&gt;StateTs m s
put::Monadm=&gt;s-&gt;StateTs m()
runStateT ::StateTs m a-&gt;s-&gt;m (a, s)
Prelude&gt; runStateT (put 8) 7
((),8)
Prelude&gt; runStateT get 8
(8,8)
Prelude&gt; runStateT (put 1 &gt;&gt; get) 8
(1,1)
Prelude&gt; (runStateT $ put 1 &gt;&gt; get) 0
(1,1)
Prelude&gt; (runStateT $ put 2 &gt;&gt; get) 10021490234890
(2,2)
Prelude&gt; (runStateT $ put 2 &gt;&gt; return 9001) 0
(9001,2)
Nowputreturns a unit value, a throwaway value, so we‚Äôre
only evaluating it for eÔ¨Äect anyway. It modifies the state but
doesn‚Äôt have any value of its own. So when we throw away its
value, we‚Äôre left with its eÔ¨Äect on the state, although getputs
that value into both the ùëéandùë†slots in the tuple.
This is an awful lot like what happens when we sequence a
parsing function such as charwithstop, as above. There is no
real result of char, but it does change the state. The state here
is the location of the cursor in the input stream. In reality, a</p>
<p>CHAPTER 24. PARSER COMBINATORS 1408
modern and mature parser design in Haskell will often look
about as familiar to you as the alien hellscape underneath the
frozen crust of one of the moons of Jupiter. Don‚Äôt take the
idea of there being an actual cursor too literally, but there may
be some utility in imagining it this way.
Back to our regularly scheduled coding
Onward with the code:
-- read two characters, '1', and '2'
oneTwo=char'1'&gt;&gt;char'2'
-- read two characters,
-- '1' and '2', then die
oneTwo' =oneTwo&gt;&gt;stop
testParse ::ParserChar-&gt;IO()
testParse p=
print$parseString p mempty &quot;123&quot;
Theùëùargument is a parser. Specifically, it‚Äôs a character
parser. The functions oneandoneTwo have the type Parser Char .
You can check the types of one'andoneTwo' yourself.
We needed to declare the type of testParse in order to Show
what we parsed because of ambiguity.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1409
The key thing to realize here is that we‚Äôre using parsers like
values and combining them using the same stuÔ¨Ä we use with
ordinary functions or operators from the Applicative andMonad
typeclasses. The structure that makes up the Applicative or
Monadin this case is the Parser itself.
Next we‚Äôll write a function to print a string to standard
output (stdout) with a newline prefixed, and then use that
function as part of a mainthat will show us what we‚Äôve got so
far:
pNLs=
putStrLn ( '\n':s)
main= do
pNL&quot;stop:&quot;
testParse stop
pNL&quot;one:&quot;
testParse one
pNL&quot;one':&quot;
testParse one'
pNL&quot;oneTwo:&quot;
testParse oneTwo
pNL&quot;oneTwo':&quot;
testParse oneTwo'
Let‚Äôs run it and interpret the results. Since it‚Äôs text on a</p>
<p>CHAPTER 24. PARSER COMBINATORS 1410
computer screen instead of tea leaves, we‚Äôll call it science. If
you remain unconvinced, you have our permission to don a
white labcoat and print the output using a dot-matrix printer.
Some of you kids probably don‚Äôt even know what a dot-matrix
printer is.3
Runmainand see what happens:
Prelude&gt; main
stop:
Failure (interactive):1:1: error: unexpected
stop
123<EOF>
^
We failed immediately before consuming any input in the
above, so the caret in the error is at the beginning of our string
value.
Next result:
one:
Success '1'
We parsed a single character, the digit 1. The result is know-
ing we succeeded. But what about the rest of the input stream?
Well, the thing we used to run the parser dropped the rest of
3shakes fist at sky</p>
<p>CHAPTER 24. PARSER COMBINATORS 1411
the input on the floor. There are ways to change this behavior
which we‚Äôll explain in the exercises.
Next up:
one':
Failure (interactive):1:2: error: unexpected
stop
123<EOF>
^
We parsed a single character successfully, then dropped it
because we used &gt;&gt;to sequence it with stop. This means the
cursor was one character forward due to the previous parser
succeeding. Helpfully, trifecta tells us where our parser failed.
And for our last result:
oneTwo:
Success '2'
oneTwo':
Failure (interactive):1:3: error: unexpected
stop
123<EOF>
^
It‚Äôs the same as before, but we parsed two characters indi-
vidually. What if we we don‚Äôt want to discard the first character
we parsed and instead parse ‚Äú12?‚Äù See the exercises below!</p>
<p>CHAPTER 24. PARSER COMBINATORS 1412
Exercises: Parsing Practice
1.There‚Äôs a combinator that‚Äôll let us mark that we expect
an input stream to be finished at a particular point in our
parser. In the parsers library this is simply called eof(end-
of-file) and is in the Text.Parser.Combinators module. See
if you can make the oneandoneTwo parsers fail because
they didn‚Äôt exhaust the input stream!
2.Usestring to make a Parser that parses ‚Äú1‚Äù, ‚Äú12‚Äù, and ‚Äú123‚Äù
out of the example input respectively. Try combining it
withstoptoo. That is, a single parser should be able to
parse all three of those strings.
3.Try writing a Parser that does what string does, but using
char.
Intermission: parsing free jazz
Let us play with these parsers! We typically use the parseString
function to run parsers, but if you figure some other way that
works for you, so be it! Here‚Äôs some parsing free jazz, if you
will, meant only to help develop your intuition about what‚Äôs
going on:
Prelude&gt; import Text.Trifecta
Prelude&gt; :t char
char :: CharParsing m =&gt; Char -&gt; m Char</p>
<p>CHAPTER 24. PARSER COMBINATORS 1413
Prelude&gt; :t parseString
parseString
:: Parser a
-&gt; Text.Trifecta.Delta.Delta
-&gt; String
-&gt; Result a
Prelude&gt; let gimmeA = char 'a'
Prelude&gt; :t parseString gimmeA mempty
parseString gimmeA mempty :: String -&gt; Result Char
Prelude&gt; parseString gimmeA mempty &quot;a&quot;
Success 'a'
Prelude&gt; parseString gimmeA mempty &quot;b&quot;
Failure (interactive):1:1: error: expected: &quot;a&quot;
b<EOF>
^
Prelude&gt; parseString (char 'b') mempty &quot;b&quot;
Success 'b'
Prelude&gt; parseString (char 'b' &gt;&gt; char 'c') mempty &quot;b&quot;
Failure (interactive):1:2: error: unexpected
EOF, expected: &quot;c&quot;
b<EOF>
^
Prelude&gt; parseString (char 'b' &gt;&gt; char 'c') mempty &quot;bc&quot;
Success 'c'</p>
<p>CHAPTER 24. PARSER COMBINATORS 1414
Prelude&gt; parseString (char 'b' &gt;&gt; char 'c') mempty &quot;abc&quot;
Failure (interactive):1:1: error: expected: &quot;b&quot;
abc<EOF>
^
Seems like we ought to have a way to say, ‚Äúparse this string‚Äù
rather than having to sequence the parsers of individual char-
acters bit by bit, right? Turns out, we do:
Prelude&gt; parseString (string &quot;abc&quot;) mempty &quot;abc&quot;
Success &quot;abc&quot;
Prelude&gt; parseString (string &quot;abc&quot;) mempty &quot;bc&quot;
Failure (interactive):1:1: error: expected: &quot;abc&quot;
bc<EOF>
^
Prelude&gt; parseString (string &quot;abc&quot;) mempty &quot;ab&quot;
Failure (interactive):1:1: error: expected: &quot;abc&quot;
ab<EOF>
^
Importantly, it‚Äôs not a given that a single parser exhausts all
of its input ‚Äî they only consume as much text as they need
to produce the value of the type requested.
Prelude&gt; parseString (char 'a') mempty &quot;abcdef&quot;
Success 'a'
Prelude&gt; let stop = unexpected &quot;stop pls&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1415
Prelude&gt; parseString (char 'a' &gt;&gt; stop) mempty &quot;abcdef&quot;
Failure (interactive):1:2: error: unexpected
stop pls
abcdef<EOF>
^
Prelude&gt; parseString (string &quot;abc&quot;) mempty &quot;abcdef&quot;
Success &quot;abc&quot;
Prelude&gt; parseString (string &quot;abc&quot; &gt;&gt; stop) mempty &quot;abcdef&quot;
Failure (interactive):1:4: error: unexpected
stop pls
abcdef<EOF>
^
Note that we can also parse UTF-8 encoded ByteString s with
trifecta :
Prelude&gt; import Text.Trifecta
Prelude&gt; :t parseByteString
parseByteString
:: Parser a
-&gt; Text.Trifecta.Delta.Delta
-&gt; Data.ByteString.Internal.ByteString
-&gt; Result a
Prelude&gt; parseByteString (char 'a') mempty &quot;a&quot;
Success 'a'</p>
<p>CHAPTER 24. PARSER COMBINATORS 1416
This ends the free jazz session. We now return to serious
matters.
24.4 Parsing fractions
Now that we have some idea of what parsing is, what parser
combinators are, and what the monadic underpinnings of
parsing look like, let‚Äôs move on to parsing fractions. The top
of this module should look like this:
{-# LANGUAGE OverloadedStrings #-}
moduleText.Fractions where
importControl.Applicative
importData.Ratio ((%))
importText.Trifecta
We named the module Text.Fractions because we‚Äôre pars-
ing fractions out of text input, and there‚Äôs no need to be more
clever about it than that. We‚Äôre going to be using String in-
puts with trifecta at first, but you‚Äôll see why we threw an
OverloadedStrings extension in there later.
Now, on to parsing fractions! We‚Äôll start with some test
inputs:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1417
badFraction =&quot;1/0&quot;
alsoBad =&quot;10&quot;
shouldWork =&quot;1/2&quot;
shouldAlsoWork =&quot;2/1&quot;
Then we‚Äôll write our actual parser:
parseFraction ::ParserRational
parseFraction = do
numerator &lt;-decimal
-- [2] [1]
char'/'
-- [3]
denominator &lt;-decimal
-- [ 4 ]
return (numerator %denominator)
-- [5] [6]
1.decimal ::Integral a=&gt;Parsera
This is the type of decimal within the context of those
functions. If you use GHCi to query the type of decimal ,
you will see a more polymorphic type signature.
2.Herenumerator has the type Integral a =&gt; a .
3.char::Char-&gt;ParserChar</p>
<p>CHAPTER 24. PARSER COMBINATORS 1418
As with decimal , if you query the type of charin GHCi,
you‚Äôll see a more polymorphic type, but this is the type
ofcharin context.
4.Same deal as numerator , but when we match an integral
number we‚Äôre binding the result to the name denominator .
5.The final result has to be a parser, so we embed our inte-
gral value in the Parser type by using return.
6.We construct ratios using the %infix operator:
(%)::Integral a
=&gt;a-&gt;a-&gt;GHC.Real.Ratioa
Then the fact that our final result is a Rational makes the
Integral a =&gt; a values into concrete Integer values.
typeRational =GHC.Real.RatioInteger
We‚Äôll put together a quick shim main function to run the
parser against the test inputs and see the results:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1419
main::IO()
main= do
letparseFraction' =
parseString parseFraction mempty
print$parseFraction' shouldWork
print$parseFraction' shouldAlsoWork
print$parseFraction' alsoBad
print$parseFraction' badFraction
Try not to worry about the mempty values; it might give you
a clue about what‚Äôs going on in trifecta under the hood, but
it‚Äôs not something we‚Äôre going to explore in this chapter.
We will briefly note the type of parseString , which is how
we‚Äôre running the parser we created:
parseString ::Parsera
-&gt;Text.Trifecta .Delta.Delta
-&gt;String
-&gt;Resulta
The first argument is the parser we‚Äôre going to run against
the input, the second is a Delta, the third is the String we‚Äôre
parsing, and then the final result is either the thing we wanted
of type ùëéor an error string to let us know something went
wrong. You can ignore the Deltathing ‚Äî use mempty to provide
the do-nothing input. We won‚Äôt be covering deltas in this book
so consider it extra credit if you get curious.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1420
Anyway, when we run the code, the results look like this:
Prelude&gt; main
Success (1 % 2)
Success (2 % 1)
Failure (interactive):1:3: error: unexpected
EOF, expected: &quot;/&quot;, digit
10<EOF>
^
Success *** Exception: Ratio has zero denominator
The first two succeeded properly. The third failed because it
couldn‚Äôt parse a fraction out of the text ‚Äú10‚Äù. The error is telling
us that it ran out of text in the input stream while still waiting
for the character '/'. The final error did not result from the
process of parsing; we know that because it is a Success data
constructor. The final error resulted from trying to construct
a ratio with a denominator that is zero ‚Äî which makes no
sense. We can reproduce the issue in GHCi:
Prelude&gt; 1 % 0
*** Exception: Ratio has zero denominator
-- So the parser result is which is tantamount to
Prelude&gt; Success (1 % 0)
Success *** Exception: Ratio has zero denominator
This is sort of a problem because exceptions end our pro-
grams. Observe:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1421
main::IO()
main= do
letparseFraction' =
parseString parseFraction mempty
print$parseFraction' badFraction
print$parseFraction' shouldWork
print$parseFraction' shouldAlsoWork
print$parseFraction' alsoBad
We‚Äôve put the expression that throws an exception in the
first line this time, when we run it we get:
Prelude&gt; main
Success *** Exception: Ratio has zero denominator
So, our program halted on the error. This is not great. You
may be tempted to ‚Äúhandle‚Äù the error. Catching exceptions
is okay, but this is a particular class of exceptions that means
something is quite wrong with your program. You should elim-
inate the possibility of exceptions occurring in your programs
where possible.
We‚Äôll talk more about error handling in a later chapter, but
the idea here is that a Parser type already explicitly encodes
the possibility of failure. It‚Äôs better for a value of type Parser
ato have only one vector for errors and that vector is the
parser‚Äôs ability to encode failure. There may be an edge case</p>
<p>CHAPTER 24. PARSER COMBINATORS 1422
that doesn‚Äôt suit this design preference, but it‚Äôs a very good
idea to not have exceptions or bottoms that aren‚Äôt explicitly
called out as a possibility in the types whenever possible.
We could modify our program to handle the 0 denominator
case and change it into a parse error:
virtuousFraction ::ParserRational
virtuousFraction = do
numerator &lt;-decimal
char'/'
denominator &lt;-decimal
casedenominator of
0-&gt;fail&quot;Denominator cannot be zero&quot;
_ -&gt;return (numerator %denominator)
Here is our first explicit use of fail, which by historical ac-
cident is part of the Monadtypeclass. Realistically, not all Monads
have a proper implementation of fail, so it will be moved out
into aMonadFail class eventually. For now, it suffices to know
that it is our means of returning an error for the Parser type
here.
Now for another run of our test inputs, but with our more
cautious parser:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1423
testVirtuous ::IO()
testVirtuous = do
letvirtuousFraction' =
parseString virtuousFraction mempty
print$virtuousFraction' badFraction
print$virtuousFraction' alsoBad
print$virtuousFraction' shouldWork
print$virtuousFraction' shouldAlsoWork
When we run this, we‚Äôre going to get a slightly diÔ¨Äerent
result at the end:
Prelude&gt; testVirtuous
Failure (interactive):1:4: error: Denominator
cannot be zero, expected: digit
1/0<EOF>
^
Failure (interactive):1:3: error: unexpected
EOF, expected: &quot;/&quot;, digit
10<EOF>
^
Success (1 % 2)
Success (2 % 1)
Now we have no bottom causing the program to halt and
we get a Failure value which explains the cause for the failure.
Much better!</p>
<p>CHAPTER 24. PARSER COMBINATORS 1424
Exercise: Unit of Success
This should not be unfamiliar at this point, even if you do not
understand all the details:
Prelude&gt; parseString integer mempty &quot;123abc&quot;
Success 123
Prelude&gt; parseString (integer &gt;&gt; eof) mempty &quot;123abc&quot;
Failure (interactive):1:4: error: expected: digit,
end of input
123abc<EOF>
^
Prelude&gt; parseString (integer &gt;&gt; eof) mempty &quot;123&quot;
Success ()
You may have already deduced why it returns ()as aSuccess
result here; it‚Äôs consumed all the input but there is no result
to return from having done so. The result Success () tells you
the parse was successful and consumed the entire input, so
there‚Äôs nothing to return.
What we want you to try now is rewriting the final example
so it returns the integer that it parsed instead of Success () .
It should return the integer successfully when it receives an
input with an integer followed by an EOF and fail in all other
cases:
Prelude&gt; parseString (yourFuncHere) mempty &quot;123&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1425
Success 123
Prelude&gt; parseString (yourFuncHere) mempty &quot;123abc&quot;
Failure (interactive):1:4: error: expected: digit,
end of input
123abc<EOF>
^
24.5 Haskell‚Äôs parsing ecosystem
Haskell has several excellent parsing libraries available. parsec
andattoparsec are perhaps the two most well known parser
combinator libraries in Haskell, but there is also megaparsec
and others. aesonandcassava are among the libraries designed
for parsing specific types of data (JSON data and CSV data,
respectively).
For this chapter, we opted to use trifecta , as you‚Äôve seen.
One reason for that decision is that trifecta has error messages
that are very easy to read and interpret, unlike some other
libraries. Also, trifecta does not seem likely to undergo major
changes in its fundamental design. Its design is somewhat
unusual and complex, but most of the things that make it
unusual will be irrelevant to you in this chapter. If you intend
to do a lot of parsing in production, you may need to get
comfortable using attoparsec , as it is particularly known for
very speedy parsing; you will see some attoparsec (andaeson)
later in the chapter.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1426
The design of trifecta has evolved such that the API4is split
across two libraries, parsers5andtrifecta . The reason for this
is that the trifecta package itself provides the concrete im-
plementation of the trifecta parser as well as trifecta -specific
functionality, but the parsers API is a collection of typeclasses
that abstract over diÔ¨Äerent kinds of things parsers can do. The
Text.Trifecta module handles exporting what you need to get
started from each package, so this information is mostly so
you know where to look if you need to start spelunking.
Typeclasses of parsers
As we noted above, trifecta relies on the parsers library for
certain typeclasses. These typeclasses abstract over common
kinds of things parsers do. We‚Äôre only going to note a few
things here that we‚Äôll be seeing in the chapter so that you have
a sense of their provenance.
Note that the following is a discussion of code provided for
you by the parsers library, you do not need to type this in!
1.The typeclass Parsing hasAlternative as a superclass. We‚Äôll
talk more about Alternative in a bit. The Parsing typeclass
4API stands for application programming interface. When we write software that
relies on libraries or makes requests to a service such as Twitter ‚Äî basically, software
that relies on other software ‚Äî we rely on a set of defined functions. The API is that set
of functions that we use to interface with that software without having to write those
functions or worry too much about their source code. When you look at a library on
Hackage, (unless you click to view the source code), you‚Äôre looking at the API of that
library.
5http://hackage.haskell.org/package/parsers</p>
<p>CHAPTER 24. PARSER COMBINATORS 1427
provides for functionality needed to describe parsers in-
dependent of input type. A minimal complete instance of
this typeclass defines the following functions: try,(&lt;?&gt;),
andnotFollowedBy . Let‚Äôs start with try:
-- Text.Parser.Combinators
classAlternative m=&gt;Parsing mwhere
try::m a-&gt;m a
Thistakesaparserthatmayconsumeinputand, onfailure,
goes back to where it started and fails if we didn‚Äôt consume
input.
It also gives us the function notFollowedBy which does not
consume input but allows us to match on keywords by
matching on a string of characters that is not followed by
some thing we do not want to match:
notFollowedBy ::Showa=&gt;m a-&gt;m()
-- &gt; noAlpha = notFollowedBy alphaNum
-- &gt; keywordLet =
-- try $ string &quot;let&quot; &lt;* noAlpha
2.TheParsing typeclass also includes unexpected which is
used to emit an error on an unexpected token, as we saw
earlier, and eof. Theeoffunction only succeeds at the end
of input:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1428
eof::m()
-- &gt; eof =
-- notFollowedBy anyChar
-- &lt;?&gt; &quot;end of input&quot;
We‚Äôll be seeing more of this one in upcoming sections.
3.The library also defines the typeclass CharParsing , which
hasParsing as a superclass. This handles parsing individ-
ual characters.
-- Text.Parser.Char
classParsing m=&gt;CharParsing mwhere
We‚Äôve already seen charfrom this class, but it also includes
these:
-- Parses any single character other
-- than the one provided. Returns
-- the character parsed.
notChar ::Char-&gt;mChar
-- Parser succeeds for any character.
-- Returns the character parsed.
anyChar ::mChar</p>
<p>CHAPTER 24. PARSER COMBINATORS 1429
-- Parses a sequence of characters, returns
-- the string parsed.
string::String-&gt;mString
-- Parses a sequence of characters
-- represented by a Text value,
-- returns the parsed Text fragment.
text::Text-&gt;mText
Theparsers library has much more than this, but for our
immediate purposes these will suffice. The important point is
that it defines for us some typeclasses and basic combinators
for common parsing tasks. We encourage you to explore the
documentation more on your own.
24.6 Alternative
Let‚Äôs say we had a parser for numbers and one for alphanu-
meric strings:
Prelude&gt; import Text.Trifecta
Prelude&gt; parseString (some letter) mempty &quot;blah&quot;
Success &quot;blah&quot;
Prelude&gt; parseString integer mempty &quot;123&quot;
Success 123
What if we had a type that could be an Integer or aString ?</p>
<p>CHAPTER 24. PARSER COMBINATORS 1430
moduleAltParsing where
importControl.Applicative
importText.Trifecta
typeNumberOrString =
EitherInteger String
a=&quot;blah&quot;
b=&quot;123&quot;
c=&quot;123blah789&quot;
parseNos ::ParserNumberOrString
parseNos =
(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
main= do
letp f i=
parseString f mempty i
print$p (some letter) a
print$p integer b
print$p parseNos a
print$p parseNos b
print$p (many parseNos) c
print$p (some parseNos) c</p>
<p>CHAPTER 24. PARSER COMBINATORS 1431
We can read &lt;|&gt;as being an or, or disjunction, of our two
parsers; manyis zero or more and someis one or more.
Prelude&gt; parseString (some integer) mempty &quot;123&quot;
Success [123]
Prelude&gt; parseString (many integer) mempty &quot;123&quot;
Success [123]
Prelude&gt; parseString (many integer) mempty &quot;&quot;
Success []
Prelude&gt; parseString (some integer) mempty &quot;&quot;
Failure (interactive):1:1: error: unexpected
EOF, expected: integer
<EOF>
^
What we‚Äôre taking advantage of here with some,many, and
(&lt;|&gt;)is theAlternative typeclass:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1432
classApplicative f=&gt;Alternative fwhere
-- | The identity of '&lt;|&gt;'
empty::f a
-- | An associative binary operation
(&lt;|&gt;)::f a-&gt;f a-&gt;f a
-- | One or more.
some::f a-&gt;f [a]
some v=some_v
where
many_v=some_v&lt;|&gt;pure[]
some_v=(fmap (:) v)&lt;<em>&gt;many_v
-- | Zero or more.
many::f a-&gt;f [a]
many v=many_v
where
many_v=some_v&lt;|&gt;pure[]
some_v=(fmap (:) v)&lt;</em>&gt;many_v
If you use the :infocommand in the REPL after importing
Text.Trifecta or loading the above module, you‚Äôll find some
andmanyare defined in GHC.Base because they come from this
typeclass rather than being specific to a particular parser or to
theparsers library, or even to this particular problem domain.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1433
What if we wanted to require that each value be separated
by newline? QuasiQuotes lets us have a multiline string without
the newline separators and use it as a single argument:
{-# LANGUAGE QuasiQuotes #-}
moduleAltParsing where
importControl.Applicative
importText.RawString.QQ
importText.Trifecta
typeNumberOrString =
EitherInteger String
eitherOr ::String
eitherOr =[r|
123
abc
456
def
|]</p>
<p>CHAPTER 24. PARSER COMBINATORS 1434
QuasiQuotes
Above, the [r|is beginning a quasiquoted6section, using the
quasiquoter named r. Note we had to enable the QuasiQuotes
language extension to use this syntax. At time of writing ris
defined in raw-strings-qq version 1.1 as follows:
r::QuasiQuoter
r=QuasiQuoter {
-- Extracted from dead-simple-json.
quoteExp =
return.LitE.StringL
.normaliseNewlines,
-- error messages elided
quotePat =
_ -&gt;fail&quot;some error message&quot;
quoteType =
_ -&gt;fail&quot;some error message&quot;
quoteDec =
_ -&gt;fail&quot;some error message&quot;
The idea here is that this is a macro that lets us write ar-
bitrary text inside of the block that begins with [r|and ends
6There‚Äôs a rather nice wiki page and tutorial example at: https://wiki.haskell.org/
Quasiquotation</p>
<p>CHAPTER 24. PARSER COMBINATORS 1435
with|]. This specific quasiquoter exists to allow writing mul-
tiline strings without manual escaping. The quasiquoter is
generating the following for us:
&quot;\n<br />
\123\n<br />
\abc\n<br />
\456\n<br />
\def\n&quot;
Not as nice right? As it happens, if you want to see what
a quasiquoter or Template Haskell7is generating at compile-
time, you can enable the -ddump-splices flag to see what it does.
Here‚Äôs an example using a minimal stub file:
7https://wiki.haskell.org/Template_Haskell</p>
<p>CHAPTER 24. PARSER COMBINATORS 1436
{-# LANGUAGE QuasiQuotes #-}
moduleQuasimodo where
importText.RawString.QQ
eitherOr ::String
eitherOr =[r|
123
abc
456
def
|]
Then in GHCi we use the :setcommand to turn on the
splice dumping flag so we can see what the quasiquoter gener-
ated:
Prelude&gt; :set -ddump-splices
Prelude&gt; :l code/quasi.hs
[1 of 1] Compiling Quasimodo
code/quasi.hs:(8,12)-(12,2): Splicing expression
&quot;\n<br />
\123\n<br />
\abc\n<br />
\456\n&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1437
======&gt;
&quot;\n<br />
\123\n<br />
\abc\n<br />
\456\n&quot;
Right, so back to the parser we were going to write!
Return to Alternative
All right, we return now to our AltParsing module. We‚Äôre going
to use this fantastic function:
parseNos ::ParserNumberOrString
parseNos =
(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
and rewrite mainto apply that to the eitherOr value:
main= do
letp f i=parseString f mempty i
print$p parseNos eitherOr
Note that we lifted LeftandRightover their arguments.
This is because there is Parser structure between the (potential)
value obtained by running the parser and what the data con-
structor expects. A value of type Parser Char is a parser that</p>
<p>CHAPTER 24. PARSER COMBINATORS 1438
will possibly produce a Charvalue if it is given an input that
doesn‚Äôt cause it to fail. The type of some letter is the following:
Prelude&gt; import Text.Trifecta
Prelude&gt; :t some letter
some letter :: CharParsing f =&gt; f [Char]
However, for our purposes we can say that the type is specif-
icallytrifecta ‚ÄôsParser type:
Prelude&gt; let someLetter = some letter :: Parser [Char]
Prelude&gt; let someLetter = some letter :: Parser String
If we try to mash a data constructor expecting a String and
our parser-of-string together like a kid playing with action
figures, we get a type error:
Prelude&gt; data MyName = MyName String deriving Show
Prelude&gt; MyName someLetter
Couldn't match type ‚ÄòParser String‚Äô with ‚Äò[Char]‚Äô
Expected type: String
Actual type: Parser String
In the first argument of ‚ÄòMyName‚Äô, namely ‚ÄòsomeLetter‚Äô
In the expression: MyName someLetter
Unless we lift it over the Parser structure, since Parser is a
Functor !</p>
<p>CHAPTER 24. PARSER COMBINATORS 1439
Prelude&gt; :info Parser
{... content elided ...}
instance Monad Parser
instance Functor Parser
instance Applicative Parser
instance Monoid a =&gt; Monoid (Parser a)
instance Errable Parser
instance DeltaParsing Parser
instance TokenParsing Parser
instance Parsing Parser
instance CharParsing Parser
We should need an fmapright?
-- same deal
Prelude&gt; :t MyName &lt;$&gt; someLetter
MyName &lt;$&gt; someLetter :: Parser MyName
Prelude&gt; :t MyName <code>fmap</code> someLetter
MyName <code>fmap</code> someLetter :: Parser MyName
Then running either of them:
Prelude&gt; parseString someLetter mempty &quot;Chris&quot;
Success &quot;Chris&quot;
Prelude&gt; let mynameParser = MyName &lt;$&gt; someLetter
Prelude&gt; parseString mynameParser mempty &quot;Chris&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1440
Success (MyName &quot;Chris&quot;)
Cool.
Back to our original code, which will spit out an error:
Prelude&gt; main
Failure (interactive):1:1: error: expected: integer,
letter
It‚Äôs easier to see why if we look at the test string:
Prelude&gt; eitherOr
&quot;\n123\nabc\n456\ndef\n&quot;
One way to fix this is to amend the quasiquoted string:
eitherOr ::String
eitherOr =[r|123
abc
456
def
|]
What if we wanted to permit a newline before attempting
to parse strings or integers?</p>
<p>CHAPTER 24. PARSER COMBINATORS 1441
eitherOr ::String
eitherOr =[r|
123
abc
456
def
|]
parseNos ::ParserNumberOrString
parseNos =
skipMany (oneOf &quot;\n&quot;)
&gt;&gt;
(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
main= do
letp f i=parseString f mempty i
print$p parseNos eitherOr
Prelude&gt; main
Success (Left 123)
OK, but we‚Äôd like to keep parsing after each line. If we try
the obvious thing and use someto ask for one-or-more results,
we‚Äôll get a somewhat mysterious error:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1442
Prelude&gt; parseString (some parseNos) mempty eitherOr
Failure (interactive):6:1: error: unexpected
EOF, expected: integer, letter
<EOF>
^
The issue here is that while skipMany lets us skip zero or more
times, it means we started the next run of the parser before we
hit EOF. This means it expects us to match an integer or some
letters after having seen the newline character after ‚Äúdef‚Äù. We
can simply amend the input:
eitherOr ::String
eitherOr =[r|
123
abc
456
def|]
Our previous attempt will now work fine:
Prelude&gt; parseString (some parseNos) mempty eitherOr
Success [Left 123,Right &quot;abc&quot;,Left 456,Right &quot;def&quot;]
If we‚Äôre dissatisfied with simply changing the rules of the
game, there are a couple ways we can make our parser cope
withspuriousterminalnewlines. Oneistoaddanother skipMany
rule after we parse our value:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1443
parseNos ::ParserNumberOrString
parseNos = do
skipMany (oneOf &quot;\n&quot;)
v&lt;-(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
skipMany (oneOf &quot;\n&quot;)
return v
Another option is to keep the previous version of the parser
which skips a potential leading newline:
parseNos ::ParserNumberOrString
parseNos =
skipMany (oneOf &quot;\n&quot;)
&gt;&gt;
(Left&lt;$&gt;integer)
&lt;|&gt;(Right&lt;$&gt;some letter)
But then tokenize it with the default tokenbehavior:
Prelude&gt; parseString (some (token parseNos)) mempty eitherOr
Success [Left 123,Right &quot;abc&quot;,Left 456,Right &quot;def&quot;]
We‚Äôll explain soon what this token stuÔ¨Ä is about, but we
want to be a bit careful here as token parsers and character
parsers are diÔ¨Äerent sorts of things. What applying tokento
parseNos did for us here is make it optionally consume trailing</p>
<p>CHAPTER 24. PARSER COMBINATORS 1444
whitespace we don‚Äôt care about, where whitespace includes
newline characters.
Exercise: Try Try
Make a parser, using the existing fraction parser plus a new dec-
imal parser, that can parse either decimals or fractions. You‚Äôll
want to use &lt;|&gt;fromAlternative to combine the‚Ä¶alternative
parsers. If you find this too difficult, write a parser that parses
straightforward integers or fractions. Make a datatype that
contains either an integer or a rational and use that datatype as
the result of the parser. Or use Either . Run free, grasshopper.
Hint: we‚Äôve not explained it yet, but you may want to try
try.
24.7 Parsing configuration files
For our next examples, we‚Äôll be using the INI8configuration
file format, partly because it‚Äôs an informal standard so we can
play fast and loose for learning and experimentation purposes.
We‚Äôre also using INI because it‚Äôs relatively uncomplicated.
Here‚Äôs a teensy example of an INI config file:
8INI is an informal standard for configuration files on some platforms. The name
comes from the file extension, .ini, short for ‚Äúinitialization.‚Äù</p>
<p>CHAPTER 24. PARSER COMBINATORS 1445
; comment
[section]
host=wikipedia .org
alias=claw
The above contains a comment, which contributes noth-
ing to the data parsed out of the configuration file but which
may provide context to the settings being configured. It‚Äôs fol-
lowed by a section header named &quot;section&quot; which contains
two settings: one named &quot;host&quot; with the value &quot;wikipedia.org&quot; ,
another named &quot;alias&quot; with the value &quot;claw&quot; .
We‚Äôll begin this example with our pragmas, module decla-
ration, and imports:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1446
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
moduleData.Ini where
importControl.Applicative
importData.ByteString (ByteString )
importData.Char (isAlpha)
importData.Map (Map)
import qualified Data.Map asM
importData.Text (Text)
import qualified Data.Text.IO asTIO
importTest.Hspec
importText.RawString.QQ
-- parsers 0.12.3, trifecta 1.5.2
importText.Trifecta
OverloadedStrings andQuasiQuotes should be familiar by now.
When writing parsers in Haskell, it‚Äôs often easiest to work in
terms of smaller parsers that deal with a sub-problem of the
overall parsing problem you‚Äôre solving, then combine them
into the final parser. This isn‚Äôt a perfect recipe for understand-
ing your parser, but being able to compose them straightfor-
wardly like functions is pretty nifty. Let‚Äôs start by creating a
test input for an INI header, a datatype, and then the parser</p>
<p>CHAPTER 24. PARSER COMBINATORS 1447
for it:
headerEx ::ByteString
headerEx =&quot;[blah]&quot;
-- &quot;[blah]&quot; -&gt; Section &quot;blah&quot;
newtype Header=
HeaderString
deriving (Eq,Ord,Show)
parseBracketPair ::Parsera-&gt;Parsera
parseBracketPair p=
char'['*&gt;p&lt;*char']'
-- these operators mean the brackets
-- will be parsed and then discarded
-- but the p will remain as our result
parseHeader ::ParserHeader
parseHeader =
parseBracketPair ( Header&lt;$&gt;some letter)
Here we‚Äôve combined two parsers in order to parse a Header .
We can experiment with each of them in the REPL. First
we‚Äôll examine the types of the some letter parser we passed to
parseBracketPair :</p>
<p>CHAPTER 24. PARSER COMBINATORS 1448
Prelude&gt; :t some letter
some letter :: CharParsing f =&gt; f [Char]
Prelude&gt; :t Header &lt;$&gt; some letter
Header &lt;$&gt; some letter :: CharParsing f =&gt; f Header
Prelude&gt; let slp = Header &lt;$&gt; some letter :: Parser Header
The first type is some parser that can understand characters
which will produce a String value if it succeeds. The second
type is the same, but produces a Header value instead of a String .
Parser types in Haskell almost always encode the possibility
of failure; we‚Äôll cover how later in this chapter. The third type
gives us concrete Parser type from trifecta where there had
been the polymorphic type ùëì.
Theletter function parses a single character, while some
letter parses one or more characters. We need to wrap the
Header constructor around that so that our result there ‚Äî what-
everlettersmightbeinsidethebrackets, the ùëùofparseBracketPair
‚Äî will be labeled as the Header of the file in the final parse.
Next,assignmentEx is just some test input so we can begin
kicking around our parser. The type synonyms are to make
the types more readable as well. Nothing too special here:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1449
assignmentEx ::ByteString
assignmentEx =&quot;woot=1&quot;
typeName=String
typeValue=String
typeAssignments =MapNameValue
parseAssignment ::Parser(Name,Value)
parseAssignment = do
name&lt;-some letter
_ &lt;-char'='
val&lt;-some (noneOf &quot;\n&quot;)
skipEOL -- important!
return (name, val)
-- | Skip end of line and
-- whitespace beyond.
skipEOL ::Parser()
skipEOL =skipMany (oneOf &quot;\n&quot;)
Let us explain parseAssignment step by step. For parsing the
initial key or name of an assignment, we parse one or more
letters:
name&lt;-some letter</p>
<p>CHAPTER 24. PARSER COMBINATORS 1450
Then we parse and throw away the ‚Äú=‚Äù used to separate keys
and values:
_ &lt;-char'='
Then we parse one or more characters as long as they aren‚Äôt
a newline. This is so letters, numbers, and whitespace are
permitted:
val&lt;-some (noneOf &quot;\n&quot;)
We skip ‚Äúend-of-line‚Äù until we stop getting newline charac-
ters:
skipEOL -- important!
This is so we can delineate the end of assignments and
parse more than one assignment in a straightforward manner.
Consider an alternative variant of this same parser that doesn‚Äôt
haveskipEOL :
parseAssignment' ::Parser(Name,Value)
parseAssignment' = do
name&lt;-some letter
_ &lt;-char'='
val&lt;-some (noneOf &quot;\n&quot;)
return (name, val)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1451
Then trying out this variant of the parser:
Prelude&gt; let spa' = some parseAssignment'
Prelude&gt; let s = &quot;key=value\nblah=123&quot;
Prelude&gt; parseString spa' mempty s
Success [(&quot;key&quot;,&quot;value&quot;)]
Pity. Can‚Äôt parse the second assignment. But the first ver-
sion that includes the skipEOL should work:
Prelude&gt; let spa = some parseAssignment
Prelude&gt; parseString spa mempty s
Success [(&quot;key&quot;,&quot;value&quot;),(&quot;blah&quot;,&quot;123&quot;)]
Prelude&gt; let d = &quot;key=value\n\n\ntest=data&quot;
Prelude&gt; parseString spa mempty d
Success [(&quot;key&quot;,&quot;value&quot;),(&quot;test&quot;,&quot;data&quot;)]
We have to skip the one-or-more newline characters sepa-
rating the first and second assignment in order for the rerun
of the assignment parser to begin successfully parsing the
letters that make up the key of the second assignment. Happy-
making, right?
We finish things oÔ¨Ä for parseAssignment by tupling name and
value together and re-embedding the result in the Parser type:
return(name, val)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1452
Then for dealing with INI comments, that is, skipping them
in the parser and discarding the data:
commentEx ::ByteString
commentEx =
&quot;; last modified 1 April <br />
\2001 by John Doe&quot;
commentEx' ::ByteString
commentEx' =
&quot;; blah\n; woot\n\n;hah&quot;
-- | Skip comments starting at the
-- beginning of the line.
skipComments ::Parser()
skipComments =
skipMany ( do _ &lt;- char';'&lt;|&gt;char'#'
skipMany (noneOf &quot;\n&quot;)
skipEOL)
We made a couple of comment examples for testing the
parser. Note that comments can begin with #or;.
Next, we need section parsing. We‚Äôll make some data for
testing that out, as we did with comments above. This is also
where we‚Äôll put that QuasiQuotes extension to use, allowing us
to make multiline strings nicer to write:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1453
sectionEx ::ByteString
sectionEx =
&quot;; ignore me \n[states] \nChris=Texas&quot;
sectionEx' ::ByteString
sectionEx' =[r|
; ignore me
[states]
Chris=Texas
|]
sectionEx'' ::ByteString
sectionEx'' =[r|
; comment
[section]
host=wikipedia .org
alias=claw
[whatisit]
red=intoothandclaw
|]
Then we get into the section parsing:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1454
dataSection =
Section HeaderAssignments
deriving (Eq,Show)
newtype Config=
Config(MapHeaderAssignments )
deriving (Eq,Show)
skipWhitespace ::Parser()
skipWhitespace =
skipMany (char ' '&lt;|&gt;char'\n')
parseSection ::ParserSection
parseSection = do
skipWhitespace
skipComments
h&lt;-parseHeader
skipEOL
assignments &lt;-some parseAssignment
return$
Section h (M.fromList assignments)
Above, we defined datatypes for a section and an entire INI
config. You‚Äôll notice that parseSection skips both whitespace
and comments now. And it returns the parsed section with</p>
<p>CHAPTER 24. PARSER COMBINATORS 1455
the header (that‚Äôs the ‚Ñé) and a map of assignments:
*Data.Ini&gt; parseByteString parseSection mempty sectionEx
Success (Section (Header &quot;states&quot;)
(fromList [(&quot;Chris&quot;,&quot;Texas&quot;)]))
So far, so good. Next, let‚Äôs roll the sections up into a Map
that keys section data by section name, with the values being
further more Maps of assignment names mapped to their
values. We use foldrto aggregate the list of sections into a
single Map value:
rollup::Section
-&gt;MapHeaderAssignments
-&gt;MapHeaderAssignments
rollup(Section h a) m=
M.insert h a m
parseIni ::ParserConfig
parseIni = do
sections &lt;-some parseSection
letmapOfSections =
foldr rollup M.empty sections
return ( ConfigmapOfSections)
After you load this code into your REPL, try running:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1456
parseByteString parseIni mempty sectionEx
and comparing it to the output of:
parseByteString parseSection mempty sectionEx
that you saw above.
Now we‚Äôll put these things together. We‚Äôre interested in
whether our parsers do what they should do rather than pars-
ing an actual INI file, so we‚Äôll have mainrun some hspectests.
We‚Äôll use a helper function, maybeSuccess , as part of the tests:
maybeSuccess ::Resulta-&gt;Maybea
maybeSuccess (Success a)=Justa
maybeSuccess _ =Nothing
main::IO()
main=hspec$ do
describe &quot;Assignment Parsing&quot; $
it&quot;can parse a simple assignment&quot; $ do
letm=parseByteString
parseAssignment
mempty assignmentEx
r'=maybeSuccess m
print m
r' <code>shouldBe</code> Just(&quot;woot&quot;,&quot;1&quot;)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1457
describe &quot;Header Parsing&quot; $
it&quot;can parse a simple header&quot; $ do
letm=
parseByteString parseHeader
mempty headerEx
r'=maybeSuccess m
print m
r' <code>shouldBe</code> Just(Header&quot;blah&quot;)
describe &quot;Comment parsing&quot; $
it&quot;Skips comment before header&quot; $ do
letp=skipComments &gt;&gt;parseHeader
i=&quot;; woot\n[blah]&quot;
m=parseByteString p mempty i
r'=maybeSuccess m
print m
r' <code>shouldBe</code> Just(Header&quot;blah&quot;)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1458
describe &quot;Section parsing&quot; $
it&quot;can parse a simple section&quot; $ do
letm=parseByteString parseSection
mempty sectionEx
r'=maybeSuccess m
states=
M.fromList [( &quot;Chris&quot;,&quot;Texas&quot;)]
expected' =
Just(Section (Header&quot;states&quot; )
states)
print m
r' <code>shouldBe</code> expected'</p>
<p>CHAPTER 24. PARSER COMBINATORS 1459
describe &quot;INI parsing&quot; $
it&quot;Can parse multiple sections&quot; $ do
letm=
parseByteString parseIni
mempty sectionEx''
r'=maybeSuccess m
sectionValues =
M.fromList
[ (&quot;alias&quot;,&quot;claw&quot;)
, (&quot;host&quot;,&quot;wikipedia.org&quot; )]
whatisitValues =
M.fromList
[(&quot;red&quot;,&quot;intoothandclaw&quot; )]
expected' =
Just(Config
(M.fromList
[ (Header&quot;section&quot;
, sectionValues)
, (Header&quot;whatisit&quot;
, whatisitValues)]))
print m
r' <code>shouldBe</code> expected'
We leave it to you to run this and experiment with it.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1460
24.8 Character and token parsers
All right, that was a lot of code. Let‚Äôs all step back and take a
deep breath.
You probably have some idea by now of what we mean by
tokenizing, but the time has come for more detail. Tokeniza-
tion is a handy parsing tactic, so it‚Äôs baked into some of the
library functions we‚Äôve been using. It‚Äôs worth diving in and
exploring what it means.
Traditionally, parsing has been done in two stages, lexing
and parsing. Characters from a stream will be fed into the
lexer, which will then emit tokens on demand to the parser
until it has no more to emit.9The parser then structures the
stream of tokens into a tree, commonly called an ‚Äúabstract
syntax tree‚Äù or AST:
-- hand-wavy types: Stream because
-- production-grade parsers in Haskell
-- won't use [] for performance reasons
lexer::StreamChar-&gt;StreamToken
parser::StreamToken-&gt;AST
Lexers are simpler, typically performing parses that don‚Äôt
require looking ahead into the input stream by more than
9Lexers and tokenizers are similar, separating a stream of text into tokens based on
indicators such as whitespace or newlines; lexers often attach some context to the tokens,
where tokenizers typically do not.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1461
one character or token at a time. Lexers are at times called
tokenizers. Lexing is sometimes done with regular expres-
sions, but a parsing library in Haskell will usually intend that
you do your lexing and parsing with the same API. Lexers (or
tokenizers) and parsers have a lot in common, being primarily
diÔ¨Äerentiated by their purpose and class of grammar.10
Insert tokens to play
Let‚Äôs play around with some things to see what tokenizing
does for us:
Prelude&gt; parseString (some digit) mempty &quot;123 456&quot;
Success &quot;123&quot;
Prelude&gt; parseString (some (some digit)) mempty &quot;123 456&quot;
Success [&quot;123&quot;]
Prelude&gt; parseString (some integer) mempty &quot;123&quot;
Success [123]
Prelude&gt; parseString (some integer) mempty &quot;123456&quot;
Success [123456]
The problem here is that if we wanted to recognize 123 and
456 as independent strings, we need some kind of separator.
Now we can go ahead and do that manually, but the tokenizers
10Formal grammars ‚Äî rules for generating strings in a formal language ‚Äî are placed
in a hierarchy, often called the Chomsky hierarchy after the linguist Noam Chomsky.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1462
inparsers can do it for you too, also handling a mixture of
whitespace and newlines:
Prelude&gt; parseString (some integer) mempty &quot;123 456&quot;
Success [123,456]
Prelude&gt; parseString (some integer) mempty &quot;123\n\n 456&quot;
Success [123,456]
Or even space and newlines interleaved:
Prelude&gt; parseString (some integer) mempty &quot;123 \n \n 456&quot;
Success [123,456]
But simply applying tokentodigitdoesn‚Äôt do what you
think:
Prelude&gt; let s = &quot;123 \n \n 456&quot;
Prelude&gt; parseString (token (some digit)) mempty s
Success &quot;123&quot;
Prelude&gt; parseString (token (some (token digit))) mempty s
Success &quot;123456&quot;
Prelude&gt; parseString (some decimal) mempty s
Success [123]
Prelude&gt; parseString (some (token decimal)) mempty s
Success [123,456]
Compare that to the integer function, which is already a
tokenizer:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1463
Prelude&gt; parseString (some integer) mempty &quot;1\n2\n 3\n&quot;
Success [1,2,3]
We can write a tokenizing parser like some integer like this:
p'::Parser[Integer]
p'=some$ do
i&lt;-token (some digit)
return (read i)
And we can compare the output of that to the output of
applying tokentodigit:
Prelude&gt; let s = &quot;1\n2\n3&quot;
Prelude&gt; parseString p' mempty s
Success [1,2,3]
Prelude&gt; parseString (token (some digit)) mempty s
Success &quot;1&quot;
Prelude&gt; parseString (some (token (some digit))) mempty s
Success [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
You‚Äôll want to think carefully about the scope at which
you‚Äôre tokenizing as well:
Prelude&gt; let tknWhole = token $ char 'a' &gt;&gt; char 'b'
Prelude&gt; parseString tknWhole mempty &quot;a b&quot;
Failure (interactive):1:2: error: expected: &quot;b&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1464
a b<EOF>
^
Prelude&gt; parseString tknWhole mempty &quot;ab ab&quot;
Success 'b'
Prelude&gt; parseString (some tknWhole) mempty &quot;ab ab&quot;
Success &quot;bb&quot;
If we wanted that first example to work, we need to tokenize
the parse of the first character, not the whole a-then-b parse:
Prelude&gt; let tknCharA = (token (char 'a')) &gt;&gt; char 'b'
Prelude&gt; parseString tknCharA mempty &quot;a b&quot;
Success 'b'
Prelude&gt; parseString (some tknCharA) mempty &quot;a ba b&quot;
Success &quot;bb&quot;
Prelude&gt; parseString (some tknCharA) mempty &quot;a b a b&quot;
Success &quot;b&quot;
The last example stops at the first ùëé ùëèparse because the
parser doesn‚Äôt say anything about a space after ùëèand the tok-
enization behavior only applies to what followed ùëé. We can
tokenize both character parsers though:
Prelude&gt; let tknBoth = token (char 'a') &gt;&gt; token (char 'b')
Prelude&gt; parseString (some tknBoth) mempty &quot;a b a b&quot;
Success &quot;bb&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1465
A mild warning: don‚Äôt get too tokenization happy. Try to
make it coarse-grained and selective. Overuse of tokenizing
parsersormixturewithcharacterparserscanmakeyourparser
slow or hard to understand. Use your judgment. Keep in mind
that tokenization isn‚Äôt exclusively about whitespace; it‚Äôs about
ignoring noise so you can focus on the structures you are
parsing.
24.9 Polymorphic parsers
If we take the time to assert polymorphic types for our parsers,
we can get parsers that can be run using attoparsec ,trifecta ,
parsec, or anything else that has implemented the necessary
typeclasses. Let‚Äôs give it a whirl, shall we?
{-# LANGUAGE OverloadedStrings #-}
moduleText.Fractions where
importControl.Applicative
importData.Attoparsec.Text (parseOnly )
importData.Ratio ((%))
importData.String (IsString )
importText.Trifecta</p>
<p>CHAPTER 24. PARSER COMBINATORS 1466
badFraction ::IsString s=&gt;s
badFraction =&quot;1/0&quot;
alsoBad ::IsString s=&gt;s
alsoBad =&quot;10&quot;
shouldWork ::IsString s=&gt;s
shouldWork =&quot;1/2&quot;
shouldAlsoWork ::IsString s=&gt;s
shouldAlsoWork =&quot;2/1&quot;
parseFraction ::(Monadm,TokenParsing m)
=&gt;mRational
parseFraction = do
numerator &lt;-decimal
_ &lt;-char'/'
denominator &lt;-decimal
casedenominator of
0-&gt;fail&quot;Denominator cannot be zero&quot;
_ -&gt;return (numerator %denominator)
We‚Äôve left some typeclass-constrained polymorphism in
our type signatures for flexibility. Our mainwill run both
attoparsec andtrifecta versions for us so we can compare the
outputs directly:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1467
main::IO()
main= do
-- parseOnly is Attoparsec
letattoP=parseOnly parseFraction
print$attoP badFraction
print$attoP shouldWork
print$attoP shouldAlsoWork
print$attoP alsoBad
-- parseString is Trifecta
letp f i=
parseString f mempty i
print$p parseFraction badFraction
print$p parseFraction shouldWork
print$p parseFraction shouldAlsoWork
print$p parseFraction alsoBad
Prelude&gt; main
Left &quot;Failed reading: Denominator cannot be zero&quot;
Right (1 % 2)
Right (2 % 1)
Left &quot;&quot;/&quot;: not enough input&quot;
Failure (interactive):1:4: error: Denominator
cannot be zero, expected: digit
1/0<EOF></p>
<p>CHAPTER 24. PARSER COMBINATORS 1468
^
Success (1 % 2)
Success (2 % 1)
Failure (interactive):1:3: error: unexpected
EOF, expected: &quot;/&quot;, digit
10<EOF>
^
See what we meant earlier about the error messages?
It‚Äôs not perfect and could bite you
While the polymorphic parser combinators in the parsers li-
brary enable you to write parsers which can then be run with
various parsing libraries, this doesn‚Äôt free you of understand-
ing the particularities of each. In general, trifecta tries to
matchparsec ‚Äôs behaviors in most respects, the latter of which
is more extensively documented.
Failure and backtracking
Returning to our cursor model of parsers, backtracking is
returning the cursor to where it was before a failing parser
consumed input. In some cases, it can be a little confusing
to debug the same error in two diÔ¨Äerent runs of the same
parser doing essentially the same things in trifecta ,parsec,</p>
<p>CHAPTER 24. PARSER COMBINATORS 1469
andattoparsec , but the errors themselves might be diÔ¨Äerent.
Let‚Äôs consider an example of this.
{-# LANGUAGE OverloadedStrings #-}
We use OverloadedStrings so that we can use string literals as
if they were ByteStrings when testing attoparsec :
moduleBTwhere
importControl.Applicative
import qualified Data.Attoparsec.ByteString
asA
importData.Attoparsec.ByteString
(parseOnly )
importData.ByteString (ByteString )
importText.Trifecta hiding(parseTest )
importText.Parsec (Parsec,parseTest )
trifP::Showa
=&gt;Parsera
-&gt;String-&gt;IO()
trifPp i=
print$parseString p mempty i
Helper function to run a trifecta parser and print the result:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1470
parsecP ::(Showa)
=&gt;ParsecString()a
-&gt;String-&gt;IO()
parsecP =parseTest
Helper function to run a parsec parser and print the result:
attoP::Showa
=&gt;A.Parsera
-&gt;ByteString -&gt;IO()
attoPp i=
print$parseOnly p i
Helper function for attoparsec ‚Äî same deal as before:
nobackParse ::(Monadf,CharParsing f)
=&gt;fChar
nobackParse =
(char'1'&gt;&gt;char'2')
&lt;|&gt;char'3'
Here‚Äôs our first parser. It attempts to parse '1'followed by
'2'or'3'. This parser does not backtrack:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1471
tryParse ::(Monadf,CharParsing f)
=&gt;fChar
tryParse =
try (char '1'&gt;&gt;char'2')
&lt;|&gt;char'3'
This parser has similar behavior to the previous one, except
it backtracks if the first parse fails. Backtracking means that the
input cursor returns to where it was before the failed parser
consumed input.
main::IO()
main= do
-- trifecta
trifP nobackParse &quot;13&quot;
trifP tryParse &quot;13&quot;
-- parsec
parsecP nobackParse &quot;13&quot;
parsecP tryParse &quot;13&quot;
-- attoparsec
attoP nobackParse &quot;13&quot;
attoP tryParse &quot;13&quot;
The error messages you get from each parser are going
to vary a bit. This isn‚Äôt because they‚Äôre wildly diÔ¨Äerent, but</p>
<p>CHAPTER 24. PARSER COMBINATORS 1472
is mostly due to how they attribute errors. You should see
something like:
Prelude&gt; main
Failure (interactive):1:2:
error: expected: &quot;2&quot;
13<EOF>
^
Failure (interactive):1:1: error:
expected: &quot;3&quot;
13<EOF>
^
parse error at (line 1, column 2):
unexpected &quot;3&quot;
expecting &quot;2&quot;
parse error at (line 1, column 2):
unexpected &quot;3&quot;
expecting &quot;2&quot;
Left &quot;&quot;3&quot;: satisfyElem&quot;
Left &quot;&quot;3&quot;: satisfyElem&quot;
Conversely, if you try the valid inputs &quot;12&quot;and&quot;3&quot;with
nobackParse and each of the three parsers, you should see all of
them succeed.
This can be confusing. When you add backtracking to a
parser, error attribution can become more complicated at</p>
<p>CHAPTER 24. PARSER COMBINATORS 1473
times. To avoid this, consider using the &lt;?&gt;operator to anno-
tate parse rules any time you use try.11
tryAnnot ::(Monadf,CharParsing f)
=&gt;fChar
tryAnnot =
(try (char '1'&gt;&gt;char'2')</p>
<?>"Tried 12" )
<p>&lt;|&gt;(char'3'&lt;?&gt;&quot;Tried 3&quot; )
Then running this in the REPL:
Prelude&gt; trifP tryAnnot &quot;13&quot;
Failure (interactive):1:1: error: expected: Tried 12,
Tried 3
13<EOF>
^
Now the error will list the parses it attempted before it failed.
You‚Äôll want to make the annotations more informative than
what we demonstrated in your own parsers.
11Parsec ‚Äútry a &lt;|&gt; b‚Äù considered harmful; Edward Z. Yang</p>
<p>CHAPTER 24. PARSER COMBINATORS 1474
24.10 Marshalling from an AST to a
datatype
Fair warning: This section relies on a little more background
knowledge from you than previous sections have. If you are
not a person who already has some programming experience,
the following may not seem terribly useful to you, and there
may be some unfamiliar terminology and concepts.
The act of parsing, in a sense, is a means of necking down
the cardinality of our inputs to the set of things our programs
have a sensible answer for. It‚Äôs unlikely you can do some-
thing meaningful and domain-specific when your input type
isString ,Text, orByteString . However, if you can parse one of
those types into something structured, rejecting bad inputs,
then you might be able to write a proper program. One of the
mistakes programmers make in writing programs handling
text is in allowing their data to stay in the textual format, doing
mind-bending backflips to cope with the unstructured nature
of textual inputs.
In some cases, the act of parsing isn‚Äôt enough. You might
have a sort of AST or structured representation of what was
parsed, but from there, you might expect that AST or repre-
sentation to take a particular form. This means we want to
narrow the cardinality and get even more specific about how
our data looks. Often this second step is called unmarshalling</p>
<p>CHAPTER 24. PARSER COMBINATORS 1475
our data. Similarly, marshalling is the act of preparing data
for serialization, whether via memory alone (foreign function
interface boundary) or over a network interface.
The whole idea here is that you have two pipelines for your
data:
Text-&gt;Structure -&gt;Meaning
-- parse -&gt; unmarshall
Meaning -&gt;Structure -&gt;Text
-- marshall -&gt; serialize
There isn‚Äôt only one way to accomplish this, but we‚Äôll show
you a commonly used library and how it has this two-stage
pipeline in the API.
Marshalling and unmarshalling JSON data
aesonis presently the most popular JSON12library in Haskell.
One of the things that‚Äôll confuse programmers coming to
Haskell from Python, Ruby, Clojure, JavaScript, or similar
languages, is that there‚Äôs usually no unmarshall/marshall step.
Instead, the raw JSON AST will be represented directly as an
untyped blob of data. Users of typed languages are more likely
12JSON stands for JavaScript Object Notation. JSON is, for better or worse, a very
common open-standard data format used to transmit data, especially between browsers
and servers. As such, dealing with JSON is a common programming task, so you might
as well get used to it now.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1476
to have encountered something like this. We‚Äôll be using aeson
0.10.0.0 for the following examples.
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
moduleMarshalling where
importData.Aeson
importData.ByteString.Lazy (ByteString )
importText.RawString.QQ
sectionJson ::ByteString
sectionJson =[r|
{&quot;section&quot; :{&quot;host&quot;:&quot;wikipedia.org&quot; },
&quot;whatisit&quot; :{&quot;red&quot;:&quot;intoothandclaw&quot; }
}
|]
Notethatwe‚Äôresayingthetypeof sectionJson isalazy ByteString .
If you get strict and lazy ByteString types mixed up you‚Äôll get
errors.
Provided a strict ByteString when a lazy one was expected:
<interactive>:10:8:
Couldn't match expected type</p>
<p>CHAPTER 24. PARSER COMBINATORS 1477
Data.ByteString.Lazy.Internal.ByteString
with actual type ByteString
NB:
Data.ByteString.Lazy.Internal.ByteString
is defined in
Data.ByteString.Lazy.Internal
ByteString
is defined in
Data.ByteString.Internal
The actual type is what we provided; the expected type is
what the types wanted. The NB:in the type error stands for
nota bene. Either we used the wrong code (so expected type
needs to change), or we provided the wrong values (actual
type, our types/values, need to change). You can reproduce
this error by making the following mistake in the marshalling
module:
-- Change the import of the ByteString
-- type constructor from:
importData.ByteString.Lazy (ByteString )
-- Into:
importData.ByteString (ByteString )</p>
<p>CHAPTER 24. PARSER COMBINATORS 1478
Provided a lazy ByteString when a strict one was expected:
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
moduleWantedStrict where
importData.Aeson
importData.ByteString.Lazy (ByteString )
importText.RawString.QQ
sectionJson ::ByteString
sectionJson =[r|
{&quot;section&quot; :{&quot;host&quot;:&quot;wikipedia.org&quot; },
&quot;whatisit&quot; :{&quot;red&quot;:&quot;intoothandclaw&quot; }
}
|]
main= do
letblah::MaybeValue
blah=decodeStrict sectionJson
print blah
You‚Äôll get the following type error if you load that up:
code/wantedStrictGotLazy.hs:19:27:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1479
Couldn't match expected type
‚ÄòData.ByteString.Internal.ByteString‚Äô
with actual type ‚ÄòByteString‚Äô
NB:
‚ÄòData.ByteString.Internal.ByteString‚Äô
is defined in ‚ÄòData.ByteString.Internal‚Äô
‚ÄòByteString‚Äô is defined in ‚ÄòData.ByteString.Lazy.Internal‚Äô
In the first argument of ‚ÄòdecodeStrict‚Äô,
namely ‚ÄòsectionJson‚Äô
In the expression: decodeStrict sectionJson
The more useful information is in the NB:or nota bene,
where the internal modules are mentioned. The key is to re-
member actual type means ‚Äúyour code‚Äù, expected type means
‚Äúwhat they expected,‚Äù and that the ByteString module that
doesn‚Äôt have Lazyin the name is the strict version. We can
modify our code a bit to get nicer type errors:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1480
-- replace the (ByteString)
-- import with these
import qualified Data.ByteString asBS
import qualified Data.ByteString.Lazy
asLBS
-- edit the type sig for this one
sectionJson ::LBS.ByteString
Then we‚Äôll get the following type error instead:
Couldn't match expected type ‚ÄòBS.ByteString‚Äô
with actual type ‚ÄòLBS.ByteString‚Äô
NB: ‚ÄòBS.ByteString‚Äô is defined in
‚ÄòData.ByteString.Internal‚Äô
‚ÄòLBS.ByteString‚Äô is defined in
‚ÄòData.ByteString.Lazy.Internal‚Äô
In the first argument of ‚ÄòdecodeStrict‚Äô,
namely ‚ÄòsectionJson‚Äô
In the expression: decodeStrict sectionJson
This is helpful because we have both versions available as
qualified modules. You may not always be so fortunate and
will need to remember which is which.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1481
Back to the JSON
Let‚Äôs get back to handling JSON. The most common functions
for using aesonare the following:
Prelude&gt; import Data.Aeson
Prelude&gt; :t encode
encode :: ToJSON a =&gt; a -&gt; LBS.ByteString
Prelude&gt; :t decode
decode :: FromJSON a =&gt; LBS.ByteString -&gt; Maybe a
These functions are sort of eliding the intermediate step
that passes through the Value type in aeson, which is a datatype
JSON AST ‚Äî ‚Äúsort of,‚Äù because you can decode the raw JSON
data into a Valueanyway:
Prelude&gt; decode sectionJson :: Maybe Value
Just (Object (fromList [
(&quot;whatisit&quot;,
Object (fromList [(&quot;red&quot;,
String &quot;intoothandclaw&quot;)])),
(&quot;section&quot;,
Object (fromList [(&quot;host&quot;,
String &quot;wikipedia.org&quot;)]))]))
Not, uh, super pretty. We‚Äôll figure out something nicer in
a moment. Also do not forget to assert a type, or the type-
defaulting in GHCi will do silly things:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1482
Prelude&gt; decode sectionJson
Nothing
Now what if we do want a nicer representation for this JSON
noise? Well, let‚Äôs define our datatypes and see if we can decode
the JSON into our type:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1483
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
moduleMarshalling where
importControl.Applicative
importData.Aeson
importData.ByteString.Lazy (ByteString )
import qualified Data.Text asT
importData.Text (Text)
importText.RawString.QQ
sectionJson ::ByteString
sectionJson =[r|
{&quot;section&quot; :{&quot;host&quot;:&quot;wikipedia.org&quot; },
&quot;whatisit&quot; :{&quot;red&quot;:&quot;intoothandclaw&quot; }
}
|]
dataTestData =
TestData {
section ::Host
, what::Color
}deriving (Eq,Show)
newtype Host=
HostString
deriving (Eq,Show)
typeAnnotation =String
dataColor=
RedAnnotation
|BlueAnnotation
|YellowAnnotation
deriving (Eq,Show)
main= do
letd::MaybeTestData
d=decode sectionJson
print d</p>
<p>CHAPTER 24. PARSER COMBINATORS 1484
This will in fact net you a type error complaining about
there not being an instance of FromJSON forTestData . Which is
true! GHC has no idea how to unmarshall JSON data (in the
form of a Value) into a TestData value. Let‚Äôs add an instance so
it knows how:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1485
instance FromJSON TestData where
parseJSON ( Objectv)=
TestData &lt;$&gt;v.:&quot;section&quot;
&lt;*&gt;v.:&quot;whatisit&quot;
parseJSON _ =
fail&quot;Expected an object for TestData&quot;
instance FromJSON Hostwhere
parseJSON ( Objectv)=
Host&lt;$&gt;v.:&quot;host&quot;
parseJSON _ =
fail&quot;Expected an object for Host&quot;
instance FromJSON Colorwhere
parseJSON ( Objectv)=
(Red&lt;$&gt;v.:&quot;red&quot;)
&lt;|&gt;(Blue&lt;$&gt;v.:&quot;blue&quot;)
&lt;|&gt;(Yellow&lt;$&gt;v.:&quot;yellow&quot; )
parseJSON _ =
fail&quot;Expected an object for Color&quot;
Also note that you can use quasiquotes to avoid having to
escape quotation marks in the REPL as well:
Prelude&gt; :set -XOverloadedStrings
Prelude&gt; decode &quot;{&quot;blue&quot;: &quot;123&quot;}&quot; :: Maybe Color</p>
<p>CHAPTER 24. PARSER COMBINATORS 1486
Just (Blue &quot;123&quot;)
Prelude&gt; :set -XQuasiQuotes
Prelude&gt; decode [r|{&quot;red&quot;: &quot;123&quot;}|] :: Maybe Color
Just (Red &quot;123&quot;)
To relate what we just did back to the relationship between
parsing and marshalling, the idea is that our FromJSON instance
is accepting the Valuetype and ToJSON instances generate the
Valuetype, closing the following loop:
-- FromJSON
ByteString -&gt;Value-&gt;yourType
-- parse -&gt; unmarshall
-- ToJSON
yourType -&gt;Value-&gt;ByteString
-- marshall -&gt; serialize
The definition of Valueat time of writing is the following:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1487
-- | A JSON value represented
-- as a Haskell value.
dataValue=Object!Object
|Array!Array
|String!Text
|Number!Scientific
|Bool!Bool
|Null
deriving (Eq,Read,Show,
Typeable ,Data)
What if we want to unmarshall something that could be a
Number or aString ?
dataNumberOrString =
NumbaInteger
|Stringy Text
deriving (Eq,Show)
instance FromJSON NumberOrString where
parseJSON ( Numberi)=return$Numbai
parseJSON ( Strings)=return$Stringy s
parseJSON _ =
fail&quot;NumberOrString must <br />
\be number or string&quot;</p>
<p>CHAPTER 24. PARSER COMBINATORS 1488
This won‚Äôt quite work at first. The trouble is that JSON (and
JavaScript, as it happens) only has one numeric type and that
type is a IEEE-754 float. JSON (and JavaScript, terrifyingly)
have no integral types or integers, so aesonhas to pick one
representation that works for all possible JSON numbers. The
most precise way to do that is the Scientific type which is an
arbitrarily precise numerical type (you may remember this
from way back in Chapter 4, Basic Datatypes). So we need to
convert from a Scientific to anInteger :
importControl.Applicative
importData.Aeson
importData.ByteString.Lazy (ByteString )
import qualified Data.Text asT
importData.Text (Text)
importText.RawString.QQ
importData.Scientific (floatingOrInteger )
dataNumberOrString =
NumbaInteger
|Stringy Text
deriving (Eq,Show)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1489
instance FromJSON NumberOrString where
parseJSON ( Numberi)=
casefloatingOrInteger i of
(Left_)-&gt;
fail&quot;Must be integral number&quot;
(Rightinteger) -&gt;
return$Numbainteger
parseJSON ( Strings)=return$Stringy s
parseJSON _ =
fail&quot;NumberOrString must <br />
\be number or string&quot;
-- so it knows what we want to parse
dec::ByteString
-&gt;MaybeNumberOrString
dec=decode
eitherDec ::ByteString
-&gt;EitherStringNumberOrString
eitherDec =eitherDecode
main= do
print$dec&quot;blah&quot;
Now let‚Äôs give it a whirl:</p>
<p>CHAPTER 24. PARSER COMBINATORS 1490
Prelude&gt; main
Nothing
Butwhathappened? Wecanrewritethecodetouse eitherDec
to get a slightly more helpful type error:
main= do
print$dec&quot;blah&quot;
print$eitherDec &quot;blah&quot;
Then reloading the code and trying again in the REPL:
Prelude&gt; main
Nothing
Left &quot;Error in $: Failed reading:
not a valid json value&quot;
By that means, we are able to get more informative errors
fromaeson. If we wanted some examples that worked, we
could try things like the following:
Prelude&gt; dec &quot;123&quot;
Just (Numba 123)
Prelude&gt; dec &quot;&quot;blah&quot;&quot;
Just (Stringy &quot;blah&quot;)
It‚Äôs worth getting comfortable with aesoneven if you don‚Äôt
plan to work with much JSON because many serialization</p>
<p>CHAPTER 24. PARSER COMBINATORS 1491
libraries in Haskell follow a similar API pattern. Play with the
example and see how you need to change the type of decto
be able to parse a list of numbers or strings.
24.11 Chapter Exercises
1.Write a parser for semantic versions as defined by http:
//semver.org/ . After making a working parser, write an Ord
instance for the SemVer type that obeys the specification
outlined on the SemVer website.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1492
-- Relevant to precedence/ordering,
-- cannot sort numbers like strings.
dataNumberOrString =
NOSSString
|NOSIInteger
typeMajor=Integer
typeMinor=Integer
typePatch=Integer
typeRelease =[NumberOrString ]
typeMetadata =[NumberOrString ]
dataSemVer=
SemVerMajorMinorPatchRelease Metadata
parseSemVer ::ParserSemVer
parseSemVer =undefined
Expected results:
Prelude&gt; parseString parseSemVer mempty &quot;2.1.1&quot;
Success (SemVer 2 1 1 [] [])
Prelude&gt; parseString parseSemVer mempty &quot;1.0.0-x.7.z.92&quot;
Success (SemVer 1 0 0
[NOSS &quot;x&quot;, NOSI 7, NOSS &quot;z&quot;, NOSI 92] [])</p>
<p>CHAPTER 24. PARSER COMBINATORS 1493
Prelude&gt; SemVer 2 1 1 [] [] &gt; SemVer 2 1 0 [] []
True
2.Write a parser for positive integer values. Don‚Äôt reuse the
pre-existing digitorinteger functions, but you can use
the rest of the libraries we‚Äôve shown you so far. You are
not expected to write a parsing library from scratch.
parseDigit ::ParserChar
parseDigit =undefined
base10Integer ::ParserInteger
base10Integer =undefined
Expected results:
Prelude&gt; parseString parseDigit mempty &quot;123&quot;
Success '1'
Prelude&gt; parseString parseDigit mempty &quot;abc&quot;
Failure (interactive):1:1: error: expected: parseDigit
abc<EOF>
^
Prelude&gt; parseString base10Integer mempty &quot;123abc&quot;
Success 123
Prelude&gt; parseString base10Integer mempty &quot;abc&quot;
Failure (interactive):1:1: error: expected: integer</p>
<p>CHAPTER 24. PARSER COMBINATORS 1494
abc<EOF>
^
Hint: Assume you‚Äôre parsing base-10 numbers. Use arith-
metic as a cheap ‚Äúaccumulator‚Äù for your final number as
you parse each digit left-to-right.
3.Extend the parser you wrote to handle negative and pos-
itive integers. Try writing a new parser in terms of the
one you already have to do this.
Prelude&gt; parseString base10Integer' mempty &quot;-123abc&quot;
Success (-123)
4.Write a parser for US/Canada phone numbers with vary-
ing formats.</p>
<p>CHAPTER 24. PARSER COMBINATORS 1495
-- aka area code
typeNumberingPlanArea =Int
typeExchange =Int
typeLineNumber =Int
dataPhoneNumber =
PhoneNumber NumberingPlanArea
Exchange LineNumber
deriving (Eq,Show)
parsePhone ::ParserPhoneNumber
parsePhone =undefined
With the following behavior:
Prelude&gt; parseString parsePhone mempty &quot;123-456-7890&quot;
Success (PhoneNumber 123 456 7890)
Prelude&gt; parseString parsePhone mempty &quot;1234567890&quot;
Success (PhoneNumber 123 456 7890)
Prelude&gt; parseString parsePhone mempty &quot;(123) 456-7890&quot;
Success (PhoneNumber 123 456 7890)
Prelude&gt; parseString parsePhone mempty &quot;1-123-456-7890&quot;
Success (PhoneNumber 123 456 7890)
Cf. Wikipedia‚Äôs article on ‚ÄúNational conventions for writ-
ing telephone numbers‚Äù. You are encouraged to adapt the</p>
<p>CHAPTER 24. PARSER COMBINATORS 1496
exercise to your locality‚Äôs conventions if they are not part
of the NNAP scheme.
5.Write a parser for a log file format and sum the time
spent in each activity. Additionally, provide an alterna-
tive aggregation of the data that provides average time
spent per activity per day. The format supports the use
of comments which your parser will have to ignore. The
#characters followed by a date mark the beginning of a
particular day.
Log format example:
-- wheee a comment</p>
<h1 id="2025-02-05"><a class="header" href="#2025-02-05">2025-02-05</a></h1>
<p>08:00 Breakfast
09:00 Sanitizing moisture collector
11:00 Exercising in high-grav gym
12:00 Lunch
13:00 Programming
17:00 Commuting home in rover
17:30 R&amp;R
19:00 Dinner
21:00 Shower
21:15 Read
22:00 Sleep</p>
<p>CHAPTER 24. PARSER COMBINATORS 1497</p>
<h1 id="2025-02-07----dates-not-nececessarily-sequential"><a class="header" href="#2025-02-07----dates-not-nececessarily-sequential">2025-02-07 -- dates not nececessarily sequential</a></h1>
<p>08:00 Breakfast -- should I try skippin bfast?
09:00 Bumped head, passed out
13:36 Wake up, headache
13:37 Go to medbay
13:40 Patch self up
13:45 Commute home for rest
14:15 Read
21:00 Dinner
21:15 Read
22:00 Sleep
You are to derive a reasonable datatype for represent-
ing this data yourself. For bonus points, make this bi-
directionalbymakingaShowrepresentationforthedatatype
which matches the format you are parsing. Then write a
generator for this data using QuickCheck‚Äôs Gen and see if
you can break your parser with QuickCheck.
6.Write a parser for IPv4 addresses.
importData.Word
dataIPAddress =
IPAddress Word32
deriving (Eq,Ord,Show)</p>
<p>CHAPTER 24. PARSER COMBINATORS 1498
A 32-bit word is a 32-bit unsigned int. Lowest value is 0
rather than being capable of representing negative num-
bers, but the highest possible value in the same number
of bits is twice as high. Note:
Prelude&gt; import Data.Int
Prelude&gt; import Data.Word
Prelude&gt; maxBound :: Int32
2147483647
Prelude&gt; maxBound :: Word32
4294967295
Prelude&gt; div 4294967295 2147483647
2
Word32 is an appropriate and compact way to represent
IPv4 addresses. You are expected to figure out not only
how to parse the typical IP address format, but how IP
addresses work numerically insofar as is required to write
a working parser. This will require using a search engine
unless you have an appropriate book on internet network-
ing handy.
Example IPv4 addresses and their decimal representa-
tions:
172.16.254.1 -&gt; 2886794753
204.120.0.15 -&gt; 3430416399</p>
<p>CHAPTER 24. PARSER COMBINATORS 1499
7.Same as before, but IPv6.
importData.Word
dataIPAddress6 =
IPAddress6 Word64Word64
deriving (Eq,Ord,Show)
Example IPv6 addresses and their decimal representa-
tions:
0:0:0:0:0:ffff:ac10:fe01 -&gt; 281473568538113
0:0:0:0:0:ffff:cc78:f -&gt; 281474112159759
FE80:0000:0000:0000:0202:B3FF:FE1E:8329 -&gt;
338288524927261089654163772891438416681
2001:DB8::8:800:200C:417A -&gt;
42540766411282592856906245548098208122
One of the trickier parts about IPv6 will be full vs. col-
lapsed addresses and the abbrevations. See this Q&amp;A
thread13about IPv6 abbreviations for more.
Ensure you can parse abbreviated variations of the earlier
examples like:
13http://answers.google.com/answers/threadview/id/770645.html</p>
<p>CHAPTER 24. PARSER COMBINATORS 1500
FE80::0202:B3FF:FE1E:8329
2001:DB8::8:800:200C:417A
8.Removethederived ShowinstancesfromtheIPAddress/IPAd-
dress6 types, and write your own Showinstance for each
type that renders in the typical textual format appropriate
to each.
9.Write a function that converts between IPAddress and
IPAddress6.
10.Write a parser for the DOT language14that Graphviz uses
to express graphs in plain-text.
We suggest you look at the AST datatype in Haphviz15for
ideas on how to represent the graph in a Haskell datatype.
If you‚Äôre feeling especially robust, you can try using fgl16.
24.12 Definitions
1.A parser parses.
You read the chapter right?
2.A parser combinator combines two or more parsers to
produce a new parser. Good examples of this are things
14http://www.graphviz.org/doc/info/lang.html
15http://hackage.haskell.org/package/haphviz
16http://hackage.haskell.org/package/fgl</p>
<p>CHAPTER 24. PARSER COMBINATORS 1501
like using &lt;|&gt;fromAlternative to produce a new parser
from the disjunction of two parser arguments to &lt;|&gt;. Or
some. Ormany. Ormappend . Or(&gt;&gt;).
3.Marshalling is transforming a potentially nonlinear rep-
resentation of data in memory into a format that can be
stored on disk or transmitted over a network socket. Go-
ing in the opposite direction is called unmarshalling. Cf.
serialization and deserialization.
4.A token(izer) converts text, usually a stream of characters,
into more meaningful or ‚Äúchunkier‚Äù structures such as
words, sentences, or symbols. The linesandwordsfunc-
tions you‚Äôve used earlier in this book are like very unso-
phisticated tokenizers.
5.Lexer ‚Äî see tokenizer.
24.13 Follow-up resources
1.Parsec try a-or-b considered harmful; Edward Z. Yang
2.Code case study: parsing a binary data format; Real World
Haskell
3.The Parsec parsing library; Real World Haskell</p>
<p>CHAPTER 24. PARSER COMBINATORS 1502
4.An introduction to parsing text in Haskell with Parsec;
James Wilson;
http://unbui.lt/#!/post/haskell-parsec-basics
5.Parsing CSS with Parsec; Jakub Arnold
6.Parsec: A practical parser library; Daan Leijen, Erik Mei-
jer;
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.
5200
7.How to Replace Failure by a List of Successes; Philip
Wadler;
http://dl.acm.org/citation.cfm?id=5288
8.How to Replace Failure by a Heap of Successes; Edward
Kmett
9.Two kinds of backtracking; Samuel G√©lineau (gelisam);
http://gelisam.blogspot.ca/2015/09/two-kinds-of-backtracking.
html
10.LL and LR in Context: Why Parsing Tools Are Hard; Josh
Haberman
http://blog.reverberate.org/2013/09/ll-and-lr-in-context-why-parsing-tools.
html
11.Parsing Techniques, a practical guide; second edition;
Grune &amp; Jacobs</p>
<p>CHAPTER 24. PARSER COMBINATORS 1503
12.Parsing JSON with Aeson; School of Haskell
13.aeson; 24 days of Hackage; Oliver Charles</p>
<p>Chapter 25
Composing types
The last thing one
discovers in composing a
work is what to put first.
T. S. Eliot
1504</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1505
25.1 Composing types
This chapter and the next are about monad transformers, both
the principles behind them and the practicalities of using them.
For many programmers, monad transformers are indistin-
guishable from magick, so we want to approach them from
both angles and demonstrate that they are both comprehen-
sible via their types and practical in normal programming.
Functors and applicatives are both closed under composi-
tion: this means that you can compose two functors (or two
applicatives) and return another functor (or applicative, as the
case may be). This is not true of monads, however; when you
compose two monads, the result is not necessarily another
monad. We will see this soon.
However, there are times when composing monads is desir-
able. DiÔ¨Äerent monads allow us to work with diÔ¨Äerent eÔ¨Äects.
Composing monads allows you to build up computations with
multiple eÔ¨Äects. By stacking, for example, a Maybemonad with
anIO, you can be performing IOactions while also building up
computations that have a possibility of failure, handled by the
Maybemonad.
A monad transformer is a variant of an ordinary type that
takes an additional type argument which is assumed to have a
Monadinstance. For example, MaybeT is the transformer variant
of theMaybetype. The transformer variant of a type gives us</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1506
aMonadinstance that binds over both bits of structure. This
allows us to compose monads and combine their eÔ¨Äects. Get-
ting comfortable with monad transformers is important to
becoming proficient in Haskell, so we‚Äôre going to take it pretty
slowly and go step by step. You won‚Äôt necessarily want to start
out early on defining a bunch of transformer stacks yourself,
but familiarity with them will help a great deal in using other
people‚Äôs libraries.
In this chapter, we will
‚Ä¢demonstrate why composing two monads does not give
you another monad;
‚Ä¢examine the Identity andCompose types;
‚Ä¢manipulate types until we can make monads compose;
‚Ä¢meet some common monad transformers;
‚Ä¢work through an Identity crisis.
25.2 Common functions as types
We‚Äôll start in a place that may seem a little strange and point-
less at first, with newtypes that correspond to some very basic
functions. We can construct types that are like those func-
tions because we have types that can take arguments ‚Äî that</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1507
is, type constructors. In particular, we‚Äôll be using types that
correspond to idand(.).
You‚Äôve seen some of the types we‚Äôre going to use in the
following sections before, but we‚Äôll be putting them to some
novel uses. The idea here is to use these datatypes as helpers in
order to demonstrate the problems with composing monads,
and we‚Äôll see how these type constructors can also serve as
monad transformers, because a monad transformer is a type
constructor that takes a monad as an argument.
Identity is boring
You‚Äôve seen this type in previous chapters, sometimes as a
datatype and sometimes as a newtype. We‚Äôll construct the
type diÔ¨Äerently this time, as a newtype with a helper function
of the sort we saw in Reader andState:
newtype Identity a=
Identity { runIdentity ::a }
We‚Äôll be using the newtype in this chapter because the
monad transformer version, IdentityT , is usually written as
a newtype. The use of the prefixes runorgetindicates that
these accessor functions are means of extracting the underly-
ing value from the type. There is no real diÔ¨Äerence in meaning
between runandget. You‚Äôll see these accessor functions often,</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1508
particularly with utility types like Identity or transformer vari-
ants reusing an original type.
Anoteaboutnewtypes Whilemonadtransformertypescould
be written using the datakeyword, they are most commonly
written as newtypes, and we‚Äôll be sticking with that pattern
here. They are only newtyped to avoid unnecessary overhead,
as newtypes, as we recall, have an underlying representation
identical to the type they contain. The important thing is that
monad transformers are never sum or product types; they are
always a means of wrapping one extra layer of (monadic) struc-
ture around a type, so there is never a reason they couldn‚Äôt
be newtypes. Haskellers have a general tendency to avoid
adding additional runtime overhead if they can, so if they can
newtype it, they most often will.
Another thing we want to notice about Identity is the sim-
ilarity of the kind of our Identity type to the type of the id
function, although the fidelity of the comparison isn‚Äôt perfect
given the limitations of type-level computation in Haskell:
Prelude&gt; :t id
id :: a -&gt; a
Prelude&gt; :k Identity
Identity :: * -&gt; *
The kind signature of the type resembles the type signature</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1509
of the function, which we hope isn‚Äôt too much of a surprise.
Fine, so far ‚Äî not much new here. Yet.
Compose
We mentioned above that we can also construct a datatype
that corresponds to function composition.
Here is the Compose type. It should look to you much like
function composition, but in this case, the ùëìandùëîrepresent
type constructors, not term-level functions:
newtype Compose f g a=
Compose { getCompose ::f (g a) }
deriving (Eq,Show)
So, we have a type constructor that takes three type argu-
ments: ùëìandùëîmust be type constructors themselves, while ùëé
will be a concrete type (consider the relationship between type
constructors and term-level functions on the one hand, and
values and type constants on the other). As we did above, let‚Äôs
look at the kind of Compose ‚Äî note the kinds of the arguments
to the type constructor:
Compose :: (* -&gt; <em>) -&gt; (</em> -&gt; *) -&gt; * -&gt; *
Does that remind you of anything?
(.)::(b-&gt;c)-&gt;(a-&gt;b)-&gt;a-&gt;c</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1510
So, what does that look like in practice? Something like this:
Prelude&gt; Compose [Just 1, Nothing]
Compose {getCompose = [Just 1,Nothing]}
Prelude&gt; let xs = [Just (1::Int), Nothing]
Prelude&gt; :t Compose xs
Compose [Just (1 :: Int), Nothing]
:: Compose [] Maybe Int
Given the above value, the type variables get bound accord-
ingly:
Compose [Just(1::Int),Nothing]
Compose { getCompose ::f (g a) }
Compose []MaybeInt
f~[]
g~Maybe
a~Int
We have one bit of structure wrapped around another, then
a value type (the ùëé) because the whole thing still has to be kind
*in the end.
We‚Äôve made the point in previous chapters that type con-
structors are functions. Type constructors can take other type</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1511
constructors as arguments, too, just as functions can take other
functions as arguments. This is what allows us to compose
types.
25.3 Two little functors sittin‚Äô in a tree,
L-I-F-T-I-N-G
Let‚Äôs start with composing functors, using the types we saw
above. We know we can lift over Identity ; you‚Äôve seen this
Functor before:
instance Functor Identity where
fmap f ( Identity a)=Identity (f a)
Identity here gives us a sort of vanilla Functor that doesn‚Äôt do
anything interesting but captures the essence of what Functor is
about. The function gets lifted into the context of the Identity
type and then mapped over the ùëévalue.
It turns out we can get a Functor instance for Compose , too, if
we ask that the ùëìandùëîboth have Functor instances:
instance (Functor f,Functor g)=&gt;
Functor (Compose f g)where
fmap f ( Compose fga)=
Compose $(fmap.fmap) f fga</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1512
Now the ùëìand the ùëîboth have to be part of the structure
that we‚Äôre lifting over, so they both have to be Functor s them-
selves. We need to be able to jump over both those layers in
order to apply to the value that‚Äôs ultimately inside. We have
tofmaptwice to get to that value inside because of the layered
structures.
To return to the example we used above, we have this type:
newtype Compose f g a=
Compose { getCompose ::f (g a) }
deriving (Eq,Show)
Compose { getCompose ::f (g a) }
Compose []MaybeInt
And if we use our Functor instance, we can apply a function
to theIntvalue wrapped up in all that structure:
Prelude&gt; let xs = [Just 1, Nothing]
Prelude&gt; Compose xs
Compose {getCompose = [Just 1,Nothing]}
Prelude&gt; fmap (+1) (Compose xs)
Compose {getCompose = [Just 2,Nothing]}</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1513
We can generalize this to diÔ¨Äerent amounts of structure,
such as with one less bit of structure. You may remember this
from a previous chapter:
newtype Onef a=
One(f a)
deriving (Eq,Show)
instance Functor f=&gt;
Functor (Onef)where
fmap f ( Onefa)=One$fmap f fa
Or one more layer of structure than Compose :
newtype Threef g h a =
Three(f (g (h a)))
deriving (Eq,Show)
instance (Functor f,Functor g,Functor h)
=&gt;Functor (Threef g h)where
fmap f ( Threefgha)=
Three$(fmap.fmap.fmap) f fgha
As with the anonymous product (,)and the anonymous
sumEither, theCompose type allows us to express arbitrarily
nested types:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1514
v::Compose []
Maybe
(Compose Maybe[]Integer)
v=Compose [Just(Compose $Just[1])]
The way to think about this is that the composition of two
datatypes that have a Functor instance gives rise to a new Functor
instance. You‚Äôll sometimes see people refer to this as functors
being closed under composition which means that when you
compose two Functor s, you get another Functor .
25.4 Twinplicative
You probably guessed this was our next step in Compose -landia.
Applicatives, it turns out, are also closed under composition.
We can compose two types that have Applicative instances and
get a new Applicative instance. But you‚Äôre going to write it.</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1515
GOTCHA! Exercise time
-- instance types provided as
-- they may help.
{-# LANGUAGE InstanceSigs #-}
instance (Applicative f,Applicative g)
=&gt;Applicative (Compose f g)where
pure::a-&gt;Compose f g a
pure=undefined
(&lt;<em>&gt;)::Compose f g (a-&gt;b)
-&gt;Compose f g a
-&gt;Compose f g b
(Compose f)&lt;</em>&gt;(Compose a)=undefined
We mentioned in an earlier chapter that Applicative is a
weaker algebra than Monad, and that sometimes there are bene-
fits to preferring an Applicative when you don‚Äôt need the full
power of the Monad. This is one of those benefits. To compose
Applicative s, you don‚Äôt need to do the legwork that Monads re-
quire in order to compose and still have a Monad. Oh, yes, right
‚Äî we still haven‚Äôt quite made it to monads composing, but
we‚Äôre about to.</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1516
25.5 Twonad?
What about Monad? There‚Äôs no problem composing two arbi-
trary datatypes that have Monadinstances. We saw this already
when we used Compose withMaybeand list, which both have Monad
instances defined. However, the result of having done so does
not give you a Monad.
The issue comes down to a lack of information. Both types
Compose is working with are polymorphic, so when you try to
write bind for the Monad, you‚Äôre trying to combine two poly-
morphic binds into a single combined bind. This, it turns out,
is not possible:
{-# LANGUAGE InstanceSigs #-}
-- impossible.
instance (Monadf,Monadg)
=&gt;Monad(Compose f g)where
return=pure
(&gt;&gt;=)::Compose f g a
-&gt;(a-&gt;Compose f g b)
-&gt;Compose f g b
(&gt;&gt;=)= ???</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1517
These are the types we‚Äôre trying to combine, because ùëìand
ùëîare necessarily both monads with their own Monadinstances:
Monadf=&gt;f a-&gt;(a-&gt;f b)-&gt;f b
Monadg=&gt;g a-&gt;(a-&gt;g b)-&gt;g b
From those, we are trying to write this bind:
(Monadf,Monadg)
=&gt;f (g a) -&gt;(a-&gt;f (g b)) -&gt;f (g b)
Or formulated diÔ¨Äerently:
(Monadf,Monadg)
=&gt;f (g (f (g a))) -&gt;f (g a)
And this is not possible. There‚Äôs not a good way to jointhat
finalùëìandùëî. It‚Äôs a great exercise to try to make it work, because
the barriers you‚Äôll run into are instructive in their own right.
You can also read Composing monads1by Mark P. Jones and
Luc Duponcheel to see why it‚Äôs not possible.
No free burrito lunches
Since getting another Monadgiven the composition of two arbi-
trary types that have a Monadinstance is impossible, what can
we do to get a Monadinstance for combinations of types? The
1http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1518
answer is, monad transformers. We‚Äôll get to that after a little
break for some exercises.
25.6 Exercises: Compose Instances
1.Write the Compose Foldable instance.
ThefoldMap = undefined bit is a hint to make it easier and
look more like what you‚Äôve seen already.
instance (Foldable f,Foldable g)=&gt;
Foldable (Compose f g)where
foldMap =undefined
2.Write the Compose Traversable instance.
instance (Traversable f,Traversable g)=&gt;
Traversable (Compose f g)where
traverse =undefined
And now for something completely diÔ¨Äerent
This has nothing to do with anything else in this chapter, but
it makes for a fun exercise.</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1519
classBifunctor pwhere
{-# MINIMAL bimap | first, second #-}
bimap::(a-&gt;b)
-&gt;(c-&gt;d)
-&gt;p a c
-&gt;p b d
bimap f g =first f .second g
first::(a-&gt;b)-&gt;p a c-&gt;p b c
first f =bimap f id
second::(b-&gt;c)-&gt;p a b-&gt;p a c
second=bimap id
It‚Äôs a functor that can map over two type arguments instead
of one. Write Bifunctor instances for the following types:
1.The less you think, the easier it‚Äôll be.
dataDeuxa b=Deuxa b
2.dataConsta b=Consta
3.dataDreia b c=Dreia b c
4.dataSuperDrei a b c=SuperDrei a b</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1520
5.dataSemiDrei a b c=SemiDrei a
6.dataQuadriceps a b c d =
Quadzzz a b c d
7.dataEithera b=
Lefta
|Rightb
25.7 Monad transformers
We‚Äôve now seen what the problem with Monadis: you can put
two together but you don‚Äôt get a new Monadinstance out of it.
When we need to get a new Monadinstance, we need a monad
transformer. It‚Äôs not magic; the answer is in the types.
We said above that a monad transformer is a type construc-
tor that takes a Monadas an argument and returns a Monadas
a result. We also noted that the fundamental problem with
composing two monads lies in the impossibility of joining two
unknown monads. In order to make that joinhappen, we need
to reduce the polymorphism and get concrete information
about one of the monads that we‚Äôre working with. The other
monad remains polymorphic as a variable type argument to
our type constructor. Transformers help you make a monad
out of multiple (2, 3, 4...) types that each have a Monadinstance</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1521
by wrapping around existing monads that provide each bit of
wanted functionality.
The types are tricky here, so we‚Äôre going to be walking
through writing monad transformers very slowly. Parts of
what follows may seem tedious, so work through it as slowly
or quickly as you need to.
Monadic stacking
Applicative allows us to apply functions of more than one ar-
gument in the presence of functorial structure, enabling us to
cope with this transition:
-- from this:
fmap(+1) (Just1)
-- to this:
(,,)
&lt;$&gt;Just1
&lt;<em>&gt;Just&quot;lol&quot;
&lt;</em>&gt;Just[1,2]
Sometimes we want a (&gt;&gt;=)which can address more than
oneMonadat once. You‚Äôll often see this in applications that have
multiple things going on, such as a web app where combining
Reader andIOis common. You want IOso you can perform ef-
fectful actions like talking to a database and also Reader for the</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1522
database connection(s) and/or HTTP request context. Some-
times you may even want multiple Readers (app-specific data
vs. what the framework provides by default), although usually
there‚Äôs a way to add only the data you want to a product type
of a single Reader .
So the question becomes, how do we get one big bind over
a type like the following?
IO(ReaderString[a])
-- where the Monad instances involved
-- are that of IO, Reader, and []
Doing it badly
We could make one-oÔ¨Ä types for each combination, but this
will get tiresome quickly. For example:
newtype MaybeIO a=
MaybeIO { runMaybeIO ::IO(Maybea) }
newtype MaybeList a=
MaybeList { runMaybeList ::[Maybea] }
We don‚Äôt need to resort to this; we can get a Monadfor two
types, as long as we know what one of the types is. Transform-</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1523
ers are a means of avoiding making a one-oÔ¨Ä Monadfor every
possible combination of types.
25.8 IdentityT
Much as Identity helps show oÔ¨Ä the most basic essence of
Functor ,Applicative , andMonad,IdentityT is going to help you
begin to understand monad transformers. Using this type that
doesn‚Äôt have a lot of interesting stuÔ¨Ä going on with it will help
keep us focused on the types and the important fundamentals
of transformers. What we see here will be applicable to other
transformers as well, but types like Maybeand list introduce
other possibilities (failure cases, empty lists) that complicate
things a bit.
First, let‚Äôs compare the Identity type you‚Äôve seen up to this
point and our new IdentityT datatype:
-- Plain old Identity. 'a' can be
-- something with more structure,
-- but it's not required and Identity
-- won't know anything about it.
newtype Identity a=
Identity { runIdentity ::a }
deriving (Eq,Show)</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1524
-- The identity monad transformer, serving
-- only to to specify that additional
-- structure should exist.
newtype IdentityT f a=
IdentityT { runIdentityT ::f a }
deriving (Eq,Show)
What changed here is that we added an extra type argument.
Thenwewant Functor instancesforboth Identity andIdentityT :
instance Functor Identity where
fmap f ( Identity a)=Identity (f a)
instance (Functor m)
=&gt;Functor (IdentityT m)where
fmap f ( IdentityT fa)=
IdentityT (fmap f fa)
TheIdentityT instancehereshouldlooksimilartothe Functor
instance for the Onedatatype above ‚Äî the ùëìùëéargument is the
value inside the IdentityT with the (untouchable) structure
wrapped around it. All we know about that additional layer of
structure wrapped around the ùëévalue is that it is a Functor .
We also want Applicative instances for each:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1525
instance Applicative Identity where
pure=Identity
(Identity f)&lt;<em>&gt;(Identity a)=
Identity (f a)
instance (Applicative m)
=&gt;Applicative (IdentityT m)where
pure x=IdentityT (pure x)
(IdentityT fab)&lt;</em>&gt;(IdentityT fa)=
IdentityT (fab&lt;<em>&gt;fa)
TheIdentity instance should be familiar. In the IdentityT
instance, the ùëìùëéùëèvariable represents the f (a -&gt; b) that is the
first argument of (&lt;</em>&gt;). Since this can rely on the Applicative
instance for ùëöto handle that bit, this instance defines how
to applicatively apply in the presence of that outer IdentityT
layer.
Finally, we want some Monadinstances:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1526
instance MonadIdentity where
return=pure
(Identity a)&gt;&gt;=f=f a
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(IdentityT ma)&gt;&gt;=f=
IdentityT $ma&gt;&gt;=runIdentityT .f
TheMonadinstance is tricky, so we‚Äôre going to do a few things
to break it down. Keep in mind that Monadis where we have to
really use concrete type information from IdentityT in order
to make the types fit.
The bind breakdown
We‚Äôll start with a closer look at the instance as written above:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1527
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(IdentityT ma)&gt;&gt;=f=
-- [ 1 ] [2] [3]
IdentityT $ma
-- [8] [4]
&gt;&gt;=runIdentityT .f
-- [5] [7] [6]
1.First we pattern match or unpack the m avalue of IdentityT
m avia the data constructor. Doing this has the type
IdentityT m a -&gt; m a and the type of maism a. This nomen-
clature doesn‚Äôt mean anything beyond mnemonic signal-
ing, but it is intended to be helpful.
2.The type of the bind we are implementing is the follow-
ing:
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
This is the instance we are defining.
3.The function we‚Äôre binding over is IdentityT m a . It has
the following type:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1528
(a-&gt;IdentityT m b)
4.Heremais the same one we unpacked out of the IdentityT
data constructor and has the type m a. Removed from its
IdentityT context, this is now the m athat this bind takes
as its first argument.
5.This is a diÔ¨Äerent bind! The first bind is the bind we‚Äôre
trying to implement; this bind is its definition or imple-
mentation. We‚Äôre now using the Monadwe asked for in the
instance declaration with the constraint Monad m =&gt; . This
will have the type:
(&gt;&gt;=)::m a-&gt;(a-&gt;m b)-&gt;m b
This is with respect to the ùëöin the type IdentityT m a , not
the class of Monadinstances in general. In other words,
since we have already unpacked the IdentityT bit and, in
a sense, gotten it out of the way, this bind will be the bind
for the type ùëöin the type IdentityT m . We don‚Äôt know
whatMonadthat is yet, and we don‚Äôt need to; since it has
theMonadtypeclass constraint on that variable, we know it
already has a Monadinstance defined for it, and this second
bind will be the bind defined for that type. All we‚Äôre doing
here is defining how to use that bind in the presence of
the additional IdentityT structure.</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1529
6.This is the same ùëìwhich was an argument to the Monad
instance we are defining, of type:
(a-&gt;IdentityT m b)
7.We need runIdentityT because ùëìreturns IdentityT m b , but
the&gt;&gt;=for the Monad m =&gt; has the type m a -&gt; (a -&gt; m b)
-&gt; m b. It‚Äôll end up trying to join m (IdentityT m b) , which
won‚Äôt work because mandIdentityT m are not the same
type. We use runIdentityT to unpack the value. Doing
this has the type IdentityT m b -&gt; m b and the composition
runIdentityT . f in this context has the type a -&gt; m b . You
can use undefined in GHCi to demonstrate this for yourself:
Prelude&gt; :{
*Main| let f :: (a -&gt; IdentityT m b)
*Main| f = undefined
*Main| :}
Prelude&gt; :t f
f :: a -&gt; IdentityT m b
Prelude&gt; :t runIdentityT
runIdentityT :: IdentityT f a -&gt; f a
Prelude&gt; :t (runIdentityT . f)
(runIdentityT . f) :: a1 -&gt; f a</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1530
OK, the type variables don‚Äôt have the same name, but you
can see how a1 -&gt; f a anda -&gt; m b are the same type.
8.To satisfy the type of the outer bind we are implementing
for the MonadofIdentityT m , which expects a final result
of the type IdentityT m b , we must take the m bwhich the
expression ma &gt;&gt;= runIdentityT . f returns and repack it
inIdentityT . Note:
Prelude&gt; :t IdentityT
IdentityT :: f a -&gt; IdentityT f a
Prelude&gt; :t runIdentityT
runIdentityT :: IdentityT f a -&gt; f a
Now we have a bind we can use with IdentityT and some
otherMonad‚Äî in this example, a list:
Prelude&gt; let sumR = return . (+1)
Prelude&gt; IdentityT [1, 2, 3] &gt;&gt;= sumR
IdentityT {runIdentityT = [2,3,4]}
Implementing the bind, step by step
Now we‚Äôre going to backtrack and go through implementing
that bind step by step. The goal here is to demystify what
we‚Äôve done and enable you to write your own instances for
whatever monad transformer you might need to implement</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1531
yourself. We‚Äôll go ahead and start back at the beginning, but
withInstanceSigs turned on so we can see the type:
{-# LANGUAGE InstanceSigs #-}
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
undefined
Let‚Äôs leave the undefined as our final return expression, then
useletbindings and contradiction to see the types of our
attempts at making a Monadinstance. We‚Äôre going to use the
bottom value ( undefined ) to defer the parts of the proof we‚Äôre
obligated to produce until we‚Äôre ready. First, let‚Äôs get a let
binding in place and see it load, even if the code doesn‚Äôt work:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1532
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb=ma&gt;&gt;=f
inundefined
We‚Äôre using ùëéùëñùëöùëèas a mnemonic for the parts of the whole
thing that we‚Äôre trying to implement.
Here we get an error:
Couldn't match type ‚Äòm‚Äô with ‚ÄòIdentityT m‚Äô
That type error isn‚Äôt the most helpful thing in the world.
It‚Äôs hard to know what‚Äôs wrong from that. So, we‚Äôll poke at this
a bit in order to get a more helpful type error.
First, we‚Äôll do something we know should work. We‚Äôll use
fmapinstead. Because that will typecheck (but not give us the
same result as (&gt;&gt;=)), we need to do something to give the
compiler a chance to contradict us and tell us the real type.
We force that type error by asserting a fully polymorphic type
forùëéùëñùëöùëè:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1533
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb::a
aimb=fmap f ma
inundefined
The type we asserted for ùëéùëñùëöùëèis impossible; we‚Äôve said it
could be every type, and it can‚Äôt. The only thing that can have
that type is bottom, as bottom inhabits all types.
Conveniently, GHC will let us know what ùëéùëñùëöùëèis:
Couldn't match expected type ‚Äòa1‚Äô
with actual type ‚Äòm (IdentityT m b)‚Äô
Withthecurrentimplementation, ùëéùëñùëöùëèhasthetype m (IdentityT
m b). Now we can see the real problem: there is an IdentityT
layer in between the two bits of ùëöthat we need to join in order
to have a monad.
Here‚Äôs a breakdown:
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
The pattern match on IdentityT comes from having lifted
over it:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1534
(a-&gt;IdentityT m b)
The problem is, we used &gt;&gt;=over
ma
-- and got
m(IdentityT m b)
It doesn‚Äôt typecheck because (&gt;&gt;=)merges structure of the
same type after lifting (remember: it‚Äôs fmapcomposed with
joinunder the hood). Had our type been m (m b) after binding
fovermait would‚Äôve worked fine. As it is, we need to find a
way to get the two bits of ùëötogether without an intervening
IdentityT layer.
We‚Äôre going to continue with having separate fmapandjoin
instead of using (&gt;&gt;=)because it makes the step-wise manip-
ulation of structure easier to see. How do we get rid of the
IdentityT in the middle of the two ùëöstructures? Well, we know
ùëöis aMonad, which means it‚Äôs also a Functor . So, we can use
runIdentityT to get rid of the IdentityT structure in the middle
of the stack of types:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1535
-- Change m (IdentityT m b)
-- into m (m b)
-- Note:
runIdentityT ::IdentityT f a-&gt;f a
fmaprunIdentityT ::Functor f
=&gt;f (IdentityT f1 a)-&gt;f (f1 a)
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb::a
aimb=fmap runIdentityT (fmap f ma)
inundefined
And when we load this code, we get an encouraging type
error:
Couldn't match expected type ‚Äòa1‚Äô
with actual type ‚Äòm (m b)‚Äô
It‚Äôs telling us we have achieved the type m (m b) , so now we
know how to get where we want. The ùëé1here is the ùëéwe had
assigned to ùëéùëñùëöùëè, but it‚Äôs telling us that our actual type is not
what we asserted but this other type. Thus we have discovered</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1536
what our actual type is, which gives us a clue about how to fix
it.
We‚Äôll use joinfromControl.Monad to merge the nested ùëö
structure:
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb::a
aimb=
join (fmap runIdentityT (fmap f ma))
inundefined
And when we load it, the compiler tells us we finally have
anm bthat we can return:
Couldn't match expected type ‚Äòa1‚Äô
with actual type ‚Äòm b‚Äô
In fact, before we begin cleaning up our code, we can verify
this is the case real quick:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1537
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb=
join (fmap runIdentityT (fmap f ma))
inaimb
We removed the type declaration for aimband also changed
thein undefined . But we know that ùëéùëñùëöùëèhas the actual type m
b, so this won‚Äôt work. Why? If we take a look at the type error:
Couldn't match type ‚Äòm‚Äô with ‚ÄòIdentityT m‚Äô
The(&gt;&gt;=)we are implementing has a final result of type
IdentityT m b , so the type of ùëéùëñùëöùëèdoesn‚Äôt match it yet. We need
to wrap m binIdentityT to make it typecheck:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1538
-- Remember:
IdentityT ::f a-&gt;IdentityT f a
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
letaimb=
join (fmap runIdentityT
(fmap f ma))
inIdentityT aimb
This should compile. We rewrap m bback in the IdentityT
type and we should be good to go.
Refactoring
Now that we have something that works, let‚Äôs refactor. We‚Äôd
like to improve our implementation of (&gt;&gt;=). Taking things
one step at a time is usually more successful than trying to
rewrite all at once, especially once you have a baseline version
that you know should work. How should we improve this line?</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1539
IdentityT $
join(fmap runIdentityT (fmap f ma))
Well, oneofthe Functor lawstellsussomethingabout fmapping
twice:
-- Functor law:
fmap(f.g)==fmap f.fmap g
Indeed! So we can change that line to the following and it
should be identical:
IdentityT $
join(fmap (runIdentityT .f) ma)
Now it seems suspicious that we‚Äôre fmapping and also us-
ingjoinon the result of having fmapped the two functions we
composed. Isn‚Äôt joincomposed with fmapjust(&gt;&gt;=)?
x&gt;&gt;=f=join (fmap f x)
Accordingly, we can change our Monadinstance to the fol-
lowing:</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1540
instance (Monadm)
=&gt;Monad(IdentityT m)where
return=pure
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
IdentityT $ma&gt;&gt;=runIdentityT .f
And that should work still! We have a type constructor now
(IdentityT ) that takes a monad as an argument and returns a
monad as a result.
This implementation can be written other ways. In the
transformers library, for example, it‚Äôs written like this:
m&gt;&gt;=k=
IdentityT $runIdentityT .k
=&lt;&lt;runIdentityT m
Take a moment and work out for yourself how that is func-
tionally equivalent to our implementation.
The essential extra of monad transformers
It may not seem like it, but the IdentityT monad transformer
captures the essence of transformers generally. We only em-</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1541
barked on this quest because we couldn‚Äôt be guaranteed a Monad
instance given the composition of two types. Given that, we
know having Functor ,Applicative , andMonadat our disposal isn‚Äôt
enough to make that new Monadinstance. So what was novel in
the following code?
(&gt;&gt;=)::IdentityT m a
-&gt;(a-&gt;IdentityT m b)
-&gt;IdentityT m b
(IdentityT ma)&gt;&gt;=f=
IdentityT $ma&gt;&gt;=runIdentityT .f
It wasn‚Äôt the pattern match on IdentityT ; we get that from
theFunctor anyway:
-- Not this
(IdentityT ma)...
It wasn‚Äôt the ability to (&gt;&gt;=)functions over the mavalue of
typeùëöùëé, we get that from the Monadconstraint on ùëöanyway.
-- Not this
...ma&gt;&gt;= ...
We needed to know one of the types concretely so that
we could use runIdentityT (essentially fmapping a fold of the
IdentityT structure) and then repack the value in IdentityT :</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1542
-- We need to know IdentityT
-- concretely to do this
IdentityT ..runIdentityT ...
As you‚Äôll recall, until we used runIdentityT we couldn‚Äôt get
the types to fit because IdentityT was wedged in the middle of
two bits of ùëö. It turns out to be impossible to fix that using
onlyFunctor ,Applicative , andMonad. This is an example of why
we can‚Äôt make a Monadinstance for the Compose type, but we
can make a transformer type like IdentityT where we leverage
information specific to the type and combine it with any other
type that has a Monadinstance. In general, in order to make the
types fit, we‚Äôll need some way to fold and reconstruct the type
we have concrete information for.
25.9 Finding a pattern
Transformers are bearers of single-type concrete information
that let you create ever-bigger monads in a sense. Nesting
such as
(Monadm)=&gt;m (m a)
is addressed by joinalready. We use transformers when
we want a &gt;&gt;=operation over ùëìandùëîof diÔ¨Äerent types (but
both have Monadinstances). You have to create new types called</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1543
monad transformers and write Monadinstances for those types
to have a way of dealing with the extra structure generated.
The general pattern is this: You want to compose two poly-
morphic types, ùëìandùëî, that each have a Monadinstance. But
you‚Äôll end up with this pattern:
f(g (f b))
Monad‚Äôs bind can‚Äôt join those types, not with that intervening
ùëî. So you need to get to this:
f(f b)
You won‚Äôt be able to unless you have some way of folding
theùëîin the middle. You can‚Äôt do that with Monad. The essence
ofMonadisjoin, but here you have only one bit of ùëîstructure,
notg (g ...) , so that‚Äôs not enough. The straightforward thing
to do is to make ùëîconcrete. With concrete type information
for the inner bit of structure, we can fold out the ùëîand get on
with it. The good news is that transformers don‚Äôt require ùëìbe
concrete; ùëìcan remain polymorphic so long as it has a Monad
instance, so we only write a transformer once for each type.
We can see this pattern with IdentityT as well. You may
recall this step in our process of writing IdentityT ‚ÄôsMonad:
(IdentityT ma)&gt;&gt;=f=
letaimb::m (IdentityT m b)
aimb=fmap f ma</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1544
We have something that‚Äôll typecheck, but it‚Äôs not quite in
the shape we would like. Of course, the underlying type once
we throw away the IdentityT data constructor is m (m b) which‚Äôll
suit us just fine, but we have to fold out the IdentityT before we
can use the joinfromMonad m =&gt; m . That leads us to the next
step:
letaimb::m (m b)
aimb=fmap runIdentityT (fmap f ma)
Now we finally have something we can join because we lifted
the record accessor for IdentityT over the ùëö! Since IdentityT
is so simple, the record accessor is sufficient to fold up the
structure. From there the following transitions become easy:
m(m b)-&gt;m b-&gt;IdentityT m b
The final type is what our definition of (&gt;&gt;=)forIdentityT
must result in.
The basic pattern that many monad transformers are en-
abling us to cope with is the following type transitions, where
ùëöis the polymorphic, outer structure and ùëáis some concrete
type the transformer is for. For example, in the above, ùëáwould
beIdentityT .</p>
<p>CHAPTER 25. E PLURIBUS MONAD 1545
m (Tm b)
-&gt;m (m b)
-&gt;m b
-&gt;Tm b
Don‚Äôt consider this a hard and fast rule for what types you‚Äôll
encounter in implementing transformers, but rather some
intuition for why transformers are necessary to begin with.</p>
<p>Chapter 26
Monad transformers
I do not say such things
except insofar as I
consider this to permit
some transformation of
things. Everything I do, I
do in order that it may be
of use.
Michel Foucault
1546</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1547
26.1 Monad transformers
The last chapter demonstrated why we need monad transform-
ers and the basic type manipulation that‚Äôs going on to make
that bit of magick happen. Monad transformers are important
in a lot of everyday Haskell code, though, so we want to dive
deeper and make sure we have a good understanding of how
to use them in practice. Even after you know how to write all
the transformer instances, managing stacks of transformers
in an application can be tricky. The goal of this chapter is to
get comfortable with it.
In this chapter, we will
‚Ä¢work through more monad transformer types and in-
stances;
‚Ä¢look at the ordering and wrapping of monad transformer
stacks;
‚Ä¢lift, lift, lift, and lift some more.
26.2 MaybeT
In the last chapter, we worked through an extended break-
down of the IdentityT transformer. IdentityT is, as you might
imagine, not the most useful of the monad transformers, al-
though it is not without practical applications (more on this</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1548
later). As we‚Äôve seen, though, the Maybe Monad can be useful, and
so it is that the tranformer variant, MaybeT, finds its way into
the pantheon of important transformers.
TheMaybeT transformer is a bit more complex than IdentityT .
If you worked through all the exercises of the previous chapter,
then this section will not be too surprising, because this will
rely on things you‚Äôve seen with IdentityT and the Compose type
already. However, to ensure that transformers are thoroughly
demystified for you, it‚Äôs worth working through them carefully.
We begin with the newtype for our transformer:
newtype MaybeTm a=
MaybeT{ runMaybeT ::m (Maybea) }
The structure of our MaybeT type and the Compose type are
similar so we can reuse the basic patterns of the Compose type
for theFunctor andApplicative instances:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1549
-- Remember the Functor for Compose?
instance (Functor f,Functor g)
=&gt;Functor (Compose f g)where
fmap f ( Compose fga)=
Compose $(fmap.fmap) f fga
-- compare to the instance for MaybeT
instance (Functor m)
=&gt;Functor (MaybeTm)where
fmap f ( MaybeTma)=
MaybeT$(fmap.fmap) f ma
We don‚Äôt need to do anything diÔ¨Äerent for the Functor in-
stance, because transformers are needed for the Monad, not the
Functor .
Spoiler alert!
If you haven‚Äôt yet written the Applicative instance for Compose
from the previous chapter, you may want to stop right here.
We‚Äôll start with what might seem like an obvious way to
write the MaybeT Applicative and find out why it doesn‚Äôt work.
This does not compile:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1550
instance (Applicative m)
=&gt;Applicative (MaybeTm)where
pure x=MaybeT(pure (pure x))
(MaybeTfab)&lt;<em>&gt;(MaybeTmma)=
MaybeT$fab&lt;</em>&gt;mma
Theùëìùëéùëèrepresents the function m (Maybe (a -&gt; b)) and the
ùëöùëöùëérepresents the m (Maybe a) .
You‚Äôll get this error if you try it:
Couldn't match type ‚ÄòMaybe (a -&gt; b)‚Äô
with ‚ÄòMaybe a -&gt; Maybe b‚Äô
Here is the Applicative instance for Compose as a comparison
with the MaybeT instance we‚Äôre trying to write:
instance (Applicative f,Applicative g)
=&gt;Applicative (Compose f g)where
pure x=Compose (pure (pure x))
Compose f&lt;<em>&gt;Compose x=
Compose ((&lt;</em>&gt;)&lt;$&gt;f&lt;*&gt;x)
Let‚Äôs break this down a bit in case you felt confused when
you wrote this for the last chapter‚Äôs exercise. Because you did
that exercise‚Ä¶right?</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1551
The idea here is that we have to lift an Applicative apply
over the outer structure ùëìto get the g (a -&gt; b) intog a -&gt; g b
so that the Applicative instance for ùëìcan be leveraged. We can
stretch this idea a bit and use concrete types:
innerMost
::[Maybe(Identity (a-&gt;b))]
-&gt;[Maybe(Identity a-&gt;Identity b)]
innerMost =(fmap.fmap) (&lt;<em>&gt;)
second'
::[Maybe(Identity a-&gt;Identity b)]
-&gt;[Maybe(Identity a)
-&gt;Maybe(Identity b) ]
second' =fmap (&lt;</em>&gt;)
final'
::[Maybe(Identity a)
-&gt;Maybe(Identity b) ]
-&gt;[Maybe(Identity a)]
-&gt;[Maybe(Identity b)]
final'=(&lt;*&gt;)
The function that could be the Applicative instance for such
a hypothetical type would look like:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1552
lmiApply ::[Maybe(Identity (a-&gt;b))]
-&gt;[Maybe(Identity a)]
-&gt;[Maybe(Identity b)]
lmiApply f x=
final' (second' (innerMost f)) x
TheApplicative instance for our MaybeT type will employ this
same idea, because applicatives are closed under composition,
as we noted in the last chapter. We only need to do something
diÔ¨Äerent from the Compose instances once we get to Monad.
So, we took the long way around to this:
instance (Applicative m)
=&gt;Applicative (MaybeTm)where
pure x=MaybeT(pure (pure x))
(MaybeTfab)&lt;<em>&gt;(MaybeTmma)=
MaybeT$(&lt;</em>&gt;)&lt;$&gt;fab&lt;*&gt;mma
MaybeT Monad instance
At last, on to the Monadinstance! Note that we‚Äôve given some of
the intermediate types:
instance (Monadm)
=&gt;Monad(MaybeTm)where
return=pure</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1553
(&gt;&gt;=)::MaybeTm a
-&gt;(a-&gt;MaybeTm b)
-&gt;MaybeTm b
(MaybeTma)&gt;&gt;=f=
-- [2] [3]
MaybeT$ do
-- [ 1 ]
-- ma :: m (Maybe a)
-- v :: Maybe a
v&lt;-ma
-- [4]
casevof
-- [5]
Nothing -&gt;returnNothing
-- [ 6 ]
Justy-&gt;runMaybeT (f y)
-- [7] [8]
-- y :: a
-- f :: a -&gt; MaybeT m b
-- f y :: MaybeT m b
-- runMaybeT (f y) :: m (Maybe b)
Explaining it step by step:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1554
1.We have to return a MaybeT value at the end, so the doblock
has the MaybeT data constructor in front of it. This means
the final value of our doblock expression must be of type
m (Maybe b) in order to typecheck because our goal is to
go from MaybeT m a toMaybeT m b .
2.The first argument to bind here is MaybeT m a . We unbun-
dled that from MaybeT by pattern matching on the MaybeT
newtype data constructor.
3.The second argument to bind is (a -&gt; MaybeT m b) .
4.In the definition of MaybeT , notice something:
newtype MaybeTm a=
MaybeT{ runMaybeT ::m (Maybea) }
-- ^---------^
It‚Äôs aMaybevalue wrapped in some other type for which
all we know is that it has a Monadinstance. Accordingly, we
begin in our doblock by using the left arrow bind syntax.
This gives us a reference to the hypothetical Maybevalue
out of the ùëöstructure which is unknown.
5.Since using &lt;-to bind Maybe a out ofm (Maybe a) left us
with aMaybevalue, we use a case expression on the Maybe
value.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1555
6.If we get Nothing , we kick Nothing back out, but we have to
embed it in the ùëöstructure. We don‚Äôt know what ùëöis, but
being a Monad(and thus also an Applicative ) means we can
usereturn (pure) to perform that embedding.
7.If we get Just, we now have a value of type ùëéthat we can
pass to our function fof type a -&gt; MaybeT m b .
8.We have to fold the m (Maybe b) value out of the MaybeT
since the MaybeT constructor is already wrapped around
the whole doblock, then we‚Äôre done.
Don‚Äôt be afraid to get a pen and paper and work all that out
until you understand how things are happening before you
move on.
26.3 EitherT
Just asMaybehas a transformer variant in the form of MaybeT , we
can make a transformer variant of Either . We‚Äôll call it EitherT .
Your task is to implement the instances for the transformer
variant:
newtype EitherT e m a=
EitherT { runEitherT ::m (Eithere a) }</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1556
Exercises: EitherT
1.Write the Functor instance for EitherT :
instance Functor m
=&gt;Functor (EitherT e m)where
fmap=undefined
2.Write the Applicative instance for EitherT :
instance Applicative m
=&gt;Applicative (EitherT e m)where
pure=undefined
f&lt;*&gt;a=undefined
3.Write the Monadinstance for EitherT :
instance Monadm
=&gt;Monad(EitherT e m)where
return=pure
v&gt;&gt;=f=undefined
4.Write the swapEitherT helper function for EitherT .</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1557
-- transformer version of swapEither.
swapEitherT ::(Functor m)
=&gt;EitherT e m a
-&gt;EitherT a m e
swapEitherT =undefined
Hint: write swapEither first, then swapEitherT in terms of
the former.
5.Write the transformer variant of the either catamorphism.
eitherT ::Monadm=&gt;
(a-&gt;m c)
-&gt;(b-&gt;m c)
-&gt;EitherT a m b
-&gt;m c
eitherT =undefined
26.4 ReaderT
ReaderT is one of the most commonly used transformers in
conventional Haskell applications. It is like Reader, except in
the transformer variant we‚Äôre generating additional structure
in the return type of the function:
newtype ReaderT r m a=
ReaderT { runReaderT ::r-&gt;m a }</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1558
The value inside the ReaderT is a function. Type constructors
such as Maybeare also functions in some senses, but we have
to handle this case a bit diÔ¨Äerently. The first argument to the
function inside ReaderT is part of the structure we‚Äôll have to
bind over.
This time we‚Äôre going to give you the instances. If you want
to try writing them yourself, do not read on!</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1559
instance (Functor m)
=&gt;Functor (ReaderT r m)where
fmap f ( ReaderT rma)=
ReaderT $(fmap.fmap) f rma
instance (Applicative m)
=&gt;Applicative (ReaderT r m)where
pure a=ReaderT (pure (pure a))
(ReaderT fmab)&lt;<em>&gt;(ReaderT rma)=
ReaderT $(&lt;</em>&gt;)&lt;$&gt;fmab&lt;*&gt;rma
instance (Monadm)
=&gt;Monad(ReaderT r m)where
return=pure
(&gt;&gt;=)::ReaderT r m a
-&gt;(a-&gt;ReaderT r m b)
-&gt;ReaderT r m b
(ReaderT rma)&gt;&gt;=f=
ReaderT $\r-&gt; do
-- [1]
a&lt;-rma r
-- [3] [ 2 ]
runReaderT (f a) r
-- [5] [ 4 ] [6]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1560
1.Again, the type of the value in a ReaderT must be a function,
so the act of binding a function over a ReaderT must itself
be a function awaiting the argument of type ùëü, which we‚Äôve
chosen to name ùëüas a convenience in our terms. Also note
that we‚Äôre repacking our lambda inside the ReaderT data
constructor.
2.Wepattern-matchedthe r -&gt; m a (representedinourterms
byùëüùëöùëé) out of the ReaderT data constructor. Now we‚Äôre ap-
plying it to the ùëüthat we‚Äôre expecting in the body of the
anonymous lambda.
3.The result of applying r -&gt; m a to a value of type ùëüism
a. We need a value of type ùëéin order to apply our a -&gt;
ReaderT r m b function. To be able to write code in terms
of that hypothetical ùëé, we bind ( &lt;-) theùëéout of the ùëö
structure. We‚Äôve bound that value to the name ùëéas a
mnemonic to remember the type.
4.Applying ùëì, which has type a -&gt; ReaderT r m b , to the value
ùëéresults in a value of type ReaderT r m b .
5.We unpack the r -&gt; m b out of the ReaderT structure.
6.Finally, we apply the resulting r -&gt; m b to theùëüwe had at
the beginning of our lambda, that eventual argument that
Reader abstracts for us. We have to return m bas the final
expression in this anonymous lambda or the function is</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1561
not valid. To be valid, it must be of type r -&gt; m b which
expresses the constraint that if it is applied to an argument
of type ùëü, it must produce a value of type m b.
No exercises this time. You deserve a break.
26.5 StateT
Similar to Reader andReaderT ,StateT isStatebut with additional
monadic structure wrapped around the result. StateT is some-
what more useful and common than the State Monad you saw
earlier. Like ReaderT , its value is a function:
newtype StateTs m a=
StateT{ runStateT ::s-&gt;m (a,s) }
Exercises: StateT
If you‚Äôre familiar with the distinction, you‚Äôll be implementing
the strict variant of StateT here. To make the strict variant,
you don‚Äôt have to do anything special. Write the most obvious
thing that could work. The lazy (lazier, anyway) variant is
the one that involves adding a bit extra. We‚Äôll explain the
diÔ¨Äerence in the chapter on nonstrictness.
1.You‚Äôll have to do the Functor andApplicative instances
first, because there aren‚Äôt Functor andApplicative instances
ready to go for the type Monad m =&gt; s -&gt; m (a, s) .</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1562
instance (Functor m)
=&gt;Functor (StateTs m)where
fmap f m =undefined
2.As with Functor , you can‚Äôt cheat and reuse an underlying
Applicative instance, so you‚Äôll have to do the work with
thes -&gt; m (a, s) type yourself.
instance (Monadm)
=&gt;Applicative (StateTs m)where
pure=undefined
(&lt;*&gt;)=undefined
Also note that the constraint on ùëöis notApplicative as you
expect, but rather Monad. This is because you can‚Äôt express
the order-dependent computation you‚Äôd expect the StateT
Applicative to have without having a Monad for ùëö. To
learn more, see this Stack Overflow question1about this
issue. Also see this Github issue2on the NICTA Course
Github repository. Beware ! The NICTA course issue
gives away the answer. In essence, the issue is that without
Monad, you‚Äôre feeding the initial state to each computation
inStateT rather than threading it through as you go. This
1Is it possible to implement ‚Äò(Applicative m) =&gt; Applica-
tive (StateT s m)‚Äò? http://stackoverflow.com/questions/18673525/
is-it-possible-to-implement-applicative-m-applicative-statet-s-m
2https://github.com/NICTA/course/issues/134</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1563
is a general pattern contrasting Applicative andMonadand
is worth contemplating.
3.TheMonadinstance should look fairly similar to the Monad
instance you wrote for ReaderT .
instance (Monadm)
=&gt;Monad(StateTs m)where
return=pure
sma&gt;&gt;=f=undefined
ReaderT, WriterT, StateT
We‚Äôd like to point something out about these three types:
newtype Readerr a=
Reader{ runReader ::r-&gt;a }
newtype Writerw a=
Writer{ runWriter ::(a, w) }
newtype States a=
State{ runState ::s-&gt;(a, s) }
and their transformer variants:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1564
newtype ReaderT r m a=
ReaderT { runReaderT ::r-&gt;m a }
newtype WriterT w m a=
WriterT { runWriterT ::m (a, w) }
newtype StateTs m a=
StateT{ runStateT ::s-&gt;m (a, s) }
You‚Äôre already familiar with Reader andState. We haven‚Äôt
shown you Writer orWriterT up to this point because, quite
frankly, you shouldn‚Äôt use it. We‚Äôll explain why not in a section
later in this chapter.
For the purposes of the progression we‚Äôre trying to demon-
strate here, it suffices to know that the Writer Applicative and
Monadwork by combining the ùë§values monoidally. With that
in mind, what we can see is that Reader lets us talk about val-
ues we need, Writer lets us deal with values we can emit and
combine (but not read), and Statelets us both read and write
values in any manner we desire ‚Äî including monoidally, like
Writer . This is one reason you needn‚Äôt bother with Writer since
Statecan replace it anyway. That‚Äôs why you don‚Äôt need Writer ;
we‚Äôll talk more about why you don‚Äôt want Writer later.
In fact, there is a type in the transformers library that com-
binesReader ,Writer , andStateinto one big type:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1565
newtype RWSTr w s m a =
RWST{ runRWST ::r-&gt;s-&gt;m (a, s, w) }
Because of the Writer component, you probably wouldn‚Äôt
want to use that in most applications either, but it‚Äôs good to
know it exists.
Correspondence between StateT and Parser
You may recall what a simple parser type looks like:
typeParsera=String-&gt;Maybe(a,String)
You may remember our discussion about the similarities
between parsers and Statein the Parsers chapter. Now, we
could choose to define a Parser type in the following manner:
newtype StateTs m a=
StateT{ runStateT ::s-&gt;m (a,s) }
typeParser=StateTStringMaybe
Nobody does this in practice, but it‚Äôs useful to consider the
similarity to get a feel for what StateT is all about.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1566
26.6 Types you probably don‚Äôt want to
use
Not every type will necessarily be performant or make sense.
ListTandWriter /WriterT are examples of this.
Why not use Writer or WriterT?
It‚Äôs a bit too easy to get into a situation where Writer is either
too lazy or too strict for the problem you‚Äôre solving, and then
it‚Äôll use more memory than you‚Äôd like. Writer can accumulate
unevaluated thunks, causing memory leaks. It‚Äôs also inappro-
priate for logging long-running or ongoing programs due to
the fact that you can‚Äôt retrieve any of the logged values until
the computation is complete.3
Usually when Writer is used in an application, it‚Äôs not called
Writer . Instead a one-oÔ¨Ä is created for a specific type ùë§. Given
that, it‚Äôs still useful to know when you‚Äôre looking at something
that‚Äôs a Reader,Writer, orState, even if the author didn‚Äôt use
the types by those names from the transformers library. Some-
times this is because they wanted a stricter Writer than the one
already available.
Determining and measuring when more strictness (more
eagerly evaluating your thunks) is needed in your programs is
3If you‚Äôd like to understand this better, Gabriel Gonzalez has a helpful blog post on
the subject. http://www.haskellforall.com/2014/02/streaming-logging.html</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1567
the topic of the upcoming chapter on nonstrictness.
The ListT you want isn‚Äôt made from the List type
The most obvious way to implement ListTis generally not
recommended for a variety of reasons, including:
1.Most people‚Äôs first attempt won‚Äôt pass the associativity law.
We‚Äôre not going to show you a way to write it that does
pass that law because it‚Äôs not worth it for the reasons listed
below.
2.It‚Äôs not very fast.
3.Streaming libraries like pipes4andconduit5do it better for
most use cases.
Prior art for ‚Äú ListTdone right‚Äù also includes AmbT6by Conal</p>
<div style="break-before: page; page-break-before: always;"></div><p>Elliott, although you may find it challenging to understand if
you aren‚Äôt familiar with ContTand the motivation behind Amb.
Lists in Haskell are as much a control structure as a data
structure, so streaming libraries such as pipesgenerally suffice
if you need a transformer. This is less of a sticking point in
writing applications than you‚Äôd think.
4http://hackage.haskell.org/package/pipes
5http://hackage.haskell.org/package/conduit
6https://wiki.haskell.org/Amb</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1568
26.7 Recovering an ordinary type from
a transformer
If you have a transformer variant of a type and want to use
it as if it was the non-transformer version, you need some ùëö
structure that doesn‚Äôt do anything. Have we seen anything like
that? What about Identity ?
Prelude&gt; runMaybeT $ (+1) &lt;$&gt; MaybeT (Identity (Just 1))
Identity {runIdentity = Just 2}
Prelude&gt; runMaybeT $ (+1) &lt;$&gt; MaybeT (Identity Nothing)
Identity {runIdentity = Nothing}
Given that, we can get Identity fromIdentityT and so on in
the following manner:
typeMyIdentity a=IdentityT Identity a
typeMaybe a=MaybeTIdentity a
typeEithere a=EitherT eIdentity a
typeReaderr a=ReaderT eIdentity a
typeStates a=StateTsIdentity a
This works fine for recovering the non-transformer variant
of each type as the Identity type is acting as a bit of do-nothing
structural paste for filling in the gap.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1569
Yeah, but why? You don‚Äôt ordinarily need to do this if you‚Äôre
working with a transformer that has a corresponding non-
transformer type you can use. For example, it‚Äôs less common
to need ( ExceptT Identity ) because the Either type is already
there, so you don‚Äôt need to retrieve that type from the trans-
former. However, if you‚Äôre writing something with, say, scotty ,
where a ReaderT is part of the environment, you can‚Äôt easily
retrieve the Reader type out of that because Reader is not a type
that exists on its own and you can‚Äôt modify that ReaderT with-
out essentially rewriting all of scotty , and, wow, nobody wants
that for you. You might then have a situation where what
you‚Äôre doing only needs a Reader, not aReaderT , so you could
use (ReaderTIdentity ) to be compatible with scotty without hav-
ing to rewrite everything but still being able to keep your own
code a bit tighter and simpler.
Thetransformers library In general, don‚Äôt use hand-rolled
versions of these transformer types without good reason. You
can find many of them in base or the transformers library, and
that library should have come with your GHC installation.
A note on ExceptT Although a library called either exists on
Hackage and provides the EitherT type, most Haskellers are
moving to the identical ExceptT type in the transformers library.
Again, this has mostly to do with the fact that transformers</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1570
comes packaged with GHC already, so ExceptT is ready-to-
hand; the underlying type is the same.
26.8 Lexically inner is structurally
outer
One of the trickier parts of monad transformers is that the
lexical representation of the types will violate your intuitions
with respect to the relationship it has with the structure of
your values. Let us note something in the definitions of the
following types:
-- definition in transformers may look
-- slightly different. It's not important.
newtype ExceptT e m a=
ExceptT { runExceptT ::m (Eithere a) }
newtype MaybeTm a=
MaybeT{ runMaybeT ::m (Maybea) }
newtype ReaderT r m a=
ReaderT { runReaderT ::r-&gt;m a }
A necessary byproduct of how transformers work is that
the additional structure ùëöis always wrapped around our value.
One thing to note is that it‚Äôs only wrapped around things</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1571
we can have, not things we need, such as with ReaderT . The
consequence of this is that a series of monad transformers in a
type will begin with the innermost type structurally speaking.
Consider the following:
moduleOuterInner where
importControl.Monad.Trans.Except
importControl.Monad.Trans.Maybe
importControl.Monad.Trans.Reader
-- We only need to use return once
-- because it's one big Monad
embedded ::MaybeT
(ExceptT String
(ReaderT ()IO))
Int
embedded =return1
We can sort of peel away the layers one by one:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1572
maybeUnwrap ::ExceptT String
(ReaderT ()IO) (MaybeInt)
maybeUnwrap =runMaybeT embedded
-- Next
eitherUnwrap ::ReaderT ()IO
(EitherString(MaybeInt))
eitherUnwrap =runExceptT maybeUnwrap
-- Lastly
readerUnwrap ::()
-&gt;IO(EitherString
(MaybeInt))
readerUnwrap =runReaderT eitherUnwrap
Then if we‚Äôd like to evaluate this code, we feed the unit
value to the function:
Prelude&gt; readerUnwrap ()
Right (Just 1)
Why is this the result? Consider that we used return for a
Monadcomprising Reader ,Either , andMaybe:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1573
instance Monad((-&gt;) r)where
return=const
instance Monad(Eithere)where
return=Right
instance MonadMaybewhere
return=Just
We can treat having used return for theReader /Either /Maybe
stack as composition, consider how we get the same result as
readerUnwrap () here:
Prelude&gt; (const . Right . Just $ 1) ()
Right (Just 1)
A terminological point to keep in mind when reading about
monad transformers is that when Haskellers say base monad
they usually mean what is structurally outermost.
typeMyTypea=IO[Maybea]
InMyType , the base monad is IO.
Exercise: Wrap It Up
TurnreaderUnwrap fromthepreviousexamplebackinto embedded
through the use of the data constructors for each transformer.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1574
-- Modify it to make it work.
embedded ::MaybeT
(ExceptT String
(ReaderT ()IO))
Int
embedded = ???(const ( Right(Just1)))
26.9 MonadTrans
We often want to lift functions into a larger context. We‚Äôve
been doing this for a while with Functor , which lifts a function
into a context and applies it to the value inside. The facility
to do this also undergirds Applicative ,Monad, andTraversable .
However, fmapisn‚Äôt always enough, so we have some functions
that are essentially fmapfor diÔ¨Äerent contexts:
fmap :: Functor f
=&gt; (a -&gt; b) -&gt; f a -&gt; f b
liftA :: Applicative f
=&gt; (a -&gt; b) -&gt; f a -&gt; f b
liftM :: Monad m
=&gt; (a -&gt; r) -&gt; m a -&gt; m r</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1575
You might notice the latter two examples have liftin the
function name. While we‚Äôve encouraged you not to get too
excited about the meaning of function names, in this case they
do give you a clue of what they‚Äôre doing. They are lifting,
just asfmapdoes, a function into some larger context. The
underlying structure of the bind function from Monadis also a
lifting function ‚Äî fmapagain! ‚Äî composed with the crucial
joinfunction.
In some cases, we want to talk about more or diÔ¨Äerent
structure than these types permit. In other cases, we want
something that does as much lifting as is necessary to reach
some (structurally) outermost position in a stack of monad
transformers. Monad transformers can be nested in order
to compose various eÔ¨Äects into one monster function, but to
manage those stacks, we need to lift more.
The typeclass that lifts
MonadTrans is a typeclass with one core method: lift. Speaking
generally, it is about lifting actions in some Monadover a trans-
former type which wraps itself in the original Monad. Fancy!</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1576
classMonadTrans twhere
-- | Lift a computation from
-- the argument monad to
-- the constructed monad.
lift::(Monadm)=&gt;m a-&gt;t m a
Here the ùë°is a (constructed) monad transformer type that
has an instance of MonadTrans defined.
We‚Äôre going to work through a relatively uncomplicated
example from scotty now.
Motivating MonadTrans
You may remember from previous chapters that scotty is a
web framework for Haskell. One thing to know about scotty,
without getting into all the gritty details of how it works, is that
the monad transformers the framework relies on are them-
selves newtypes for monad transformer stacks. Wait, what?
Well, look:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1577
newtype ScottyT e m a=
ScottyT
{ runS::State(ScottyState e m) a }
deriving (Functor,Applicative ,Monad)
newtype ActionT e m a=
ActionT
{ runAM
::ExceptT
(ActionError e)
(ReaderT ActionEnv
(StateTScottyResponse m))
a
}
deriving (Functor,Applicative )
typeScottyM =ScottyT TextIO
typeActionM =ActionT TextIO
We‚Äôll use ActionM andActionT andScottyM andScottyT as if
they were the same thing, but the Mvariants are type synonyms
for the transformers with the inner types already set. This
roughly translates to the errors (the left side of the ExceptT ) in
ScottyM orActionM being returned as Text, while the right side
of theExceptT , whatever it does, is IO.ExceptT is the transformer</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1578
version of Either, and a ReaderT and aStateT are stacked up
inside that as well. These internal mechanics don‚Äôt matter that
much to you, as a user of the scotty API, but it‚Äôs useful to see
how much is packed up in there.
Now, back to our example. This is the ‚Äúhello, world‚Äù exam-
ple using scotty , but the following will cause a type error:
-- scotty.hs
{-# LANGUAGE OverloadedStrings #-}
moduleScottywhere
importWeb.Scotty
importData.Monoid (mconcat)
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
putStrLn &quot;hello&quot;
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1579
Reminder: in your terminal, you can follow along with this
like so:
$ stack build scotty
$ stack ghci
Prelude&gt; :l scotty.hs
When you try to load it, you should get a type error:
Couldn't match expected type
‚ÄòWeb.Scotty.Internal.Types.ActionT
Data.Text.Internal.Lazy.Text IO a0‚Äô
with actual type ‚ÄòIO ()‚Äô
In a stmt of a 'do' block: putStrLn &quot;hello&quot;
In the second argument of ‚Äò($)‚Äô, namely
‚Äòdo { beam &lt;- param &quot;word&quot;;
putStrLn &quot;hello&quot;;
html $ mconcat [&quot;<h1>Scotty, &quot;, beam, ....] }‚Äô
The reason for this type error is that putStrLn has the type
IO (), but it is inside a doblock inside our get, and the monad
that code is in is therefore ActionM /ActionT :
get::RoutePattern
-&gt;ActionM ()
-&gt;ScottyM ()</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1580
OurActionT type eventually reaches IO, but there‚Äôs addi-
tional structure we need to lift over first. To fix this, we‚Äôll start
by adding an import:
importControl.Monad.Trans.Class
And amend that line with putStrLn to the following:
lift(putStrLn &quot;hello&quot;)
It should work.
You can assert a type for the liftembedded in the scotty
action:
lethello=putStrLn &quot;hello&quot;
(lift::IOa-&gt;ActionM a) hello
Let‚Äôs see what it does. Load the file again and call the main
function. You should see this message:
Setting phasers to stun... (port 3000) (ctrl-c to quit)
In the address bar of your web browser, type localhost:3000 .
You should notice two things: one is that there is nothing in
thebeamslot of the text that prints to your screen, and the other
is that it prints ‚Äòhello‚Äô to your terminal where the program is
running. Try adding a word to the end of the address:
localhost:3000/beam</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1581
The text on your screen should change, and ‚Äòhello‚Äô should
print in your terminal again. That /:word parameter is what has
been bound via the variable beaminto that html line at the end
of thedoblock, while the ‚Äòhello‚Äô has been lifted over the ActionM
so that it can print in your terminal. It will print another ‚Äòhello‚Äô
to your terminal every time something happens on the web
page.
We can concretize our use of liftin the following steps.
Please follow along by asserting the types for the application
ofliftin thescotty application above:
lift::(Monadm,MonadTrans t)
=&gt;m a-&gt;t m a
lift::(MonadTrans t)
=&gt;IOa-&gt;tIOa
lift::IOa-&gt;ActionM a
lift::IO()-&gt;ActionM ()
We go from (t IO a) to(ActionM a) because the IOis inside
theActionM .
Let‚Äôs examine ActionM more carefully:
Prelude&gt; import Web.Scotty
Prelude&gt; import Web.Scotty.Trans
Prelude&gt; :info ActionM
type ActionM = ActionT Data.Text.Internal.Lazy.Text IO
-- Defined in ‚ÄòWeb.Scotty‚Äô</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1582
We can see for ourselves what this liftdid by looking at
theMonadTrans instance for ActionT , which is what ActionM is a
type alias of:
instance MonadTrans (ActionT e)where
lift=ActionT .lift.lift.lift
Part of the niceness here is that ActionT is itself defined in
terms of three more monad transformers. We can see this in
the definition of ActionT :
newtype ActionT e m a=
ActionT {
runAM
::ExceptT
(ActionError e)
(ReaderT ActionEnv
(StateTScottyResponse m))
a
}deriving (Functor,Applicative )
Let‚Äôs first replace the liftforActionT with its definition and
see if it still works:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1583
{-# LANGUAGE OverloadedStrings #-}
moduleScottywhere
importWeb.Scotty
importWeb.Scotty.Internal.Types
(ActionT(..))
importControl.Monad.Trans.Class
importData.Monoid (mconcat)
All the (..)means is that we want to import all the data
constructors of the ActionT type, rather than none or a partic-
ular list of them. You can look into the syntax in more detail
independently if you like. Now for the scotty application itself:
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
(ActionT .lift.lift.lift)
(putStrLn &quot;hello&quot;)
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1584
This should still work! Note that we had to ask for the data
constructor for ActionT from an Internal module because the
implementation is hidden by default. We‚Äôve got three lifts,
one each for ExceptT ,ReaderT , andStateT .
Next we‚Äôll do ExceptT :
instance MonadTrans (ExceptT e)where
lift=ExceptT .liftMRight
To use that in our code, add the following import:
importControl.Monad.Trans.Except
And our app changes into the following:
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
(ActionT
.(ExceptT .liftMRight)
.lift
.lift) (putStrLn &quot;hello&quot;)
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1585
Thenfor ReaderT ,wetakeaganderat Control.Monad.Trans.Reader
in thetransformers library and see the following:
instance MonadTrans (ReaderT r)where
lift=liftReaderT
liftReaderT ::m a-&gt;ReaderT r m a
liftReaderT m=ReaderT (const m)
For reasons, liftReaderT isn‚Äôt exported by transformers , but
we can redefine it ourselves. Add the following to the module:
importControl.Monad.Trans.Reader
liftReaderT ::m a-&gt;ReaderT r m a
liftReaderT m=ReaderT (const m)
Then our app can be defined as follows:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1586
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
(ActionT
.(ExceptT .fmapRight)
.liftReaderT
.lift
) (putStrLn &quot;hello&quot;)
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]
Or instead of liftReaderT , we could‚Äôve done:
.(\m-&gt;ReaderT (const m))
Or:
(ActionT
.(ExceptT .fmapRight)
.ReaderT .const
.lift
) (putStrLn &quot;hello&quot;)</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1587
Now for that last liftoverStateT ! Remembering that it was
the lazy StateT that the type of ActionT mentioned, we see the
following MonadTrans instance:
instance MonadTrans (StateTs)where
lift m=StateT$\s-&gt; do
a&lt;-m
return (a, s)
First, let‚Äôs get our import in place:
importControl.Monad.Trans.State.Lazy
hiding(get)
We needed to hide getbecause scotty already has a diÔ¨Äerent
getfunction defined and we don‚Äôt need the one from StateT.
Then inlining that into our app code:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1588
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
(ActionT
.(ExceptT .fmapRight)
.ReaderT .const
.\m-&gt;StateT(\s-&gt; do
a&lt;-m
return (a, s))
) (putStrLn &quot;hello&quot;)
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]
Note that we needed an outer lambda before the StateT
in order to get the monadic action we were lifting. At this
point, we‚Äôre in the outermost position we can be, and since
ActionM defines ActionT ‚Äôs outermost monadic type as being IO,
that means our putStrLn works fine after all this lifting.
Typically a MonadTrans instance lifts over only one layer at
a time, but scotty abstracts away the underlying structure so
that you don‚Äôt have to care. That‚Äôs why it goes ahead and does
the next three lifts for you. The critical thing to realize here is
that lifting means you‚Äôre embedding an expression in a larger</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1589
context by adding structure that doesn‚Äôt do anything.
MonadTrans instances
Now you see why we have MonadTrans and have a picture of
whatlift, the only method of MonadTrans , does.
Here are some examples of MonadTrans instances:
1.IdentityT
instance MonadTrans IdentityT where
lift=IdentityT
2.MaybeT
instance MonadTrans MaybeTwhere
lift=MaybeT.liftMJust</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1590
lift
::(Monadm)
=&gt;m a-&gt;t m a
(MaybeT.liftMJust)
::Monadm
=&gt;m a-&gt;MaybeTm a
MaybeT
::m (Maybea)-&gt;MaybeTm a
(liftMJust)
::Monadm
=&gt;m a-&gt;m (Maybea)
Roughly speaking, this has taken an m aand lifted it into
aMaybeT context.
Thegeneralpatternwith MonadTrans instancesdemonstrated
byMaybeT is that you‚Äôre usually going to lift the injection
of the known structure (with MaybeT , the known structure
isMaybe) over some Monad. Injection of structure usually
meansreturn , but since with MaybeT we know we want Maybe
structure, we use Just. That transforms an m aintom (T a)
where capital Tis some concrete type you‚Äôre lifting the m
ainto. Then to cap it all oÔ¨Ä, you use the data constructor
for your monad transformer, and the value is now lifted
into the larger context. Here‚Äôs a summary of the stages</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1591
the type of the value goes through:
v::Monadm=&gt;m a
liftMJust::Monadm=&gt;m a-&gt;m (Maybea)
liftMJustv::m (Maybea)
MaybeT(liftMJustv)::MaybeTm a
See if you can work out the types of this one:
3.ReaderT
instance MonadTrans (ReaderT r)where
lift=ReaderT .const
And now, write some instances!
Exercises: Lift More
Keep in mind what these are doing, follow the types, lift till
you drop.
1.You thought you were done with EitherT .
instance MonadTrans (EitherT e)where
lift=undefined
2.OrStateT . This one‚Äôll be more obnoxious. It‚Äôs fine if you‚Äôve
seen this before.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1592
instance MonadTrans (StateTs)where
lift=undefined
Prolific lifting is the failure mode
Apologies to the original authors, but sometimes with the use
of concretely and explicitly typed monad transformers you‚Äôll
see stuÔ¨Ä like this:
addSubWidget ::(YesodSubRoute sub master)
=&gt;sub
-&gt;WidgetT sub master a
-&gt;WidgetT sub' master a
addSubWidget sub w=
domaster&lt;-liftHandler getYesod
letsr=fromSubRoute sub master
i&lt;-WidgetT $lift$lift$lift
$lift$lift$lift
$lift get</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1593
w'&lt;-liftHandler
$toMasterHandlerMaybe sr
(const sub) Nothing
$flip runStateT i $runWriterT
$runWriterT $runWriterT
$runWriterT $runWriterT
$runWriterT $runWriterT
$unWidgetT w
let((((((((a,
body),
title),
scripts),
stylesheets),
style),
jscript),
h),
i')=w'</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1594
WidgetT $ do
tell body
lift$tell title
lift$lift$tell scripts
lift$lift$lift
$tell stylesheets
lift$lift$lift$lift
$tell style
lift$lift$lift$lift$lift
$tell jscript
lift$lift$lift$lift$lift
$lift$tell h
lift$lift$lift$lift
$lift$lift$lift$put i'
return a
Do not write code like this. Especially, do not write code
like this and then proceed to blog about how terrible monad
transformers are.
Wrap it, smack it, pre-lift it
OK, so how do we avoid that horror show? Well, there are a lot
of ways, but one of the most robust and common is newtyp-
ing your Monadstack and abstracting away the representation.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1595
From there, you provide the functionality leveraging the rep-
resentation as part of your API. A good example of this comes
to us from‚Ä¶ scotty .
Let‚Äôs take a gander at the ActionM type we mentioned earlier:
Prelude&gt; import Web.Scotty
-- again, to make the type read more nicely
-- we import some other modules.
Prelude&gt; import Data.Text.Lazy
Prelude&gt; :info ActionM
type ActionM = Web.Scotty.Internal.Types.ActionT Text IO
-- Defined in ‚ÄòWeb.Scotty‚Äô
scotty hides the underlying type by default because you
ordinarily wouldn‚Äôt care or think about it in the course of writ-
ing your application. What scotty does here is good practice.
This design keeps the underlying implementation hidden by
default but lets us import an Internal module to get at the
representation in case we need to:
Prelude&gt; import Web.Scotty.Internal.Types
-- more modules to clean up the types
Prelude&gt; import Control.Monad.Trans.Reader
Prelude&gt; import Control.Monad.Trans.State.Lazy
Prelude&gt; import Control.Monad.Trans.Except
Prelude&gt; :info ActionT</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1596
type role ActionT nominal representational nominal
newtype ActionT e (m :: * -&gt; *) a
= ActionT
{runAM :: ExceptT
(ActionError e)
(ReaderT ActionEnv
(StateT ScottyResponse m))
a}
instance (Monad m, ScottyError e) =&gt; Monad (ActionT e m)
instance Functor m =&gt; Functor (ActionT e m)
instance Monad m =&gt; Applicative (ActionT e m)
What‚Äôs nice about this approach is that it subjects the con-
sumers (which could include yourself) of your type to less
noise within an application. It also doesn‚Äôt require reading
papers written by people trying very hard to impress a thesis
advisor, although poking through prior art for ideas is rec-
ommended. It can reduce or eliminate manual lifting within
theMonadas well. Note that we only had to use liftonce to
perform an I/O action in ActionM even though the underly-
ing implementation has more than one transformer flying
around.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1597
26.10 MonadIO aka zoom-zoom
There‚Äôs more than one way to skin a cat and there‚Äôs more than
one way to lift an action over additional structure. MonadIO is
a diÔ¨Äerent design than MonadTrans because rather than lifting
through one layer at a time, MonadIO is intended to keep lifting
yourIOaction until it is lifted over all structure embedded in
the outermost IOtype. The idea here is that you‚Äôd write liftIO
once and it would instantiate to all of the following types:
liftIO::IOa-&gt;ExceptT eIOa
liftIO::IOa-&gt;ReaderT rIOa
liftIO::IOa-&gt;StateTsIOa
-- As Sir Mix-A-Lot once said,
-- stack 'em up deep
liftIO::IOa-&gt;StateTs (ReaderT rIO) a
liftIO::IOa
-&gt;ExceptT
e
(StateTs (ReaderT rIO))
a
You don‚Äôt have to lift multiple times if you‚Äôre trying to reach
a base (outermost) Monadthat happens to be IO, because you
haveliftIO .</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1598
In thetransformers library, the MonadIO class resides in the
module Control.Monad.IO.Class :
class(Monadm)=&gt;MonadIO mwhere
-- | Lift a computation
-- from the 'IO' monad.
liftIO::IOa-&gt;m a
The commentary within the module is reasonably helpful,
though it doesn‚Äôt highlight what makes MonadIO diÔ¨Äerent from
MonadTrans :
Monads in which IO computations may be embed-
ded. Any monad built by applying a sequence of
monad transformers to the IO monad will be an in-
stance of this class.
Instances should satisfy the following laws, which
state that liftIO is a transformer of monads:
1.liftIO.return=return
2.liftIO(m&gt;&gt;=f)=
liftIO m &gt;&gt;=(liftIO .f)
Let us modify the scotty example app to print a string:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1599
{-# LANGUAGE OverloadedStrings #-}
moduleMainwhere
importWeb.Scotty
importControl.Monad.IO.Class
importData.Monoid (mconcat)
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
liftIO (putStrLn &quot;hello&quot;)
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]
If you then run mainin a REPL or build a binary and execute
it, you‚Äôll be able to request a response from the server using
your web browser (as we showed you earlier) or a command
line application like curl. If you used a browser and see ‚Äúhello‚Äù
printed more than once, it‚Äôs likely your browser made the
request more than once. You shouldn‚Äôt see this behavior if
you test it with curl.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1600
Example MonadIO instances
1.IdentityT
instance (MonadIO m)
=&gt;MonadIO (IdentityT m)where
liftIO=IdentityT .liftIO
2.EitherT
instance (MonadIO m)
=&gt;MonadIO (EitherT e m)where
liftIO=lift.liftIO
Exercises: Some Instances
1.MaybeT
instance (MonadIO m)
=&gt;MonadIO (MaybeTm)where
liftIO=undefined
2.ReaderT
instance (MonadIO m)
=&gt;MonadIO (ReaderT r m)where
liftIO=undefined
3.StateT</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1601
instance (MonadIO m)
=&gt;MonadIO (StateTs m)where
liftIO=undefined
Hint: your instances should be simple.
26.11 Monad transformers in use
MaybeT in use
These are some example of MaybeT in use; we will not comment
upon them and instead let you research them further yourself
if you want. Origins of the code are noted in the samples.
-- github.com/wavewave/hoodle-core
recentFolderHook
::MainCoroutine (MaybeFilePath )
recentFolderHook = do
xstate&lt;-get
(r::MaybeFilePath )&lt;-runMaybeT $ do
hset&lt;-hoist (view hookSet xstate)
rfolder &lt;-
hoist (H.recentFolderHook hset)
liftIO rfolder
return r</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1602
-- github.com/devalot/hs-exceptions
-- src/maybe.hs
addT::FilePath
-&gt;FilePath
-&gt;IO(MaybeInteger)
addTf1 f2=runMaybeT $ do
s1&lt;-sizeT f1
s2&lt;-sizeT f2
return (s1 +s2)</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1603
-- wavewave/ghcjs-dom-delegator
-- example/Example.hs
main::IO()
main= do
clickbarref &lt;-
asyncCallback1 AlwaysRetain clickbar
clickbazref &lt;-
asyncCallback1 AlwaysRetain clickbaz
r&lt;-runMaybeT $ do
doc&lt;-MaybeTcurrentDocument
bar&lt;-lift.toJSRef
=&lt;&lt;MaybeT
(documentQuerySelector doc
(&quot;.bar&quot;::JSString ))
baz&lt;-lift.toJSRef
=&lt;&lt;MaybeT
(documentQuerySelector doc
(&quot;.baz&quot;::JSString ))
lift$ do
ref&lt;-newObj
del&lt;-delegator ref
addEvent bar &quot;click&quot; clickbarref
addEvent baz &quot;click&quot; clickbazref
caserof
Nothing -&gt;print&quot;something wrong&quot;
Just_ -&gt;print&quot;welldone&quot;</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1604
Temporary extension of structure
Although we commonly think of monad transformers as being
used to define one big context for an application, particularly
with things like ReaderT , there are other ways. One pattern that
is often useful is temporarily extending additional structure
to avoid boilerplate. Here‚Äôs an example using plain old Maybe
andscotty :</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1605
{-# LANGUAGE OverloadedStrings #-}
moduleMainwhere
importControl.Monad.IO.Class
importData.Maybe (fromMaybe )
importData.Text.Lazy (Text)
importWeb.Scotty
param'::Parsable a
=&gt;Text-&gt;ActionM (Maybea)
param'k=rescue ( Just&lt;$&gt;param k)
(const (return Nothing))
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam'&lt;-param'&quot;word&quot;
letbeam=fromMaybe &quot;&quot;beam'
i&lt;-param'&quot;num&quot;
liftIO$print (i ::MaybeInteger)
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1606
This works well enough but could get tedious in a hurry if
we had a bunch of stuÔ¨Ä that returned ActionM (Maybe ...) and
we wanted to short-circuit the moment any of them failed.
So, we do something similar but with MaybeT and building up
more data in one go:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1607
{-# LANGUAGE OverloadedStrings #-}
moduleMainwhere
importControl.Monad.IO.Class
importControl.Monad.Trans.Class
importControl.Monad.Trans.Maybe
importData.Maybe (fromMaybe )
importData.Text.Lazy (Text)
importWeb.Scotty
param'::Parsable a
=&gt;Text-&gt;MaybeTActionM a
param'k=MaybeT$
rescue ( Just&lt;$&gt;param k)
(const (return Nothing))
typeReco=
(Integer,Integer,Integer,Integer)
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
reco&lt;-runMaybeT $ do
a&lt;-param'&quot;1&quot;
liftIO$print a
b&lt;-param'&quot;2&quot;
c&lt;-param'&quot;3&quot;
d&lt;-param'&quot;4&quot;
(lift.lift)$print b
return ((a, b, c, d) ::Reco)
liftIO$print reco
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1608
Some important things to note here:
1.We only had to use liftIO once, even in the presence of
additional structure, whereas with liftwe had to lift twice
to address MaybeT andActionM .
2.The one big bind of the MaybeT means we could take the
existence of ùëé,ùëè,ùëê, andùëëfor granted in that context, but
therecovalue itself is Maybe Reco because any part of the
computation could fail in the absence of the needed pa-
rameter.
3.It knows what monad we mean for that doblock because
of therunMaybeT in front of the do. This serves the dual
purpose of unpacking the MaybeT into an ActionM (Maybe
Reco)which we can bind out into Maybe Reco .
ExceptT aka EitherT in use
The example with Maybeandscotty may not have totally satis-
fied because the failure mode isn‚Äôt helpful to an end-user ‚Äî
all they know is ‚ÄúNothing.‚Äù Accordingly, Maybeis usually some-
thing that should get handled early and often in a place local
to where it was produced so that you avoid mysterious Nothing
values floating around and short-circuiting your code. They‚Äôre
not something you want to return to end-users either. Fortu-
nately, we have Either for more descriptive short-circuiting
computations!</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1609
Scotty, again
We‚Äôll use scotty again to demonstrate this. Once again, we‚Äôll
show you a plain example:
{-# LANGUAGE OverloadedStrings #-}
moduleMainwhere
importControl.Monad.IO.Class
importData.Text.Lazy (Text)
importWeb.Scotty
param'::Parsable a
=&gt;Text-&gt;ActionM (EitherStringa)
param'k=
rescue ( Right&lt;$&gt;param k)
(const
(return
(Left$&quot;The key: &quot;
++show k
++&quot; was missing!&quot; )))</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1610
main=scotty3000$ do
get&quot;/:word&quot; $ do
beam&lt;-param&quot;word&quot;
a&lt;-param'&quot;1&quot;
leta'=either (const 0) id a
liftIO$print (a ::EitherStringInt)
liftIO$print (a' ::Int)
html$
mconcat [ &quot;<h1>Scotty, &quot; ,
beam,
&quot; me up!</h1>&quot; ]
Note that we had to manually fold the Either if we wanted
to address the desired Intvalue. Try to avoid having default
fallback values in real code though. This could get nutty in
a hurry if we had many things we were pulling out of the
parameters.
Let‚Äôs do that but with ExceptT fromtransformers . Remember,
ExceptT is another name for EitherT :</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1611
{-# LANGUAGE OverloadedStrings #-}
moduleMainwhere
importControl.Monad.IO.Class
importControl.Monad.Trans.Class
importControl.Monad.Trans.Except
importData.Text.Lazy (Text)
import qualified Data.Text.Lazy asTL
importWeb.Scotty</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1612
param'::Parsable a
=&gt;Text-&gt;ExceptT StringActionM a
param'k=
ExceptT $
rescue ( Right&lt;$&gt;param k)
(const
(return
(Left$&quot;The key: &quot;
++show k
++&quot; was missing!&quot; )))
typeReco=
(Integer,Integer,Integer,Integer)
tshow=TL.pack.show</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1613
main=scotty3000$ do
get&quot;/&quot;$ do
reco&lt;-runExceptT $ do
a&lt;-param'&quot;1&quot;
liftIO$print a
b&lt;-param'&quot;2&quot;
c&lt;-param'&quot;3&quot;
d&lt;-param'&quot;4&quot;
(lift.lift)$print b
return ((a, b, c, d) ::Reco)
caserecoof
(Lefte)-&gt;text (TL.pack e)
(Rightr)-&gt;
html$
mconcat [ &quot;<h1>Success! Reco was: &quot; ,
tshow r,
&quot;</h1>&quot;]
If you pass it a request like:
http://localhost:3000/?1=1
It‚Äôll ask for the parameter 2because that was the next param
you asked for after 1.
If you pass it a request like:
http://localhost:3000/?1=1&amp;2=2&amp;3=3&amp;4=4</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1614
You should see the response in your browser or terminal
of:
Success! Reco was: (1,2,3,4)
As before, we get to benefit from one big bind under the
ExceptT .
Slightly more advanced code
From some code7by Sean Chalmers8.
Some context for the EitherT application you‚Äôll see:
typeEta=EitherT SDLErrIOa
mkWindow ::HasSDLErr m=&gt;
String
-&gt;CInt-&gt;CInt
-&gt;mSDL.Window
mkRenderer ::HasSDLErr m
=&gt;SDL.Window-&gt;mSDL.Renderer
7https://github.com/mankyKitty/Meteor/
8http://mankykitty.github.io/</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1615
hasSDLErr ::(MonadIO m,MonadError e m)
=&gt;(a-&gt;b)
-&gt;(a-&gt;Bool)
-&gt;e-&gt;IOa-&gt;m b
hasSDLErr g f e a =
liftIO a
&gt;&gt;=\r-&gt;
bool (return $g r)
(throwError e) $f r
class(MonadIO m,MonadError SDLErrm)
=&gt;HasSDLErr mwhere
decide ::(a-&gt;Bool)
-&gt;SDLErr-&gt;IOa-&gt;m a
decide' ::(Eqn,Numn)
=&gt;SDLErr-&gt;IOn-&gt;m()
instance HasSDLErr
(EitherT SDLErrIO)where
decide =hasSDLErr id
decide' =hasSDLErr (const ()) (/=0)
Then in use:</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1616
initialise ::Et(SDL.Window,SDL.Renderer )
initialise = do
initSDL [ SDL.SDL_INIT_VIDEO ]
win&lt;-
mkWindow &quot;Meteor!&quot;
screenHeight
screenWidth
rdr&lt;-mkRenderer win
return (win,rdr)
createMeteor ::IO(EitherSDLErrMeteorS)
createMeteor = do
eM&lt;-runEitherT initialise
return$mkMeteor &lt;$&gt;eM
where
emptyBullets =V.empty
mkMeteor (w,r) =MeteorS w r
getInitialPlayer
emptyBullets
getInitialMobs
False</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1617
26.12 Monads do not commute
Remember that monads in general do not commute, and
you aren‚Äôt guaranteed something sensible for every possible
combination of types. The kit we have for constructing and
using monad transformers is useful but is not a license to not
think!
Hypothetical Exercise
Consider ReaderT r Maybe andMaybeT (Reader r) ‚Äî are these
types equivalent? Do they do the same thing? Try writing
otherwise similar bits of code with each and see if you can
prove they‚Äôre the same or diÔ¨Äerent.
26.13 Transform if you want to
If you find monad transformers difficult or annoying, then
don‚Äôt bother! Most of the time you can get by with liftIO and
plainIOactions, functions, Maybevalues, etc. Do the simplest
(for you) thing first when mapping out something new or un-
familiar. It‚Äôs better to let more structured formulations of
programs fall out naturally from having kicked around some-
thing uncomplicated than to blow out your working memory
budget in one go. Don‚Äôt worry about seeming unsophisticated;</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1618
in our opinion, being happy and productive is better than
being fancy.
Keep it basic in your first attempt. Never make it more
elaborate initially than is strictly necessary. You‚Äôll figure out
when the transformer variant of a type will save you complex-
ity in the process of writing your programs. We have taken
you through these topics because you‚Äôll need at least a passing
familiarity to use modern Haskell libraries or frameworks, but
it‚Äôs not a design dictate you must follow.
26.14 Chapter Exercises
Write the code
1.rDecis a function that should get its argument in the con-
text ofReader and return a value decremented by one.
rDec::Numa=&gt;Readera a
rDec=undefined
Prelude&gt; import Control.Monad.Trans.Reader
Prelude&gt; runReader rDec 1
0
Prelude&gt; fmap (runReader rDec) [1..10]
[0,1,2,3,4,5,6,7,8,9]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1619
Note that ‚ÄúReader‚Äù from transformers isReaderT ofIdentity
and that runReader is a convenience function throwing
awaythemeaninglessstructureforyou. Playwith runReaderT
if you like.
2.Once you have an rDecthat works, make it and any inner
lambdas pointfree if that‚Äôs not already the case.
3.rShowisshow, but in Reader .
rShow::Showa
=&gt;ReaderT aIdentity String
rShow=undefined
Prelude&gt; runReader rShow 1
&quot;1&quot;
Prelude&gt; fmap (runReader rShow) [1..10]
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;]
4.Once you have an rShowthat works, make it pointfree.
5.rPrintAndInc will first print the input with a greeting, then
return the input incremented by one.
rPrintAndInc ::(Numa,Showa)
=&gt;ReaderT aIOa
rPrintAndInc =undefined</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1620
Prelude&gt; runReaderT rPrintAndInc 1
Hi: 1
2
Prelude&gt; traverse (runReaderT rPrintAndInc) [1..10]
Hi: 1
Hi: 2
Hi: 3
Hi: 4
Hi: 5
Hi: 6
Hi: 7
Hi: 8
Hi: 9
Hi: 10
[2,3,4,5,6,7,8,9,10,11]
6.sPrintIncAccum first prints the input with a greeting, then
puts the incremented input as the new state, and returns
the original input as a String .
sPrintIncAccum ::(Numa,Showa)
=&gt;StateTaIOString
sPrintIncAccum =undefined
Prelude&gt; runStateT sPrintIncAccum 10
Hi: 10</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1621
(&quot;10&quot;,11)
Prelude&gt; mapM (runStateT sPrintIncAccum) [1..5]
Hi: 1
Hi: 2
Hi: 3
Hi: 4
Hi: 5
[(&quot;1&quot;,2),(&quot;2&quot;,3),(&quot;3&quot;,4),(&quot;4&quot;,5),(&quot;5&quot;,6)]
Fix the code
The code won‚Äôt typecheck as written; fix it so that it does. Feel
free to add imports if it provides something useful. Functions
will be used that we haven‚Äôt introduced. You‚Äôre not allowed
to change the types asserted. You may have to fix the code in
more than one place.
importControl.Monad.Trans.Maybe
importControl.Monad
isValid ::String-&gt;Bool
isValid v='!'<code>elem</code> v</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1622
maybeExcite ::MaybeTIOString
maybeExcite = do
v&lt;-getLine
guard$isValid v
return v
doExcite ::IO()
doExcite = do
putStrLn &quot;say something excite!&quot;
excite&lt;-maybeExcite
caseexciteof
Nothing -&gt;putStrLn &quot;MOAR EXCITE&quot;
Juste-&gt;
putStrLn
(&quot;Good, was very excite: &quot; ++e)
Hit counter
We‚Äôre going to provide an initial scaÔ¨Äold of a scotty application
which counts hits to specific URIs. It also prefixes the keys
with a prefix defined on app initialization, retrieved via the
command line arguments.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1623
{-# LANGUAGE OverloadedStrings #-}
moduleMainwhere
importControl.Monad.Trans.Class
importControl.Monad.Trans.Reader
importData.IORef
import qualified Data.Map asM
importData.Maybe (fromMaybe )
importData.Text.Lazy (Text)
import qualified Data.Text.Lazy asTL
importSystem.Environment (getArgs)
importWeb.Scotty.Trans
dataConfig=
Config{
-- that's one, one click!
-- two...two clicks!
-- Three BEAUTIFUL clicks! ah ah ahhhh
counts::IORef(M.MapTextInteger)
, prefix ::Text
}
StuÔ¨Ä inside ScottyT is, except for things that escape via IO,
eÔ¨Äectively read-only so we can‚Äôt use StateT . It would overcom-</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1624
plicate things to attempt to do so and you should be using a
proper database for production applications.
typeScotty=
ScottyT Text(ReaderT ConfigIO)
typeHandler =
ActionT Text(ReaderT ConfigIO)
bumpBoomp ::Text
-&gt;M.MapTextInteger
-&gt;(M.MapTextInteger,Integer)
bumpBoomp k m=undefined
app::Scotty()
app=
get&quot;/:key&quot; $ do
unprefixed &lt;-param&quot;key&quot;
letkey'=mappend undefined unprefixed
newInteger &lt;-undefined
html$
mconcat [ &quot;<h1>Success! Count was: &quot;
,TL.pack$show newInteger
,&quot;</h1>&quot;
]</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1625
main::IO()
main= do
[prefixArg] &lt;-getArgs
counter &lt;-newIORef M.empty
letconfig=undefined
runR=undefined
scottyT 3000runR app
Code is missing and broken. Your task is to make it work,
whatever is necessary.
You should be able to run the server from inside of GHCi,
passing arguments like so:
Prelude&gt; :main lol
Setting phasers to stun... (port 3000) (ctrl-c to quit)
You could also build a binary and pass the arguments from
your shell, but do what you like. Once it‚Äôs running, you should
be able to bump the counts like so:
$ curl localhost:3000/woot</p>
<h1 id="success-count-was-1"><a class="header" href="#success-count-was-1">Success! Count was: 1</a></h1>
$ curl localhost:3000/woot
<h1 id="success-count-was-2"><a class="header" href="#success-count-was-2">Success! Count was: 2</a></h1>
$ curl localhost:3000/blah
<h1 id="success-count-was-1-1"><a class="header" href="#success-count-was-1-1">Success! Count was: 1</a></h1>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1626
Note that the underlying ‚Äúkey‚Äù used in the counter when
youGET /woot is&quot;lolwoot&quot; because we passed ‚Äùlol‚Äù to main. For
a giggle, try the URI for one of the keys in your browser and
mash refresh a bunch.
If you get stuck, consider checking for examples such as the
reader file in scotty ‚Äôs examples directory of the git repository.
Morra
1.Write the game Morra9usingStateT andIO. The state
being accumulated is the score of the player and the com-
puter AI the player is playing against. To start, make the
computer choose its play randomly.
On exit, report the scores for the player and the computer,
congratulating the winner.
2.Add a human vs. human mode to the game with inter-
stitial screens between input prompts so the players can
change out of the hotseat without seeing the other player‚Äôs
answer.
3.Improve the computer AI slightly by making it remem-
ber 3-grams of the player‚Äôs behavior, adjusting its answer
instead of deciding randomly when the player‚Äôs behavior
matches a known behavior. For example:
9You can find descriptions of the rules and gameplay of the Morra game online.</p>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1627
-- p is Player
-- c is Computer
-- Player is odds, computer is evens.
P: 1
C: 1</p>
<ul>
<li>C wins
P: 2
C: 1</li>
<li>P wins
P: 2
C: 1</li>
<li>P wins
At this point, the computer should register the pattern (1,
2, 2) player picked 2 after 1 and 2. Next time the player
picks 1 followed by 2, the computer should assume the
next play will be 2 and pick 2 in order to win.
4.The 3-gram thing is pretty simple and dumb. Humans are
still bad at being random; they often have sub-patterns
in their moves.
26.15 Defintion
In general, the term leak refers to something that consumes
a resource in a way that renders it unusable or irrecoverable;</li>
</ul>
<p>CHAPTER 26. STACK ‚ÄòEM UP 1628
specifically, when we talk about a memory leak, we‚Äôre talking
about consuming memory in a way that renders it not usable
or recoverable by other programs or parts of a program. This
can happen if your program is written in such a way that it
accumulates large amounts of unevaluated thunks or holds in
memory a reference to something that it‚Äôs not using anymore.
The garbage collector cannot sweep those things away, so the
amount of memory a program is using can increase, some-
times rapidly and alarmingly, while the amount of available
or free memory decreases.
26.16 Follow-up resources
1.Parallel and Concurrent Programming in Haskell; Simon
Marlow; http://chimera.labs.oreilly.com/books/1230000000929</p>
<p>Chapter 27
Nonstrictness
Progress doesn‚Äôt come
from early risers ‚Äî
progress is made by lazy
men looking for easier
ways to do things.
Robert A. Heinlein
1629</p>
<p>CHAPTER 27. NONSTRICTNESS 1630
27.1 Laziness
This chapter concerns the ways in which Haskell programs are
evaluated. We‚Äôve addressed this a bit in previous chapters, for
example, in the Folds chapter where we went into some detail
about how folds evaluate. In this chapter, our goal is to give
you enough information about Haskell‚Äôs evaluation strategy
that you‚Äôll be able to reason confidently about the reduction
process of your expressions and introduce stricter evaluation
where that is wanted.
Most programming languages have strict evaluation seman-
tics. Haskell technically has nonstrict ‚Äî not lazy ‚Äî evaluation,
but the diÔ¨Äerence between lazy and nonstrict is not practi-
cally relevant, so you‚Äôll hear Haskell referred to as either a lazy
language or a nonstrict one.
A very rough outline of Haskell‚Äôs evaluation strategy is this:
most expressions are only reduced, or evaluated, when neces-
sary. When the evaluation process begins, a thunk is created
for each expression. We‚Äôll go into more detail about this in
the chapter, but a thunk is like a placeholder in the underly-
ing graph of the program. Whatever expression the thunk is
holding a place for can be evaluated when necessary, but if
it‚Äôs never needed, it never gets reduced, and then the garbage
collector comes along and sweeps it away. If it is evaluated,
because it‚Äôs in a graph, it can be often shared between expres-
sions ‚Äî that is, once x = 1 + 1 has been evaluated, anytime ùë•</p>
<p>CHAPTER 27. NONSTRICTNESS 1631
is forced it does not have to be re-computed.
This is the laziness of Haskell: don‚Äôt do more work than
needed. Don‚Äôt evaluate until necessary. Don‚Äôt re-evaluate if
you don‚Äôt have to. We‚Äôll go through the details of how this
works, exceptions to the general principles, and how to control
the evaluation by adding strictness where desired.
Specifically, we will:
‚Ä¢define call-by-name and call-by-need evaluation;
‚Ä¢explain the main eÔ¨Äects of nonstrict evaluation;
‚Ä¢live the Thunk Life1;
‚Ä¢consider the runtime behavior of non-strict code in terms
of sharing;
‚Ä¢developmethodsforobservingsharingbehaviorandmea-
suring program efficiency;
‚Ä¢bottom out with the bottoms.
27.2 Observational Bottom Theory
In our discussion about nonstrictness in Haskell, we‚Äôre going
to be talking about bottom2a lot. This is partly because non-
strictness is defined by the ability to evaluate expressions that
1We love you, Jesse!
2Observational bottom theory is not a real thing. Do not email us about this.</p>
<p>CHAPTER 27. NONSTRICTNESS 1632
have bindings which are bottom in them, as long as the bot-
tom itself is never forced. Bottoms also give us a convenient
method of observing evaluation in Haskell. By causing the
program to halt immediately with an error, bottom serves as
our first means of understanding nonstrictness in Haskell. You
probably recall we have used this trick before.
Standards and obligations
Technically Haskell is only obligated to be nonstrict, not lazy.
A truly lazy language memoizes, or holds in memory, the
results of all the functions it does evaluate, and, outside of toy
programs, this tends to use unacceptably large amounts of
memory. Implementations of Haskell, such as GHC Haskell,
are only obligated to be nonstrict such that they have the same
behavior with respect to bottom; they are not required to take
a particular approach to how the program executes or how
efficiently it does so.
The essence of nonstrictness is that you can have an expres-
sion which results in a value, even if bottom or infinite data
lurks within. For example, the following would only work in a
nonstrict language:
Prelude&gt; fst (1, undefined)
1
Prelude&gt; snd (undefined, 2)
2</p>
<p>CHAPTER 27. NONSTRICTNESS 1633
The idea is that any given implementation of nonstrictness
is acceptable as long as it respects when it‚Äôs supposed to return
a value successfully or bottom out.
27.3 Outside in, inside out
Strict languages evaluate inside out; nonstrict languages like
Haskell evaluate outside in. Outside in means that evaluation
proceeds from the outermost parts of expressions and works
inward based on what values are forced. This means the order
of evaluation and what gets evaluated can vary depending on
inputs.
The following example is written in a slightly arcane way
to make the evaluation order more obvious:
possiblyKaboom =
\f-&gt;f fst snd ( 0, undefined)
-- booleans in lambda form
true::a-&gt;a-&gt;a
true=\a-&gt;(\b-&gt;a)
false::a-&gt;a-&gt;a
false=\a-&gt;(\b-&gt;b)
When we apply possiblyKaboom totrue,trueis theùëì,fstis
theùëé, andsndis theùëè. Semantically, case matches, guards</p>
<p>CHAPTER 27. NONSTRICTNESS 1634
expressions, and if-then-else expressions could all be rewritten
in this manner (they are not in fact decomposed this way by the
compiler), by nesting lambdas and reducing from the outside
in:
(\f-&gt;
f fst snd ( 0, undefined))
(\a-&gt;(\b-&gt;a))
(\a-&gt;(\b-&gt;a)) fst snd ( 0, undefined)
(\b-&gt;fst) snd ( 0, undefined)
fst(0, undefined)
0
The next example is written in more normal Haskell but
will return the same result. When we apply the function to
Truehere, we case on the Trueto return the first value of the
tuple:
possiblyKaboom b=
casebof
True-&gt;fst tup
False-&gt;snd tup
wheretup=(0, undefined)
The bottom is inside a tuple, and the tuple is bound inside
of a lambda that cases on a boolean value and returns either the
first or second element of the tuple. Since we start evaluating</p>
<p>CHAPTER 27. NONSTRICTNESS 1635
from the outside, as long as this function is only ever applied
toTrue, that bottom will never cause a problem. However, at
the risk of stating the obvious, we do not encourage you to
write programs with bottoms lying around willy-nilly.
When we say evaluation works outside in, we‚Äôre talking
about evaluating a series of nested expressions, and not only
are we starting from the outside and working in, but we‚Äôre also
only evaluating some of the expressions some of the time. In
Haskell, we evaluate expressions when we need them rather
than when they are first referred to or constructed. This is one
of the ways in which nonstrictness makes Haskell expressive
‚Äî we can refer to values before we‚Äôve done the work to create
them.
This pattern applies to data structures and lambdas alike.
You‚Äôve already seen the eÔ¨Äects of outside-in evaluation in the
chapter on folds. Outside-in evaluation is why we can take the
length of a list without touching any of the contents. Consider
the following:
-- using an old definition of foldr
foldrk z xs=go xs
where
go[]=z
go (y:ys)=y <code>k</code> go ys
c=foldr const 'z'['a'..'e']</p>
<p>CHAPTER 27. NONSTRICTNESS 1636
Expanding the foldrinùëê:
c=const'z'&quot;abcde&quot; =go&quot;abcde&quot;
where
go[]='z'
go ('a':&quot;bcde&quot;)='a'<code>const</code> go &quot;bcde&quot;
-- So the first step of evaluating
-- of the fold here is:
const'a'(go&quot;bcde&quot;)
constx y =x
const'a'(go&quot;bcde&quot;)='a'
The second argument and step of the fold is never evalu-
ated:
const'a'_ ='a'
It doesn‚Äôt even matter if the next value is bottom:
Prelude&gt; foldr const 'z' ['a', undefined]
'a'
This is outside-in showing itself. The constfunction was in
the outermost position so it was evaluated first.</p>
<p>CHAPTER 27. NONSTRICTNESS 1637
27.4 What does the other way look like?
In strict languages, you cannot ordinarily bind a computa-
tion to a name without having already done all the work to
construct it.
We‚Äôll use this example program to compare inside-out and
outside-in (strict and non-strict) evaluation strategies:
moduleOutsideIn where
hypo::IO()
hypo= do
letx::Int
x=undefined
s&lt;-getLine
casesof
&quot;hi&quot;-&gt;print x
_ -&gt;putStrLn &quot;hello&quot;
For a strict language, this is a problem. A strict language
cannot evaluate hyposuccessfully unless the ùë•isn‚Äôt bottom.
This is because strict languages will force the bottom before
binding ùë•. A strict language is evaluating each binding as it
comes into scope, not when a binding is used.
In nonstrict Haskell, you can probably guess how this‚Äôll go:
Prelude&gt; hypo</p>
<p>CHAPTER 27. NONSTRICTNESS 1638
s
hello
Prelude&gt; hypo
hi
*** Exception: Prelude.undefined
The idea is that evaluation is driven by demand, not by
construction. We don‚Äôt get the exception unless we‚Äôre forcing
evaluation of ùë•‚Äî outside in.
27.5 Can we make Haskell strict?
Let‚Äôs see if we can replicate the results of a strict language,
though, which will give us a good picture of how Haskell is
diÔ¨Äerent. We can add strictness here in the following manner:
hypo'::IO()
hypo'= do
letx::Integer
x=undefined
s&lt;-getLine
casex <code>seq</code> s of
&quot;hi&quot;-&gt;print x
_ -&gt;putStrLn &quot;hello&quot;
Running it will give this result:</p>
<p>CHAPTER 27. NONSTRICTNESS 1639
Prelude&gt; hypo'
asd
*** Exception: Prelude.undefined
Why? Because this little seqfunction magically forces eval-
uation of the first argument if and when the second argument
has to be evaluated. Adding seqmeans that anytime ùë†is evalu-
ated,ùë•must also be evaluated. We‚Äôll get into more detail in a
moment.
One thing to note before we investigate seqis that we man-
aged to run getLine before the bottom got evaluated, so this
still isn‚Äôt quite what a strict language would‚Äôve done. Case
expressions are in general going to force evaluation. This
makes sense if you realize it has to evaluate the expression to
discriminate on the cases. A small example to demonstrate:
letb= ???
casebof
True-&gt; ...
False
Hereùëècould be pretty much anything. It must evaluate ùëè
to find out if the expression results in TrueorFalse.</p>
<p>CHAPTER 27. NONSTRICTNESS 1640
seq and ye shall find
Before we move any further with making Haskell stricter, let‚Äôs
talk about seqa little bit. One thing is that the type is, uh, a bit
weird:
seq::a-&gt;b-&gt;b
Clearly there‚Äôs more going on here than flip const . It might
help to know that in some old versions of Haskell, it used to
have the type:
seq::Evala=&gt;a-&gt;b-&gt;b
Evalis short for evaluation to weak head normal form, and
it provided a method for forcing evaluation. Instances were
provided for all the types in base. It was elided in part so you
could use seqin your code without churning your polymor-
phic type variables and forcing a bunch of changes. With
respect to bottom, seqis defined as behaving in the following
manner:
seqbottom b =bottom
seqliterallyAnythingNotBottom b =b
Now why does seqlook like const‚Äôs gawky cousin? Because
evaluation in Haskell is demand driven, we can‚Äôt guarantee that
something will ever be evaluated period . Instead we have to</p>
<p>CHAPTER 27. NONSTRICTNESS 1641
create links between nodes in the graph of expressions where
forcing one expression will force yet another expression. Let‚Äôs
look at another example:
Prelude&gt; :{
*Main| let wc x z =
*Main| let y =
*Main| undefined <code>seq</code> 'y' in x
*Main| :}
Prelude&gt; foldr wc 'z' ['a'..'e']
'a'
Prelude&gt; foldr (flip wc) 'z' ['a'..'e']
'z'
We never evaluated ùë¶, so we never forced the bottom. How-
ever, we can lash yet another data dependency from ùë¶toùë•:
Prelude&gt; let bot = undefined
Prelude&gt; :{
*Main| let wc x z =
*Main| let y =
*Main| bot <code>seq</code> 'y'
*Main| in y <code>seq</code> x
*Main| :}
Prelude&gt; foldr wc 'z' ['a'..'e']
*** Exception: Prelude.undefined
Prelude&gt; foldr (flip wc) 'z' ['a'..'e']</p>
<p>CHAPTER 27. NONSTRICTNESS 1642
*** Exception: Prelude.undefined
Previously the evaluation dependency was between the
bottom value and ùë¶:
undefined <code>seq</code> y
-- forcing y necessarily forces undefined
y -&gt; undefined
Changing the expression as we did caused the following to
happen:
undefined <code>seq</code> y <code>seq</code> x
-- forcing x necessarily forces y
-- forcing y necessarily forces undefined
x -&gt; y -&gt; undefined
We think of this as a chain reaction.
All we can do is chuck a life raft from one value to another
as a means of saying, ‚Äúif you want to get him, you gotta get
through me!‚Äù We can even set our life-raft buddies adrift!
Check it out:</p>
<p>CHAPTER 27. NONSTRICTNESS 1643
notGonnaHappenBru ::Int
notGonnaHappenBru =
letx=undefined
y=2
z=(x <code>seq</code> y <code>seq</code> 10,11)
insnd z
The above will not bottom out! Our life-raft buddies are
bobbing in the ocean blue, with no tugboat evaluator to pull
them in.
seq and weak head normal form
Whatseqdoes is evaluate your expression up to weak head nor-
mal form. We‚Äôve discussed it before, but if you‚Äôd like a deeper
investigation and contrast of weak head normal form and nor-
mal form, we strongly recommend Simon Marlow‚Äôs Parallel
and Concurrent Programming in Haskell3. WHNF evaluation
means it stops at the first data constructor or lambda. Let‚Äôs
test that hypothesis!
Prelude&gt; let dc = (,) undefined undefined
Prelude&gt; let noDc = undefined
Prelude&gt; let lam = _ -&gt; undefined
Prelude&gt; dc <code>seq</code> 1
1
3http://chimera.labs.oreilly.com/books/1230000000929</p>
<p>CHAPTER 27. NONSTRICTNESS 1644
Prelude&gt; noDc <code>seq</code> 1
*** Exception: Prelude.undefined
Prelude&gt; lam <code>seq</code> 1
1
Right-o. No surprises, right? Right? Okay.
Sincedchas a data constructor, seqdoesn‚Äôt need to care
about the values inside that constructor; weak head normal
form evaluation only requires it to evaluate the constructor.
On the other hand, noDchas no data constructor or lambda
outside the value, so there‚Äôs no head for the evaluation to stop
at. Finally, lamhas a lambda outside the expression which has
the same eÔ¨Äect on evaluation as a data constructor does.
Case matching also chains evaluation
This forcing behavior happens already without seq! For ex-
ample, when you case or pattern match on something, you‚Äôre
forcing the value you pattern matched on because it doesn‚Äôt
know which data constructor is relevant until it is evaluated
to the depth required to yield the depth of data constructors
you pattern matched. Let‚Äôs look at an example:</p>
<p>CHAPTER 27. NONSTRICTNESS 1645
dataTest=
ATest2
|BTest2
deriving (Show)
dataTest2=
CInt
|DInt
deriving (Show)
forceNothing ::Test-&gt;Int
forceNothing _ =0
forceTest ::Test-&gt;Int
forceTest (A_)=1
forceTest (B_)=2
forceTest2 ::Test-&gt;Int
forceTest2 (A(Ci))=i
forceTest2 (B(Ci))=i
forceTest2 (A(Di))=i
forceTest2 (B(Di))=i
We‚Äôll test forceNothing first:
Prelude&gt; forceNothing undefined</p>
<p>CHAPTER 27. NONSTRICTNESS 1646
0
Prelude&gt; forceNothing (A undefined)
0
It‚Äôll never bottom out because it never forces anything. It‚Äôs
just a constant value that drops its argument on the floor. What
aboutforceTest ?
Prelude&gt; forceTest (A undefined)
1
Prelude&gt; forceTest (B undefined)
2
Prelude&gt; forceTest undefined
*** Exception: Prelude.undefined
We only get a bottom when the outermost Testvalue is
bottom because that‚Äôs the only value whose data constructors
we‚Äôre casing on. And then with forceTest2 :
Prelude&gt; forceTest2 (A (C 0))
0
Prelude&gt; forceTest2 (A (C undefined))
*** Exception: Prelude.undefined
Prelude&gt; forceTest2 (A undefined)
*** Exception: Prelude.undefined</p>
<p>CHAPTER 27. NONSTRICTNESS 1647
Prelude&gt; forceTest2 undefined
*** Exception: Prelude.undefined
There we go: outside -&gt; in.
Core Dump
Not the usual core dump you might be thinking of. In this
case, we‚Äôre talking about the underlying language that GHC
Haskell gets simplified to after the compiler has desugared our
code.
Our first means of determining strictness was by injecting
bottoms into our expressions and observing the evaluation.
Injecting bottoms everywhere allows us to see clearly what‚Äôs
being evaluated strictly and what‚Äôs not. Our second means of
determining strictness in Haskell is examining GHC Core4.
Here‚Äôs the example we‚Äôll be working with:
moduleCoreDump where
discriminatory ::Bool-&gt;Int
discriminatory b=
casebof
False-&gt;0
True-&gt;1
4https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType</p>
<p>CHAPTER 27. NONSTRICTNESS 1648
Load this up in GHCi in the following manner:
Prelude&gt; :set -ddump-simpl
Prelude&gt; :l code/coreDump.hs
[1 of 1] Compiling CoreDump
================ Tidy Core ==============
... some noise...
You should then get the following GHC Core output:
discriminatory ::Bool-&gt;Int
[GblId,Arity=1,
Caf=NoCafRefs ,
Str=DmdType]
discriminatory =
(b_aZJ::Bool)-&gt;
caseb_aZJof _[Occ=Dead] {
False-&gt;GHC.Types.I#0;
True-&gt;GHC.Types.I#1
}
We‚Äôre not going to dissemble: GHC Core is a bit ugly. How-
ever, there are some means of cleaning it up. One is to use the
-dsuppress-all flag:
Prelude&gt; :set -dsuppress-all</p>
<p>CHAPTER 27. NONSTRICTNESS 1649
Prelude&gt; :r
Note that you may need to poke the file to force it to reload.
This then outputs:
discriminatory
discriminatory =
\b_aZY-&gt;
caseb_aZYof _{
False-&gt;I#0;
True-&gt;I#1
}
A titch more readable. The idea here is that the simpler
Core language gives us a clearer idea of when precisely some-
thing will be evaluated. For the sake of simplicity, we‚Äôll revisit
a previous example:
forceNothing _ =0
In Core, it looks like this:
forceNothing =_ -&gt;I#0#
We‚Äôre looking for case expressions in GHC Core to find out
where the strictness is in our code, because case expressions
must be evaluated. There aren‚Äôt any cases here, so it forces</p>
<p>CHAPTER 27. NONSTRICTNESS 1650
strictly5nothing! The I# O#is the underlying representation
of anIntliteral which is exposed in GHC Core. On with the
show!
Let‚Äôs see what the Core for forceTest looks like:
forceTest =
\ds_d2oX -&gt;
caseds_d2oX of _{
Ads1_d2pI -&gt;I#1#;
Bds1_d2pJ -&gt;I#2#
}
From the GHC Core for this we can see that we force one
value, the outermost data constructors of the Testtype. The
contents of those data constructors are given a name but never
used and so are never evaluated.
5HAAAAAAAAAAAA</p>
<p>CHAPTER 27. NONSTRICTNESS 1651
forceTest2 =
\ds_d2n2 -&gt;
caseds_d2n2 of _{
Ads1_d2oV -&gt;
caseds1_d2oV of _{
Ci_a1lo-&gt;i_a1lo;
Di_a1lq-&gt;i_a1lq
};
Bds1_d2oW -&gt;
caseds1_d2oW of _{
Ci_a1lp-&gt;i_a1lp;
Di_a1lr-&gt;i_a1lr
}
}
WithforceTest2 the outsideness and insideness shows more
clearly. In the outer part of the function, we do the same as
forceTest , but the diÔ¨Äerence is that we end up also forcing the
contents of the outer Testdata constructors. The function has
four possible results that aren‚Äôt bottom and if it isn‚Äôt passed bot-
tom it‚Äôll always force twice ‚Äî once for Testand once for Test2.
It returns but does not itself force or evaluate the contents of
theTest2data constructor.
In Core, a case expression always evaluates what it cases
on ‚Äî even if no pattern matching is performed ‚Äî whereas in</p>
<p>CHAPTER 27. NONSTRICTNESS 1652
Haskell proper, values are forced when matching on data con-
structors. We recommend reading the GHC documentation
on the Core language in the footnote above if you‚Äôd like to
leverage Core to understand your Haskell code‚Äôs performance
or behavior more deeply.
Now let us use this to analyze something:
discriminatory ::Bool-&gt;Int
discriminatory b=
letx=undefined
in case bof
False-&gt;0
True-&gt;1
What does the Core for this look like?
discriminatory
discriminatory =
\b_a10c-&gt;
caseb_a10cof _{
False-&gt;I#0;
True-&gt;I#1
}
GHC is too clever for our shenanigans! It knows we‚Äôll never
evaluate ùë•, so it drops it. What if we force it to evaluate ùë•before
we evaluate ùëè?</p>
<p>CHAPTER 27. NONSTRICTNESS 1653
discriminatory ::Bool-&gt;Int
discriminatory b=
letx=undefined
in case x <code>seq</code> b of
False-&gt;0
True-&gt;1
Then the Core:
discriminatory =
\b_a10D-&gt;
let{
x_a10E
x_a10E=undefined } in
case
casex_a10Eof _{
__DEFAULT -&gt;b_a10D
}of _{
False-&gt;I#0;
True-&gt;I#1
}
What‚Äôs happened here is that there are now two case ex-
pressions, one nested in another. The nesting is to make the
evaluation of ùë•obligatory before evaluating ùëè. This is how seq
changes your code.</p>
<p>CHAPTER 27. NONSTRICTNESS 1654
A Core diÔ¨Äerence In Haskell, case matching is strict ‚Äî or, at
least, the pattern matching of it is ‚Äî up to WHNF. In Core,
cases are always strict6to WHNF. This doesn‚Äôt seem to be a
distinction that matters, but there are times when the distinc-
tion becomes relevant. In Haskell, this will not bottom out:
caseundefined of{_ -&gt;False}
When that gets transliterated into Core, it recognizes that
we didn‚Äôt actually use the case match for anything and drops
the case expression entirely, simplifying it to just the data
constructor False.
However, this Core expression is syntactically similar to the
Haskell above, but it will bottom out:
caseundefined of{DEFAULT -&gt;False}
Case in Core is strict even if there‚Äôs one case and it doesn‚Äôt
match on anything. Core and Haskell are not the same lan-
guage, but anytime you need to know if two expressions in
Haskell are the same, one way to know for sure is by examining
the Core.
6https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType#
Caseexpressions</p>
<p>CHAPTER 27. NONSTRICTNESS 1655
A little bit stricter now
Okay, we had a nice little digression there into wonderland!
Let‚Äôs get back to the point which is‚Ä¶we still haven‚Äôt quite man-
aged to accomplish what a strict language would have done
with our hypofunction, because we did partially evaluate the
expression. We evaluated the ùë†which forced the ùë•which is
what finally gave us the exception. A strict language would not
even have evaluated ùë†, because evaluating ùë†would depend on
theùë•inside already being evaluated.
What if we want our Haskell program to do as a strict lan-
guage would‚Äôve done?
hypo''::IO()
hypo''= do
letx::Integer
x=undefined
s&lt;-x <code>seq</code> getLine
casesof
&quot;hi&quot;-&gt;print x
_ -&gt;putStrLn &quot;hello&quot;
Notice we moved the seqto the earliest possible point in
ourIOaction. This one‚Äôll just pop without so much as a by-
your-leave:
Prelude&gt; hypo''</p>
<p>CHAPTER 27. NONSTRICTNESS 1656
*** Exception: Prelude.undefined
The reason is that we‚Äôre forcing evaluation of the bottom
before we evaluate getLine , which would have performed the
eÔ¨Äect of awaiting user input. While this reproduces the ob-
servable results of what a strict language might have done,
it isn‚Äôt truly the same thing because we‚Äôre not firing oÔ¨Ä the
error upon the construction of the bottom. It‚Äôs not possible for
an expression to be evaluated until the path evaluation takes
through your program has reached that expression. In Haskell,
the tree doesn‚Äôt fall in the woods until you walk through the
forest and get to the tree. For that matter, the tree didn‚Äôt exist
until you walked up to it.
Exercises: Evaluate
Expand the expression in as much detail as possible. Then,
work outside-in to see what the expression evaluates to.
1.const1undefined
2.constundefined 1
3.flipconst undefined 1
4.flipconst1undefined
5.constundefined undefined</p>
<p>CHAPTER 27. NONSTRICTNESS 1657
6.foldrconst'z'['a'..'e']
7.foldr(flip const) 'z'['a'..'e']
27.6 Call by name, call by need
Another way we can talk about diÔ¨Äerent evaluation strategies
is by distinguishing them on the basis of call by name, call by
need, and call by value.
1.Call by value: Argument expressions have been evaluated
before entering a function. The expressions that bindings
reference are evaluated before creating the binding. This
is conventionally called strict. This is inside-out evalua-
tion.
2.Call by name: Expressions can be arguments to a function
without having been evaluated, or in some cases, never
being evaluated. You can create bindings to expressions
without evaluating them first. Nonstrictness includes this
evaluation strategy. This is outside-in.
3.Call by need: This is the same as call by name, but expres-
sions are only evaluated once. This only happens some
of the time in GHC Haskell, usually when an expression
isn‚Äôt a lambda that takes arguments and also has a name.
Results are typically shared within that name only in GHC</p>
<p>CHAPTER 27. NONSTRICTNESS 1658
Haskell (that is, other implementations of Haskell may
choose to do things diÔ¨Äerently). This is also nonstrict and
outside-in.
27.7 Nonstrict evaluation changes what
we can do
We‚Äôll cover normal order evaluation (the nonstrict strategy
Haskell prescribes for its implementations) in more detail later.
Now, we‚Äôll look at examples of what nonstrictness enables. The
following will work in languages with a strict or a nonstrict
evaluation strategy:
Prelude&gt; let myList = [1, 2, 3]
Prelude&gt; tail myList
[2,3]
That works in either strict or nonstrict languages because
there is nothing there that can‚Äôt be evaluated. However, if we
keep in mind that undefined as an instance of bottom will throw
an error when forced:
Prelude&gt; undefined
*** Exception: Prelude.undefined
We‚Äôll see a diÔ¨Äerence between strict and nonstrict. This will
only work in languages that are nonstrict:</p>
<p>CHAPTER 27. NONSTRICTNESS 1659
Prelude&gt; let myList = [undefined, 2, 3]
Prelude&gt; tail myList
[2,3]
A strict language would have crashed on construction of
myList due to the presence of bottom. This is because strict
languages eagerly evaluate all expressions as soon as they
are constructed. The moment [undefined, 2, 3] was declared,
undefined would‚Äôve been evaluated as an argument to (:)and
raised the exception. In Haskell, however, nonstrict evaluation
means that bottom value won‚Äôt be evaluated unless it is needed
for some reason.
Take a look at the next example and, before going on, see
if you can figure out whether it will throw an exception and
why:
Prelude&gt; head $ sort [1, 2, 3, undefined]
When we call headon a list that has been passed to sort, we
only need the lowest value in the list and that‚Äôs all the work we
will do. The problem is that in order for sortto know what the
lowest value is, it must evaluate undefined which then throws
the error.</p>
<p>CHAPTER 27. NONSTRICTNESS 1660
27.8 Thunk Life
A thunk is used to reference suspended computations that
might be performed or computed at a later point in your pro-
gram. You can get into considerably more detail7on this topic,
but essentially thunks are computations not yet evaluated up
to weak head normal form. If you read the GHC notes on
this you‚Äôll see references to head normal form ‚Äî it‚Äôs the same
thing as weak head normal form.
Not all values get thunked
We‚Äôre going to be using the GHCi command sprint in this
section as one means of showing when something is thunked.
You may remember this from the Lists chapter, but let‚Äôs refresh
our memories a bit.
Thesprint command allows us to show what has been eval-
uated already by printing in the REPL. An underscore is used
to represent values that haven‚Äôt been evaluated yet. We noted
before that this command can have some quirky behavior, al-
though this chapter will explain some of the things that cause
those seemingly unpredictable behaviors.
Let‚Äôs start with a simple example:
Prelude&gt; let myList = [1, 2] :: [Integer]
7https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects</p>
<p>CHAPTER 27. NONSTRICTNESS 1661
Prelude&gt; :sprint myList
myList = [1,2]
Wait a second ‚Äî what happened here? Why is the list shown
fully evaluated when it‚Äôs not been needed by anything? This
is an opportunistic strictness. GHC will not thunk (and thus
delay) data constructors. Data constructors are known to be
constant, which justifies the safety of the optimization. The
data constructors here are cons (:), theInteger s, and the empty
list ‚Äî all of them are constants.
But aren‚Äôt data constructors functions? Data constructors
are like functions when they‚Äôre unapplied, and constants once
they are fully applied. Since all the data constructors in the
above example are fully applied already, evaluating to weak
headnormalformmeansevaluatingeverythingbecausethere‚Äôs
nothing left to apply.
Now back to the thunkery.
A graph of the values of myList looks like:
myList
|
:
/ <br />
1 :
/ </p>
<p>CHAPTER 27. NONSTRICTNESS 1662
2 :
/ <br />
3 []
Here there aren‚Äôt any unevaluated thunks; it‚Äôs just the final
values that have been remembered. However, if we make it
more polymorphic:
Prelude&gt; let myList2 = [1, 2, 3]
Prelude&gt; :t myList2
myList2 :: Num t =&gt; [t]
Prelude&gt; :sprint myList2
myList2 = _
we‚Äôll see an unevaluated thunk represented by the under-
score at the very top level of the expression. Since the type
is not concrete, there‚Äôs an implicit function Num a -&gt; a under-
neath, awaiting application to something that will force it to
evaluate to a concrete type. There‚Äôs nothing here triggering
that evaluation, so the whole list remains an unevaluated thunk.
We‚Äôll get into more detail about how typeclass constraints eval-
uate soon.
GHC will also stop opportunistically evaluating as soon as
it hits a computation:
Prelude&gt; let xs = [1, 2, id 1] :: [Integer]
Prelude&gt; :sprint xs</p>
<p>CHAPTER 27. NONSTRICTNESS 1663
myList = [1,2,_]
It‚Äôs a trivial computation, but GHCi conveniently leaves it
be. Here‚Äôs the thunk graph for the above:
myList
|
:
/ <br />
1 :
/ <br />
2 :
/ <br />
_ []
Now let us consider another case that might be slightly
confusing initially for some:
Prelude&gt; let xs = [1, 2, id 1] :: [Integer]
Prelude&gt; let xs' = xs ++ undefined
Prelude&gt; :sprint xs'
myList' = _
Whoa whoa whoa. What‚Äôs going on here? The whole thing
is thunked because it‚Äôs not in weak head normal form. Why
isn‚Äôt it in weak head normal form already? Because the out-
ermost term isn‚Äôt a data constructor like (:). The outermost
term is the function (++):</p>
<p>CHAPTER 27. NONSTRICTNESS 1664
myList' = (++) _ _
The function is outermost, despite the fact that it is super-
ficially an infix operator, because the function is the lambda.
The arguments are passed into the function body to be evalu-
ated.
27.9 Sharing is caring
Sharing here roughly means what we‚Äôve implied above: that
when a computation is named, the results of evaluating that
computation can be shared between all references to that name
without re-evaluating it. We care about sharing because mem-
ory is finite, even today in the land of chickens in every pot
and smartphones in every pocket. The idea here is that non-
strictness is a fine thing, but call-by-name semantics aren‚Äôt
always enough to make it sufficiently efficient. What is suffi-
ciently efficient? That depends on context and whether it‚Äôs
your dissertation or not.
One of the points of confusion for people when trying to
figure out how GHC Haskell really runs code is that it turns
sharing on and oÔ¨Ä (that is, it oscillates between call-by-need
and call-by-name) based on necessity and what it thinks will
produce faster code. Part of the reason it can do this at all
without breaking your code is because the compiler knows
when your code does or does not perform I/O.</p>
<p>CHAPTER 27. NONSTRICTNESS 1665
Using trace to observe sharing
The base library has a module named Debug.Trace that has
functions useful for observing sharing. We‚Äôll mostly use trace
here, but feel free to poke around for whatever else might catch
your fancy. Debug.Trace is a means of cheating the type system
and putting a putStrLn without having IOin the type. This is def-
initely something you want to restrict to experimentation and
education; do not use it as a logging mechanism in production
code ‚Äî it won‚Äôt do what you think. However, it does give us a
convenient means of observing when things evaluate.
Let us demonstrate how we can use this to see when things
get evaluated:
Prelude&gt; import Debug.Trace
Prelude&gt; let a = trace &quot;a&quot; 1
Prelude&gt; let b = trace &quot;b&quot; 2
Prelude&gt; a + b
b
a
3
This isn‚Äôt an example of sharing, but it demonstrates how
tracecan be used to observe evaluation. We can see that ùëè
got printed first because that was the first argument that the
addition function evaluated, but you cannot and should not
rely on the evaluation order of the arguments to addition.</p>
<p>CHAPTER 27. NONSTRICTNESS 1666
Here we‚Äôre talking about the order in which the arguments to
a single application of addition are forced, not associativity.
You can count on addition being left associative, but within
each pairing, which in the pair of arguments gets forced is not
guaranteed.
Let‚Äôs look at a longer example and see how it shows us where
the evaluations occur:
importDebug.Trace (trace)
inc=(+1)
twice=inc.inc
howManyTimes =
inc (trace &quot;I got eval'd&quot; (1+1))
+twice
(trace&quot;I got eval'd&quot; (1+1))
howManyTimes' =
letonePlusOne =
trace&quot;I got eval'd&quot; (1+1)
ininc onePlusOne +twice onePlusOne
Prelude&gt; howManyTimes
I got eval'd</p>
<p>CHAPTER 27. NONSTRICTNESS 1667
I got eval'd
7
Prelude&gt; howManyTimes'
I got eval'd
7
Cool, with that in mind, let‚Äôs talk about ways to promote
and prevent sharing.
What promotes sharing
Kindness. Also, names. Names turn out to be a pretty good
way to make GHC share something, if it could‚Äôve otherwise
been shared. First, let‚Äôs consider the example of something
that won‚Äôt get shared:
Prelude&gt; import Debug.Trace
Prelude&gt; let x = trace &quot;x&quot; (1 :: Int)
Prelude&gt; let y = trace &quot;y&quot; (1 :: Int)
Prelude&gt; x + y
x
y
2
This seems intuitive and reasonable, but the values of ùë•
andùë¶cannot be shared because they have diÔ¨Äerent names.</p>
<p>CHAPTER 27. NONSTRICTNESS 1668
So, even though they have the same value, they have to be
evaluated separately.
GHC does use this intuition that you‚Äôll expect results to be
shared when they have the same name to make performance
more predictable. If we add two values that have the same
name, it will get evaluated once and only once:
Prelude&gt; import Debug.Trace
Prelude&gt; let a = trace &quot;a&quot; (1 :: Int)
Prelude&gt; a + a
a
2
Prelude&gt; a + a
2
Indirection won‚Äôt change this either:
Prelude&gt; let x = trace &quot;x&quot; (1 :: Int)
Prelude&gt; (id x) + (id x)
x
2
Prelude&gt; (id x) + (id x)
2
GHC knows what‚Äôs up, despite the addition of identity func-
tions. Notice the second time we ran it, it didn‚Äôt evaluate ùë•at</p>
<p>CHAPTER 27. NONSTRICTNESS 1669
all. The value of ùë•is now held there in memory so whenever
your program calls ùë•, it already knows the value.
In general, GHC relies on an intuition around names and
sharing to make performance more predictable. However,
this won‚Äôt always behave in ways you expect. Consider the
case of a list with a single character‚Ä¶and a String with a sin-
gle character. They‚Äôre actually the same thing, but the way
they get constructed is not. This produces diÔ¨Äerences in the
opportunistic strictness GHC will engage in.
Prelude&gt; let a = Just ['a']
Prelude&gt; :sprint a
a = Just &quot;a&quot;
Prelude&gt; let a = Just &quot;a&quot;
Prelude&gt; :sprint a
a = Just _
So uh, what gives? Well, the deal is that the strictness analy-
sis driven optimization GHC performs here is limited to data
constructors only, no computation! But where‚Äôs the function
you ask? Well if we turn on our night vision goggles‚Ä¶
Prelude&gt; let a = Just ['a']
returnIO
(: ((Just (: (C# 'a') ([])))</p>
<p>CHAPTER 27. NONSTRICTNESS 1670
<code>cast</code> ...) ([]))
Prelude&gt; let a = Just &quot;a&quot;
returnIO
(: ((Just (unpackCString# &quot;a&quot;#))
<code>cast</code> ...) ([]))
The issue is that a call to a primitive function in GHC.Base
interposes between Justand aCString literal. The reason string
literals aren‚Äôt actually lists of characters at time of construction
is mostly to present optimization opportunities, such as when
we convert string literals into ByteString orTextvalues. More
on that in the next chapter!
What subverts or prevents sharing
Sometimes we don‚Äôt want sharing. Sometimes we want to
know why sharing didn‚Äôt happen when we did want it. Un-
derstanding what kinds of things prevent sharing is therefore
useful.
Inlining expressions where they get used prevents sharing
because it creates independent thunks that will get computed
separately. In this example, instead of declaring the value of ùëì
to equal 1, we make it a function:
Prelude&gt; :{</p>
<p>CHAPTER 27. NONSTRICTNESS 1671
Prelude| let f :: a -&gt; Int
Prelude| f _ = trace &quot;f&quot; 1
Prelude| :}
Prelude&gt; f 'a'
f
1
Prelude&gt; f 'a'
f
1
In the next examples you can directly compare the dif-
ference between assigning a name to the value of (2 + 2) versus
inlining it directly. When it‚Äôs named, it gets shared and not
re-evaluated:
Prelude&gt; let a :: Int; a = trace &quot;a&quot; 2 + 2
Prelude&gt; let b = (a + a)
Prelude&gt; b
a
8
Prelude&gt; b
8
Here we saw ùëéonce, which makes sense as we expect the
result to get shared.
Prelude&gt; :{</p>
<p>CHAPTER 27. NONSTRICTNESS 1672
Prelude| let c :: Int;
Prelude| c = (trace &quot;a&quot; 2 + 2)
Prelude| + (trace &quot;a&quot; 2 + 2)
Prelude| :}
Prelude&gt; c
a
a
8
Prelude&gt; c
8
Here an expression equivalent to ùëédidn‚Äôt get shared be-
cause the two occurrences of the expression weren‚Äôt bound
to the same name. This is a trivial example of inlining. This
illustrates the diÔ¨Äerence in how things evaluate when an ex-
pression is bound to a name versus when it gets repeated via
inlining in an expression.
Being a function with explicit, named arguments also pre-
vents sharing. Haskell is not fully lazy; it is merely nonstrict,
so it is not required to remember the result of every func-
tion application for a given set of arguments, nor would it be
desirable given memory constraints. A demonstration:
Prelude&gt; :{
Prelude| let f :: a -&gt; Int
Prelude| f = trace &quot;f&quot; const 1</p>
<p>CHAPTER 27. NONSTRICTNESS 1673
Prelude| :}
Prelude&gt; f 'a'
f
1
Prelude&gt; f 'a'
1
Prelude&gt; f 'b'
1
The explicit, named arguments part here is critical! Eta re-
duction (i.e., writing pointfree code, thus dropping the named
arguments) will change the sharing properties of your code.
This will be explained in more detail in the next chapter.
Typeclass constraints also prevent sharing. If we forget to
add a concrete type to an earlier example, we evaluate ùëétwice:
Prelude&gt; let blah = Just 1
Prelude&gt; fmap ((+1) :: Int -&gt; Int) blah
Just 2
Prelude&gt; :sprint blah
blah = _
Prelude&gt; :t blah
blah :: Num a =&gt; Maybe a
Prelude&gt; let bl = Just 1
Prelude&gt; :t bl</p>
<p>CHAPTER 27. NONSTRICTNESS 1674
bl :: Num a =&gt; Maybe a
Prelude&gt; :sprint bl
bl = _
Prelude&gt; fmap (+1) bl
Just 2
Prelude&gt; let fm = fmap (+1) bl
Prelude&gt; :t fm
fm :: Num b =&gt; Maybe b
Prelude&gt; :sprint fm
fm = _
Prelude&gt; fm
Just 2
Prelude&gt; :sprint fm
fm = _
Prelude&gt; :{
Prelude| let fm' =
Prelude| fmap ((+1) :: Int -&gt; Int) bla
Prelude| :}
Prelude&gt; fm'
Just eval'd 1
2
Prelude&gt; :sprint fm'
fm' = Just 2</p>
<p>CHAPTER 27. NONSTRICTNESS 1675
Again, that‚Äôs because typeclass constraints are a function
in Core. They are awaiting application to something that will
make them become concrete types. We‚Äôre going to go into a
bit more detail on this in the next section.
Implicit parameters are implemented similarly to type-
class constraints and have the same eÔ¨Äect on sharing. Sharing
doesn‚Äôt work in the presence of constraints (typeclasses or im-
plicit parameters) because typeclass constraints and implicit
parameters decay into function arguments when the compiler
simplifies the code:
Prelude&gt; :set -XImplicitParams
Prelude&gt; import Debug.Trace
Prelude&gt; :{
Prelude| let add :: (?x :: Int) =&gt; Int
Prelude| add = trace &quot;add&quot; 1 + ?x
Prelude| :}
Prelude&gt; let ?x = 1 in add
add
2
Prelude&gt; let ?x = 1 in add
add
2
We won‚Äôt talk about implicit parameters too much more as
wedon‚Äôtthinkthey‚Äôreagoodideaforgeneraluse. Inmostcases</p>
<p>CHAPTER 27. NONSTRICTNESS 1676
where you believe you want implicit parameters, more likely
you want Reader ,ReaderT , or a plain old function argument.
Why polymorphic values never seem to get
forced
As we‚Äôve said, GHC engages in opportunistic strictness when it
can do so safely without making an otherwise valid expression
result in bottom. This is one of the things that confounds the
use ofsprint to observe evaluation in GHCi ‚Äî GHC will often
be opportunistically strict with data constructors if it knows
the contents definitely can‚Äôt be a bottom, such as when they‚Äôre
a literal value. It gets more complicated when we consider
that, under the hood, typeclass constraints are simplified into
additional arguments.
Reusing a similar example from earlier we will first observe
this in action, then we‚Äôll talk about why it happens:
Prelude&gt; :{
Prelude| let blah =
Prelude| Just (trace &quot;eval'd 1&quot; 1)
Prelude| :}
Prelude&gt; :sprint blah
blah = _
Prelude&gt; :t blah
blah :: Num a =&gt; Maybe a</p>
<p>CHAPTER 27. NONSTRICTNESS 1677
Prelude&gt; fmap (+1) blah
Just eval'd 1
2
Prelude&gt; fmap (+1) blah
Just eval'd 1
2
Prelude&gt; :sprint blah
blah = _
So we have at least some evidence that we‚Äôre re-evaluating.
Does it change when it‚Äôs concrete?
Prelude&gt; :{
Prelude| let blah =
Prelude| Just (trace &quot;eval'd 1&quot;
Prelude| (1 :: Int))
Prelude| :}
Prelude&gt; :sprint blah
blah = Just _
TheIntvalue being obscured by traceprevented oppor-
tunistic evaluation there. However, eliding the Num a =&gt; a in
favor of a concrete type does bring sharing back:
Prelude&gt; fmap (+1) blah
Just eval'd 1
2</p>
<p>CHAPTER 27. NONSTRICTNESS 1678
Prelude&gt; fmap (+1) blah
Just 2
Now our trace gets emitted only once. The idea here is that
after the typeclass constraints get simplified to the underlying
GHC Core language, they‚Äôre really function arguments.
It doesn‚Äôt matter if you use a function that accepts a concrete
type and forces the Num a =&gt; a , it‚Äôll re-do the work on each
evaluation because of the typeclass constraint. For example:
Prelude&gt; fmap ((+1) :: Int -&gt; Int) blah
Just 2
Prelude&gt; :sprint blah
blah = _
Prelude&gt; :t blah
blah :: Num a =&gt; Maybe a
Prelude&gt; let bl = Just 1
Prelude&gt; :t bl
bl :: Num a =&gt; Maybe a
Prelude&gt; :sprint bl
bl = _
Prelude&gt; fmap (+1) bl
Just 2
Prelude&gt; let fm = fmap (+1) bl
Prelude&gt; :t fm
fm :: Num b =&gt; Maybe b</p>
<p>CHAPTER 27. NONSTRICTNESS 1679
Prelude&gt; :sprint fm
fm = _
Prelude&gt; fm
Just 2
Prelude&gt; :sprint fm
fm = _
Prelude&gt; :{
Prelude| let fm' =
Prelude| fmap ((+1) :: Int -&gt; Int)
Prelude| blah
Prelude| :}
Prelude&gt; fm'
Just eval'd 1
2
Prelude&gt; :sprint fm'
fm' = Just 2
So, what‚Äôs the deal here with the typeclass constraints? It‚Äôs as
ifNum a =&gt; a were really Num a -&gt; a . In Core, they are. The only
way to apply that function argument is to reach an expression
that provides a concrete type satisfying the constraint. Here‚Äôs
a demonstration of the diÔ¨Äerence in behavior using values:
Prelude&gt; let poly = 1
Prelude&gt; let conc = poly :: Int
Prelude&gt; :sprint poly</p>
<p>CHAPTER 27. NONSTRICTNESS 1680
poly = _
Prelude&gt; :sprint conc
conc = _
Prelude&gt; poly
1
Prelude&gt; conc
1
Prelude&gt; :sprint poly
poly = _
Prelude&gt; :sprint conc
conc = 1
Num a =&gt; a is a function awaiting an argument, while Intis
not. Behold the Core:
moduleBlahwhere
a::Numa=&gt;a
a=1
concrete ::Int
concrete =1
Prelude&gt; :l code/blah.hs
[1 of 1] Compiling Blah</p>
<p>CHAPTER 27. NONSTRICTNESS 1681
================ Tidy Core ==============
Result size of Tidy Core =
{terms: 9, types: 9, coercions: 0}
concrete
concrete = I# 1
a
a =
\ @ a1_aRN $dNum_aRP -&gt;
fromInteger $dNum_aRP (__integer 1)
Do you see how ùëéhas a lambda? In order to know what
instance of the typeclass to deploy at any given time, the type
has to be concrete. As we‚Äôve seen, types can become concrete
through assignment or type defaulting. Whichever way it
becomes concrete, the result is the same: once the concrete
type is known, the typeclass constraint function gets applied
to the typeclass instance for that type. If you don‚Äôt declare the
concrete type, it will have to re-evaluate this function every
time, because it can‚Äôt know that the type didn‚Äôt change some-
where along the way. So, because it remains a function and
unapplied functions are not shareable values, polymorphic
expressions can‚Äôt be shared.
Mostly the behavior doesn‚Äôt change when it involves values
defined in terms of functions, but if you forget the type con-</p>
<p>CHAPTER 27. NONSTRICTNESS 1682
cretion it‚Äôll stay _and you‚Äôll be confused and upset. Observe:
Prelude&gt; :{
Prelude| let blah :: Int -&gt; Int
Prelude| blah x = x + 1
Prelude| :}
Prelude&gt; let woot = blah 1
Prelude&gt; :sprint blah
blah = _
Prelude&gt; :sprint woot
woot = _
Prelude&gt; woot
2
Prelude&gt; :sprint woot
woot = 2
Values of a concrete, constant type can be shared, once
evaluated. Polymorphic values may be evaluated once but still
not shared because, underneath, they continue to be functions
awaiting application.
Preventing sharing on purpose
When do we want to prevent sharing? When we don‚Äôt want
a large datum hanging out in memory that was calculated to
provide a much smaller answer. First an example that demon-
strates sharing:</p>
<p>CHAPTER 27. NONSTRICTNESS 1683
Prelude&gt; import Debug.Trace
Prelude&gt; let f x = x + x
Prelude&gt; f (trace &quot;hi&quot; 2)
hi
4
We see ‚Äúhi‚Äù once because ùë•got evaluated once. In the next
example, ùë•gets evaluated twice:
Prelude&gt; let f x = (x ()) + (x ())
Prelude&gt; f (_ -&gt; trace &quot;hi&quot; 2)
hi
hi
4
Using unit ()as arguments to ùë•turnedùë•into a very trivial,
weird-looking function, which is why the value of ùë•can no
longer be shared. It doesn‚Äôt matter much since that ‚Äúfunction‚Äù
ùë•doesn‚Äôt really do anything.
OK, that was weird; maybe it‚Äôll be easier to see if we use
some more traditional-seeming argument to ùë•:
Prelude&gt; let f x = (x 2) + (x 10)
Prelude&gt; f (\x -&gt; trace &quot;hi&quot; (x + 1))
hi
hi
14</p>
<p>CHAPTER 27. NONSTRICTNESS 1684
Using a lambda that mentions the argument in some fash-
ion disables sharing:
Prelude&gt; let g = _ -&gt; trace &quot;hi&quot; 2
Prelude&gt; f g
hi
hi
4
However, this worked in part because the function passed
toùëìhad the argument as part of the declaration, even though
it used underscore to ignore it. Notice what happens if we
make it pointfree:
Prelude&gt; let g = const (trace &quot;hi&quot; 2)
Prelude&gt; f g
hi
4
We‚Äôre going to get into a little more detail about this dis-
tinction in the next chapter, but the idea here is that functions
aren‚Äôt shared when there are named arguments but are when
the arguments are elided, as in pointfree. So, one way to pre-
vent sharing is adding named arguments.</p>
<p>CHAPTER 27. NONSTRICTNESS 1685
Forcing sharing
You can force sharing by giving your expression a name. The
most common way of doing this is with let.
-- calculates 1 + 1 twice
(1+1)<em>(1+1)
-- shares 1 + 1 result under 'x'
letx=1+1
inx</em>x
With that in mind, if you take a look at the forever function
inControl.Monad , you might see something a little mysterious
looking:
forever ::(Monadm)=&gt;m a-&gt;m b
forever a= leta'=a&gt;&gt;a'ina'
Why the letexpression? Well, we want sharing here so that
running a monadic action indefinitely doesn‚Äôt leak memory.
The sharing here causes GHC to overwrite the thunk as it runs
each step in the evaluation, which is quite handy. Otherwise,
it would keep constructing new thunks indefinitely and that
would be very unfortunate.</p>
<p>CHAPTER 27. NONSTRICTNESS 1686
27.10 Refutable and irrefutable patterns
When we‚Äôre talking about pattern matching, it‚Äôs important to
be aware that there are refutable and irrefutable patterns. An
irrefutable pattern is one which will never fail to match. A
refutable pattern is one which has potential failures. Often,
the problem is one of specificity.
refutable ::Bool-&gt;Bool
refutable True=False
refutable False=True
irrefutable ::Bool-&gt;Bool
irrefutable x=not x
oneOfEach ::Bool-&gt;Bool
oneOfEach True=False
oneOfEach _ =True
Remember, the pattern is refutable or not, not the function
itself. The function refutable is refutable because each case is
refutable; each case could be given an input that fails to match.
In contrast, irrefutable has an irrefutable pattern; that is, its
pattern doesn‚Äôt rely on matching with a specific value.
In the case of oneOfEach , the first pattern is refutable because
it pattern matches on the Truedata constructor. irrefutable</p>
<p>CHAPTER 27. NONSTRICTNESS 1687
and the second match of oneOfEach are irrefutable because they
don‚Äôt need to look inside the data they are applied to.
That said, the second pattern match of oneOfEach being ir-
refutable isn‚Äôt terribly semantically meaningful as Haskell will
have to inspect the data to see if it matches the first case any-
way.
Theirrefutable function works for any inhabitant (all two
of them) of Boolbecause it doesn‚Äôt specify which Boolvalue in
the pattern to match. You could think of an irrefutable pattern
as one which will never fail to match. If an irrefutable pattern
for a particular value comes before a refutable pattern, the
refutable pattern will never get invoked.
This little function appeared in an earlier chapter, but we‚Äôll
bring it back for a quick demonstration:
isItTwo ::Integer -&gt;Bool
isItTwo 2=True
isItTwo _ =False
In the case of Bool, the order of matching TrueandFalse
specifically doesn‚Äôt matter, but in cases like isItTwo where one
case is specific and the other is a catchall otherwise case, the
ordering will certainly matter. You can reorder the expressions
ofisItTwo to see what happens, although it‚Äôs probably clear.</p>
<p>CHAPTER 27. NONSTRICTNESS 1688
Lazy patterns
Lazy patterns are also irrefutable.
strictPattern ::(a, b)-&gt;String
strictPattern (a,b)=const&quot;Cousin It&quot; a
lazyPattern ::(a, b)-&gt;String
lazyPattern ~(a,b)=const&quot;Cousin It&quot; a
The tilde is how one makes a pattern match lazy. A caveat
is that since it makes the pattern irrefutable, you can‚Äôt use
it to discriminate cases of a sum ‚Äî it‚Äôs useful for unpacking
products that might not get used.
Prelude&gt; strictPattern undefined
*** Exception: Prelude.undefined
Prelude&gt; lazyPattern undefined
&quot;Cousin It&quot;
And as we see here, in the lazy pattern version since const
didn‚Äôt actually need ùëéfrom the tuple, we never forced the
bottom. The default behavior is to just go ahead and force
it before evaluating the function body, mostly for more pre-
dictable memory usage and performance.</p>
<p>CHAPTER 27. NONSTRICTNESS 1689
27.11 Bang patterns
Sometimes we want to evaluate an argument to a function
whether we use it or not. We can do this with seqas in the
following example:
{-# LANGUAGE BangPatterns #-}
moduleManualBang where
doesntEval ::Bool-&gt;Int
doesntEval b=1
manualSeq ::Bool-&gt;Int
manualSeq b=b <code>seq</code> 1
Or we can also do it with a bang pattern on ùëè‚Äî note the
exclamation point:
banging ::Bool-&gt;Int
banging !b=1
Let‚Äôs look at the Core for those three:</p>
<p>CHAPTER 27. NONSTRICTNESS 1690
doesntEval
doesntEval =
_ -&gt;I#1#
manualSeq
manualSeq =
\b_a1ia-&gt;
caseb_a1iaof _
{ __DEFAULT -&gt;I#1#}
banging
banging =
\b_a1ib-&gt;
caseb_a1ibof _
{ __DEFAULT -&gt;I#1#}
If you try passing bottom to each function you‚Äôll find that
manualSeq and banging are forcing their argument despite not
using it for anything. Remember that forcing something is
expressed in Core as a case expression and that case evaluates
up to weak head normal form in Core.
Bang patterns in data
When we evaluate the outer data constructor of a datatype,
at times we‚Äôd also like to evaluate the contents to weak head</p>
<p>CHAPTER 27. NONSTRICTNESS 1691
normal form just like with functions.
One way to see the diÔ¨Äerence between strict and nonstrict
constructor arguments is how they behave when they are un-
defined. Let‚Äôs look at an example (note the exclamation mark):
dataFoo=FooInt!Int
first(Foox_)=x
second(Foo_y)=y
Since the nonstrict argument isn‚Äôt evaluated by second , pass-
ing in undefined doesn‚Äôt cause a problem:</p>
<blockquote>
<p>second (Foo undefined 1)
1
But the strict argument can‚Äôt be undefined, even if we don‚Äôt
use the value:
first (Foo 1 undefined)
*** Exception: Prelude.undefined
You could do this manually with seq, but it‚Äôs a little tedious.
Here‚Äôs another example with two equivalent datatypes, one
of them with strictness annotations on the contents and one
without:</p>
</blockquote>
<p>CHAPTER 27. NONSTRICTNESS 1692
{-# LANGUAGE BangPatterns #-}
moduleManualBang where
dataDoesntForce =
TisLazy IntString
gibString ::DoesntForce -&gt;String
gibString (TisLazy _s)=s
-- note the exclamation marks again
dataBangBang =
SheShotMeDown !Int!String
gimmeString ::BangBang -&gt;String
gimmeString (SheShotMeDown _s)=s
Then testing those in GHCi:
Prelude&gt; let x = TisLazy undefined &quot;blah&quot;
Prelude&gt; gibString x
&quot;blah&quot;
Prelude&gt; let s = SheShotMeDown
Prelude&gt; let x = s undefined &quot;blah&quot;
Prelude&gt; gimmeString x
&quot;*** Exception: Prelude.undefined</p>
<p>CHAPTER 27. NONSTRICTNESS 1693
The idea here is that in some cases, it‚Äôs cheaper to just com-
pute something than to construct a thunk and then evaluate
it later. This case is particularly common in numerics code
where you have a lot of IntandDouble values running around
which are individually cheap to conjure. If the values are both
cheap to compute and small, then you may as well make them
strict unless you‚Äôre trying to dance around bottoms. Types
with underlying primitive representations IntandDouble most
assuredly qualify as small.
A good rule to follow is lazy in the spine, strict in the leaves!
Sometimes a ‚Äúleak‚Äù isn‚Äôt really a leak but temporarily exces-
sive memory that subsides because you made 1,000,000 tiny
values into less-tiny thunks when you could‚Äôve just computed
them as your algorithm progressed.
27.12 Strict and StrictData
If you‚Äôre using GHC 8.0 or newer, you can avail yourself of the
Strict andStrictData extensions. The key thing to realize is
Strict /StrictData are just letting you avoid putting in pervasive
uses of seqand bang patterns yourself. They don‚Äôt add any-
thing to the semantics of the language. Accordingly, it won‚Äôt
suddenly make lazy data structures defined elsewhere behave
diÔ¨Äerently, although it does make functions defined in that
module processing lazy data structures behave diÔ¨Äerently.</p>
<p>CHAPTER 27. NONSTRICTNESS 1694
Let‚Äôs play with that (if you have GHC 8.0 or newer; if not,
this code won‚Äôt work):
{-# LANGUAGE Strict #-}
moduleStrictTest where
blahx=1
main=print (blah undefined)
The above will bottom out because blahis defined under
the module with the Strict extension and will get translated
into the following:
blahx=x <code>seq</code> 1
-- or with bang patterns
blah!x=1
So, the Strict andStrictData extensions are a means of
avoiding noise when everything or almost everything in a
module is supposed to be strict. You can use the tilde for ir-
refutable patterns to recover laziness on a case by case basis:</p>
<p>CHAPTER 27. NONSTRICTNESS 1695
{-# LANGUAGE Strict #-}
moduleLazyInHostileTerritory where
willForce x=1
willNotForce ~x=1
Admittedlytheseareglorifiedrenamesof const, butitdoesn‚Äôt
matterforthepurposesofdemonstratingwhathappens. Here‚Äôs
what we‚Äôll see in GHCi when we pass them bottom:
Prelude&gt; willForce undefined
*** Exception: Prelude.undefined
Prelude&gt; willNotForce undefined
1
So even when you‚Äôre using the Strict extension, you can
selectively recover laziness when desired.
27.13 Adding strictness
Now we shall examine how applying strictness to a datatype
and operations we‚Äôre already familiar with can change how
they behave in the presence of bottom through the list type.
This is intended to be mostly demonstrative rather than a
practical example.</p>
<p>CHAPTER 27. NONSTRICTNESS 1696
moduleStrictTest1 where
dataLista=
Nil
|Consa (Lista)deriving Show
sTake::Int-&gt;Lista-&gt;Lista
sTaken_
|n&lt;=0=Nil
sTakenNil=Nil
sTaken (Consx xs)=
(Consx (sTake (n -1) xs))
twoEls =Cons1(Consundefined Nil)
oneEl =sTake1twoEls
The name of the module here is a bit of a misnomer. List
here is lazy, just like the built-in [a]in the Haskell prelude.
Ourtakederivative named sTakeis lazy too.
Now let‚Äôs load up this code in our REPL and test it out:
Prelude&gt; twoEls
Cons 1 (Cons
*** Exception: Prelude.undefined
Prelude&gt; oneEl</p>
<p>CHAPTER 27. NONSTRICTNESS 1697
Cons 1 Nil
Now let‚Äôs experiment with adding strictness to diÔ¨Äerent
parts of our program and observe what changes in our code‚Äôs
behavior.
First we‚Äôre going to add BangPatterns so that we have a syn-
tactically convenient way to denote when and where we want
strictness:
moduleStrictTest2 where
dataLista=
Nil
|Cons!a (Lista)deriving Show
sTake::Int-&gt;Lista-&gt;Lista
sTaken_
|n&lt;=0=Nil
sTakenNil=Nil
sTaken (Consx xs)=
(Consx (sTake (n -1) xs))
twoEls=Cons1(Consundefined Nil)
oneEl=sTake1twoEls</p>
<p>CHAPTER 27. NONSTRICTNESS 1698
Noting the placement of the exclamation marks denoting
strictness, let‚Äôs run it in GHCi and see if it does what we want:
Prelude&gt; twoEls
Cons 1 *** Exception: Prelude.undefined
Prelude&gt; oneEl
Cons 1 Nil</p>
<p>CHAPTER 27. NONSTRICTNESS 1699
{-# LANGUAGE BangPatterns #-}
moduleStrictTest3 where
dataLista=
Nil
|Cons!a (Lista)deriving Show
sTake::Int-&gt;Lista-&gt;Lista
sTaken_
|n&lt;=0=Nil
sTakenNil=Nil
sTaken (Consx!xs)=
(Consx (sTake (n -1) xs))
twoEls=Cons1(Consundefined Nil)
oneEl=sTake1twoEls
threeElements =Cons2twoEls
oneElT =sTake1threeElements
We added strictness to the ùë•ùë†so thatsTakeis going to force
more of the list. Let‚Äôs see what happens:
Prelude&gt; twoEls
Cons 1 *** Exception: Prelude.undefined</p>
<p>CHAPTER 27. NONSTRICTNESS 1700
Prelude&gt; oneEl
*** Exception: Prelude.undefined
Prelude&gt; threeElements
Cons 2 (Cons 1
*** Exception: Prelude.undefined
Prelude&gt; oneElT
Cons 2 Nil
Let‚Äôs add more strictness:</p>
<p>CHAPTER 27. NONSTRICTNESS 1701
moduleStrictTest4 where
dataLista=
Nil
|Cons!a!(Lista)deriving Show
sTake::Int-&gt;Lista-&gt;Lista
sTaken_
|n&lt;=0=Nil
sTakenNil=Nil
sTaken (Consx xs)=
(Consx (sTake (n -1) xs))
twoEls=Cons1(Consundefined Nil)
oneEl=sTake1twoEls
And run it again:
Prelude&gt; twoEls
*** Exception: Prelude.undefined
Prelude&gt; oneEl
*** Exception: Prelude.undefined
So, what‚Äôs the upshot of our experiments with adding strict-
ness here?</p>
<p>CHAPTER 27. NONSTRICTNESS 1702
NCons sTake
1Cons a (List a) Cons x xs
2Cons !a (List a) Cons x xs
3Cons !a (List a) Cons x !xs
4Cons !a !(List a) Cons x xs
Then the results themselves:
NtwoEls oneEl
1Cons 1 (Cons *** Cons 1 Nil
2Cons 1 *** Cons 1 Nil
3Cons 1 *** ***
4*** ***
You can see clearly what adding strictness in diÔ¨Äerent places
does to our evaluation in terms of bottom.
27.14 Chapter Exercises
Strict List
Try messing around with the following list type and compare
what it does with the bang-patterned list variants we experi-
mented with earlier:</p>
<p>CHAPTER 27. NONSTRICTNESS 1703
{-# LANGUAGE Strict #-}
moduleStrictList where
dataLista=
Nil|
Consa (Lista)
deriving (Show)
take'n_ | n&lt;=0=Nil
take'_Nil =Nil
take'n (Consx xs) =
(Consx (take' (n -1) xs))
map'_Nil =Nil
map'f (Consx xs)=
(Cons(f x) (map' f xs))
repeat' x=xswherexs=(Consx xs)
main= do
print$take'10$map' (+1) (repeat' 1)</p>
<p>CHAPTER 27. NONSTRICTNESS 1704
What will :sprint output?
We show you a definition or multiple definitions, you deter-
mine what :sprint will output when passed the bindings listed
in your head before testing it.
1.letx=1
2.letx=['1']
3.letx=[1]
4.letx=1::Int
5.letf=\x-&gt;x
letx=f1
6.letf::Int-&gt;Int; f=\x-&gt;x
letx=f1
Will printing this expression result in bottom?
1.snd(undefined, 1)
2.letx=undefined
lety=x <code>seq</code> 1insnd (x, y)
3.length$[1..5]++undefined</p>
<p>CHAPTER 27. NONSTRICTNESS 1705
4.length$[1..5]++[undefined]
5.const1undefined
6.const1(undefined <code>seq</code> 1)
7.constundefined 1
Make the expression bottom
Using only bang patterns or seq, make the code bottom out
when executed.
1.x=undefined
y=&quot;blah&quot;
main= do
print (snd (x, y))
27.15 Follow-up resources
1.The Incomplete Guide to Lazy Evaluation (in Haskell);
Heinrich Apfelmus
https://hackhands.com/guide-lazy-evaluation-haskell/
2.Chapter 2. Basic Parallelism: The Eval Monad; Parallel
and Concurrent Programming in Haskell; Simon Marlow;
http://chimera.labs.oreilly.com/books/1230000000929/ch02.html</p>
<p>CHAPTER 27. NONSTRICTNESS 1706
3.Lazy evaluation illustrated for Haskell divers; Takenobu
Tani
4.A Natural Semantics for Lazy Evaluation; John Launch-
bury
5.AnOperationalSemanticsforParallelCall-by-Need; Clem
Baker-Finch, David King, Jon Hall and Phil Trinder</p>
<p>Chapter 28
Basic libraries
Bad programmers worry
about the code. Good
programmers worry
about data structures and
their relationships.
Linus Torvalds
1707</p>
<p>CHAPTER 28. BASIC LIBRARIES 1708
28.1 Basic libraries and data structures
Data structures are kind of important. Insofar as computers
are fast, they aren‚Äôt getting much faster ‚Äî at least, the CPU
isn‚Äôt. This is usually a lead-in for a parallelism/concurrency
sales pitch. But this isn‚Äôt that book.
The data structures you choose to represent your problem
aÔ¨Äect the speed and memory involved in processing your data,
perhaps to a larger extent than is immediately obvious. At the
level of your program, making the right decision about how
to represent your data is the first important step to writing
efficient programs. In fact, your choice of data structure can
aÔ¨Äect whether it‚Äôs worthwhile or even makes sense to attempt
to parallelize something.
This chapter is here to help you make the decision of the
optimal data structures for your programs. We can‚Äôt prescribe
one or the other of similar data structures because how ef-
fective they are will depend a lot on what you‚Äôre trying to
do. So, our first step will be to give you tools to measure for
yourself how diÔ¨Äerent structures will perform in your context.
We‚Äôll also cover some of the mistakes that can cause your
memory usage and execution time to explode.
This chapter will
‚Ä¢demonstrate how to measure the usage of time and space
in your programs;</p>
<p>CHAPTER 28. BASIC LIBRARIES 1709
‚Ä¢oÔ¨Äer guidelines on when weak head normal form or nor-
mal form are appropriate when benchmarking code;
‚Ä¢define constant applicative forms and explain argument
saturation;
‚Ä¢demonstrate and critically evaluate when to use diÔ¨Äerent
data structures in diÔ¨Äerent circumstances;
‚Ä¢sacrifice some jargon for the jargon gods.
We‚Äôre going to kick this chapter oÔ¨Ä with some benchmark-
ing.
28.2 Benchmarking with Criterion
It‚Äôs a common enough thing to want to know how fast our
code is. If you can‚Äôt benchmark properly, then you can‚Äôt know
if you used six microseconds or only five, and can only ask
yourself, ‚ÄúWell, do I feel lucky?‚Äù
Well, do ya, punk?
If you‚Äôd rather not trust your performance to guesswork,
the best way to measure performance is to sample many times
in order to establish a confidence interval. Fortunately, that
work has already been done for us in the wonderful library
criterion1by Bryan O‚ÄôSullivan.
1http://hackage.haskell.org/package/criterion</p>
<p>CHAPTER 28. BASIC LIBRARIES 1710
As it happens, criterion comes with a pretty nice tutorial2,
but we‚Äôll still work through an example so you can follow along
with this chapter. In our toy program here, we‚Äôre looking to
write a total version of (!!)which returns Maybeto make the
bottoms unnecessary. When you compile code for bench-
marking, make sure you‚Äôre using -Oor-O2in the build flags to
GHC. Those can be specified by running GHC manually:
-- with stack
$ stack ghc -- -O2 bench.hs
-- without stack
$ ghc -O2 bench.hs
Or via the Cabal setting ghc-options3.
Let‚Äôs get our module set up:
2http://www.serpentine.com/criterion/tutorial.html
3https://www.haskell.org/cabal/users-guide/</p>
<p>CHAPTER 28. BASIC LIBRARIES 1711
moduleMainwhere
importCriterion.Main
infixl9!?
_ !? n|n&lt;0=Nothing
[]!? _ = Nothing
(x:<em>)!?0 =Justx
(</em>:xs)!?n =xs!?(n-1)
myList::[Int]
myList=[1..9999]
main::IO()
main=defaultMain
[ bench &quot;index list 9999&quot;
$whnf (myList !!)9998
, bench &quot;index list maybe index 9999&quot;
$whnf (myList !?)9998
]
Our version of (!!)shouldn‚Äôt have anything too surprising
going on. We have declared that it‚Äôs a left-associating infix op-
erator (infixl ) with a precedence of 9. We haven‚Äôt talked much
about the associativity or fixity of operators since Chapter 2.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1712
This is the same associativity and precedence as the normal
(!!)operator in base.
Criterion.Main is the convenience module to import from
criterion if you‚Äôre running benchmarks in a Mainmodule. Usu-
ally you‚Äôll have a benchmark stanza in your Cabal file that be-
haves like an executable. It‚Äôs also possible to do it as a one-oÔ¨Ä
using Stack:
$ stack build criterion
$ stack ghc -- -O2 benchIndex.hs
$ ./benchIndex
Heremainuses a function from criterion calledwhnf. The
functions whnfandnf(also in criterion ), as you might guess,
refer to weak head normal form and normal form, respectively.
Weak head normal form, as we said before, evaluates to the
first data constructor. That means that if your outermost data
constructor is a Maybe, it‚Äôs only going to evaluate enough to find
out if it‚Äôs a Nothing or aJust‚Äî if there is a Just a , it won‚Äôt count
the cost of evaluating the ùëévalue.
Usingnfwould mean you wanted to include the cost of
fully evaluating the ùëéas well as the first data constructor. The
key when determining whether you want whnfornfis to think
about what you‚Äôre trying to benchmark and if reaching the first
data constructor will do all the work you‚Äôre trying to measure
or not. We‚Äôll talk more about what the diÔ¨Äerence is here and
how to decide which you need in a bit.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1713
In our case, what we want is to compare two things: the
weak head normal form evaluation of the original indexing
operator and that of our safe version, applied to the same long
list. We only need weak head normal form because (!!)and
(!?)don‚Äôt return a data constructor until they‚Äôve done the
work already, as we can see by taking a look at the first three
cases:
_ !? n|n&lt;0=Nothing
[]!? _ = Nothing
(x:<em>)!?0 =Justx
These first three cases aren‚Äôt reached until you‚Äôve gone
through the list as far as you‚Äôre going to go. The recursive case
below doesn‚Äôt return a data constructor. Instead, it invokes
itself repeatedly until one of the above cases is reached. Eval-
uating to WHNF cannot and does not pause in a self-invoked
recursive case like this:
(</em>:xs)!?n =xs!?(n-1)
-- Self function call,
-- not yet in weak head.
When evaluated to weak head normal form the above will
continue until it reaches the index, you reach the element, or
you hit the end of the list. Let us consider an example:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1714
[1,2,3]!?2
-- matches final case
(<em>:[2,3])!?2
=[2,3]!?(2-1)
-- not a data constructor, keep going
[2,3]!?1
-- matches final case
(</em>:[3])!?1
=[3]!?(1-1)
-- not a data constructor, keep going
[3]!?0
-- matches Just case
(x:[])!?0=Justx
-- We stop at Just
In the above, we happen to know ùë•is 3, but it‚Äôll get thunked
if it wasn‚Äôt opportunistically evaluated on construction of the
list.
Next, let‚Äôs look at the types of the following functions:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1715
defaultMain ::[Benchmark ]-&gt;IO()
whnf::(a-&gt;b)-&gt;a-&gt;Benchmarkable
nf::Control.DeepSeq.NFDatab=&gt;
(a-&gt;b)-&gt;a-&gt;Benchmarkable
The reason it wants a function it can apply an argument
to is so that the result isn‚Äôt shared, which we discussed in the
previous chapter. We want it to re-perform the work for each
sampling in the benchmark results, so this design prevents
that sharing. Keep in mind that if you want to use your own
datatype with nf, which has an NFData constraint you will need
to provide your own instance. You can find examples in the
deepseq library on Hackage.
Our goal with this example is to equalize the performance
diÔ¨Äerence between (!?)and(!!). In this case, we‚Äôve derived
the implementation of (!?)from the Report version of (!!).
Here‚Äôs how it looks in base:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1716
-- Go to the Data.List docs in <code>base</code>,
-- click the source link for (!!)
#ifdefUSE_REPORT_PRELUDE
xs!!n|n&lt;0=
error&quot;Prelude.!!: negative index&quot;
[]!! _ =
error&quot;Prelude.!!: index too large&quot;
(x:<em>)!!0=x
(</em>:xs)!!n=xs!!(n-1)
#else
However, after you run the benchmarks, you‚Äôll find our
version based on the above isn‚Äôt quite as fast.4Fair enough! It
turns out that most of the time when there‚Äôs a Report version as
well as a non-Report version of a function in base, it‚Äôs because
they found a way to optimize it and make it faster. If we look
down from the #else, we can find the version that replaced it:
4Note that if you get weird benchmark results, you‚Äôll want to resort to the old pro-
grammer‚Äôs trick of wiping your build. With Stack you‚Äôd run stack clean , with Cabal it‚Äôd
becabal clean . Inexplicable things happen sometimes. You shouldn‚Äôt need to do this
regularly, though.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1717
-- negIndex and tooLarge are a bottom
-- and a const bottom respectively.
{-# INLINABLE (!!) #-}
xs!!n
|n&lt;0=negIndex
|otherwise =
foldr
(\x r k-&gt; case kof
0-&gt;x
_ -&gt;r (k-1))
tooLarge xs n
The non-Report version is written in terms of foldr, which
often benefits from the various rewrite rules and optimizations
attached to foldr‚Äî rules we will not be explaining here at all,
sorry. This version also has a pragma letting GHC know it‚Äôs
okay to inline the code of the function where it‚Äôs used when
the cost estimator thinks it‚Äôs worthwhile to do so. So, let‚Äôs
change our version of this operator to match this version to
make use of those same optimizations:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1718
infixl9!?
{-# INLINABLE (!?) #-}
xs!?n
|n&lt;0=Nothing
|otherwise =
foldr
(\x r k-&gt;
casekof
0-&gt;Justx
_ -&gt;r (k-1))
(constNothing) xs n
If you run this, you‚Äôll find that‚Ä¶things have not improved.
So, what can we do to improve the performance of our opera-
tor?
Well, unless you added one already, you‚Äôll notice the type
signature is missing. If you add a declaration that the number
argument is an Int, it should now perform the same as the
original:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1719
infixl9!?
{-# INLINABLE (!?) #-}
(!?)::[a]-&gt;Int-&gt;Maybea
xs!?n
|n&lt;0=Nothing
|otherwise =
foldr
(\x r k-&gt;
casekof
0-&gt;Justx
_ -&gt;r (k-1))
(constNothing) xs n
Change the function in your module to reflect this and run
the benchmark again to check.
The issue was that the version with an inferred type was
defaulting the Num a =&gt; a toInteger which compiles to a less
efficient version of this code than does one that specifies the
typeInt. TheIntversion will turn into a more primitive, faster
loop. You can verify this for yourself by specifying the type
Integer and re-running the code or comparing the GHC Core
output for each version.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1720
More on whnf and nf
Let‚Äôs return now to the question of when we should use whnf
ornf. You want to use whnfwhen the first data constructor is a
meaningful indicator of whether the work you‚Äôre interested in
has been done. Consider the simplistic example of a program
that is meant to locate some data in a database, say, a person‚Äôs
name and whether there are any known addresses for that
person. If it finds any data, it might print that information
into a file.
Thepartyou‚Äôreprobablytryingtojudgetheperformanceof
is the lookup function that finds the data and assesses whether
it exists, not how fast your computer can print the list of ad-
dresses into a file. In that case, what you care about is at the
level of weak head normal form, and whnfwill tell you more
precisely how long it is taking to find the data and decide
whether you have a Nothing or aJust a .
On the other hand, if you are interested in measuring the
time it takes to print your results, in addition to looking up the
data, then you may want to evaluate to normal form. There
are times when measuring that makes sense. We‚Äôll see some
examples shortly.
For now, let us consider each indexing operator, the (!!)
that exists in baseand the one we‚Äôve written that uses Maybe
instead of bottoms.
In the former case, the final result has the type ùëé. The</p>
<p>CHAPTER 28. BASIC LIBRARIES 1721
function doesn‚Äôt stop recursing until it either returns bottom
or the value at that index. In either case, it‚Äôs done all the work
you‚Äôd care to measure ‚Äî traversing the list. Evaluation to
WHNF means stopping at your ùëévalue.
In the latter case with Maybe, evaluation to WHNF means
stopping at either JustorNothing . It won‚Äôt evaluate the contents
of theJustdata constructor under whnf, but it will under nf.
Either is sufficient for the purposes of the benchmark as, again,
we‚Äôre measuring how quickly this code reaches the value at an
index in the list.
Let us consider an example with a few changes:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1722
moduleMainwhere
importCriterion.Main
importDebug.Trace
myList::[Int]
myList=trace&quot;myList was evaluated&quot;
([1..9999]++[undefined])
-- your version of (!?) here
main::IO()
main=defaultMain
[ bench &quot;index list 9999&quot;
$whnf (myList !!)9998
, bench &quot;index list maybe index 9999&quot;
$nf (myList !?)9999
]
Notice what we did here. We added an undefined in what
will be the index position 9999. With the (!!)operator, we are
accessing the index just before that bottom value because there
is no outer data constructor (such as Nothing orJust) where we
could stop the evaluation. Both whnfandnfwill necessarily
force that bottom value.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1723
We also modified the whnftonffor the benchmark of (!?).
Now it will evaluate the undefined it found at that index under
the bottom in the first run of the benchmark and fail:
benchmarking index list maybe index 9999
criterion1: Prelude.undefined
A function value that returned bottom instead of a data
constructor would‚Äôve also acted as a stopping point for WHNF.
Consider the following:
Prelude&gt; (Just undefined) <code>seq</code> 1
1
Prelude&gt; (_ -&gt; undefined) <code>seq</code> 1
1
Prelude&gt; ((_ -&gt; Just undefined) 0) <code>seq</code> 1
1
Prelude&gt; ((_ -&gt; undefined) 0) <code>seq</code> 1
*** Exception: Prelude.undefined
Much of the time, whnfis going to cover the thing you‚Äôre
trying to benchmark.
Making the case for nf
Let us now look at an example of when whnfisn‚Äôt sufficient for
benchmarking, something that uses guarded recursion, unlike
(!!):</p>
<p>CHAPTER 28. BASIC LIBRARIES 1724
moduleMainwhere
importCriterion.Main
myList::[Int]
myList=[1..9999]
main::IO()
main=defaultMain
[ bench &quot;map list 9999&quot; $
whnf (map ( +1)) myList
]
The above is an example of guarded recursion because a
data constructor is interposed between each recursion step.
The data constructor is the cons cell when we‚Äôre talking about
map. Guarded recursion lets us consume the recursion steps
up to weak head normal form incrementally on demand.
Importantly, foldrcan be used to implement guarded and
unguarded recursion, depending entirely on what the folding
function does rather than any special provision made by foldr
itself. So what happens when we benchmark this?
Linking bin/bench ...
time
8.844 ns (8.670 ns .. 9.033 ns)</p>
<p>CHAPTER 28. BASIC LIBRARIES 1725
0.998 R¬≤ (0.997 R¬≤ .. 1.000 R¬≤)
mean
8.647 ns (8.567 ns .. 8.751 ns)
std dev
293.3 ps (214.7 ps .. 412.9 ps)
variance introduced by outliers:
57% (severely inflated)
Well, that‚Äôs suspect. Does it really take 8.8 nanoseconds
to traverse a 10,000 element linked list in Haskell? We saw
an example of how long it should take, roughly. This is an
example of our benchmark being too lazy. The issue is that
mapuses guarded recursion and the cons cells of the list are
interposed between each recursion of map. You may recall this
from the lists and folds chapters. So, it ends up evaluating
only this far:
(_ : _)
Ah, that first data constructor. It has neither done the work
of incrementing the value nor has it traversed the rest of the
list. It‚Äôs just sitting there at the first cons cell. Using bottoms,
you can progressively prove to yourself what whnfis evaluating
by replacing things and re-running the benchmark:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1726
-- is it applying (+1)?
myList=(undefined :[2..9999])
-- Is it going any further in the list?
myList::[Int]
myList=(undefined :undefined)
-- This should s'plode because
-- it'll be looking for that first
-- data constructor or (-&gt;) to stop at
myList::[Int]
myList=undefined
No matter, we can fix this!
-- change this bit
whnf(map (+1)) myList
-- into:
nf(map (+1)) myList
Then we get:
time
122.5 Œºs (121.7 Œºs .. 123.9 Œºs)
0.999 R¬≤ (0.998 R¬≤ .. 1.000 R¬≤)</p>
<p>CHAPTER 28. BASIC LIBRARIES 1727
mean
123.0 Œºs (122.0 Œºs .. 125.6 Œºs)
std dev
5.404 Œºs (2.806 Œºs .. 9.323 Œºs)
That is considerably more realistic considering we‚Äôve eval-
uated the construction of a whole new list. This is slower than
the indexing operation because we‚Äôre not just kicking a new
value out, we‚Äôre also constructing a new list.
In general when deciding between whnfandnf, ask yourself,
‚Äúwhen I have reached the first data constructor, have I done
most or all of the work that matters?‚Äù Be careful not to use nf
too much. If you have a function that returns a nontrivial data
structure or collection for which it‚Äôs already done all the work
to produce, nfwill make your code look excessively slow and
lead you on a wild goose chase.
28.3 Profiling your programs
We‚Äôre going to do our best to convey what you should know
about profiling programs with GHC and what we think is con-
ceptually less well covered, but we aren‚Äôt going to presume to
replace the GHC User Guide. We strongly recommend you
read the guide5for more information.
5https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html</p>
<p>CHAPTER 28. BASIC LIBRARIES 1728
Profiling time usage
Sometimes rather than seeing how fast our programs are, we
want to know why they‚Äôre slow or fast and where they‚Äôre spend-
ing their time. To that end, we use profiling. First, let‚Äôs put
together a simple example for motivating this:
-- profilingTime.hs
moduleMainwhere
f::IO()
f= do
print ([ 1..]!!999999)
putStrLn &quot;f&quot;
g::IO()
g= do
print ([ 1..]!!9999999)
putStrLn &quot;g&quot;
main::IO()
main= do
f
g
Given that we traverse 10 times as much list structure in the</p>
<p>CHAPTER 28. BASIC LIBRARIES 1729
case of ùëî, we believe we should see something like 10 times
as much CPU time spent in ùëî. We can do the following to
determine if that‚Äôs the case:
$ stack ghc -- -prof -fprof-auto </p>
<blockquote>
<p>-rtsopts -O2 profile.hs
./profile +RTS -P
cat profile.prof
Breaking down what each flag does:
1.-profenables profiling. Profiling isn‚Äôt enabled by default
because it can lead to slower programs but this generally
isn‚Äôt an issue when you‚Äôre investigating the performance
of your programs. Used alone, -profwill require you to
annotate cost centers manually, places for GHC to mark
for keeping track of how much time is spent evaluating
something.
2.-fprof-auto assigns all bindings not marked inline a cost
center named after the binding. This is fine for little stuÔ¨Ä
or otherwise not terribly performance-sensitive stuÔ¨Ä, but
if you‚Äôre dealing with a large program or one sensitive
to perturbations from profiling, it may be better to not
use this and instead assign your ‚ÄúSCCs‚Äù manually. SCC is
what the GHC documentation calls a cost center.</p>
</blockquote>
<p>CHAPTER 28. BASIC LIBRARIES 1730
3.-rtsopts enables you to pass GHC RTS options to the gen-
erated binary. This is optional so you can get a smaller
binary if desired. We need this to tell our program to
dump the profile to the .proffile named after our pro-
gram.
4.-O2enables the highest level of program optimizations.
This is wise if you care about performance but -Oby itself
also enables optimizations, albeit somewhat less aggres-
sive ones. Either option can make sense when bench-
marking; it‚Äôs a case by case thing, but most Haskell pro-
grammers feel pretty free to default to -O2.
After examining the .proffile which contains the profiler
output, this is roughly what we‚Äôll see:
Sun Feb 14 21:34 2016
Time and Allocation
Profiling Report (Final)
profile +RTS -P -RTS
total time = 0.22 secs
(217 ticks @ 1000 us, 1 processor)
total alloc = 792,056,016 bytes
(excludes profiling overheads)</p>
<p>CHAPTER 28. BASIC LIBRARIES 1731
COST CENTRE MODULE %time %alloc ticks bytes
g Main 91.2 90.9 198 720004344
f Main 8.8 9.1 19 72012568
...later noise snipped,
we care about the above...
And indeed, 91.2% time spent in ùëî, 8.8% time spent in ùëìwould
seem to validate our hypothesis here.
Time isn‚Äôt the only thing we can profile. We‚Äôd also like
to know about the space (or memory) diÔ¨Äerent parts of our
program are responsible for using.
Profiling heap usage
We have measured time; now we shall measure space. Well,
memory anyway; we‚Äôre not astrophysicists. We‚Äôre going to
keep this quick and boring so that we might be able to get to
the good stuÔ¨Ä:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1732
moduleMainwhere
importControl.Monad
blah::[Integer]
blah=[1..1000]
main::IO()
main=
replicateM_ 10000(print blah)
ghc -prof -fprof-auto -rtsopts -O2 loci.hs
./loci +RTS -hc -p
hp2ps loci.hp
If you open the loci.ps postscript file with your PDF reader
of choice, you‚Äôll see how much memory the program used
over the time the program ran. Note that you‚Äôll need the
program to run a minimum amount of time for the profiler
to get any samples of the heap size.
28.4 Constant applicative forms
Whenwe‚ÄôretalkingaboutmemoryusageandsharinginHaskell,
we have to also talk about CAFs: constant applicative forms.
CAFs are expressions that have no free variables and are held</p>
<p>CHAPTER 28. BASIC LIBRARIES 1733
in memory to be shared with all other expressions in a module.
They can be literal values or partially applied functions that
have no named arguments.
We‚Äôre going to construct a very large CAF here. Notice we
are mapping over an infinite list and want to know how much
memory this uses. You might consider betting on a lot:
moduleMainwhere
incdInts ::[Integer]
incdInts =map (+1) [1..]
main::IO()
main= do
print (incdInts !!1000)
print (incdInts !!9001)
print (incdInts !!90010)
print (incdInts !!9001000)
print (incdInts !!9501000)
print (incdInts !!9901000)
Now we can profile that:
Thu Jan 21 23:25 2016
Time and Allocation
Profiling Report (Final)</p>
<p>CHAPTER 28. BASIC LIBRARIES 1734
cafSaturation +RTS -p -RTS
total time = 0.28 secs
(283 ticks @ 1000 us, 1 processor)
total alloc = 1,440,216,712 bytes
(excludes profiling overheads)
COST CENTRE MODULE %time %alloc
incdInts Main 90.1 100.0
main Main 9.9 0.0
-- some irrelevant bits elided
COST CENTRE MODULE no. entries %time %alloc
MAIN MAIN 45 0 0.0 0.0
CAF Main 89 0 0.0 0.0
incdInts Main 91 1 90.1 100.0
main Main 90 1 9.9 0.0
Note how incdInts is its own constant applicative form (CAF)
here apart from main. And notice the size of that memory
allocation. It‚Äôs because that mapping over an infinite list is a
top-level value that can be shared throughout a module, so it
must be evaluated and the results held in memory in order to
be shared.
CAFs include
‚Ä¢values;</p>
<p>CHAPTER 28. BASIC LIBRARIES 1735
‚Ä¢partially applied functions without named arguments;
‚Ä¢fully applied functions such as incdInts above, although
that would be rare in real code.
CAFs can make some programs faster since you don‚Äôt have
to keep re-evaluating shared values; however, CAFs can be-
come memory-intensive quite quickly. The important take-
away is that, if you find your program using much more mem-
ory than you expected, find the golden CAF and kill it.
Fortunately, CAFs mostly occur in toy code. Real world
code is usually pulling the data from somewhere, which avoids
the problem of holding large amounts of data in memory.
Let‚Äôs look at a way to avoid creating a CAF by introducing
an argument into our incdInts example:
moduleMainwhere
-- not a CAF
incdInts ::[Integer]-&gt;[Integer]
incdInts x=map (+1) x
main::IO()
main= do
print (incdInts [ 1..]!!1000)
If you examine the profile:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1736
CAF
main
incdInts
Pointfree top-level declarations will be CAFs, but pointful
ones will not. We‚Äôd discussed this to some degree in the pre-
vious chapter as well. The reason the diÔ¨Äerence matters is
often not because of the total allocation reported by the pro-
file, which is often misleading anyway. Rather it‚Äôs important
because lists are as much control structures as data structures
and it‚Äôs very cheap in GHC to construct a list which is thrown
away immediately. Doing so might increase how much mem-
ory you allocate in total, but unlike a CAF, it won‚Äôt stay in your
heap which may lead to lower peak memory usage and the
runtime spending less time collecting garbage.
Indeed, this is not a standalone CAF. But what if we eta
reduce it (that is, remove its named arguments) so that it is
pointfree?</p>
<p>CHAPTER 28. BASIC LIBRARIES 1737
moduleMainwhere
-- Gonna be a CAF this time.
incdInts ::[Integer]-&gt;[Integer]
incdInts =map (+1)
main::IO()
main= do
print (incdInts [ 1..]!!1000)
This time when you look at the profile, it‚Äôll be its own CAF:
CAF
incdInts
main
incdInts
GREAT SCOTT!
It doesn‚Äôt really change the performance for something so
trivial, but you get the idea. The big diÔ¨Äerence between the
two is in the heap profiles. Check them and you will likely see
what we mean.
28.5 Map
We‚Äôre going to start our exploration of data structures with Map.
It‚Äôs worth pointing out here that most of the structures we‚Äôll</p>
<p>CHAPTER 28. BASIC LIBRARIES 1738
look at are, in some sense, replacements for the lists we have
depended on throughout the book. Lists and strings are useful
for a lot of things, but they‚Äôre not the most performant or even
the most useful way to structure your data. What is the most
performant or useful for any given program can vary, so we
can‚Äôt give a blanket recommendation that you should always
use any one of the structures we‚Äôre going to talk about. You
have to judge that based on what problems you‚Äôre trying to
solve and use benchmarking and profiling tools to help you
fine tune the performance.
Most of the data structures we‚Äôll be looking at are in the
containers6library. If you build it, Mapwill come. And also
Sequence andSetand some other goodies. You‚Äôll notice a lot of
the data structures have a similar API, but each are designed
for diÔ¨Äerent sets of circumstances.
We‚Äôve used the Maptype before to represent associations of
unique pairings of keys to values. You may remember it from
the Testing chapter in particular, where we used it to look up
Morse code translations of alphabetic characters. Those were
fun times, so carefree and innocent.
The structure of the Maptype looks like this:
6http://hackage.haskell.org/package/containers</p>
<p>CHAPTER 28. BASIC LIBRARIES 1739
dataMapk a
=Bin
{-# UNPACK #-}
!Size!k a
!(Mapk a)!(Mapk a)
|Tip
typeSize=Int
You may recognize the exclamation marks denoting strict-
nessfromthe sectionson bangpatterns inthe previouschapter.
Tip is a data constructor for capping oÔ¨Ä the branch of a tree.
If you‚Äôd like to find out about the unpacking of strict fields,
which is what the UNPACK pragma is for; see the GHC documen-
tation for more information.
What‚Äôs something that‚Äôs faster with Map?
Well, lookups by key in particular are what it‚Äôs used for. Con-
siderthefollowingcomparisonofanassociationlistand Data.Map :
moduleMainwhere
importCriterion.Main
import qualified Data.Map asM</p>
<p>CHAPTER 28. BASIC LIBRARIES 1740
genList ::Int-&gt;[(String,Int)]
genList n=go n[]
wherego0xs=(&quot;0&quot;,0):xs
go n' xs =
go (n'-1) ((show n', n') :xs)
pairList ::[(String,Int)]
pairList =genList 9001
testMap ::M.MapStringInt
testMap =M.fromList pairList
main::IO()
main=defaultMain
[ bench &quot;lookup one thing, list&quot; $
whnf (lookup &quot;doesntExist&quot; ) pairList
, bench &quot;lookup one thing, map&quot; $
whnf (M.lookup&quot;doesntExist&quot; ) testMap
]
Association lists such as pairList are fine if you need some-
thing cheap and cheerful for a very small series of pairs, but
you‚Äôre better oÔ¨Ä using Mapby default when you have keys and
values. You get a handy set of baked-in functions for looking
things up and an efficient means of doing so. Insert operations</p>
<p>CHAPTER 28. BASIC LIBRARIES 1741
also benefit from being able to find the existing key-value pair
inMapmore quickly than in association lists.
What‚Äôs slower with Map?
Using an Intas your key type is usually a sign you‚Äôd be better oÔ¨Ä
with aHashMap ,IntMap , orVector , depending on the semantics of
your problem. If you need good memory density and locality
‚Äî which will make aggregating and reading values of a large
Vector faster, then Mapmight be inappropriate and you‚Äôll want
Vector instead.
28.6 Set
This is also in containers. It‚Äôs like a Map, but without the ‚Äòvalue‚Äô
part of the key-value pair. You may be asking yourself, why
do I want only keys?
When we use Map, it has an Ordconstraint on the functions
to ensure the keys are in order. That is one of the things that
makes lookups in Mapparticularly efficient. Knowing that the
keys will be ordered divides the problem space up by halves:
if we‚Äôre looking for the key 6 in a set of keys from 1-10, we
don‚Äôt have to search in the first half of the set because those
numbers are less than 6. Set, likeMap, is structured associatively,
not linearly.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1742
Functions with Sethave the same Ordconstraint, but now
we don‚Äôt have key-value pairs ‚Äî we only have keys. Another
way to think of it is the keys are now the values. That means
thatSetrepresents a unique, ordered set of values.
Here is the datatype for Set:
dataSeta
=Bin
{-# UNPACK #-}
!Size!a!(Seta)!(Seta)
|Tip
typeSize=Int
It‚Äôs eÔ¨Äectively equivalent to a Maptype with unit values.
moduleMainwhere
importCriterion.Main
import qualified Data.Map asM
import qualified Data.Set asS
bumpIt(i, v)=(i+1, v+1)</p>
<p>CHAPTER 28. BASIC LIBRARIES 1743
m::M.MapIntInt
m=M.fromList $take10000stream
wherestream=iterate bumpIt ( 0,0)
s::S.SetInt
s=S.fromList $take10000stream
wherestream=iterate ( +1)0
membersMap ::Int-&gt;Bool
membersMap i=M.member i m
membersSet ::Int-&gt;Bool
membersSet i=S.member i s
main::IO()
main=defaultMain
[ bench &quot;member check map&quot; $
whnf membersMap 9999
, bench &quot;member check set&quot; $
whnf membersSet 9999
]
If you benchmark the above, you should get very similar
results for both, with Mapperhaps being a smidgen slower than
Set. They‚Äôre similar because they‚Äôre nearly identical data struc-
tures in the containers library.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1744
There‚Äôs not much more to say. It has the same pros and
cons7asMap, with the same performance of the core operations,
save that you‚Äôre more limited.
Exercise: Benchmark Practice
Make a benchmark to prove for yourself whether MapandSet
have similar performance. Try operations other than mem-
bership testing, such as insertion or unions.
28.7 Sequence
Sequence is a nifty datatype built atop finger trees; we aren‚Äôt
going to address finger trees in this book, unfortunately, but we
encourage you to check them out.8Sequence appends cheaply
on the front and the back, which avoids a common problem
with lists where you can only cons to the front cheaply.
Here is the datatype for Sequence :
7HA HA GET IT?!
8see, for example, Finger Trees: A Simple General-purpose Data Structure by Ralf
Hinze and Ross Paterson</p>
<p>CHAPTER 28. BASIC LIBRARIES 1745
newtype Seqa=Seq(FingerTree (Elema))
-- Elem is so elements and nodes can be
-- distinguished in the types of the
-- implementation. Don't sweat it.
newtype Elema=Elem{ getElem ::a }
dataFingerTree a
=Empty
|Singlea
|Deep{-# UNPACK #-} !Int!(Digita)
(FingerTree (Nodea))!(Digita)
What‚Äôs faster with Sequence?
Updates (cons and append) to both ends of the data structure
and concatenation are what Sequence is particularly known for.
You won‚Äôt want to resort to using Sequence by default though,
as the list type is often competitive. Sequence will have more
efficient access to the tail than a list will. Here‚Äôs an example
whereSequence does better because the list is a bit big:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1746
moduleMainwhere
importCriterion.Main
import qualified Data.Sequence asS
lists::[[Int]]
lists=replicate 10[1..100000]
seqs::[S.SeqInt]
seqs=
replicate 10(S.fromList [ 1..100000])
main::IO()
main=defaultMain
[ bench &quot;concatenate lists&quot; $
nf mconcat lists
, bench &quot;concatenate sequences&quot; $
nf mconcat seqs
]
Note that in the above, a substantial amount of the time in
the benchmark is spent traversing the data structure because
we‚Äôre evaluating to normal form to ensure all the work is done.
Incidentally, this accentuates the diÔ¨Äerence between a list and
Sequence because it‚Äôs faster to index or traverse a sequence than</p>
<p>CHAPTER 28. BASIC LIBRARIES 1747
a list. Consider the following:
moduleMainwhere
importCriterion.Main
import qualified Data.Sequence asS
lists::[Int]
lists=[1..100000]
seqs::S.SeqInt
seqs=S.fromList [ 1..100000]
main::IO()
main=defaultMain
[ bench &quot;indexing list&quot; $
whnf (\xs-&gt;xs!!9001) lists
, bench &quot;indexing sequence&quot; $
whnf (flip S.index9001) seqs
]
The diÔ¨Äerence between list and Sequence in the above when
we ran the benchmark was two orders of magnitude.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1748
What‚Äôs slower with Sequence?
Sequence is a persistent data structure like Map, so the memory
density isn‚Äôt as good as it is with Vector (we‚Äôre getting there).
Indexing by Intwill be faster with Vector as well. List will be
faster with consing and concatenation in some cases, if the
lists are small. When you know you need cheap appending
to the end of a long list, it‚Äôs worth giving Sequence a try, but
it‚Äôs better to base the final decision on benchmarking data if
performance matters.
28.8 Vector
The next data structure we‚Äôre going to look at is not in contain-
ers. It‚Äôs in its own library called, unsurprisingly, vector9. You‚Äôll
notice it says vectors are ‚Äúefficient arrays.‚Äù We‚Äôre not going to
look at arrays, or Haskell‚Äôs Arraytype, specifically here, though
you may already be familiar with the idea.
Onerarelyusesarrays, ormorespecifically, Array10inHaskell.
Vector is almost always what you want instead of an array. The
default Vector type is implemented as a slice wrapper of Array;
we can see this in the definition of the datatype:
9https://hackage.haskell.org/package/vector
10http://hackage.haskell.org/package/array</p>
<p>CHAPTER 28. BASIC LIBRARIES 1749
-- | Boxed vectors, supporting
-- efficient slicing.
dataVectora=
Vector{-# UNPACK #-} !Int
{-# UNPACK #-} !Int
{-# UNPACK #-} !(Arraya)
deriving (Typeable )
There are many variants of Vector, although we won‚Äôt dis-
cuss them all here. These include boxed, unboxed, immutable,
mutable, and storable vectors, but the plain version above is
the usual one you‚Äôd use. We‚Äôll talk about mutable vectors in
their own section. Boxed means the vector can reference any
datatype you want; unboxed represents raw values without
pointer indirection.11The latter can save a lot of memory but
is limited to types like Bool,Char,Double ,Float,Int,Word, tuples
of unboxable values. Since a newtype is unlifted and doesn‚Äôt
introduce any pointer indirection, you can unbox any newtype
that contains an unboxable type.
When does one want a Vector in Haskell?
You want a Vector when
11This book isn‚Äôt the right place to talk about what pointers are in detail. Briefly, they
are references to things in memory, rather than the things themselves.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1750
‚Ä¢you need memory efficiency close to the theoretical max-
imum for the data you are working with;
‚Ä¢your data access is almost exclusively in terms of indexing
via anIntvalue;
‚Ä¢you want uniform access times for accessing each element
in the data structure; and/or,
‚Ä¢you will construct a Vector once and read it many times (al-
ternatively, you plan to use a mutable Vector for ongoing,
efficient updates).
What‚Äôs this about slicing?
Remember this from the definition of Vector ?
-- | Boxed vectors, supporting
-- efficient slicing.
Slicing refers to slicing oÔ¨Ä a portion, or creating a sub-array.
TheVector type is designed for making slicing much cheaper
than it otherwise would be. Consider the following:</p>
<p>CHAPTER 28. BASIC LIBRARIES 1751
moduleMainwhere
importCriterion.Main
import qualified Data.Vector asV
slice::Int-&gt;Int-&gt;[a]-&gt;[a]
slicefrom len xs =
take len (drop from xs)
l::[Int]
l=[1..1000]
v::V.VectorInt
v=V.fromList [ 1..1000]
main::IO()
main=defaultMain
[ bench &quot;slicing list&quot; $
whnf (head .slice100900) l
, bench &quot;slicing vector&quot; $
whnf (V.head.V.slice100900) v
]
If you run this benchmark, Vector should be faster than
list. Why? Because when we constructed that new Vector with</p>
<p>CHAPTER 28. BASIC LIBRARIES 1752
V.slice , all it had to do was the following:
-- from Data.Vector
instance G.VectorVectorawhere
-- other methods elided
{-# INLINE basicUnsafeSlice #-}
basicUnsafeSlice j n ( Vectori_arr)=
Vector(i+j) n arr
What makes Vector nicer than lists and Arrayin this respect
is that when you construct a slice or view of another Vector , it
doesn‚Äôt have to construct as much new data. It returns a new
wrapper around the original underlying array with a new index
and oÔ¨Äset with a reference to the same original Array. Doing
the same with an ordinary Arrayor a list would‚Äôve required
copying more data. Speed comes from being sneaky and
skipping work.
Updating vectors
Persistent vectors are not great at handling updates on an
ongoing basis, but there are some situations in which they can
surprise you. One such case is fusion12. Fusion, or loop fusion,
12Stream Fusion; Duncan Coutts; http://code.haskell.org/~dons/papers/icfp088-coutts.
pdf</p>
<p>CHAPTER 28. BASIC LIBRARIES 1753
means that as an optimization the compiler can fuse several
loops into one megaloop and do it in one pass:
moduleMainwhere
importCriterion.Main
import qualified Data.Vector asV
testV'::Int-&gt;V.VectorInt
testV'n=
V.map (+n)$V.map (+n)$
V.map (+n)$V.map (+n)
(V.fromList [ 1..10000])
testV::Int-&gt;V.VectorInt
testVn=
V.map ( (+n).(+n)
.(+n).(+n) )
(V.fromList [ 1..10000])</p>
<p>CHAPTER 28. BASIC LIBRARIES 1754
main::IO()
main=defaultMain
[ bench &quot;vector map prefused&quot; $
whnf testV 9998
, bench &quot;vector map will be fused&quot; $
whnf testV' 9998
]
The vector library has loop fusion built in, so in a lot of
cases, such as with mapping, you won‚Äôt construct 4 vectors just
because you mapped four times. Through the use of GHC
RULES13the code in testV‚Äô will change into what you see in
testV. It‚Äôs worth noting that part of the reason this optimization
is sound is because we know what code performs eÔ¨Äects and
what does not because we have types.
However, loop fusion isn‚Äôt a panacea and there will be situ-
ations where you want to change one element at a time, selec-
tively. Let‚Äôs consider more efficient ways of updating vectors.
We‚Äôre going to use the (//)operator from the vector library
here. It‚Äôs a batch update operator that allows you to modify
several elements of the vector at one time:
13https://wiki.haskell.org/GHC/Using_rules</p>
<p>CHAPTER 28. BASIC LIBRARIES 1755
moduleMainwhere
importCriterion.Main
importData.Vector ((//))
import qualified Data.Vector asV
vec::V.VectorInt
vec=V.fromList [ 1..10000]
slow::Int-&gt;V.VectorInt
slown=go n vec
wherego0v=v
go n v=go (n-1) (v//[(n,0)])
batchList ::Int-&gt;V.VectorInt
batchList n=vec//updates
whereupdates =
fmap (\n-&gt;(n,0)) [0..n]
main::IO()
main=defaultMain
[ bench &quot;slow&quot;$whnf slow 9998
, bench &quot;batch list&quot; $
whnf batchList 9998
]</p>
<p>CHAPTER 28. BASIC LIBRARIES 1756
The issue with the first example is that we‚Äôre using a batch
API‚Ä¶ but not in batch. It‚Äôs much cheaper (500‚Äì1000x in our
tests) to construct the list of updates all at once and then feed
them to the (//)function. We can make it even faster still by
using the update function that uses a vector of updates:
batchVector ::Int-&gt;V.VectorInt
batchVector n=V.unsafeUpdate vec updates
whereupdates =
fmap (\n-&gt;(n,0))
(V.fromList [ 0..n])
Benchmarkingthis versionshould getyoucode thatis about
1.4x faster. But we‚Äôre greedy. So we want more.
Mutable Vectors
‚ÄúMoria! Moria! Wonder of the Northern world. Too
deep we delved there, and woke the nameless fear.‚Äù
‚Äî Gl√≥in, The Fellowship of the Ring
What if we want something even faster? Although many
people don‚Äôt realize this about Haskell, we can obtain the bene-
fits of in-place updates if we so desire. What sets Haskell apart
is that we cannot do so in a way that compromises referential
transparency or the nice equational properties our expressions</p>
<p>CHAPTER 28. BASIC LIBRARIES 1757
have. First we‚Äôll demonstrate how to do this, then we‚Äôll talk
about how this is designed to behave predictably.
Here comes an example:
moduleMainwhere
importControl.Monad.Primitive
importControl.Monad.ST
importCriterion.Main
import qualified Data.Vector asV
import qualified Data.Vector.Mutable asMV
import qualified
Data.Vector.Generic.Mutable asGM
mutableUpdateIO
::Int
-&gt;IO(MV.MVector RealWorld Int)
mutableUpdateIO n= do
mvec&lt;-GM.new (n+1)
go n mvec
wherego0v=return v
go n v=
(MV.write v n 0)&gt;&gt;go (n-1) v</p>
<p>CHAPTER 28. BASIC LIBRARIES 1758
mutableUpdateST ::Int-&gt;V.VectorInt
mutableUpdateST n=runST$ do
mvec&lt;-GM.new (n+1)
go n mvec
wherego0v=V.freeze v
go n v=
(MV.write v n 0)&gt;&gt;go (n-1) v
main::IO()
main=defaultMain
[ bench &quot;mutable IO vector&quot;
$whnfIO (mutableUpdateIO 9998)
, bench &quot;mutable ST vector&quot;
$whnf mutableUpdateST 9998
]
We‚Äôre going to talk about runSTshortly. For the moment,
let‚Äôs concentrate on the fact that the mutable IOversion is
approximately 7,000x faster than the original unbatched loop
in our tests. The STversion is about 1.5x slower than the IO
version, but still very fast. The added time in the STversion is
from freezing the mutable vector into an ordinary vector. We
won‚Äôt explain STfully here, but, as we‚Äôll see, it can be handy
when you want to temporarily make something mutable and
ensure no mutable references are exposed outside of the ST
monad.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1759
Here were the timings we got with the various vector oper-
ations on our computer:
Variant Microseconds
slow 133,600
batchList 244
batchVector 176
mutableUpdateST 32
mutableUpdateIO 19
Notably, most of the performance improvement was from
not doing something silly. Don‚Äôt resort to the use of mutation
viaIOorSTexcept where you know it‚Äôs necessary. It‚Äôs worth
noting that given our test involved updating almost 10,000
indices in the vector, we spent an average of 1.9 nanoseconds
per update when we used mutability and 17.6 ns when we did
it in batch with a persistent vector.
A sidebar on the ST Monad
STcan be thought of as a mutable variant of the strict State
monad. From another angle, it could be thought of as IO
restricted exclusively to mutation which is guaranteed safe.
Safe how? STis relying on the principle behind that old
philosophical saw about the tree that falls in the forest with no
one to see it fall. The idea behind this ‚Äúmorally eÔ¨Äect-free‚Äù un-
derstanding of mutable state was introduced in the paper Lazy</p>
<p>CHAPTER 28. BASIC LIBRARIES 1760
Functional State Threads.14It unfreezes your data, mutates
it, then refreezes it so that it can‚Äôt mutate anymore. Thus it
manages to mutate and still maintain referential transparency.
ForSTto work properly, the code that mutates the data must
not get reordered by the optimizer or otherwise monkeyed
with, much like the code in IO. So there must be something
underlying the type which prevents GHC ruining our day. Let
us examine the STtype:
Prelude&gt; import Control.Monad.ST
Prelude&gt; :info ST
type role ST nominal representational
newtype ST s a =
GHC.ST.ST (GHC.ST.STRep s a)
...
Prelude&gt; import GHC.ST
Prelude&gt; :info STRep
type STRep s a =
GHC.Prim.State# s
-&gt; (# GHC.Prim.State# s, a #)
There‚Äôs a bit of ugliness in here that shouldn‚Äôt be too sur-
prising after you‚Äôve seen GHC Core in the previous chapter.
What‚Äôs important is that ùë†is getting its type from the thing
14Lazy Functional State Threads; John Launchbury and Simon Peyton Jones</p>
<p>CHAPTER 28. BASIC LIBRARIES 1761
you‚Äôre mutating, but it has no value-level witness. The State
monad here is therefore erasable; it can encapsulate this mu-
tation process and then melt away.
It‚Äôs important to understand that ùë†isn‚Äôt the state you‚Äôre
mutating. The mutation is a side eÔ¨Äect of having entered
the closures that perform the eÔ¨Äect. This strict, unlifted state
transformer monad happens to structure your code in a way
that preserves the intended order of the computations and
their associated eÔ¨Äects.
By closures here, we mean lambda expressions. Of course
we do, because this whole book is one giant lambda expression
under the hood. Entering each lambda performs its eÔ¨Äects.
The eÔ¨Äects of a series of lambdas are not batched, because the
ordering is important when we‚Äôre performing eÔ¨Äects, as each
new expression might depend on the eÔ¨Äects of the previous
one. The eÔ¨Äects are performed and then, if the value that
should result from the computation is also going to be used,
the value is evaluated.
So what is the ùë†type for? Well, while it‚Äôs all well and good to
ask politely that programmers freeze a mutable reference into
a persistent, immutable data structure as the final result‚Ä¶you
can‚Äôt count on that. STenforces it at compile time by making
it so that ùë†will never unify with anything outside of the ST
Monad. The trick for this is called existential quantification15,
15Existentially quantified types; Haskell Wikibook
https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types</p>
<p>CHAPTER 28. BASIC LIBRARIES 1762
but having said this won‚Äôt necessarily mean anything to you
right now. But it does prevent you from accidentally leaking
mutable references to code outside ST, which could then lead
to code that does unpredictable things depending on the state
of the bits in memory.
Avoid dipping in and out of STover and over. The thaws
and freezes will cost you in situations where it might have
been better to just use IO. Batching your mutation is best for
performance and code comprehensibility.
Exercises: Vector
Setup a benchmark harness with criterion to profile how much
memory boxed and unboxed vectors containing the same
data uses. You can combine this with a benchmark to give it
something to do for a few seconds. We‚Äôre not giving you a lot
because you‚Äôre going to have to learn to read documentation
and source code anyway.
28.9 String types
The title is a slight bit of a misnomer as we‚Äôll talk about two
string (or text) types and one type for representing sequences
ofbytes. Here‚Äôsabriefexplanationof String ,Text, andByteString :</p>
<p>CHAPTER 28. BASIC LIBRARIES 1763
String
You know what String is. It‚Äôs a type alias for a list of Char, yet
underneath it‚Äôs not quite as simple as an actual list of Char.
One of the benefits of using strings is the simplicity, and
they‚Äôre easy enough to explain. For most demonstration and
toy program purposes, they‚Äôre fine.
However, like lists themselves, they can be infinite. The
memory usage for even very large strings can get out of control
rapidly. Furthermore, they have very inefficient character-by-
character indexing into the String. The time taken to do a
lookup increases proportionately with the length of the list.
Text
This one comes in the text16library on Hackage. This is best
when you have plain text, but need to store the data more
efficiently ‚Äî particularly as it concerns memory usage.
We‚Äôve used this one a bit in previous chapters, when we
were playing with OverloadedStrings . The benefits here are that
you get:
‚Ä¢compact representation in memory; and
‚Ä¢efficient indexing into the string.
16http://hackage.haskell.org/package/text</p>
<p>CHAPTER 28. BASIC LIBRARIES 1764
However, Textis encoded as UTF-16, and that isn‚Äôt what
most people expect given UTF-8‚Äôs popularity. In Text‚Äôs defense,
UTF-16 is often faster due to cache friendliness via chunkier
and more predictable memory accesses.
Don‚Äôt trust your gut, measure
We mentioned Texthas a more compact memory represen-
tation, but what do you think the memory profile for the
following program will look up? High first, then low, or low
first, then high?</p>
<p>CHAPTER 28. BASIC LIBRARIES 1765
moduleMainwhere
importControl.Monad
import qualified Data.Text asT
import qualified Data.Text.IO asTIO
import qualified System.IO asSIO
-- replace &quot;/usr/share/dict/words&quot;
-- as appropriate
dictWords ::IOString
dictWords =
SIO.readFile &quot;/usr/share/dict/words&quot;
dictWordsT ::IOT.Text
dictWordsT =
TIO.readFile &quot;/usr/share/dict/words&quot;
main::IO()
main= do
replicateM_ 1000(dictWords &gt;&gt;=print)
replicateM_ 1000
(dictWordsT &gt;&gt;=TIO.putStrLn)
The issue is that Textwent ahead and loaded the entire file
into memory each of the ten times you forced the IOaction.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1766
ThereadFile operation for String , however, was lazy and only
read as much of the file into memory as needed to print the
data to stdout. The proper way to handle incrementally pro-
cessing data is with streaming17, but this is not something we‚Äôll
cover in detail in this book. However, there is a lazy way we
could change this:
-- Add the following to the module you
-- already made for profiling String
-- and Text.
import qualified Data.Text.Lazy asTL
import qualified Data.Text.Lazy.IO asTLIO
dictWordsTL ::IOTL.Text
dictWordsTL =
TLIO.readFile &quot;/usr/share/dict/words&quot;
main::IO()
main= do
replicateM_ 1000(dictWords &gt;&gt;=print)
replicateM_ 1000
(dictWordsT &gt;&gt;=TIO.putStrLn)
replicateM_ 1000
(dictWordsTL &gt;&gt;=TLIO.putStrLn)
17https://wiki.haskell.org/Pipes</p>
<p>CHAPTER 28. BASIC LIBRARIES 1767
Now you should see memory usage plummet again after
a middle plateau because you‚Äôre reading in as much text as
necessary to print, able to deallocate as you go. This is some,
but not all, of the benefits of streaming but we do strongly
recommend using streaming rather than relying on a lazy IO
API.
ByteString
Thisisnotastring. Ortext. Notnecessarilyanyway. ByteString s
are sequences of bytes represented (indirectly) as a vector of
Word8values. Text on a computer is made up of bytes, but it
has to have a particular encoding in order for it to be text.
Encodings of text can be ASCII, UTF-8, UTF-16, or UTF-32,
usually UTF-8 or UTF-16. The Texttype encodes the data as
UTF-16, partly for performance. It‚Äôs often faster to read larger
chunks of data at a time from memory, so the 16-bits-per-rune
encoding of UTF-16 performs a bit better in most cases.
The main benefit of ByteString is that it‚Äôs easy to use via the
OverloadedStrings extension but is bytes instead of text. This
addresses a larger problem space than mere text.
The flip side of that, of course, is that it encompasses byte
data that isn‚Äôt comprehensible text. That‚Äôs a drawback if you
didn‚Äôt mean to permit non-text byte sequences in your data.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1768
ByteString examples
Here‚Äôs an example highlighting that ByteStrings are not always
text:
{-# LANGUAGE OverloadedStrings #-}
moduleBSwhere
import qualified Data.Text.IO asTIO
import qualified Data.Text.Encoding asTE
import qualified Data.ByteString.Lazy asBL
-- https://hackage.haskell.org/package/zlib
import qualified
Codec.Compression.GZip asGZip
We‚Äôre going to use the gzipcompression format to compress
some data. This is so we have an example of data that includes
bytes that aren‚Äôt a valid text encoding.
input::BL.ByteString
input=&quot;123&quot;
compressed ::BL.ByteString
compressed =GZip.compress input
TheGZipmodule expects a lazy ByteString , probably so that
it‚Äôs streaming friendly.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1769
main::IO()
main= do
TIO.putStrLn $TE.decodeUtf8 (s input)
TIO.putStrLn $
TE.decodeUtf8 (s compressed)
wheres=BL.toStrict
Theencodingmoduleinthetextlibraryexpectsstrict ByteString s,
so we have to make them strict before attempting a decoding.
The second text decode will fail because there‚Äôll be a byte that
isn‚Äôt recognizably correct as an encoding of text information.
ByteString traps
You might think to yourself at some point, ‚ÄúI‚Äôd like to convert
aString to aByteString !‚Äù This is a perfectly reasonable thing to
want to do, but many Haskellers will mistakenly use the Char8
module in the bytestring library when that is not really what
they want. The Char8module is really a convenience for data
that mingles bytes and ASCII data18there. It doesn‚Äôt work for
Unicode and shouldn‚Äôt be used anywhere there‚Äôs even a hint
of possibility that there could be Unicode data. For example:
18Since ASCII is 7 bits and Char8is 8 bits you could use the eighth bit to represent
Latin-1 characters. However, since you will usually intend to convert the Char8data to
encodings like UTF-8 and UTF-16 which use the eighth bit diÔ¨Äerently that would be
unwise.</p>
<p>CHAPTER 28. BASIC LIBRARIES 1770
moduleChar8ProllyNotWhatYouWant where
import qualified Data.Text asT
import qualified Data.Text.Encoding asTE
import qualified Data.ByteString asB
import qualified
Data.ByteString.Char8 asB8
-- utf8-string
import qualified
Data.ByteString.UTF8 asUTF8
-- Manual unicode encoding of Japanese text
-- GHC Haskell allows UTF8 in source files
s::String
s=&quot;\12371\12435\12395\12385\12399\12289<br />
\20803\27671\12391\12377\12363\65311 &quot;
utf8ThenPrint ::B.ByteString -&gt;IO()
utf8ThenPrint =
putStrLn .T.unpack.TE.decodeUtf8</p>
<p>CHAPTER 28. BASIC LIBRARIES 1771
throwsException ::IO()
throwsException =
utf8ThenPrint ( B8.pack s)
bytesByWayOfText ::B.ByteString
bytesByWayOfText =TE.encodeUtf8 ( T.pack s)
-- letting utf8-string do it for us
libraryDoesTheWork ::B.ByteString
libraryDoesTheWork =UTF8.fromString s
thisWorks ::IO()
thisWorks =utf8ThenPrint bytesByWayOfText
alsoWorks ::IO()
alsoWorks =
utf8ThenPrint libraryDoesTheWork
Then we go to run the code that attempts to get a ByteString
via theChar8module which contains Unicode:
Prelude&gt; throwsException
*** Exception: Cannot decode byte '\x93':
Data.Text.Internal.Encoding.decodeUtf8:
Invalid UTF-8 stream</p>
<p>CHAPTER 28. BASIC LIBRARIES 1772
You can use ordfromData.Char to get the Intvalue of the
byte of a character:
Prelude&gt; import Data.Char (ord)
Prelude&gt; :t ord
ord :: Char -&gt; Int
Prelude&gt; ord 'A'
65
Prelude&gt; ord '\12435'
12435
The second example seems obvious, but when the data is
represented natively on your computer this is more useful.
Use non-English websites to get sample data to test.
We can now use the ordering of characters to find the first
character that breaks Char8:
Prelude&gt; let xs = ['A'..'\12435']
Prelude&gt; let cs = map (:[]) xs
Prelude&gt; mapM_ (utf8ThenPrint . B8.pack) cs
... bunch of output ...
Then to narrow this down, we know we need to find what
came after the tilde and the \DELcharacter:
... some trial and error ...
Prelude&gt; let f = take 3 $ drop 60</p>
<p>CHAPTER 28. BASIC LIBRARIES 1773
Prelude&gt; mapM_ putStrLn (f cs)
}
~
Hrm, okay, but where is this in the ASCII table? We can
use the opposite of the ordfunction from Data.Char ,chrto
determine this:
Prelude&gt; import Data.Char (chr)
Prelude&gt; :t chr
chr :: Int -&gt; Char
Prelude&gt; map chr [0..128]
... prints the first 129 characters ...
What it printed corresponds to the ASCII table, which is
how UTF-8 represents the same characters. Now we can use
this function to narrow down precisely what our code fails at:
-- works fine
Prelude&gt; utf8ThenPrint (B8.pack [chr 127])
-- fails
Prelude&gt; utf8ThenPrint (B8.pack [chr 128])
*** Exception: Cannot decode byte '\x80':
Data.Text.Internal.Encoding.decodeUtf8:
Invalid UTF-8 stream</p>
<p>CHAPTER 28. BASIC LIBRARIES 1774
Don‚Äôt use Unicode characters with the Char8module! This
problem isn‚Äôt exclusive to Haskell ‚Äî all programming lan-
guages must acknowledge the existence of diÔ¨Äerent encodings
for text.
Char8 is bad mmmmmkay TheChar8module is not for Uni-
code or for text more generally! The packfunction it contains
is for ASCII data only! This fools programmers because the
UTF-8 encoding of the English alphabet with some Latin ex-
tension characters intentionally overlaps exactly with the same
bytes ASCII uses to encode those characters. So the following
will work but is wrong in principle:
Prelude&gt; utf8ThenPrint (B8.pack &quot;blah&quot;)
blah
Getting a UTF-8 bytestring via the textorutf8-string li-
braries works fine, as you‚Äôll see if you take a look at the result
ofthisWorks andalsoWorks .
When would I use ByteString instead of Text for
textual data?
This does happen sometimes, usually because you want to
keep data that arrived in a UTF-8 encoding in UTF-8. Of-
ten this happens because you read UTF-8 data from a file or
network socket and you don‚Äôt want the overhead of bouncing</p>
<p>CHAPTER 28. BASIC LIBRARIES 1775
it into and back out of Text. If you do this, you might want
to use newtypes to avoid accidentally mixing this data with
non-UTF-8 bytestrings.
28.10 Chapter Exercises
DiÔ¨Äerence List
Lists are really nice, but they don‚Äôt append or concatenate
cheaply. We covered Sequence as one potential solution to this,
but there‚Äôs a simpler data structure that solves slow appending
specifically, the diÔ¨Äerence list!
Rather than justify and explain diÔ¨Äerence lists, part of the
exercise is figuring out what it does and why (although feel
free to look up the documentation on Hackage). Attempt
the exercise before resorting to the tutorial in the follow-up
reading. First, the DListtype is built on top of ordinary lists,
but it‚Äôs a function:
newtype DLista=DL{ unDL::[a]-&gt;[a] }
The API that follows is based on code by Don Stewart and
Sean Leather. Here‚Äôs what you need to write:
1.empty::DLista
empty=undefined
{-# INLINE empty #-}</p>
<p>CHAPTER 28. BASIC LIBRARIES 1776
2.singleton ::a-&gt;DLista
singleton =undefined
{-# INLINE singleton #-}
3.toList::DLista-&gt;[a]
toList=undefined
{-# INLINE toList #-}
4.-- Prepend a single element to a dlist.
infixr<code>cons</code>
cons ::a-&gt;DLista-&gt;DLista
consx xs=DL((x:).unDL xs)
{-# INLINE cons #-}
5.-- Append a single element to a dlist.
infixl<code>snoc</code>
snoc::DLista-&gt;a-&gt;DLista
snoc=undefined
{-# INLINE snoc #-}
6.-- Append dlists.
append::DLista-&gt;DLista-&gt;DLista
append=undefined
{-# INLINE append #-}</p>
<p>CHAPTER 28. BASIC LIBRARIES 1777
What‚Äôs so nifty about DListis thatcons,snoc, andappend all
take the same amount of time no matter how long the dlist is.
That is to say, they take a constant amount of time rather than
growing with the size of the data structure.
Your goal is to get the following benchmark harness running
with the performance expected:
schlemiel ::Int-&gt;[Int]
schlemiel i=go i[]
wherego0xs=xs
go n xs =go (n-1) ([n]++xs)
constructDlist ::Int-&gt;[Int]
constructDlist i=toList$go i empty
wherego0xs=xs
go n xs =
go (n-1)
(singleton n <code>append</code> xs)
main::IO()
main=defaultMain
[ bench &quot;concat list&quot; $
whnf schlemiel 123456
, bench &quot;concat dlist&quot; $
whnf constructDlist 123456
]</p>
<p>CHAPTER 28. BASIC LIBRARIES 1778
If you run the above, the DListvariant should be about twice
as fast.
A simple queue
We‚Äôre going to write another data structure in terms of list, but
this time it‚Äôll be a queue. The main feature of queues is that
we can add elements to the front cheaply and take items oÔ¨Ä
the back of the queue cheaply.
-- From Okasaki's Purely
-- Functional Data Structures
dataQueuea=
Queue{ enqueue ::[a]
, dequeue ::[a]
}deriving (Eq,Show)
-- adds an item
push::a-&gt;Queuea-&gt;Queuea
push=undefined
pop::Queuea-&gt;Maybe(a,Queuea)
pop=undefined
We‚Äôre going to give you less code this time, but your task is
to implement the above and write a benchmark comparing it</p>
<p>CHAPTER 28. BASIC LIBRARIES 1779
against performing alternating pushes and pops from a queue
based on a single list. Alternating so that you can‚Äôt take advan-
tage of reversing the list after a long series of pushes in order
to perform a long series of pops efficiently.
Don‚Äôt forget to handle the case where the dequeue is empty
and you need to shift items from the enqueue to the dequeue.
You need to do so without violating ‚Äúfirst come, first served‚Äù.
Lastly, benchmark it against Sequence . Come up with a vari-
ety of tests. Add additional operations for your Queuetype if
you want.
28.11 Follow-up resources
1.Criterion tutorial; Bryan O‚ÄôSullivan
http://www.serpentine.com/criterion/tutorial.html
2.Demystifying DList; Tom Ellis
http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
3.Memory Management; GHC; Haskell Wiki
https://wiki.haskell.org/GHC/Memory_Management
4.Performance; Haskell Wiki
https://wiki.haskell.org/Performance
5.Pragmas, specifically UNPACK ; GHC Documentation</p>
<p>CHAPTER 28. BASIC LIBRARIES 1780
6.High Performance Haskell; Johan Tibell
http://johantibell.com/files/slides.pdf
7.Haskell Performance Patterns; Johan Tibell
8.Faster persistent data structures through hashing; Johan
Tibell
9.Lazy Functional State Threads; John Launchbury and
Simon Peyton Jones
10.Write Haskell as fast as C: exploiting strictness, laziness
and recursion; Don Stewart
11.Haskell as fast as C: A case study; Jan Stolarek
12.Haskell FFT 11: Optimisation Part 1; Ian Ross
13.Understanding the RealWorld; Edsko de Vries
14.Stream Fusion; Duncan Coutts
http://code.haskell.org/~dons/papers/icfp088-coutts.pdf
15.Purely functional data structures; Chris Okasaki</p>
<p>Chapter 29
IO
In those days, many
successful projects started
out as graffitis on a beer
mat in a very, very smoky
pub.
Peter J. Landin
1781</p>
<p>CHAPTER 29. IO 1782
29.1 IO
You should be proud of yourself for making it this far into the
book. You‚Äôre juggling monads. You‚Äôve defeated an army of
monad transformers. You‚Äôre comfortable with using algebraic
structures in typeclass form. You‚Äôve got a basic understand-
ing of how Haskell terms evaluate, nonstrictness, and sharing.
With those things in hand, let‚Äôs talk about IO.
We‚Äôve used the IOtype at various times throughout the
book, with only cursory explanation. You no doubt know that
we use this type in Haskell as a means of keeping our chocolate
separate from our peanut butter ‚Äî that is, our pure functions
from our eÔ¨Äectful ones. Perhaps you‚Äôre wondering how it all
works, what‚Äôs underneath that opaque type. To many people,
IOseems mysterious.
An eÔ¨Äectful function is one which has an observable impact
on the environment it is evaluated in, other than computing
and returning a result. Examples of eÔ¨Äects includes writing to
standard output (like putStrLn ), reading from standard input
(getChar ), or modifying state destructively ( ST). Implicit to this,
is that this almost always means the code requires it be evalu-
ated in a particular order. Haskell expressions which aren‚Äôt in
IOwill always return the same result regardless of what order
they are evaluated in; we lose this guarantee and others besides
onceIOis introduced.
Most explanations of the IOtype in Haskell don‚Äôt help much,</p>
<p>CHAPTER 29. IO 1783
either. They seem designed to confuse the reader rather than
convey anything useful. Don‚Äôt look now, but somebody is writ-
ing an explanation of IOright now that uses van Laarhoven
Free Monads and costate comonad coalgebras to explain some-
thing that‚Äôs much simpler than either of those topics.
We‚Äôre not going to do that here. We will instead try to
demystify IOa bit. The important thing about IOis that it‚Äôs a
special kind of datatype that disallows sharing in some cases.
In this chapter, we will
‚Ä¢explain how IOworks operationally;
‚Ä¢explore what it should mean to you when you read a type
that has IOin it;
‚Ä¢provide a bit more detail about the IO Functor ,Applicative ,
andMonad.
29.2 Where IO explanations go astray
A lot of explanations of IOare misleading or muddled. We‚Äôve
already alluded to the overwrought and complex explanations
ofIO. Others call it ‚Äúthe IO Monad ‚Äù and seem to equate IOwith
Monad. While IOis a type that has a Monadinstance, it is not only
aMonadand monads are not only IO. Other presentations imply
that once you enter IO, you destroy purity and referential
transparency. And some references don‚Äôt bother to say much</p>
<p>CHAPTER 29. IO 1784
aboutIObecause the fact that it remains opaque won‚Äôt stop
you from doing most of what you want to use it for anyway.
We want to oÔ¨Äer some guidance in critically evaluating
explanations of IO. Let us consider one of the most popular
explanations of IO, the one that attempts to explain IOin terms
ofState.
Burn the State to the ground!
The temptation to use Stateto get someone comfortable with
the idea of IOis strong. Give the following passage early in the
documentation to GHC.IO a gander:
The IO Monad is just an instance of the ST monad,
where the state is the real world.
The motivation for these explanations is easy to understand
when you look at the underlying types:</p>
<p>CHAPTER 29. IO 1785
-- from ghc-prim
importGHC.Prim
importGHC.Types
newtype States a
=State{runState ::s-&gt;(a, s)}
-- :info IO
newtype IOa=
IO(State#RealWorld
-&gt;(#State#RealWorld , a#))
Yep, it sure looks like State! However, this is less meaningful
or helpful than you‚Äôd think at first.
The issue with this explanation is that you don‚Äôt usefully
see or interact with the underlying State#1inIO. It‚Äôs not State
in the sense that one uses State,StateT, or even ST, although
the behavior of the ùë†here is certainly very like that of ST.
TheStatehere is a signalling mechanism for telling GHC
what order your IOactions are in and what a unique IOaction
is. If we look through the GHC.Prim documentation, we see:
State# is the primitive, unlifted type of states. It has
one type parameter, thus State# RealWorld, or State#
1The#indicates a primitive type. These are types that cannot be defined in Haskell
itself and are exported by the GHC.Prim module.</p>
<p>CHAPTER 29. IO 1786
ùë†, where ùë†is a type variable. The only purpose of
the type parameter is to keep diÔ¨Äerent state threads
separate. It is represented by nothing at all.
RealWorld is deeply magical. It is primitive, but it
is not unlifted (hence ptrArg). We never manipulate
values of type RealWorld; it‚Äôs only used in the type
system, to parameterise State# .
When they say that RealWorld is ‚Äúrepresented by nothing at
all,‚Äù they mean it literally uses zero bits of memory. The state
tokens underlying the IOtype are erased during compile time
and add no overhead to your runtime. So the problem with
explaining IOin terms of Stateis not precisely that it‚Äôs wrong;
it‚Äôs that it‚Äôs not a Stateyou can meaningfully interact with or
control in the way you‚Äôd expect from the other Statetypes.
29.3 The reason we need this type
So, let‚Äôs try to move from there to an understanding of IOthat
is meaningful to us in our day-to-day Haskelling. IOprimarily
exists to give us a way to order operations and to disable some
of the sharing that we talked so much about in the chapter on
nonstrictness.
GHC is ordinarily free to do a lot of reordering of opera-
tions, delaying of evaluation, sharing of named values, dupli-
cating code via inlining, and other optimizations in order to</p>
<p>CHAPTER 29. IO 1787
increase performance. The main thing the IOtype does is turn
oÔ¨Ä most of those abilities.
What?
No, really. That‚Äôs a lot of it.
Order and chaos
As we‚Äôve seen in the previous chapters, GHC can normally
reorder operations. This is disabled in IO(as inST).IOactions
are instead enclosed within nested lambdas ‚Äî nesting is the
only way to ensure that actions are sequenced within a pure
lambda calculus.
Nesting lambdas is how we guarantee that this
main= do
putStr &quot;1&quot;
putStr &quot;2&quot;
putStrLn &quot;3&quot;
will output ‚Äú123‚Äù and we want that guarantee. The underly-
ing representation of IOallows the actions to be nested, and
therefore sequenced.
When we enter a lambda expression, any eÔ¨Äects that need to
beperformedwillbeperformedfirst, beforeanycomputations
are evaluated. Then if there is a computation to evaluate, that</p>
<p>CHAPTER 29. IO 1788
may be evaluated next, before we enter the next lambda to
perform the next eÔ¨Äect and so on. We‚Äôve seen how this plays
out in previous chapters; think of the parsers that perform the
eÔ¨Äect of moving a ‚Äúcursor‚Äù through the text without reducing
to any value; also recall what we saw with STand mutable
vectors.
In fact, the reason we have Monadis because it was a means
of abstracting away the nested lambda noise that underlies IO.
29.4 Sharing
In addition to enforcing ordering, IOturns oÔ¨Ä a lot of the shar-
ing we talked about in the nonstrictness chapter. As we‚Äôll soon
see, it doesn‚Äôt disable all forms of sharing ‚Äî it couldn‚Äôt, because
all Haskell programs have a mainaction with an obligatory IO
type. But we‚Äôll get to that in a moment.
For now, let‚Äôs turn our attention to what sharing is disabled
and why. Usually in Haskell, we‚Äôre pretty confident that if a
function is going to be evaluated at all, it will result in a value
of a certain type, bearing in mind that this could be a Nothing
value or an empty list. When we declare the type, we say, ‚Äúif
this is evaluated at all, we will have a value of this type as a
result.‚Äù
But with the IOtype, you‚Äôre not guaranteed anything. Values
oftypeIO aarenotan ùëé; they‚Äôreadescriptionofhowyoumight
get anùëé. Something of type IO String is not a computation</p>
<p>CHAPTER 29. IO 1789
that, if evaluated, will result in a String; it‚Äôs a description of
how you might get that String from the ‚Äúreal world,‚Äù possibly
performing eÔ¨Äects along the way. Describing IOactions does
not perform them, just as having a recipe for a cake does not
give you a cake.2
In this environment, where you do not have a value but
only a means of getting a value, it wouldn‚Äôt make sense to say
that value could be shared.
The time has come
So, one of the key features of IOis that it turns oÔ¨Ä sharing.
Let‚Äôs use an example to think of why we want this. We have
this library function that gets the current UTC time from the
system clock:
-- from Data.Time.Clock
getCurrentTime ::IOUTCTime
Without IOpreventing sharing, how would this work? When
you fetched the time once, it would share that result, and the
time would be whatever time it was the first time you forced it.
Unfortunately, this is not a means of stopping time; we would
continue to age, but your program wouldn‚Äôt work at all the
way you‚Äôd intended.
2See Brent Yorgey‚Äôs explanation of IOfor the cis194 class at UPenn http://www.cis.
upenn.edu/~cis194/spring13/lectures/08-IO.html</p>
<p>CHAPTER 29. IO 1790
But if that‚Äôs so, and it‚Äôs clearly a value with a name that
could be shared, why isn‚Äôt it?
getCurrentTime ::IOUTCTime
-- ^-- that right there
Remember: what we have here is a description of how we
can get the current time when we need it. We do not have the
current time yet, so it isn‚Äôt a value that can be shared, and we
don‚Äôt want it to be shared anyway, because we want it to get a
new time each time we run it.
And the way we run it is by defining mainin that module
for the runtime system to find and execute. Everything inside
mainis within IOso that everything is nested and sequenced
and happens in the order you‚Äôre expecting.
Another example
Let‚Äôs look at another example of IOturning oÔ¨Ä sharing. You
remember the whnfandnffunctions from criterion that we
used in the last chapter. You may recall that we want to turn
oÔ¨Ä sharing for those so that they get evaluated over and over
again; if the result was shared, our benchmarking would only
tell us how long it takes to evaluate it once instead of giving us
an average of evaluating it many times. The way we disabled
sharing for those functions is by applying them to arguments.</p>
<p>CHAPTER 29. IO 1791
But the IOvariants of those functions do not require this
function application in order to disable sharing, because the
IOparameter itself disables sharing. Contrast the following
types:
whnf::(a-&gt;b)-&gt;a-&gt;Benchmarkable
nf::NFDatab
=&gt;(a-&gt;b)-&gt;a-&gt;Benchmarkable
whnfIO::IOa-&gt;Benchmarkable
nfIO::NFDataa=&gt;IOa-&gt;Benchmarkable
TheIOvariants don‚Äôt need a function argument to apply
because sharing is already prevented by being an IOaction ‚Äî
it can be executed over and over without resorting to adding
an argument.
As we said earlier, IOdoesn‚Äôt turn oÔ¨Ä all sharing everywhere;
it couldn‚Äôt, or else sharing would be meaningless because main
is always in IO. But it‚Äôs important to understand when sharing
will be disabled and why, because if you‚Äôve got this notion of
sharing running around in the back of your head you‚Äôll have
the wrong intuitions for how Haskell code works. Which then
leads to‚Ä¶</p>
<p>CHAPTER 29. IO 1792
The code! It doesn‚Äôt work!
We‚Äôre going to use an example here that takes advantage of
theMVartype. This is based on a real code event that was how
Chris finally learned what IOmeans and the example he first
used to explain it to Julie.
TheMVartype is a means of synchronizing shared data in
Haskell. To give a very cursory overview, the MVarcan hold
one value at a time. You put a value into it; it holds onto it
until you take that value out. Then and only then can you
put another cat in the box.3We cannot hope to best Simon
Marlow‚Äôs work4on this front, so if you want more information
about it, we strongly recommend you peruse Marlow‚Äôs book.
OK, so we‚Äôll set up some toy code here with the idea that
we want to put a value into an MVarand then take it back out:
3What you need is a cat gif. https://twitter.com/argumatronic/status/
631158432859488258
4Parallel &amp; Concurrent Programming in Haskell http://chimera.labs.oreilly.com/
books/1230000000929</p>
<p>CHAPTER 29. IO 1793
moduleWhatHappens where
importControl.Concurrent
myData::IO(MVarInt)
myData=newEmptyMVar
main::IO()
main= do
mv&lt;-myData
putMVar mv 0
mv'&lt;-myData
zero&lt;-takeMVar mv'
print zero
This will spew an error about being stuck or in a deadlock.
The problem here is that the type IO MVar a ofnewEmptyMVar is
a recipe for producing as many empty MVars as you need or
want; it is not a reference to a single, shared MVar. In other
words, the two references to myData here are not referring to
the same MVar.
Taking from an empty MVarblocks until something is put
into the MVar. Consider the following ordering:
take
put</p>
<p>CHAPTER 29. IO 1794
take
put
That will terminate successfully. An attempt to take a value
from the MVarblocked, then a value was put in it, then another
blocked take occurred, then there was another put to satisfy
the second take. This is fine.
The following is an example of something that will dead-
lock:
put
take
take
Whatever part of your program performed the second take
will now be blocked until a second put occurs. If your program
is designed such that no put ever occurs again, it‚Äôs deadlocked.
A deadlock error looks like the following:
Prelude&gt; main
*** Exception:
thread blocked indefinitely
in an MVar operation
When you see a type like:
IOString</p>
<p>CHAPTER 29. IO 1795
You don‚Äôt have a String; you have a means of (possibly)
obtaining a String , with some eÔ¨Äects possibly performed along
the way. Similarly, what happened earlier is that we had two
MVars with two diÔ¨Äerent lifetimes and that looked something
like this:
mv mv'
put take (the final one)
The point here is that this type
IO(MVara)
tells you that you have a recipe for producing as many
empty MVars as you want, not a reference to a single shared
MVar.
You can share the MVar, but it has to be done explicitly rather
than implicitly. Failing to explicitly share the MVarreference
after binding it once will simply spew out new, empty MVars.
Again, we recommend Simon Marlow‚Äôs book when you‚Äôre
ready to explore MVars in more detail.
29.5 IO doesn‚Äôt disable sharing for
everything
As we mentioned earlier, IOdoesn‚Äôt disable sharing for every-
thing, and it wouldn‚Äôt make sense if it did. It only disables</p>
<p>CHAPTER 29. IO 1796
sharing for the terminal value it reduces to. Values that are
not dependent on IOfor their evaluation can still be shared,
even within a larger IOaction such as main.
In the following example, we‚Äôll use Debug.Trace again to show
us when things are being shared. For blah, thetraceis outside
theIOaction, so we‚Äôll use outer trace :
importDebug.Trace
blah::IOString
blah=return&quot;blah&quot;
blah'=trace&quot;outer trace&quot; blah
And for woot, we‚Äôll use inner trace inside the IOaction:
woot::IOString
woot=return (trace &quot;inner trace&quot; &quot;woot&quot;)
Then we throw both of them into a larger IOaction,main:</p>
<p>CHAPTER 29. IO 1797
main::IO()
main= do
b&lt;-blah'
putStrLn b
putStrLn b
w&lt;-woot
putStrLn w
putStrLn w
Prelude&gt; main
outer trace
blah
blah
inner trace
woot
woot
We only saw inner and outer emitted once because IOis not
intended to disable sharing for values not in IOthat happen to
be used in the course of running of an IOaction.
29.6 Purity is losing meaning
It‚Äôs common at this time to use the words ‚Äúpurely functional‚Äù
or to talk about purity when one means without eÔ¨Äects. This is
inaccurate and not very useful as a definition, but we‚Äôre going</p>
<p>CHAPTER 29. IO 1798
to provide some context here and an alternative understand-
ing.
Semantically, pedantically accurate
Purity and ‚Äúpure functional‚Äù have undergone a few changes in
connotation and denotation since the 1950s. What was origi-
nally meant when describing a pure functional programming
language is that the semantics of the language would only be
lambda calculus. For quite a long time, impure functional lan-
guages were more typical. They admitted the augmentation of
lambda calculus, usually so that the means to describe imper-
ative, eÔ¨Äectful programs was embedded within the semantics.
The strength of Haskell is that by sticking to lambda calculus,
we not only have a much simpler core language for describing
our language, but we retain referential transparency in the
language. We use nested lambdas (hidden behind a Monadab-
straction) to order and encapsulate eÔ¨Äects while maintaining
referential transparency.
Referential transparency
Referential transparency is something you are probably fa-
miliar with, even if you‚Äôve never called it that before. Put
casually, it means that any function, when given the same in-
puts, returns the same result. More precisely, an expression</p>
<p>CHAPTER 29. IO 1799
is referentially transparent when it can be replaced with its
value without changing the behavior of a program.
One source of the confusion between purity as referential
transparency and purity as pure lambda calculus could be that
in a pure lambda calculus, referential transparency is assured.
Thus, a pure lambda calculus is necessarily pure in the other
sense as well.
The mistake people make with IOis that they conflate the
eÔ¨Äects with the semantics of the program. A function that
returns IO ais still referentially transparent, because given the
same arguments, it‚Äôll generate the same IOaction every time!
To make this point:
moduleIORefTrans where
importControl.Monad (replicateM )
importSystem.Random (randomRIO )
gimmeShelter ::Bool-&gt;IO[Int]
gimmeShelter True=
replicateM 10(randomRIO ( 0,10))
gimmeShelter False=pure [0]
The trick here is to realize that while executing IO [Int] can
and does produce diÔ¨Äerent literal values when the argument
isTrue, it‚Äôs still producing the same result (i.e., a list of ran-</p>
<p>CHAPTER 29. IO 1800
dom numbers) for the same input. Referential transparency is
preserved because we‚Äôre still returning the same IO action, or
‚Äúrecipe,‚Äù for the same argument, the same means of obtaining
a list of Int. Every Trueinput to this function will return a list
of random Ints:
Prelude&gt; gimmeShelter True
[1,8,7,9,10,4,2,9,3,6]
Prelude&gt; gimmeShelter True
[10,0,7,1,10,2,4,0,9,3]
Prelude&gt; gimmeShelter False
[0]
The sense we‚Äôre trying to convey here is that as far as Haskell
is concerned, it‚Äôs a language for evaluating expressions and
constructing IOactions that get executed by mainat some point
later.
29.7 IO‚Äôs Functor, Applicative, and
Monad
Another mistake people make is in implying that IOis aMonad,
rather than accounting for the fact that, like all Monads,IOis
a datatype that has a Monadinstance ‚Äî as well as Functor and
Applicative instances:</p>
<p>CHAPTER 29. IO 1801
fmap: construct an action which performs the same eÔ¨Äects
but transforms the ùëéinto aùëè:
fmap::(a-&gt;b)-&gt;IOa-&gt;IOb
(&lt;<em>&gt;): construct an action that performs the eÔ¨Äects of both
the function and value arguments, applying the function to
the value:
(&lt;</em>&gt;)::IO(a-&gt;b)-&gt;IOa-&gt;IOb
join: merge the eÔ¨Äects of a nested IOaction:
join::IO(IOa)-&gt;IOa
The IO Functor
What does fmapmean with respect to IO? As always, we want
an example:
fmap(+1) (randomIO ::IOInt)
If we‚Äôre going to get that Intvalue, we will have to perform
some eÔ¨Äects. What fmapdoes here is lift our incrementing
function over the eÔ¨Äects that we might perform to obtain the
Intvalue. It doesn‚Äôt aÔ¨Äect the eÔ¨Äects, because the eÔ¨Äects here
are part of that IOstructure. Using fmaphere returns a recipe for
obtaining an Intthat also increments the result of the original
action that was lifted over.</p>
<p>CHAPTER 29. IO 1802
The key here is that we didn‚Äôt perform any eÔ¨Äects. We pro-
duced a new IOaction in terms of the old one by transforming
the final result of the IOaction.
Applicative and IO
IOalso has an Applicative instance, as we mentioned in the
Applicative chapter. You might remember an example like
this:
Prelude&gt; (++) &lt;$&gt; getLine &lt;<em>&gt; getLine
hello
julie
&quot;hellojulie&quot;
There we fmapped the concatenation operator over two
(potential) IO String s to produce the final result. Let‚Äôs look at
another, more interesting example:
(+)
&lt;$&gt;(randomIO ::IOInt)
&lt;</em>&gt;(randomIO ::IOInt)
After the initial fmap, we have a means of obtaining a func-
tion which is monoidally lifted over a means of obtaining an
Int. What this means is that you‚Äôll get a single new means
of obtaining the result of having applied the function which
performs the eÔ¨Äects of both.</p>
<p>CHAPTER 29. IO 1803
Monad and IO
ForIO,pureorreturn can be read as an eÔ¨Äect-free embedding
of a value in a recipe-creating environment. Let‚Äôs consider the
following examples.
First, GHCi does basically two things: it can print values
not inIO, such as these:
Prelude&gt; &quot;I'll pile on the candy&quot;
&quot;I'll pile on the candy&quot;
Prelude&gt; 1
1
It can also run IOactions and print their results, if any. When
you have values of type IO (IO a) , what you have is a recipe
for making a recipe that produces an ùëé. Consider why the
following example using printdoes not print anything:
Prelude&gt; :{
*Main| let embedInIO =
*Main| return :: a -&gt; IO a
*Main| :}
Prelude&gt; embedInIO 1
1
Prelude&gt; :{
*Main| let s =
*Main| &quot;I'll put in some ingredients&quot;</p>
<p>CHAPTER 29. IO 1804
*Main| :}
Prelude&gt; embedInIO (print s)
In order to merge those eÔ¨Äects and get a single IO awhich
will print a result in GHCi, we need join:
Prelude&gt; let s = &quot;It's a piece of cake&quot;
Prelude&gt; join $ embedInIO (print s)
&quot;It's a piece of cake&quot;
Prelude&gt; embedInIO (embedInIO 1)
Prelude&gt; join $ embedInIO (embedInIO 1)
1
What sets the IO Monad apart from the Applicative is that the
eÔ¨Äects performed by the outer IOaction can influence what
recipe you get in the inner part. The nesting also lets us express
order dependence, a useful trick for lambda calculi noted by
Peter J. Landin5.
An example for eÔ¨Äect:
5A correspondence between ALGOL 60 and Church‚Äôs Lambda-notations; P.J. Landin</p>
<p>CHAPTER 29. IO 1805
moduleNestedIO where
importData.Time.Calendar
importData.Time.Clock
importSystem.Random
huehue::IO(Either(IOInt) (IO()))
huehue= do
t&lt;-getCurrentTime
let(<em>,</em>, dayOfMonth) =
toGregorian (utctDay t)
caseeven dayOfMonth of
True-&gt;
return$LeftrandomIO
False-&gt;
return$
Right(putStrLn &quot;no soup for you&quot; )
TheIOaction we return here is contingent on having per-
formed eÔ¨Äects and observed whether the day of the month
was an even number6or an odd one. Note this is inexpressible
withApplicative . If you‚Äôd like a way to run it and see what
happens, try the following:
Prelude&gt; blah &lt;- huehue
6Why? Monad chapter‚Äôs long passed, we need something to be spooky.</p>
<p>CHAPTER 29. IO 1806
Prelude&gt; either (&gt;&gt;= print) id blah
-7077132465932290066
It was the 28th of January when we wrote this. Your mileage
may vary.
Monadic associativity
Haskellers will often get confused when they are told Monad‚Äôs
bind is associative because they‚Äôll think of IOas a counterex-
ample. The mistake being made here is mistaking the con-
struction of IOactions for the execution of IOactions. As far
as Haskell is concerned, we only construct IOactions to be
executed when we call main. Semantically, IOactions aren‚Äôt
something we do, but something we talk about. Binding over
anIOaction doesn‚Äôt execute it, it produces a new IOaction in
terms of the old one.
You can reconcile yourself with this framing by remem-
bering how IOactions are like recipes, an analogy created by
Brent Yorgey that we‚Äôre fond of.
29.8 Well, then, how do we MVar?
Earlier in the chapter, we showed you an example of when
IOprevents sharing, using the MVartype. Our previous code
would block because the following:</p>
<p>CHAPTER 29. IO 1807
myData::IO(MVarInt)
myData=newEmptyMVar
is anIOaction that produces an empty MVar; it isn‚Äôt a stable
reference to a single given MVar. We have a couple ways of
fixing this. One is by passing the single stable reference as an
argument. The following will terminate successfully:
moduleWhatHappens where
importControl.Concurrent
main::IO()
main= do
mv&lt;-newEmptyMVar
putMVar mv ( 0::Int)
zero&lt;-takeMVar mv
print zero
There is a somewhat more evil and unnecessary way of
doing it. We‚Äôll use this opportunity to examine an unsafe
means of enabling sharing for an IOaction: unsafePerformIO !
Consider that the following will also terminate:</p>
<p>CHAPTER 29. IO 1808
moduleWhatHappens where
importControl.Concurrent
importSystem.IO.Unsafe
myData::MVarInt
myData=unsafePerformIO newEmptyMVar
main::IO()
main= do
putMVar myData 0
zero&lt;-takeMVar myData
print zero
The type of unsafePerformIO isIO a -&gt; a , which is seemingly
impossible and not a good idea in general. In real code, you
should pass references to MVars as an argument or via ReaderT ,
but the combination of MVarandunsafePerformIO gives us an
opportunity to see in very stark terms what it means to use
unsafePerformIO in our code. The new empty MVarcan now be
shared implicitly, as often as you want, instead of creating a
new one each time.
Do not use unsafePerformIO when unnecessary or where it
could break referential transparency in your code! If you
aren‚Äôt sure ‚Äî don‚Äôt use it! There are other unsafe IOfunctions,</p>
<p>CHAPTER 29. IO 1809
too, but there is rarely a need for any of them, and in general
you should prefer explicit rather than implicit.
29.9 Chapter Exercises
File I/O with Vigen√®re
ReusingtheVigen√®recipheryouwrotebackinalgebraicdatatypes
and wrote tests for in testing, make an executable that takes
a key and a mode argument. If the mode is -dthe executable
decrypts the input from standard in and writes the decrypted
text to standard out. If the mode is -ethe executable blocks
on input from standard input ( stdin) and writes the encrypted
output to stdout .
Consider this an opportunity to learn more about how file
handles and the following members of the baselibrary work:
System.Environment .getArgs ::IO[String]
System.IO.hPutStr
::Handle-&gt;String-&gt;IO()
System.IO.hGetChar ::Handle-&gt;IOChar
System.IO.stdout::Handle
System.IO.stdin::Handle
Whatever OS you‚Äôre on, you‚Äôll need to learn how to feed
files as input to your utility and how to redirect standard out
to a file. Part of the exercise is figuring this out for yourself.</p>
<p>CHAPTER 29. IO 1810
You‚Äôll want to use hGetChar more than once to accept a string
which is encrypted or decrypted.
Add timeouts to your utility
UsehWaitForInput to make your utility timeout if no input is
provided within a span of time of your choosing. You can
make it an optional command-line argument. Exit with a
nonzero error code and an error message printed to standard
error (stderr ) instead of stdout .
System.IO.hWaitForInput
::Handle-&gt;Int-&gt;IOBool
System.IO.stderr::Handle
Config directories
Reusing the INI parser from the Parsing chapter, parse a direc-
tory of INI config files into a Mapwhose key is the filename and
whose value is the result of parsing the INI file. Only parse
files in the directory that have the file extension .ini.
29.10 Follow-up resources
1.Referential Transparency; Haskell Wiki
https://wiki.haskell.org/Referential_transparency</p>
<p>CHAPTER 29. IO 1811
2.IO Inside; Haskell Wiki
https://wiki.haskell.org/IO_inside
3.Unraveling the mystery of the IO Monad; Edward Z. Yang
4.Primitive Haskell; Michael Snoyman
https://github.com/commercialhaskell/haskelldocumentation/
blob/master/content/primitive-haskell.md
5.Evaluation order and state tokens; Michael Snoyman
https://wiki.haskell.org/Evaluation_order_and_state_tokens
6.Haskell GHC Illustrated; Takenobu Tani
7.Tackling the Awkward Squad; Simon PEYTON JONES
http://research.microsoft.com/en-us/um/people/simonpj/papers/
marktoberdorf/mark.pdf
8.Note [IO hack in the demand analyser]; GHC source code
9.Monadic I/O in Haskell 1.3; Andrew D. Gordon and Kevin
Hammond
10.Notions of computation and monads; Eugenio Moggi
http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf
11.The Next 700 Programming Languages; P. J. Landin
12.Haskell Report 1.2</p>
<p>Chapter 30
When things go wrong
It is easier to write an
incorrect program than
understand a correct one
Alan Perlis
1812</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1813
30.1 Exceptions
Let‚Äôs face it: in the execution of a program, a lot of things can
happen, not all of them expected or desired. In those unhappy
times when things have not gone as we wanted them to, we
will throw or raise an exception. The term exception refers
to the condition that has interrupted the expected execution
of the program. Encountering an exception causes an error,
or exception, message to appear, informing you that due to
some condition you weren‚Äôt prepared for, the execution of the
program has halted in an unfortunate way.
In previous chapters, we‚Äôve covered ways of using Maybe,
Either , andValidation types to handle certain error conditions
explicitly. Raising exceptional conditions via such datatypes
isn‚Äôt always ideal, however. In some cases, exceptions can
be faster by eliding repeated checks for an adverse condition.
Exceptions are not explicitly part of the interfaces you‚Äôre using,
and that has immediate consequences when trying to reason
about the ways in which your program could fail.
Letting exceptions arise as they will ‚Äî and the program
halt willy-nilly ‚Äî is suboptimal. Exception handling is a way
of dealing with errors and giving the program some alternate
means of execution or termination should one arise. This
chapter is going to cover both exceptions and what they look
like as well as various means of handling them.
In this chapter, we will:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1814
‚Ä¢examine the Exception typeclass and methods;
‚Ä¢dip our toes into existential quantification;
‚Ä¢discuss ways of handling exceptions.
30.2 The Exception class and methods
Exceptions are plain old types and values like you‚Äôve seen
throughout the book. The types that encode exceptions must
have an instance of the Exception typeclass. The origins of
exceptions as they exist in Haskell today are in Simon Mar-
low‚Äôs work on an extensible hierarchy of exceptions1which
are discriminated at runtime. Using this extensible hierarchy
allows you to both catch exceptions that may have various
types and also add new exception types as the need arises.
TheException typeclass definition looks like this:
class(Typeable e,Showe)=&gt;
Exception ewhere
toException ::e-&gt;SomeException
fromException ::SomeException -&gt;Maybee
displayException ::e-&gt;String
-- Defined in ‚ÄòGHC.Exception‚Äô
1http://community.haskell.org/~simonmar/papers/ext-exceptions.pdf</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1815
We‚Äôll take a look at those methods in a moment. The Show
constraint is there so that we can print the exception to the
screen in a readable form for whatever type ùëíends up being.
Typeable is a typeclass that defines methods of identifying types
at runtime. We will talk about this more and explain why these
constraints are necessary to our Exception class soon.
The list of types that have an Exception instance is long:
-- some instances elided
instance Exception IOException
instance Exception Deadlock
instance Exception BlockedIndefinitelyOnSTM
instance
Exception BlockedIndefinitelyOnMVar
instance Exception AsyncException
instance Exception AssertionFailed
instance Exception AllocationLimitExceeded
instance Exception SomeException
instance Exception ErrorCall
instance Exception ArithException
We won‚Äôt talk in detail about each of these, but you may be
able to figure out what, for example, BlockedIndefinitelyOnMVar
is used for. We‚Äôll note that it‚Äôs simply a datatype with one
inhabitant:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1816
dataBlockedIndefinitelyOnMVar =
BlockedIndefinitelyOnMVar
-- Defined in ‚ÄòGHC.IO.Exception‚Äô
If we look at ArithException , we‚Äôll find that it‚Äôs a sum type
with several values:
dataArithException
=Overflow
|Underflow
|LossOfPrecision
|DivideByZero
|Denormal
|RatioZeroDenominator
instance Exception ArithException
If you import the Control.Exception module, you can poke
atArithException ‚Äôs data constructors and see that they‚Äôre plain
old values, nothing unusual at all.
But there is something diÔ¨Äerent going on here
We‚Äôre going to start unpacking all this to see how the parts
work together. First, let‚Äôs take a look at the methods of the
Exception typeclass:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1817
toException ::e-&gt;SomeException
fromException ::SomeException -&gt;Maybee
We don‚Äôt have much occasion to use the toException and
fromException functions themselves. Instead, we use other func-
tions that call them for us. As it turns out, the toException
methodisquitesimilartothedataconstructorfor SomeException .
You may have noticed that SomeException is also a type that is
listed as having an instance of the Exception typeclass, and now
here it is in the Exception methods. It seems a bit circular, but
it turns out that SomeException is ultimately the key to the way
we handle exceptions.
A brief introduction to existential quantification
SomeException acts as a sort of parent type for all the other ex-
ception types, so that we can handle many exception types at
once, without having to match all of them. Let‚Äôs examine how:
dataSomeException where
SomeException
::Exception e=&gt;e-&gt;SomeException
This may not seem odd at first glance. That is due, in part,
to the fact that the weirdness is hiding in a construction called
a GADT, for generalized algebraic datatype. For the most</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1818
part, GADTs are out of the scope of this book, being well
into intermediate Haskell territory that is fun to explore but
not strictly necessary to programming in Haskell. What the
GADT syntax is hiding there is something called existential
quantification.
We could rewrite the SomeException type like this without a
change in meaning:
dataSomeException =
forall e .Exception e=&gt;SomeException e
Ordinarily, the forall quantifies variables universally, as
you might guess from the word all. However, the SomeException
type constructor doesn‚Äôt take an argument; the type variable
ùëíis a parameter of the data constructor. It takes an ùëíand
results in a SomeException . Moving the quantifier to the data
constructor limits the scope of its application, and changes
the meaning from for all e to there exists some e. That is exis-
tential quantification. It means that any type that implements
theException class can be that ùëíand be subsumed under the
SomeException type.
We aren‚Äôt going to examine existential quantification deeply
here; this is a mere taste. Usually when type constructors are
parameterized, they are universally quantified. Arguments
have to be supplied to satisfy them. Your Maybe a type is, as</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1819
we‚Äôve noted before, a sort of function waiting for an argument
to be supplied to be a fully realized type.
Butwhenweexistentiallyquantifyatype, aswith SomeException ,
we can‚Äôt do much with that polymorphic type variable in its
data constructor. We can‚Äôt concretize it. Other than adding
constraints, we can‚Äôt know anything about it. It must remain
polymorphic, and we can cram any value of any type that im-
plements its constraint into that role. It‚Äôs like a polymorphic
parasite just hanging out on your type.
So, any exception type ‚Äî any type with an instance of
theException typeclass ‚Äî can be that ùëíand be handled as a
SomeException . We need Typeable andShowin order to determine
what type of exception we‚Äôre dealing with, as we will soon see.
So, wait, what?
For an example of what existential quantification lets us do,
we‚Äôre going to show you an example that doesn‚Äôt rely on the
magic of the runtime exception machinery. Here we‚Äôll be
returning errors in Either of totally diÔ¨Äerent types without
having to unify them under a single sum type:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1820
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs #-}
moduleWhySomeException where
importControl.Exception
(ArithException (..)
,AsyncException (..))
importData.Typeable
dataMyException =
forall e .
(Showe,Typeable e)=&gt;MyException e
instance ShowMyException where
showsPrec p ( MyException e)=
showsPrec p e</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1821
multiError ::Int
-&gt;EitherMyException Int
multiError n=
casenof
0-&gt;
Left(MyException DivideByZero )
1-&gt;
Left(MyException StackOverflow )
_ -&gt;Rightn
What‚Äôs special about the above is that we have a Leftcase
in ourEither that includes error values of two totally diÔ¨Äerent
types without enumerating them in a sum type. MyException
doesn‚Äôt appear to have a polymorphic argument in the type
constructor, but it does in the data constructor. We are able
to apply the MyException data constructor to values of diÔ¨Äerent
types because of the existentially quantified type for ùëí.
dataSomeError =
ArithArithException
|AsyncAsyncException
|SomethingElse
deriving (Show)</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1822
discriminateError ::MyException
-&gt;SomeError
discriminateError (MyException e)=
casecast eof
(Justarith)-&gt;Aritharith
Nothing -&gt;
casecast eof
(Justasync)-&gt;Asyncasync
Nothing -&gt;SomethingElse
runDisc n=
either discriminateError
(constSomethingElse ) (multiError n)
Then trying this out:
Prelude&gt; runDisc 0
Arith divide by zero
Prelude&gt; runDisc 1
Async stack overflow
Prelude&gt; runDisc 2
SomethingElse
This is the essence of why we need existential quantification
for exceptions ‚Äî so that we can throw various exception types
without being forced to centralize and unify them under a
sum type. Don‚Äôt abuse this facility.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1823
Prior to this design, there were a few ways you could do
exception handling. Some of the more apparent methods
would‚Äôve been one big sum type or strings. The problem is
that neither of them are meaningfully extensible to structured,
proper data types. We want, in a sense, a hierarchy of values
where catching a ‚Äúparent‚Äù means catching any of the possible
‚Äúchildren.‚Äù The combination of SomeException and the Typeable
typeclass gives you a means of throwing diÔ¨Äerent exceptions
of diÔ¨Äerent types and then catching some or all of them in a
handler without wrapping them in a sum type.
Typeable
TheTypeable typeclasslivesinthe Data.Typeable module. Typeable
exists to permit types to be known at runtime, allowing for a
sort of dynamic typechecking. It allows you to learn the type
of a value at runtime and also to compare the types of two val-
ues and check that they are the same. Typeable is particularly
useful when you have code that needs to allow various types
to be passed to it but needs to enforce or trigger on specific
types.
This is ordinarily unwise, but it makes sense when you‚Äôre
talking about exceptions. When we‚Äôre concerned with excep-
tion handling, we want to be able to check whether values of
possibly varying types match the Exception type we‚Äôre trying to
handle, and we need to do that at runtime, when the exception</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1824
occurs. Thus we need this runtime witness to the types of the
exceptions.
Let‚Äôs look at a method called cast, simplified from its im-
plementation in base:
cast::(Typeable a,Typeable b)
=&gt;a-&gt;Maybeb
We don‚Äôt usually call this function directly, but it gets called
for us by the fromException function, and fromException is called
by thecatchfunction.
At runtime, when an exception is thrown, it starts rolling
back through the stack, looking for a catch. When it finds a
catch, it checks to see what type of exception this catchcatches.
It callsfromException andcastto check if the type of the excep-
tion that got thrown matches the type of an exception we‚Äôre
handling with the catch. Acatchthat handles a SomeException
will match any type of exception, due to the flexibility of that
type.
If they don‚Äôt match, we get a Nothing value; the exception
will keep rolling up through the stack, looking for a catchthat
can handle the exception that was thrown. If it doesn‚Äôt find
one, your program just dies an unseemly death.
If they do match, the Just a allows us to catch the exception.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1825
30.3 This machine kills programs
Exceptions can result from pure code:
Prelude&gt; 2 <code>div</code> 0
*** Exception: divide by zero
However, running code is an I/O action (and GHCi is implic-
itly invoking IO), so most of the time when you need to worry
about exceptions, you‚Äôll be in IO. Even when they happen in
pure code, exceptions may only be caught, or handled, in IO.
IOcontains the implicit contract, ‚ÄúYou cannot expect this
computation to succeed unconditionally.‚Äù It turns out the
outside world is a harsh mistress ‚Äî just about any IOaction
can fail, even putStrLn .
First, let‚Äôs demonstrate that any I/O action can fail. We will
assume that you do not currently have a file called aaain your
working directory. So, when you run this code, it will create
the file, write to it, print ‚Äúwrote to file‚Äù in your terminal and
terminate successfully:
-- writePls.hs
moduleMainwhere
main= do
writeFile &quot;aaa&quot;&quot;hi&quot;
putStrLn &quot;wrote to file&quot;</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1826
You can fire up your REPL and load that, or you can compile
the binary like this (this is review, so if you already have all
this down, then go ahead and do it):
stack ghc -- <filename> -o <output file name>
And run it like this:
$ ./<output file name>
So, if you called the output file wp, for example, your termi-
nal session might look like this:
$ stack ghc -- writepls.hs -o wp
[stack compilation messages]
$ ./wp
wrote to file
$ cat aaa
hi
Cool, that all worked. That worked in part because writeFile
will go ahead and create a file and give it write permissions
if the file you‚Äôre trying to write to does not exist. But what if
you‚Äôre trying to write to a file that does already exist and does
not have write permissions?
Make a read-only file named zzzthat we can experiment
with. To make a file that cannot be written to on Linux or OSX,
the following suffices:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1827
$ touch zzz
$ chmod 400 zzz
Suppose that file cohabits a directory where we‚Äôre trying to
execute this program:
-- writePls.hs
moduleMainwhere
main= do
writeFile &quot;zzz&quot;&quot;hi&quot;
putStrLn &quot;wrote to file&quot;
It‚Äôs the same program we had for the aaafile, just with the
file name changed. You can fire up your REPL and load that,
or you can compile the binary as we did above.
Then, if you run this program with such a file, you‚Äôll get the
following result:
$ ./wp
wp: zzz: openFile: permission denied (Permission denied)
There‚Äôs a hole in our bucket, dear Liza: an exception.
Catch me if you can
Let‚Äôs fix that, dear Henry. We‚Äôll start with some rudimentary
exception handling:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1828
moduleMainwhere
importControl.Exception
importData.Typeable
handler ::SomeException -&gt;IO()
handler (SomeException e)= do
print (typeOf e)
putStrLn ( &quot;We errored! It was: &quot;
++show e)
main=
writeFile &quot;zzz&quot;&quot;hi&quot;
<code>catch</code> handler
We‚Äôre still going to terminate without writing to the file, for
the same reasons as above. The program will run and termi-
nate successfully, but it‚Äôll mention the error and say that it
failed with an IOException . We‚Äôll get a bit more information
about why the program failed and be able to log that informa-
tion with our exception handler if we wish. Sometimes, that‚Äôs
exactly what you want: for your program to log the exception
and then die. Soon, we‚Äôll look at some other options for han-
dling exceptions in a way that lets your program proceed with
an alternate execution.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1829
For now, let‚Äôs turn our attention to catch:
catch::Exception e
=&gt;IOa
-&gt;(e-&gt;IOa)
-&gt;IOa
You may recall we mentioned catchearlier because it calls
fromException andcastfor us. It runs only if the exception
matching the type you specified gets thrown, and it gives you
an opportunitity to recover from the error and still satisfy
the original type that your IOaction purported to be. If no
exception gets thrown, then nothing happens with that ùëíand
theIO aat the front is the same as the IO aat the end.
Let‚Äôs expand our rudimentary error handling in a way that
allows the program an alternate execution method instead
of allowing it to die. This time, the mainaction still wants to
write to that read-only file, but this time our handler gives
it an alternate file that does not exist to write to (if you do
have a file called bbbin your present working directory, you
can change the name of the writeFile argument to some other
name, anything as long as it doesn‚Äôt exist in your directory
yet):</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1830
-- writePls.hs
moduleMainwhere
importControl.Exception
importData.Typeable
handler ::SomeException -&gt;IO()
handler (SomeException e)= do
putStrLn ( &quot;Running main caused an error! <br />
\It was: &quot;
++show e)
writeFile &quot;bbb&quot;&quot;hi&quot;
main=
writeFile &quot;zzz&quot;&quot;hi&quot;
<code>catch</code> handler
When writing to zzzfails, it should print the error message
to the terminal. If you check your directory, you should see
your alternate file, named in the handler function, and if you
look inside that, it should say ‚Äúhi‚Äù to you.
Let‚Äôs look at another, slightly more complex, use of catch.
This is taken from a program that deletes things from a Twitter
account and relies on the library twitter-conduit .2This portion
2https://www.stackage.org/package/twitter-conduit</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1831
of the program can fail when it doesn‚Äôt have access to the
appropriate credentials for talking to a Twitter account. So,
we built an exception handler that tells it what to do when that
exception arises:
withCredentials action= do
twinfo&lt;-
loadCredentials <code>catch</code> handleMissing
casetwinfoof
Nothing -&gt;
getTWInfo &gt;&gt;=saveCredentials
Justtwinfo-&gt;action twinfo
wherehandleMissing ::IOException
-&gt;IO(MaybeTWInfo)
handleMissing _ =returnNothing
We turn an IOException into an IO (Maybe a) so we can case
on the Maybeto tell it what to do in the Nothing case. In this
case, if we throw an IOException and return a Nothing value, our
program will execute this:
getTWInfo &gt;&gt;=saveCredentials
By saving the credentials (the code that does the saving is
not shown here), we hopefully won‚Äôt encounter this exception
the next time we try to run it. In which case, we perform the</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1832
action that is named in the Just twinfo line (said action is also
not shown here, sorry!).
30.4 Want either? Try!
Sometimes we‚Äôd like to lift exceptions out into explicit Either
values. This is quite doable, but you can‚Äôt erase the fact that
you performed I/O in the process. It‚Äôs also no guarantee you‚Äôll
catch all exceptions. Here‚Äôs the function we need to turn im-
plicit exceptions into an explicit Either :
-- Control.Exception
try::Exception e
=&gt;IOa
-&gt;IO(Eithere a)
Then to use it, we could write something like the following
code (please note, this will not compile to a binary the way
earlier examples did because it is not a Mainexecutable; use
GHCi):</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1833
moduleTryExcept where
importControl.Exception
willIFail ::Integer
-&gt;IO(EitherArithException ())
willIFail denom=
try$print$div5denom
Here we print the result because you can only handle ex-
ceptions in IO, evidenced by the types of tryandcatch. If you
feed this some inputs, you‚Äôll see something like the following:
Prelude&gt; willIFail 1
5
Right ()
Prelude&gt; willIFail 0
Left divide by zero
One thing to keep in mind is that exceptions in Haskell are
like exceptions in most other programming languages ‚Äî they
are imprecise. An exception not caught by a particular bit of
code will get rolled up by the exception until it‚Äôs either caught
or kills your program.
If you wanted to get rid of the Right () that it‚Äôs printing in
the successful cases, here‚Äôs one way to get rid of it:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1834
onlyReportError ::Showe
=&gt;IO(Eithere a)
-&gt;IO()
onlyReportError action= do
result&lt;-action
caseresultof
Lefte-&gt;print e
Right_ -&gt;return()
willFail ::Integer -&gt;IO()
willFail denom=
onlyReportError $willIFail denom
Or you could use catch:
willIFail' ::Integer -&gt;IO()
willIFail' denom=
print (div 5denom) <code>catch</code> handler
wherehandler ::ArithException
-&gt;IO()
handler e =print e
Let‚Äôs expand on this. We want to take the above examples
and turn them into an executable binary, which is a problem,
because in an executable, maincan‚Äôt take arguments. So, we‚Äôll
have to do some serious modification in order to be able to</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1835
pass arguments to mainwhen we call it. We‚Äôre going to import
System.Environment so that we can make use of a function called
getArgs that allows us to pass arguments in at the point where
we callmain:
moduleMainwhere
importControl.Exception
importSystem.Environment (getArgs)
willIFail ::Integer
-&gt;IO(EitherArithException ())
willIFail denom=
try$print$div5denom
onlyReportError ::Showe
=&gt;IO(Eithere a)
-&gt;IO()
onlyReportError action= do
result&lt;-action
caseresultof
Lefte-&gt;print e
Right_ -&gt;return()</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1836
testDiv ::String-&gt;IO()
testDiv d=
onlyReportError $willIFail (read d)
main::IO()
main= do
args&lt;-getArgs
mapM_ testDiv args
The use of mapM_here might not be obvious, so let‚Äôs unpack
that a bit. It is essentially a less general traverse function that
throws away its end result and only produces the eÔ¨Äects. In this
case, those eÔ¨Äects are going to be the results of mapping our
testDiv function over a list of arguments ‚Äî returning either
the result of a successful division or the type of an exception.
We‚Äôll compile this one to an executable binary again, as we
did earlier in the chapter. To pass in the arguments, it will
look like this:
$ stack ghc -- writepls.hs -o wp
[stack noise]
$ ./wp 4 5 0 9
1
1
divide by zero
0</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1837
IncaseyouwantedtotrythisintheREPL,reproducingwhat
you did above, use the indexmain@ :mainGHCi command and
pass the same arguments.
Prelude&gt; :main 4 5 0 9
1
1
divide by zero
0
Notice that, now that the exception is handled, we can still
get that last result ‚Äî we have survived an ArithException !
30.5 The unbearable imprecision of
trying
Let‚Äôs do another little experiment:
importControl.Exception
canICatch ::Exception e
=&gt;e
-&gt;IO(EitherArithException ())
canICatch e=
try$throwIO e</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1838
The new thing here is throwIO , a function that allows you
to throw an exception. Right now we want to demonstrate
that this handler doesn‚Äôt catch all types of exceptions, so we‚Äôre
usingthrowIO to cause exceptions of various types to be thrown.
TheLefthere can only handle or catch an ArithException ,
not any other kind. So when we throw a diÔ¨Äerent type of
exception, we get the following:
Prelude&gt; canICatch DivideByZero
Left divide by zero
Prelude&gt; canICatch StackOverflow
*** Exception: stack overflow
Prelude&gt; :t DivideByZero
DivideByZero :: ArithException
Prelude&gt; :t StackOverflow
StackOverflow :: AsyncException
The latter case blew past our trybecause we were trying to
catch an ArithException , not an AsyncException .
We‚Äôvementionedseveraltimesthat SomeException willmatch
on all types that implement the Exception typeclass, so try
rewriting the above such that the StackOverflow or any other
exception can also be caught.
We‚Äôll continue the experiment by making a program that
runs until an unhandled exception stops the party:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1839
moduleStoppingTheParty where
importControl.Concurrent (threadDelay )
importControl.Exception
importControl.Monad (forever)
importSystem.Random (randomRIO )
randomException ::IO()
randomException = do
i&lt;-randomRIO ( 1,10::Int)
ifi <code>elem</code> [ 1..9]
thenthrowIO DivideByZero
elsethrowIO StackOverflow
main::IO()
main=forever $ do
lettryS::IO()
-&gt;IO(EitherArithException ())
tryS=try
_ &lt;-tryS randomException
putStrLn &quot;Live to loop another day!&quot;
-- microseconds
threadDelay ( 1*1000000)
We‚Äôve talked about forever before; it causes the program
execution to loop indefinitely. We have added the threadDelay</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1840
to slow the looping down so that what‚Äôs happening is more
noticeable. Note that the thread is delayed by a number of
microseconds.
ThetrySallows it to survive the ArithException s. We throw
away those exceptions and keep looping, but we can only throw
away the exception that we matched on ( ArithException ). At
some point, when our random number is 10, we will throw an
AsyncException instead of an ArithException , and our program
will die a rapid death. Try modifying this one so that both
exceptions are handled and the loop never terminates.
30.6 Why throwIO?
It may have seemed odd to you (or not!) to encounter throwIO
above. Why do we want to stop a program by purposely throw-
ing an exception? In the real world, we often do want to do
that ‚Äî to stop the program when some condition occurs, but
it may be difficult to see that from what we‚Äôve shown you so
far.
There‚Äôs a function called throwthat allows exceptions, such
as the arithmetic exceptions, but you rarely use it. It‚Äôs what
allows the divfunction to throw a DivideByZero exception when
that happens, but outside of such library functions, you don‚Äôt
need it.
The diÔ¨Äerence between throwandthrowIO can be seen in the
type:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1841
throwIO ::Exception e=&gt;e-&gt;IOa
Partiality in the form of throwing an exception can be
thought of as an eÔ¨Äect. The conventional way to throw an
exception is to use throwIO , which has IOin its result. This is
the same thing as throw, butthrowIO embeds the exception in
IO. You always handle exceptions in IO3. Handling exceptions
must be done in IOeven if they were thrown without an IOtype.
You almost never want throwas it throws exceptions without
any warning in the type, even IO.
We‚Äôll look at an example of an unconditionally thrown ex-
ception in IOso you can see how it aÔ¨Äects the control flow of
your program:
importControl.Exception
main::IO()
main= do
throwIO DivideByZero
putStrLn &quot;lol&quot;
Prelude&gt; main
*** Exception: divide by zero
Likethrow,throwIO is often called for us, behind the scenes,
by library functions. Often, in interacting with the real world,
3Why? Because catching and handling exceptions means you could produce diÔ¨Äerent
results from the same inputs. That breaks referential transparency.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1842
we need to tell our program that in certain conditions, we want
it to stop or to give us an error message and let us know things
went wrong. We‚Äôll take a look at a couple of examples from
real code, a library called http-client4by Michael Snoyman,
that uses throwIO to throw some exceptions when httpthings
haven‚Äôt gone the way we wanted them to:
connectionReadLine ::Connection
-&gt;IOByteString
connectionReadLine conn= do
bs&lt;-connectionRead conn
when (S.null bs) $
throwIO IncompleteHeaders
connectionReadLineWith conn bs
In the above, throwIO will throw an IncompleteHeaders excep-
tion when the ByteString header is empty. In the next example,
it‚Äôs used to throw a ResponseTimeout exception when, well, the
response times out:
4https://www.stackage.org/package/http-client</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1843
parseStatusHeaders ::Connection
-&gt;MaybeInt
-&gt;Maybe(IO())
-&gt;IOStatusHeaders
parseStatusHeaders conn timeout' cont
|Justk&lt;-cont=
getStatusExpectContinue k
|otherwise =
getStatus
where
withTimeout = casetimeout' of
Nothing -&gt;id
Justt-&gt;
timeout t &gt;=&gt;
maybe
(throwIO ResponseTimeout )
return
-- ... other code elided ...
You can use http-client without worrying about how he
makes the exceptions happen. But let‚Äôs next take a look at
making our own exception types for those times when you
do need to worry about it. Keep in mind that since time of
writing, http-client has changed how it defines and throws
exceptions, but the examples should still be useful.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1844
30.7 Making our own exception types
Often we‚Äôll want our own exception types, like http-client has.
They enable us to be more precise about what‚Äôs going on in
our program. Let‚Äôs work through a small example to emit one
of a couple diÔ¨Äerent possible errors in an otherwise simple
function to see how we could do this:
moduleOurExceptions where
importControl.Exception
dataNotDivThree =
NotDivThree
deriving (Eq,Show)
instance Exception NotDivThree
dataNotEven =
NotEven
deriving (Eq,Show)
instance Exception NotEven
Note here that Exception instances are derivable ‚Äî you don‚Äôt
need to write an instance. Continuing on:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1845
evenAndThreeDiv ::Int-&gt;IOInt
evenAndThreeDiv i
|rem i3/=0=throwIO NotDivThree
|odd i=throwIO NotEven
|otherwise =return i
Then we‚Äôll see the error and success conditions:
*OurExceptions&gt; evenAndThreeDiv 0
0
*OurExceptions&gt; evenAndThreeDiv 1
*** Exception: NotDivThree
*OurExceptions&gt; evenAndThreeDiv 2
*** Exception: NotDivThree
*OurExceptions&gt; evenAndThreeDiv 3
*** Exception: NotEven
*OurExceptions&gt; evenAndThreeDiv 6
6
*OurExceptions&gt; evenAndThreeDiv 9
*** Exception: NotEven
*OurExceptions&gt; evenAndThreeDiv 12
12
There is an issue with this setup, although it‚Äôs common.
What if we want to know what input or inputs caused the
error? We need to add context!</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1846
Adding context
Convenient subsection titling! Anyhow, let‚Äôs modify that:
moduleOurExceptions where
importControl.Exception
dataNotDivThree =
NotDivThree Int
deriving (Eq,Show)
instance Exception NotDivThree
dataNotEven =
NotEven Int
deriving (Eq,Show)
instance Exception NotEven
evenAndThreeDiv ::Int-&gt;IOInt
evenAndThreeDiv i
|rem i3/=0=throwIO ( NotDivThree i)
|odd i=throwIO ( NotEven i)
|otherwise =return i
Now when we get errors, we can know what input caused
the error:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1847
*OurExceptions&gt; evenAndThreeDiv 12
12
*OurExceptions&gt; evenAndThreeDiv 9
*** Exception: NotEven 9
*OurExceptions&gt; evenAndThreeDiv 8
*** Exception: NotDivThree 8
*OurExceptions&gt; evenAndThreeDiv 3
*** Exception: NotEven 3
*OurExceptions&gt; evenAndThreeDiv 2
Catch one, catch all
Now, you can probably figure out how to catch these two dif-
ferent errors:
catchNotDivThree ::IOInt
-&gt;(NotDivThree -&gt;IOInt)
-&gt;IOInt
catchNotDivThree =catch
catchNotEven ::IOInt
-&gt;(NotEven -&gt;IOInt)
-&gt;IOInt
catchNotEven =catch
Or perhaps with try:</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1848
Prelude&gt; type EA e = IO (Either e Int)
Prelude&gt; try (evenAndThreeDiv 2) :: EA NotEven
*** Exception: NotDivThree 2
Prelude&gt; try (evenAndThreeDiv 2) :: EA NotDivThree
Left (NotDivThree 2)
Thetypesynonymisn‚Äôtsemanticallyimportant, butitshrinks
the noise a bit. Now, you could handle both errors with the
catches function:
catches ::IOa-&gt;[Handler a]-&gt;IOa
catchBoth ::IOInt
-&gt;IOInt
catchBoth ioInt=
catches ioInt
[Handler
((NotEven _)-&gt;return maxBound)
,Handler
((NotDivThree _)-&gt;return minBound)
]
ThemaxBound /minBound thingisnotgoodcodeforrealuse, just
a convenience. Incidentally, the same trick the SomeException
type uses to hide type arguments is used by the Handler type
to wrap the values in the list of exception handlers: existential
quantification.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1849
dataHandler awhere
Handler ::Exception e
=&gt;(e-&gt;IOa)-&gt;Handler a
-- Defined in ‚ÄòControl.Exception‚Äô
We can make a list of handlers that handle exceptions of
varying types because the exception types are existentially
quantified under Handler ‚Äôs datatype.
But what if this isn‚Äôt convenient enough? What if we have a
family of semantically related or otherwise similar exceptions
we want to catch as a group? For this we revive our old friend,
the sum type!</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1850
moduleOurExceptions where
importControl.Exception
dataEATD=
NotEven Int
|NotDivThree Int
deriving (Eq,Show)
instance Exception EATD
evenAndThreeDiv ::Int-&gt;IOInt
evenAndThreeDiv i
|rem i3/=0=throwIO ( NotDivThree i)
|even i=throwIO ( NotEven i)
|otherwise =return i
Now when we want to catch either error, we only need one
handler and then we can pattern match on the exception type
just like good old fashioned datatypes:
Prelude&gt; type EA e = IO (Either e Int)
Prelude&gt; try (evenAndThreeDiv 0) :: EA EATD
Left (NotEven 0)
Prelude&gt; try (evenAndThreeDiv 1) :: EA EATD
Left (NotDivThree 1)</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1851
Nifty, eh? The notion here is to exercise the same taste
and judgment in designing your error types as you would in
your happy-path types. Preserve context and try to make it so
somebody could understand the problem you‚Äôre solving from
the types. If necessary. On a desert island. With a lot of rum.
And sea turtles.
30.8 Surprising interaction with
bottom
One thing to watch out for is situations where you catch an
exception for a value that might be bottom. Due to nonstrict-
ness, the bottom could‚Äôve been forced before or after your
exception handler, so you might be surprised if you expected
either:
‚Ä¢that your exception handler was meant to catch the bot-
tom, or
‚Ä¢that no bottoms would cause your program to fail after
having caught, say, a SomeException .
The proper coping mechanism for this is a glass of scotch
and to realize the following things:
‚Ä¢The exception handling mechanism is not for, nor should
be used for, catching bottoms.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1852
‚Ä¢Having caught an exception, even SomeException , without
rethrowing an exception doesn‚Äôt mean your program
won‚Äôt fail.
To demonstrate the point, we‚Äôll show you a case where we
caught an exception from a bottom and a case where a bottom
leap-frogged our handler:
importControl.Exception
noWhammies ::IO(EitherSomeException ())
noWhammies =
try undefined
megaButtums ::IO(EitherSomeException ())
megaButtums =
try$return undefined
Do you think these should have the same result? We‚Äôve got
bad news:
Prelude&gt; noWhammies
Left Prelude.undefined
Prelude&gt; megaButtums
Right *** Exception: Prelude.undefined
The issue is that nonstrictness means burying the bottom
in areturn causes the bottom to not get forced until you‚Äôre</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1853
already past the try, resulting in an uncaught error inside the
Rightconstructor. The take-away here shouldn‚Äôt be, ‚Äúlaziness
is terrifying,‚Äù but rather, ‚Äúwrite total programs that don‚Äôt use
bottom.‚Äù It‚Äôs not only unforced bottoms that can cause pro-
grams that shouldn‚Äôt have any uncaught exceptions to fail
either, there‚Äôs also‚Ä¶
30.9 Asynchronous Exceptions
Asynchronousexceptionsarethepredatorshuntingyourhappy
little programs. You probably don‚Äôt have much experience
with anything like this unless you‚Äôve written Erlang before.
Even then, Erlang‚Äôs asynchronous exceptions are handled by
a separate process. Most languages don‚Äôt have anything like
this if only because they don‚Äôt have a hope of making it safe
within their implementation runtimes.
moduleMainwhere
-- we haven't explained this.
-- tough cookies.
importControl.Concurrent
(forkIO,threadDelay )
importControl.Exception
importSystem.IO</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1854
openAndWrite ::IO()
openAndWrite = do
h&lt;-openFile &quot;test.dat&quot; WriteMode
threadDelay 1500
hPutStr h
(replicate 100000000 '0'++&quot;abc&quot;)
hClose h
dataPleaseDie =
PleaseDie
deriving Show
instance Exception PleaseDie
main::IO()
main= do
threadId &lt;-forkIO openAndWrite
threadDelay 1000
throwTo threadId PleaseDie
If you run this program, the intended result is that you‚Äôll
have a file named test.dat with only zeroes that didn‚Äôt reach
the ‚Äúabc‚Äù at the end. Since we can‚Äôt predict the future, if you
have a disk with preternaturally fast I/O, increase the argu-
ments to replicate to reproduce the intended issue. If it ain‚Äôt
broken, break it.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1855
What happened was that we threw an asynchronous excep-
tion from the main thread to our child thread, short-circuiting
what we were doing in the middle of doing it. If you did this
in a loop, you‚Äôd leak file handles, too. Done continually over a
period of time, leaking file handles can cause your process to
get killed or your computer to become unstable.
We can think of asynchronous exceptions as exceptions
raised from a diÔ¨Äerent thread than the one that‚Äôll receive the
error. They‚Äôre immensely useful and give us a means of talk-
ing about error conditions that are quite real and possible in
languages that don‚Äôt have formal asynchronous exceptions.
Your process can get axe-murdered by the operating system
out of nowhere in any language. We just happen to have the
ability to do the same within the programming language at the
thread level as well. The issue is that we want to temporarily
ignore exceptions until we‚Äôve finished what we‚Äôre doing. This
is so the state of the file is correct but also so that we don‚Äôt leak
resources like file handles or perhaps database connections or
something similar.5Never fear, we can fix this!
5In this case, leaking means having too many (files, database connections, etc.) open
at one time, thus consuming all the resources your OS can allocate, the way trying to
hold too much in memory for too long causes memory leaks.</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1856
moduleMainwhere
-- we haven't explained this.
-- tough cookies.
importControl.Concurrent
(forkIO,threadDelay )
importControl.Exception
importSystem.IO
openAndWrite ::IO()
openAndWrite = do
h&lt;-openFile &quot;test.dat&quot; AppendMode
threadDelay 1500
hPutStr h
(replicate 10000000 '0'++&quot;abc&quot;)
hClose h
dataPleaseDie =
PleaseDie
deriving Show
instance Exception PleaseDie
main::IO()
main= do
threadId &lt;-forkIO (mask_ openAndWrite)
threadDelay 1000
throwTo threadId PleaseDie</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1857
Here we used mask_fromControl.Exception in order to mask
or delay exceptions thrown to our child thread until the IO
actionopenAndWrite wascomplete. Incidentally, sincetheendof
the mask is the last thing our child thread does, the exception
our main thread tried to throw to the child blows up in its
face, Wile E. Coyote style, and is now thrown within the main
thread.
Don‚Äôt panic!
Async exceptions are helpful and manifest in less obvious ways
in other language runtimes and ecosystems. Don‚Äôt try to catch
everything; just let it die, and make sure you have a process
supervisor and good logs. No execution is better than bad
execution.
30.10 Follow-up Reading
1.ABeginner‚ÄôsGuidetoExceptionsinHaskell; ErinSwenson-
Healey
https://www.youtube.com/watch?v=PWS0Whf6-wc
2.Chapter 8. Overlapping Input/Output; Parallel and Con-
current Programming in Haskell; Simon Marlow;
http://chimera.labs.oreilly.com/books/1230000000929/ch08.html</p>
<p>CHAPTER 30. WHEN THINGS GO WRONG 1858
3.Chapter 9. Cancellation and Timeouts; Parallel and Con-
current Programming in Haskell; Simon Marlow;
http://chimera.labs.oreilly.com/books/1230000000929/ch09.html
4.An Extensible Dynamically-Typed Hierarchy of Excep-
tions; Simon Marlow
http://community.haskell.org/~simonmar/papers/ext-exceptions.
pdf</p>
<p>Chapter 31
Final project
1859</p>
<p>CHAPTER 31. FINAL PROJECT 1860
31.1 Final project
For our final project, we‚Äôre doing something a little weird, but
small and modernized a bit from the original design. Surely
no one who knows us from Twitter or IRC will be surprised
that we‚Äôve chosen something eccentric for this, but we felt it
was important to show you an end-to-end project that brings
in so much real world it‚Äôll make your head spin.
In this chapter,
‚Ä¢FINGER DAEMONS.
31.2 fingerd
Dating back to 1971, the finger1service was a means of figuring
out how to contact colleagues or other people on the same
computer network and whether they were on the network at
a given time, often on the same mainframe in a time when
computing was usually time-shared on the same physical ma-
chine.finger was originally intended to be used to share an
office number, email address, basic contact details like that.
By the time the 1990s and public internet access was widely
available finger was also used to deliver .planor.project files
as sort of pre-Twitter/Tumblr microblog.
1http://www.rajivshah.com/Case_Studies/Finger/Finger.htm</p>
<p>CHAPTER 31. FINAL PROJECT 1861
We‚Äôre going to be writing a finger daemon in this chapter.
Finger daemon programs are often called fingerd. A daemon
is a process that runs in the background without direct user
interaction; in the case of finger , the daemon acts as the server
side of the protocol, while the finger program itself is on the
client side. When you use finger from your command line,
it sends a request to the finger daemon, and the daemon re-
sponds with the requested information if it can.
We use this as an example in part because it‚Äôs not a typical
web app, only requires working with text, and because the
text-based protocol is spare and easy to debug once you know
how. This chapter is going to be somewhat more Unix/Linux-
oriented than previous ones, for a few reasons. Windows users
will find that not all of the examples can be followed along
literally, but the final version of the finger daemon2should
work.
Caveat for the Windows users
You will not be able to follow all of the instructions here ver-
batim. You can still build and hack on the project, but if you
aren‚Äôt willing to install a finger client for testing your finger
daemon via Cygwin then you‚Äôll need to write your own client.
2A daemon is a computer program that runs as a background process</p>
<p>CHAPTER 31. FINAL PROJECT 1862
31.3 Exploring finger
If you had fingerd running on your local machine under the
username callen, the result of having done so might look some-
thing like:3
$ finger callen@localhost
Login: callen Name: callen
Directory: /home/callen Shell: /bin/zsh
On OS X, this will work, without having fired up or installed
a finger service, by not specifying a hostname to query:
$ finger callen
Login: callen Name: Chris Allen
Directory: /Users/callen Shell: /bin/bash
Spooky! Don‚Äôt ask. The finger protocol operates over Trans-
mission Control Protocol (TCP) sockets, something it has in
common with the protocol used by web browsers. However,
while they both use TCP, a finger daemon is not a web server.
It‚Äôs something much simpler. Rather than having an entire
application protocol layered atop TCP like the web (HTTP)
does, it‚Äôs a single message text protocol. Rather than go into a
long explanation of the internet, UDP, and TCP, let‚Äôs say TCP
3You can still use finger to check on the status of the bathrooms in the Random Hall
dormitory at MIT by typing finger @bathroom.mit.edu in your terminal. Try it.</p>
<p>CHAPTER 31. FINAL PROJECT 1863
is a protocol for sending messages back and forth between a
client and a server. Those messages can be raw bytes or text.
A socket is an address where a message can be delivered.4
Leaving aside the socket business, the way this should work
is roughly like this: the client requests some information, and
that request is trasmitted to the server with TCP magic. The
server (our friendly daemon) dishes up that information (if it
has it), TCP magic sends it to the client, then the client prints
the information in your terminal. We will start our project
with a little TCP echo server that prints the literal text the
client sent so that we can understand the cases we‚Äôre dealing
with.
Project overview
To kick this oÔ¨Ä, we‚Äôll use Stack with the stack new command
like so:
$ stack new fingerd simple
This gets us a simple project with a single executable stanza
in the Cabal file. The final version after we‚Äôve added Debug.hs
will have the following layout:
$ tree .
4If you‚Äôre new to networking and sockets, this guide by Julia Evans is a great intro-
duction. http://jvns.ca/zines/#networking-ack</p>
<p>CHAPTER 31. FINAL PROJECT 1864
.
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Setup.hs
‚îú‚îÄ‚îÄ fingerd.cabal
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Debug.hs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Main.hs
‚îî‚îÄ‚îÄ stack.yaml
fingerd.cabal
Our Cabal file will mention an executable we‚Äôre not going to
give you yet, so you can leave the placeholder Stack generated
there for now. Note we have gently reformatted the text to fit
this book‚Äôs format.
name: fingerd
version: 0.1.0.0
synopsis: Simple project template
description: Please see README.md
homepage: https://github.com/u/fingerd
license: BSD3
license-file: LICENSE
author: Chris Allen
maintainer: cma@bitemyapp.com
copyright: 2016, Chris Allen
category: Web</p>
<p>CHAPTER 31. FINAL PROJECT 1865
build-type: Simple
cabal-version: &gt;=1.10
executable debug
ghc-options: -Wall
hs-source-dirs: src
main-is: Debug.hs
default-language: Haskell2010
build-depends: base &gt;= 4.7 &amp;&amp; &lt; 5
, network
executable fingerd
ghc-options: -Wall
hs-source-dirs: src
main-is: Main.hs
default-language: Haskell2010
build-depends: base &gt;= 4.7 &amp;&amp; &lt; 5
, bytestring
, network
, raw-strings-qq
, sqlite-simple
, text
Now that we have taken care of that, let‚Äôs write some code.</p>
<p>CHAPTER 31. FINAL PROJECT 1866
src/Debug.hs
This is our first source file. We‚Äôre going to use this program to
show us what the client sends and send it back. In this respect,
it‚Äôs almost identical to the echo server demonstrated in the
documentation of the network5library we‚Äôre relying on. The
diÔ¨Äerence is that it also prints a literal representation of the
text that was sent.
Our debug program is a TCP server, similar to a web server
which provides a web page, but lower level and limited to
sending raw text back and forth. What is diÔ¨Äerent is that a web
server communicates with browsers over a TCP socket using a
structured protocol rich with metadata, routes, and a standard
describing that protocol. What we‚Äôre doing is older and more
primitive.
moduleMainwhere
importControl.Monad (forever)
importNetwork.Socket hiding(recv)
importNetwork.Socket.ByteString
(recv,sendAll)
5https://www.stackage.org/package/network The example we‚Äôre referring to is in the Net-
work.Socket.ByteString module. Click on it and look for the example.</p>
<p>CHAPTER 31. FINAL PROJECT 1867
logAndEcho ::Socket-&gt;IO()
logAndEcho sock=forever $ do
(soc,_)&lt;-accept sock
printAndKickback soc
sClose soc
whereprintAndKickback conn = do
msg&lt;-recv conn 1024
print msg
sendAll conn msg
This sets up our server. Its argument is a socket ( sock) that
listens for new client connections; due to our use of forever ,
that socket remains open indefinitely. The accept action will
block until a client connects to the server. The socket socis
the result of accept -ing a connection for communicating with
the client.
The server can receive up to 1024 bytes of text from the
client. All it does here is print the text literally, then echo
what the client sent right back to the client that made the
connection. Note that recvis permitted to return fewer than
the maximum bytes specified if that‚Äôs all the client sent. Then
the connection to the client is closed ‚Äî we apply sClose to
socbut not to sock, sosock, the server socket, remains open.
Because this action loops forever, the next thing we do is await
another client connection.</p>
<p>CHAPTER 31. FINAL PROJECT 1868
main::IO()
main=withSocketsDo $ do
addrinfos &lt;-getAddrInfo
(Just(defaultHints
{addrFlags =
[AI_PASSIVE ]}))
Nothing (Just&quot;79&quot;)
letserveraddr =head addrinfos
sock&lt;-socket (addrFamily serveraddr)
StreamdefaultProtocol
bindSocket sock (addrAddress serveraddr)
listen sock 1
logAndEcho sock
sClose sock
At the beginning of main,withSocketsDo is not going to do any-
thing at all unless you‚Äôre on Windows. If you are on Windows,
it‚Äôs obligatory to use the sockets API in the network library. The
address information stuÔ¨Ä is mostly noise and can be ignored
as a means for describing what kind of TCP server we‚Äôre firing
up and what port it‚Äôs listening on.
The important part is the (Just &quot;79&quot;) part ‚Äî that‚Äôs the port
we‚Äôre listening for connections on. Also note that you‚Äôll need
administrative privileges on most operating systems to listen
on that port.</p>
<p>CHAPTER 31. FINAL PROJECT 1869
TCP socket libraries like network often call everything a
socket. Server listening for connections? That‚Äôs a socket.
Client connection that you were listening for? That‚Äôs a socket.
Everything‚Äôs a socket, and nothing‚Äôs a wrench.
The next bit constructs a sort of socket descriptor with
socket . Thenwebindthesockettotheaddress(port)wewanted.
Lastly, we let the operating system know we‚Äôre prepared to
listen for connections from clients with listen . From there, we
fire oÔ¨Ä our server logic which runs indefinitely. If and when
logAndEcho finishes, we‚Äôll close the socket server and then our
story is over.
The next step, assuming your project is built, is to fire up the
debug server ‚Äî note that it‚Äôll want administrative privileges
for using port 79:
$ sudo <code>stack exec which debug</code>
{... build noise and a password prompt ...}
That will get our echo server set up, and we can now test
it using telnet to connect. Telnet is often used to debug TCP
services that use text to communicate. Note that you‚Äôll need
to usesudoor otherwise make use of administrator powers to
start the program because it wants to use a network port that
only administrators or root accounts have access to in most
operating systems. Usually this is the first 1024 ports. Once
you have the debug server running in one terminal, you‚Äôll
connect to it from a new terminal like so:</p>
<p>CHAPTER 31. FINAL PROJECT 1870
$ telnet localhost 79
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
From there, telnet is waiting for you to type something and
then hit enter:
blah
blah
Connection closed by foreign host.
In the above, we typed ‚Äúblah,‚Äù hit enter, got ‚Äúblah‚Äù echoed
back to us, then the server closed the connection. Remember
thatsClose is applied to socin ourlogAndEcho function, ensuring
that the temporary telnet connection is closed. However, the
server is still open, and you can make further requests by
reopening the telnet connection.
Let us take a look at the server side to see what it printed:
&quot;blah\r\n&quot;
We used printrather than putStrLn inlogAndEcho on purpose,
so we could get a literal representation of the data that was
sent. In this case, the string ‚Äúblah‚Äù and the special characters
\rand\nwere sent. On Unix-based operating systems such</p>
<p>CHAPTER 31. FINAL PROJECT 1871
as Linux, \nis the default line-ending character. Microsoft
Windows uses \rfollowed by \nfor the same.
Having done that, let us now do the same with a finger
client:
$ finger callen@localhost
[localhost]
Trying 127.0.0.1...
callen
$ finger @localhost
[localhost]
Trying 127.0.0.1...
Particularly if you‚Äôre on a Mac, you may get some noise
here like this:
Trying ::1...
finger: connect: Connection refused
Trying 127.0.0.1...
It should connect after that. It attempts to use IPv6 first to
reach your finger daemon; when it can‚Äôt, it should use IPv4.
You can probably ignore this.
Then the output server-side for this would be:
&quot;callen\r\n&quot;
&quot;\r\n&quot;</p>
<p>CHAPTER 31. FINAL PROJECT 1872
The first command asked the finger daemon running at
localhost for information on the user callen; the second asked
for a listing of users. With the printed output the server gave
us, we now know what queries from a finger client will look
like to our TCP server. With that done, we‚Äôll now write up the
final TCP server itself.
31.4 Slightly modernized fingerd
Historically, the data that finger returns about users was part
of the operating system. That information is still typically
stored in the OS, but for security reasons, it‚Äôs no longer rou-
tinely shared through finger requests. We‚Äôre going to update
the source of data for finger by using an embedded SQL6
database called SQLite. A database is a convenient yet robust
way of sorting and reading data, and SQLite is a lightweight
database. The data will be stored in a file within the main
project directory, so there won‚Äôt be a lot of mystery or magic
involved in interacting with it.
First we‚Äôll show you the TCP server‚Äôs framing of the logic,
then we‚Äôll show you how the database interaction works. From
here, all the code goes into your Main.hs file.
6Pronounced ‚Äúsquirrel.‚Äù</p>
<p>CHAPTER 31. FINAL PROJECT 1873
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE RecordWildCards #-}
OverloadedStrings you already know. QuasiQuotes is for the
literals, which you‚Äôve seen before. RecordWildCards is the new
one and isn‚Äôt too difficult to figure out. It spares us manually
yanking the contents of a record into scope; instead, the record
accessors become bindings to the contents such that,
{-# LANGUAGE RecordWildCards #-}
moduleRWCDemo where
dataBlah=
Blah{ myThing ::Int}
wewBlah{..}=print myThing
wewwill print the myThing inside of the Blahargument it is
applied to without needing to apply myThing to aBlahvalue or
to destructure the contents of Blahin the pattern match. It‚Äôs
purely a convenience.</p>
<p>CHAPTER 31. FINAL PROJECT 1874
moduleMainwhere
importControl.Exception
importControl.Monad (forever)
importData.List (intersperse )
importData.Text (Text)
import qualified Data.Text asT
importData.Text.Encoding
(decodeUtf8 ,encodeUtf8 )
We‚Äôll need the ability to decode a Textvalue from a UTF-8
ByteString andthenre-encodea TextvalueasaUTF-8 ByteString .
importData.Typeable
importDatabase.SQLite.Simple
hiding(close)
import qualified Database.SQLite.Simple
asSQLite
importDatabase.SQLite.Simple.Types
importNetwork.Socket hiding(close,recv)
importData.ByteString (ByteString )
import qualified Data.ByteString asBS
importNetwork.Socket.ByteString
(recv,sendAll)
importText.RawString.QQ</p>
<p>CHAPTER 31. FINAL PROJECT 1875
Creating the database We‚Äôre using the sqlite-simple library
to make a self-contained database stored in a file in the same
directory as our project. This will act as the repository of users
our finger daemon can report on.
dataUser=
User{
userId ::Integer
, username ::Text
, shell ::Text
, homeDirectory ::Text
, realName ::Text
, phone ::Text
}deriving (Eq,Show)
Now we dig into where the data comes from. Useris the
datatype describing our user records. It‚Äôs not super structured
or interesting, but gets things rolling. The only bit potentially
out of the ordinary here is that we have a userId field of type
Integer in order to provide the database with what‚Äôs called a
primary key. This is to provide a means of uniquely identify-
ing data in the database independent of the text fields in our
record type, among other things.
Weneedsomeboilerplatetypeclassinstancesformarshalling
and unmarshalling data to and from the SQLite database:</p>
<p>CHAPTER 31. FINAL PROJECT 1876
instance FromRow Userwhere
fromRow =User&lt;$&gt;field
&lt;<em>&gt;field
&lt;</em>&gt;field
&lt;<em>&gt;field
&lt;</em>&gt;field
&lt;*&gt;field
instance ToRowUserwhere
toRow (Userid_ username shell homeDir
realName phone) =
toRow (id_, username, shell, homeDir,
realName, phone)
This should remind you of FromJSON andToJSON .
createUsers ::Query
createUsers =[r|
CREATETABLEIFNOTEXISTSusers
(idINTEGER PRIMARY KEYAUTOINCREMENT ,
username TEXTUNIQUE,
shellTEXT, homeDirectory TEXT,
realName TEXT, phone TEXT)
|]</p>
<p>CHAPTER 31. FINAL PROJECT 1877
TheQuerytype is a newtype wrapper for a Textvalue. Con-
veniently, Queryhas anIsString instance, so string literals can
beQueryvalues. This isn‚Äôt really a query, though; it‚Äôs a SQL
statement defining the database table that will contain our
user data. The primary key stuÔ¨Ä is noise saying that the row is
namedidand that we want that field to autoincrement without
needing to do it ourselves. That is, if the last row we inserted
into the database had the id 1, then the new one will be auto-
assigned the primary key 2. The rest of it describes field names
and their representation (‚ÄúTEXT‚Äù), but you‚Äôll note we require
usernames to be unique so that there cannot be two Uservalues
with the same username.
insertUser ::Query
insertUser =
&quot;INSERT INTO users <br />
\VALUES (?, ?, ?, ?, ?, ?)&quot;
allUsers ::Query
allUsers =
&quot;SELECT * from users&quot;
getUserQuery ::Query
getUserQuery =
&quot;SELECT * from users where username = ?&quot;</p>
<p>CHAPTER 31. FINAL PROJECT 1878
This is utility stuÔ¨Ä for inserting a new user, getting all users
from the user table, and getting all the fields for a single user
with a particular username. The question marks are how the
sqlite-simple library parameterizes database queries.
dataDuplicateData =
DuplicateData
deriving (Eq,Show,Typeable )
instance Exception DuplicateData
The type above is a one-oÔ¨Ä exception we throw whenever
we get something other than zero or one users for a particular
username. That should be impossible, but you never know.
typeUserRow =
(Null,Text,Text,Text,Text,Text)
UserRow is a type synonym for the tuples we insert to create
a new user.</p>
<p>CHAPTER 31. FINAL PROJECT 1879
getUser ::Connection
-&gt;Text
-&gt;IO(MaybeUser)
getUser conn username = do
results &lt;-
query conn getUserQuery ( Onlyusername)
caseresults of
[]-&gt;return$Nothing
[user]-&gt;return$Justuser
_ -&gt;throwIO DuplicateData
TheOnlydata constructor is how we pass a single argument
instead of a 2-or-greater tuple to our query parameters when
using the sqlite-simple library. This is needed because basehas
no one-tuple type and getUserQuery takes a single parameter.
We check for none, one, or many results converting it into a
Nothing ,Just, orIOexception.
Finally, we need a utility function for creating the database
with a single example row of data:</p>
<p>CHAPTER 31. FINAL PROJECT 1880
createDatabase ::IO()
createDatabase = do
conn&lt;-open&quot;finger.db&quot;
execute_ conn createUsers
execute conn insertUser meRow
rows&lt;-query_ conn allUsers
mapM_ print (rows ::[User])
SQLite.close conn
wheremeRow::UserRow
meRow=
(Null,&quot;callen&quot; ,&quot;/bin/zsh&quot; ,
&quot;/home/callen&quot; ,&quot;Chris Allen&quot; ,
&quot;555-123-4567&quot; )
Stack may balk because you have a module called Mainthat
has nomaindefined. If that‚Äôs the case for you, you can do this:
main::IO()
main=createDatabase
We‚Äôll change that mainlater, but that will get your executable
building for now.
Running this a second time will error without changing the
database. If you need or want to reset the database, you can
delete the finger.db file.</p>
<p>CHAPTER 31. FINAL PROJECT 1881
Before you continue The code that follows will assume and
require a SQLite database by the name of finger.db with the
schema outlined in createUsers exists in the same directory as
where you run your fingerd service.
To run createDatabase , you could do the following:
$ stack ghci --main-is fingerd:exe:fingerd
{... noise noise ...}
Prelude&gt; createDatabase
User {userId = 1, ... noise ... }
With that in place, you can continue implementing your
finger daemon.
Let your fingers do the walking
We‚Äôre still in our Mainmodule here. You should have created
the database already, but now we‚Äôll write the functions that
will allow the server to listen and respond to client queries.</p>
<p>CHAPTER 31. FINAL PROJECT 1882
returnUsers ::Connection
-&gt;Socket
-&gt;IO()
returnUsers dbConn soc = do
rows&lt;-query_ dbConn allUsers
letusernames =map username rows
newlineSeparated =
T.concat$
intersperse &quot;\n&quot;usernames
sendAll soc (encodeUtf8 newlineSeparated)
returnUsers uses a database Connection and aSocket for talk-
ing to the user. The database connection is used to get a list
of all the users in the database which is then changed into
a newline separated Textvalue. Then that is encoded into a
UTF-8ByteString which is sent through the socket to the client.
formatUser ::User-&gt;ByteString
formatUser (User_username shell
homeDir realName _)=BS.concat
[&quot;Login: &quot; , e username, &quot;\t\t\t\t &quot;,
&quot;Name: &quot; , e realName, &quot;\n&quot;,
&quot;Directory: &quot; , e homeDir, &quot;\t\t\t&quot;,
&quot;Shell: &quot; , e shell, &quot;\n&quot;]
wheree=encodeUtf8</p>
<p>CHAPTER 31. FINAL PROJECT 1883
This function is used to format Userrecords as a UTF-8
ByteString value. The format is intended to mimic popular
fingerd implementations but we‚Äôre not going for precision
here.
returnUser ::Connection
-&gt;Socket
-&gt;Text
-&gt;IO()
returnUser dbConn soc username = do
maybeUser &lt;-
getUser dbConn ( T.strip username)
casemaybeUser of
Nothing -&gt; do
putStrLn
(&quot;Couldn't find matching user <br />
\for username: &quot;
++(show username))
return()
Justuser-&gt;
sendAll soc (formatUser user)
This is the single user query case, where we use formatUser
to provide detailed information to the client on a single user.
We have to handle the case where no user by the username
provided was found. As it stands, the Nothing case here will</p>
<p>CHAPTER 31. FINAL PROJECT 1884
print the report that no user was found by that username in the
server terminal but will not send that information ‚Äî or any
information ‚Äî to the client side. You may want to change that,
as it might be useful to tell the end user why no information
was returned.
If a user is found, we send the formatted ByteString of the
Userrecord to the client. The stripping of the username text
prior to querying is because the literal data sent for a user-
name query is &quot;yourname\r\n&quot; and in order for that to match
‚Äúyourname,‚Äù we need to strip the control characters from the
text, which stripfromData.Text does for us.
handleQuery ::Connection
-&gt;Socket
-&gt;IO()
handleQuery dbConn soc = do
msg&lt;-recv soc 1024
casemsgof
&quot;\r\n&quot;-&gt;returnUsers dbConn soc
name-&gt;
returnUser dbConn soc
(decodeUtf8 name)
handleQuery receives up to 1024 bytes of data. Based on
that data the client sends to the server, the case discriminates
between when it should send a list of all users or only a single</p>
<p>CHAPTER 31. FINAL PROJECT 1885
user. Fortunately, the protocol is relatively uncomplicated,
so we don‚Äôt have to do any parsing as would ordinarily be
required for communicating with a more elaborate protocol.
handleQueries ::Connection
-&gt;Socket
-&gt;IO()
handleQueries dbConn sock =forever $ do
(soc,_)&lt;-accept sock
putStrLn &quot;Got connection, handling query&quot;
handleQuery dbConn soc
sClose soc
It‚Äôs similar to the echo server, save for the additional ar-
gument of the database connection and the logging of when
connections were accepted.
Now we need to change mainto assemble our whole pro-
gram:</p>
<p>CHAPTER 31. FINAL PROJECT 1886
main::IO()
main=withSocketsDo $ do
addrinfos &lt;-
getAddrInfo
(Just(defaultHints
{addrFlags =[AI_PASSIVE ]}))
Nothing (Just&quot;79&quot;)
letserveraddr =head addrinfos
sock&lt;-socket (addrFamily serveraddr)
StreamdefaultProtocol
bindSocket sock (addrAddress serveraddr)
listen sock 1
-- only one connection open at a time
conn&lt;-open&quot;finger.db&quot;
handleQueries conn sock
SQLite.close conn
sClose sock
The only new bit above is the opening of a connection to a
SQLite database located in the same directory as your project.
The connection to the database is passed to the query-handling
code, which runs indefinitely like the echo-and-log server. If
it somehow stops without throwing an exception, we close the
server socket, just to be good little programmers.
Now we‚Äôre done, assuming you‚Äôve created a SQLite database</p>
<p>CHAPTER 31. FINAL PROJECT 1887
usingcreateDatabase which is valid and accessible to your pro-
gram, the following should work. You‚Äôll want to do this in one
terminal:
$ stack build
$ sudo <code>stack exec which fingerd</code>
Theninanother, diÔ¨Äerent, shellsessionthefollowingshould
work:
$ finger callen@localhost
Login: callen Name: Chris Allen
Directory: /home/callen Shell: /bin/zsh
And that‚Äôs it. In the exercises, we‚Äôve given some ways to
extend this, and we hope you‚Äôve enjoyed this little foray into
TCP sockets and basic networking. Security concerns aside,
thefinger protocol has been used over the years for some
pretty cool things. Perhaps most famously, John Carmack
used.planfiles as a kind of microblog to deliver updates on
the development process of Quake.7
31.5 Chapter Exercises
1.Try using the sqlite3 command line interface to add a
new user or modify an existing user in finger.db .
7http://atrophied.co.uk/read/john-carmacks-plan-archive</p>
<p>CHAPTER 31. FINAL PROJECT 1888
2.Write an executable separate of fingerd anddebugwhich
allows you to add new users to the database.
3.Add the ability to modify an existing user in the database.
4.Bound on a diÔ¨Äerent port, try creating a ‚Äúcontrol socket‚Äù
that permits inserting new data into the database while
the server is running. This will probably require, at mini-
mum, learning how to use forkIO and the basics of concur-
rency in Haskell among other things. Design the format
for representing the user rows passed over the TCP socket
yourself. For bonus points, write your own client exe-
cutable that takes the arguments from the command line
as well.
5.Celebrate completing this massive book.</p>
<p>Index
(), see unit
(-&gt;), see function type
constructor
(:), see cons
(&lt;-), see bind
($), 79, 80, 82, 389‚Äì391, 1059
<em>, see kind
(++), see concatenation
::, see type signature
&lt;</em>, seeApplicative
&lt;*&gt;, 1054, 1055, 1057, 1059,
1145, see also Applicative
&lt;|&gt;, seeAlternative
&lt;$&gt;, seefmap
=&lt;&lt;, see flip bind
=&gt;, see typeclass constraint
&gt;&gt;, seeMonad
&gt;&gt;=, see bind
[], see list syntax
eta reduction, 1017, 1022~, see tilde
(||), 1231
|, see pipe
abs, 378, 382
abstract datatype, 1031, 1149
abstraction, 7, 32
accessor function, 1508
actual type, 190, 284
actual vs expected type, 1477
ad hoc polymorphism, see
constrained
polymorphism
aeson, 1425, 1476, 1481, 1484,
1488
algebra, 611, 615, 627, 636,
888, 889, 904, 941, 942
algebra, definition, 955
algebraic datatype, 627
All(newtype), 909
1889</p>
<p>INDEX 1890
all, 789
alpha equivalence, 9, 15, 218
Alternative , 1427, 1429, 1433,
1501
ambiguous type, 281, 839,
842, 929
AmbT, 1567
anamorphism, 742
anarchy, 375
anonymous function, 8, 339,
340, 344, 492, 509, 512
anonymous function
definition, 406
syntax, 200
anonymous product, 172,
613, 632
Any(newtype), 909
API definition, 1426
application, 3, 7, 21, 32
Applicative , 1053, 1054, 1127,
1131, 1143, 1150, 1170,
1197, 1226, 1227, 1231,
1283, 1319, 1337, 1341,
1353, 1514, 1525, 1563
Applicative
Compose , 1549IO, 1802
Reader , 1351
composition law, 1108
definition, 1138
homomorphism law, 1109
identity law, 1106
interchange law, 1111
applicative, 1110
Arbitrary , 835, 837, 843, 863,
869, 873, 928, 1012
arbitrary precision, 146
argument, 3, 7, 11, 45, 192,
330, 334, 336, 392, 611
argument
multiple, 15, 192, 194, 195,
198, 330, 332, 333, 459
type, see type argument
argument, definition, 95
arithmetic, 51, 68
arity, 161, 165, 611
arity, definition, 174
Array, 1752
array, 1748
as patterns, 693
ASCII, 1769, 1773
association list, see Map(type)</p>
<p>INDEX 1891
associativity, 53‚Äì55, 185, 196,
367, 541, 550‚Äì553, 557,
569, 885, 890, 892, 905,
915, 925, 927, 932, 941,
1190, 1712
associativity, Monad, 1806
AST, 1460, 1475
asynchronous exception,
1853, 1855
attoparsec , 1425, 1465, 1469
backtracking, 1469, 1471
bang bang, 121, see indexing
bang pattern, 1691, 1693,
1697, 1739
BangPatterns , 1689
base, 258, 502, 787, 937, 1665,
1712
base case, 422, 423, 425, 437,
443, 445, 462, 463, 535,
539
base monad, 1573
benchmarking, 1709, 1716,
1724, 1727, 1739, 1743,
1747, 1751
benchmarkingstring types, 1766
vectors, 1759
beta reduction, 10, 11, 13, 17
Bifunctor , 1519
binary tree, 681, 682, 746, 851
bind, 775, 777, 780, 781, 784,
797, 1144, 1145, 1148, 1156,
1170, 1191, 1202, 1296,
1516, 1522, 1526, 1528,
1531, 1534, 1539, 1543,
1575
bind, definition, 1210
binding, 46, 87, 88, 330, 334,
335, 338, 344
binding
definition, 406
local, 109, 117, 129
top level, 130
Bloodhound (library), 676
Bool, 134, 135, 148, 152, 155,
156, 250, 251, 286, 378,
382, 592, 594, 595, 616,
908
Bool, fun with, 153
bool, 510
Boole, George, 134</p>
<p>INDEX 1892
Boolean logic, 153
bottom, 236, 347, 431‚Äì434,
487, 495, 496, 498, 509,
543, 545, 546, 560, 570,
723, 897, 1180, 1531, 1533,
1632, 1635, 1640, 1658,
1676, 1702, 1722, 1851,
1853
bottom, definition, 412
Bounded , 143, 251
burrito, 1141, 1518
ByteString , 1239, 1253, 1255,
1415, 1469, 1670, 1762,
1767, 1874
ByteString
String conversion, 1769
lazy, 1476, 1479, 1768
lazy vs strict, 1476
strict, 1769
versusText, 1775
bytestring (library), 1241,
1769
Cabal, 752, 753, 1716
.cabal file, 754, 757, 759, 764,
786, 822, 826, 847, 1237,1712
cabal install, 139
Caesar cipher, 519
CAF (constant applicative
form), 1733, 1734, 1736,
1737
call by name, 1657, 1664
call by need, 1657, 1658
call by value, 1657
cardinality, 615, 616, 618, 619,
627, 628, 631‚Äì634, 637,
1474
Carnap, Rudolf, 959, 1048
Cartesian product, 1072
case expression, 360‚Äì363,
375, 537, 710, 806, 1639,
1644, 1652, 1654
cassava , 1425
cast, seeTypeable
catamorphism, 531, 908,
1260, 1268, 1270
catamorphism, definition,
585
catch, 1824, 1829‚Äì1831, 1833
catMaybes , 1287, 1294
Char, 99, 100, 150</p>
<p>INDEX 1893
Char8, 1769
character, 99, 100
checkers (library), 1115, 1117,
1191, 1308
Chomsky hierarchy, 1461
Church, Alonzo, 2
Clinton, George, 1050
closure, 1761
CoArbitrary , 873, 1012
combinator, 21, 22, 1399
command line argument,
1226
comment syntax, 65, 66
commutative monoid, 917
commutativity, 203, 916, 917,
1617
compare , 286
comparison functions, 147,
152, 284
compile a binary, 1826, 1832
compile time, 181, 605, 620,
622
composability, 985
Compose (type), 1308, 1509,
1511, 1513, 1514, 1516,
1548composition, 387‚Äì392, 394,
395, 397, 400, 425‚Äì428,
511, 1199, 1295, 1307,
1320, 1335, 1505, 1518
composition
Traversable , 1308
definition, 415
law, 980, 984, 1108
concat , 107, 110, 1147
concatenation, 105, 107, 110,
113, 115, 891, 894, 916,
1748
concatenation, definition,
129
concrete type, 187, 196, 209,
211, 212, 226, 279, 313,
314, 595, 598, 599, 603,
721‚Äì724, 1526, 1543, 1677,
1679, 1681
concurrency, 1708
conditional, 155
conduit (library), 1567
conjunction, 133, 154, 161,
526
conjunction ( Monoid ), 909,
910</p>
<p>INDEX 1894
cons (:), 119, 459, 460, 464,
487, 503, 504, 533, 554,
555
cons cell, 464, 465, 485‚Äì487,
489, 494, 546
cons cell, definition, 528
cons, definition, 526
Const(type), 1024, 1303
const, 538, 547, 556, 559, 569,
1024
Constant (type), 1024, 1025,
1080
Constant (type)Functor , 1025
constant, 595, 596, 600, 604,
618
constant applicative form,
see CAF
constrained polymorphism,
174, 183, 187, 190, 209,
211, 215, 239, 249, 279,
310, 314, 981, 1466, 1468
constructor, 594, 595, 603,
604, 606, 642
constructor
data, see data constructor
nullary, see nullaryconstructor
smart, see smart
constructor
type, see type constructor
constructor class, 979
containers (library), 1738
Control.Exception , 1857
Control.Monad , 1685
ContT, 1567
criterion , 1709, 1712, 1790
CSV parsing, 1228, 1425
curry, 201
Curry, Haskell, 15
currying, 15, 43, 192,
194‚Äì196, 199, 330, 367
currying, definition, 406
daemon, 1861
Damas-Hindley-Milner, 180,
217
data constructor, 133‚Äì135,
137, 152, 153, 162, 179,
260, 262, 344, 345, 349,
350, 352, 353, 360, 361,
363, 491, 591, 595, 596,
599, 600, 602, 607, 608,</p>
<p>INDEX 1895
611, 612, 619, 632, 633,
638, 707, 710, 729, 730,
732, 1229, 1266, 1644,
1661, 1676, 1720, 1724,
1819
data constructor
currying, 729
definition, 173
infix, 460, 679, 937
data declaration, 134, 135,
179, 258, 592‚Äì594, 597,
606, 608, 705
data declaration
definition, 174
how to read, 134
data structure, 1708, 1736,
1738
Data.Bool , 510
Data.Char , 517, 1772, 1773
Data.Foldable , 1262
Data.Map , 1073, 1219
Data.Maybe , 1356
Data.Monoid , 898, 1262
Data.Tuple , 163
database, 1872, 1875, 1877,
1882, 1885database
FromRow , 1876
ToRow, 1876
datatype, 128, 132, 135, 152,
179, 353, 360, 592
datatype
algebraic, see algebraic
datatype
definition, 129, 703
recursive, 460, 485
Debug.Trace , 1665, 1796
declaration, 41, 45, 46, 61, 85,
108, 152
declaration
class, see typeclass
declaration
data, see data declaration
instance , see typeclass
instance
type, see type alias
fixity, 1712, 1776
import, 765
local, 108
module, 758
newtype, 620
top level, 117, 223, 226</p>
<p>INDEX 1896
type signature, 99, 196
deepseq , 1715
dependency, 753, 758, 787,
823, 824, 826, 827, 833
DeriveGeneric , 874
deriving, 136, 257, 259, 289,
290, 609, 624, 710, 1844
deriving Show, 265, 301, 303
deriving, definition, 323
desugar, 199, 465, 505, 1155,
1161
diÔ¨Äerence list, see DList
disjunction, 133, 134, 152, 154,
527, 627, 652, 1231
disjunction ( Monoid ), 909, 910
distributive property, 636,
637, 639, 640
division, 73, 442, 443, 445
division
fractional, 145, 146, 187
integral, 68
DList, 1388, 1775
dosyntax, 104, 774, 779,
781‚Äì784, 797, 806, 828,
1033, 1145, 1154, 1155,
1161, 1169, 1234, 1350,1554
documentation, 181, 827
Double , 139, 145, 146, 1693
drop, 120, 469, 471
dropWhile , 469, 472, 473
dynamic typechecking, 1823
eÔ¨Äects, 103, 299‚Äì301, 774,
783, 1031, 1149, 1159,
1161, 1221, 1227, 1761,
1782, 1788, 1798, 1799,
1836, 1841
eÔ¨Äects, definition, 323
Either , 640, 709, 712‚Äì714, 716,
717, 722, 844, 1006, 1021,
1132, 1255, 1276, 1298,
1306, 1608, 1819, 1821,
1832
Either
Applicative , 1131
Functor , 1021
Monad, 1182
EitherT , 1235, 1555, 1600,
1610, 1614
elem, 203, 482, 801, 1276
Elliott, Conal, 1115, 1567</p>
<p>INDEX 1897
empty list, 503
Enum, 251, 261, 275, 294, 467
Enumfunctions, 294
enumFromTo , 296
Eq, 148, 249, 251, 252, 256,
258‚Äì260, 270, 272, 292,
293, 710
Eqfunctions, 254
equality, 147, 148, 249, 252,
253, 259, 264, 293
Erlang, 1853
error, 433, 434, 1376
error
ambiguous type variable,
1272
could not deduce, 277, 284,
312, 341
expected vs actual type,
189, 255, 284, 368, 435,
566, 622, 648, 653, 666,
707, 729, 777, 782, 900,
963, 1030, 1201
expecting one more
argument, 725‚Äì727
no instance for, 114, 151,
158, 216, 225, 259, 265,271, 272, 292, 302, 308,
310, 434, 731, 895, 899
no instance for Show, 162,
288
not in scope, 118, 336, 732,
767
too many arguments, 900
error message, how to read,
114, 119, 152, 288
eta reduction, 1673, 1736
Eval(typeclass), 1640
evaluate, 3
evaluation, 20, 41, 47, 49, 196,
485, 487‚Äì491, 493‚Äì498,
504, 508, 539, 550, 1630,
1633, 1640, 1788
evaluation
foldl, 549, 553‚Äì555,
559‚Äì561, 569
foldr, 538, 539, 541‚Äì543,
545, 551, 569
call by need, 491
folds, 541
inside out, 1635
outside in, 1635
recursive function, 538,</p>
<p>INDEX 1898
541, 543
strategies, 1657
evaluation order, 1782, 1786,
1790
Exception (typeclass), 1815,
1844
Exception ,throw, 1840
exception, 122, 347, 361, 431,
432, 1421, 1813, 1825,
1833, 1878
exception
mask_, 1857
asynchronous, see
asynchronous
exception
empty structure, 1278
handling , see exception
handling
loop, 431
missing field, 660
no match, 665
no parse, 304
non-exhaustive patterns,
266, 347, 433, 462
thread blocked, 1794
throw, 1838, 1840, 1842,1843, 1845
undefined, 508, 546, 547,
559, 569
exception handling, 1823,
1824, 1827, 1829, 1831,
1833, 1840, 1841
exception handling
catch, 1824, 1829, 1833, see
alsocatch
Either , 1832
Maybe, 1831
try, 1832, 1833, 1848
bottom, 1851
ExceptT , 1569, 1570, 1584, 1610
executable, 757, 759, 1835,
1880
executable, with arguments,
1836
ExistentialQuantification ,
1819
existential quantification,
1762, 1817, 1821, 1848
exitSuccess , 792
expected type, 190, 256, 284
exponentiation, 55
export, 849</p>
<p>INDEX 1899
expression, 3, 7, 41, 43, 47, 48,
60, 85, 133
expression problem, 249
expression, definition, 95
factorial, 421, 425
fail, 1422
fibonacci, 436, 441, 576‚Äì578
file, 58
filter , 511, 578
finger , 1860
finger tree, 1744
finger, MIT, 1862
First(newtype), 910, 912
FlexibleInstances , 1044
flip, 365, 553
flip bind ( Monad), 1288
Float, 138, 145
floating point numbers, 139
fmap, 500, 502, 508, 714, 732,
962, 1018, 1057, 1059,
1087, 1145, 1157, 1201,
1221, 1224, 1274, 1288,
1295, 1302, 1318, 1330,
1539, 1574
fmap,IO, 1801fmap, infix, 1087
fold, 531, 532, 903, 1038,
1542, 1543, 1635
fold, 1263
fold left, see foldl
fold right, see foldr
fold, definition, 585
Foldable , 112, 482, 532, 790,
903, 1261, 1262, 1302,
1303, 1390
foldl, 548, 549, 559, 570, 572,
588, 1269
foldl' , 561
foldMap , 1261, 1263, 1265,
1270
foldr, 532, 533, 536, 545, 569,
571, 1261, 1267, 1269,
1717, 1724
forall , 1818
foreign function interface
(FFI), 1475
forever , 809, 1685, 1840
Fractional , 138, 146, 215, 276,
277
fractional, 145
FromJSON , 1484, 1486</p>
<p>INDEX 1900
fromMaybe , 1293, 1359
fst, 162, 508
function, 3, 4, 7, 41, 43‚Äì45,
192, 298, 330, 332, 333,
984
function
anonymous, 8
application, 10, 41, 46‚Äì48,
80, 185, 195, 330, 334,
335, 389, 427, 507, 598,
707, 973, 984, 1059, 1071,
1110, 1199, 1219
body, 46
composition, see function
composition
datatype, 184
first-class, 3, 330
head, 46
higher-order, see
higher-order function
infix, 51
mathematical, 48
parameter, 192
prefix, 51
structure, 7, 8
unsafe, 122function composition, 985,
995, 1203, 1209, 1325,
1328, 1331, 1334, 1507,
1509, 1573
function type, 192, 194, 195,
252, 289, 1319
function type
Applicative , 1337
Functor , 1328, 1330, 1336
Monad, 1348
Monoid , 1218, 1220
asReader , 1334
function type constructor,
185, 195, 197, 367, 723,
729, 748, 875
function, definition, 96
functional dependencies,
596
Functor , 500, 502, 714, 958,
960‚Äì962, 965, 972, 973,
984, 1005, 1018, 1039,
1054, 1057, 1143, 1197,
1221, 1276, 1319, 1328,
1330, 1334, 1511, 1524
Functor laws, 979, 983, 1010
Functor , definition, 1047</p>
<p>INDEX 1901
functor, 959, 960, 1142, 1200,
1318, 1325
functor, applicative, 1145
fusion, 1753, 1754
GADTs, 1818, 1819
garbage collection, 1628,
1631, 1736
Gen, 835, 837, 839, 861, 864,
866, 869, 873
GeneralizedNewtypeDeriving ,
624, 626
generalized algebraic
datatype, see GADTs
generator, 477, 478
generator
multiple, 479, 480
Generic , 874
getArgs , 1835
getChar , 1782
getLine , 775, 777, 1157
GHC 8.0, 1693
GHC Core, 1647, 1652, 1654,
1680, 1689
GHC extension, see
language extensionGHC flag, 1729
GHC flag
-ddump , 1435, 1648
-fprof-auto , 1729
-I, 921
-O2, 1710, 1730
-O, 1710
-prof, 1729
-rtsopts , 1730
-Wall, 267, 348, 385
GHC optimization, 1661,
1716, 1730, 1754, 1787
GHC optimization,
strictness, 1669, 1676
GHC Rules, 1754
GHC.Prim , 1785
GHCi, 36, 41, 45, 339, 929,
1031, 1032, 1825
GHCi block syntax, 345, 348,
378
GHCi command
:browse , 358, 765, 827
:info, 53, 78, 135, 144, 155,
250, 252, 843
:kind, 598, 676, 721
:load, 40</p>
<p>INDEX 1902
:main, 1837
:module , 40, 770
:reload , 47
:set, 348, 385, 770, 1436,
1648
:sprint , 488, 493, 1660
:type, 99, 111, 152, 182, 618,
964
GHCi options, 766
Gibbard, Cale, 540
git, 753, 754
gopattern, 445
Gofer, 979
guard, 377, 379, 380,
382‚Äì385, 711
guarded recursion, 1724
gzip, 1768
Hackage, 258
HashMap , 1741
Haskell ninjas, 307
Haskell Report, 279, 596,
600, 720, 1716
head, 120
heap profiling, 1731
hGetChar , 1809hgrev(library), 1226
higher-kinded, 720, 722, 726,
729
higher-kinded
polymorphism
definition, 1047
higher-kinded type, 674, 677,
680, 681, 720, 965, 974,
979, 1005, 1007, 1034,
1047, 1262
higher-kinded type, Functor ,
972
higher-kinded type,
definition, 748
higher-order function, 200,
365, 366, 369, 375, 387,
421, 425, 472, 500, 512,
1399
higher-order function
definition, 413
Hindley-Milner, see
Damas-Hindley-Milner
homomorphism, 1109, 1130
Hoogle, 252
hspec(testing), 822, 825, 828,
833, 845, 1456</p>
<p>INDEX 1903
http-client (library), 1842,
1843
Hutton‚Äôs Razor, 702
I/O, 103, 301, 775, 1825
id, 210, 1507, 1508
idempotent, 881
idempotent, definition, 886
Identity (type), 270, 865,
1078, 1269, 1270, 1302,
1307, 1507, 1508, 1511,
1524, 1568, 1569
identity, 905
identity
function, 11, 12, 21, see id
law, 979, 983, 1106, 1189
property, 929, 932
identity value, 425, 535, 536,
561, 890‚Äì892, 917, 933,
936, 939, 941, 1270
IdentityT , 1508, 1523, 1524,
1526, 1530, 1534, 1538,
1541, 1544, 1589, 1600
idiom, 1139
ifexpression, 155, 156, 360,
361, 363, 377‚Äì380, 509,510, 783, 805
immutability, 504, 511, 643,
683
imperative programming,
783, 1149
import, 109, 155, 163, 246,
765, 767, 787, 825, 850,
855
import
hiding, 1469, 1866
qualified, 768, 1244
qualified as, 769, 850, 1244
import syntax, 1583, 1587
indentation, 59, 60
indexing, 121, 577, 796, 1748
infinite list, 1733
infix operator, 51, 53, 68, 79,
185, 194, 202, 678, 1712
infix operator
associativity, 53‚Äì55, 194,
195
precedence, 53, 54, 195
prefix, 52, 82, 110, 115
sectioning, see sectioning
infix, definition, 96
infixl , 54</p>
<p>INDEX 1904
infixr , 55, 1776
:info, 135
INI, 1444
INLINABLE , 1717
INLINE , 1776
inlining, 1670, 1672, 1787
input, 3
input/output, see I/O
instance, 140, 146, 257
instance , 260
instance, orphan, see orphan
instance
InstanceSigs , 1343, 1515, 1516,
1531
Int, 138, 141, 616, 1693
IntversusInteger , 1719
Int32, 1368
Int8, 142, 616, 629
Integer , 128, 138, 140, 143,
895, 1488
Integer ,Monoid , 895, 896
integer, 68, 140
Integral , 274, 275
Integral functions, 274
interface, 249
intersperse , 791IntMap , 1741
IO (), 103, 300, 776, 779,
1031, 1158
IO, 103, 299, 301, 774, 781,
782, 837, 1031, 1032,
1149, 1154, 1224, 1233,
1235, 1244, 1505, 1522,
1573, 1597, 1759, 1782,
1784, 1825, 1841
IO
Applicative , 1075, 1801,
1802
Functor , 1031, 1157, 1800
Monad, 1149, 1804
asState, 1785, 1786
associativity, 1806
exceptions, 1833
sharing, 1664
unsafe functions, 1809
IOaction, 301, 1161, 1255,
1787, 1789
IO, definition, 323
IO Monad , the, 1784
IOException , 1828, 1831
IRC, 540, 591
irrefutable pattern,</p>
<p>INDEX 1905
1686‚Äì1688, 1694
isomorphism, 885
IsString , 1239, 1241
JavaScript, 1488
join, seeMonad, 1148, 1154,
1160, 1209, 1296, 1529,
1536, 1539, 1543, 1801
join,IO, 1804
JSON, 676, 677, 1397, 1425,
1476, 1481, 1488
JSON parsing, 1227
key-value pair, see Map(type)
keyword
~, 1688, 1694
!, 1691, 1739
*, 598, 966
--, 65
-&gt;, 192, 966
::, 99, 106, 196, 720
&lt;-, 781
=&gt;, 190
=, 45
@, 693
#, 625, 1786
_, 137, 345as, 769, 1244
case, see case expression,
see case expression
class, 305, 960
data, 135, 174, 593
deriving , 257, 609
do, 104, 775, 779
forall , 1818
hiding , 1469, 1866
if-then-else , 156
if, 156
import , 765, 767
infixl , 54, 1712
infixr , 55, 1776
instance , 251, 260, 261
let, 45, 85
let,in, 61
module , 751
newtype , 620
qualified , 768, 769, 1244
type, 620, 633
where, 85, 88, 261, 961
|, 134, 593
kind, 597‚Äì599, 603, 674, 681,
720, 722, 723, 725, 726,
966, 971, 978, 989</p>
<p>INDEX 1906
kind inference, 970
Kleisli composition, 1202,
1203, 1209
lambda, 3, 31, 195
lambda calculus, 2, 32, 43,
48, 180, 192, 298, 427,
1161, 1798
lambda expression, 1761
lambda term, 7
language extension
BangPatterns , 1689
DeriveGeneric , 874
ExistentialQuantification ,
1819
GADTs, 1819
GeneralizedNewtypeDeriving ,
624, 626
InstanceSigs , 1343, 1515,
1516, 1531
NegativeLiterals , 631
NoImplicitPrelude , 766
NoMonomorphismRestriction ,
226
OverloadedStrings , 1214,
1239, 1416, 1469, 1485,1598, 1605, 1767
QuasiQuotes , 1433, 1485,
1873
RankNTypes , 1035
RecordWildCards , 1873
StrictData , 1693
Strict , 1693
TypeApplications , 964
Last(newtype), 910, 912
laws, 904
laws
Applicative , 1106
Functor , 979, 982
Monad, 1188
Monoid , 904
Traversable , 1307
mathematical, 955
laziness, 1630, 1632, see also
nonstrictness
leaf, 682
length , 167, 186, 215, 490,
494‚Äì496, 535, 544, 1275
let, 45, 59, 85, 86, 108, 224,
335, 338, 1685
letexpression, 86, 338
letversuswhere, 85</p>
<p>INDEX 1907
lexing, 1460, 1461
library, 759, 761, 764
library
aeson, 1476
attoparsec , 1425
bytestring , 1241, 1476, 1769
checkers , 1115, 1191
containers , 849, 1738
criterion , 1709
hspec, 822
http-client , 1842
network , 1866
parsec , 1468
parsers , 1412, 1426
QuickCheck , 871, 1012, 1115
random , 792, 1367
scientific , 139, 145
scotty , 1247, 1256, 1576
snap, 1224
sqlite-simple , 1875
text, 1223, 1241, 1763, 1774
time, 1789
transformers , 1378, 1564,
1585, 1598
trifecta , 1415, 1425, 1468
uuid, 1223vector , 1290, 1748
wreq, 1300
lift, seeMonadTrans , 1589,
1608
liftA2 , 1229, 1231
lifting, 977, 981, 1032, 1054,
1055, 1059, 1150, 1221,
1229, 1331, 1511, 1574,
1575, 1580, 1582, 1588
lifting
definition, 1048
liftIO , 1253, 1597, 1608
liftM, 1151
lines, 793
List, 592, 597, 678‚Äì680, 726,
727
list
Applicative , 1061, 1068,
1069
Monad, 1163
Monoid , 1265
datatype, 459, 527, 528
empty, 536
infinite, 542, 543, 561, 576
structure, 486, 487,
494‚Äì496, 507, 529</p>
<p>INDEX 1908
type constructor, 165
list comprehension, 477‚Äì479,
482, 512
list comprehension, with
condition, 478, 479, 482
list functions, 119
list monoid, 1120
list syntax, 165, 460
lists, 98‚Äì100, 105, 112, 113,
119, 165, 464, 500, 503,
891, 893, 1260, 1567,
1695, 1738, 1745, 1747,
1748, 1752
ListT, 1567
logging, 1566
lookup , 1072, 1356
loop fusion, see fusion
LTS Haskell, 754, 755
Main, 89, 1832, 1880
:main, 1837
main, 102‚Äì104, 1243, 1256,
1788, 1835, 1880
main, with arguments, 1836
many, seeAlternative
Map(type), 850, 853, 1073,1219, 1738, 1739, 1741,
1748
map, 500, 502, 506‚Äì508, 533,
534, 962, 1725
mapM_, 1836
mapM, 1289
mappend , 891, 893, 896, 899,
1216
mappend
infix, 901, 1215, 1219
Marlow, Simon, 1792, 1814
marshalling, 1475, 1476, 1486,
see also serialization
marshalling, definition, 1501
max, 286
maxBound , 143
maximum , 1277
Maybe, 128, 433‚Äì435, 462, 463,
705, 706, 708, 722, 724,
725, 727, 802, 805, 844,
871, 910, 1062, 1224,
1255, 1270, 1404, 1604,
1608, 1831
Maybe
Applicative , 1066, 1075,
1083, 1097, 1172</p>
<p>INDEX 1909
Functor , 1015
Monad, 1166, 1172, 1174
Monoid , 1066
MaybeT , 1506, 1548, 1552, 1589,
1591, 1601, 1606
mconcat , 901, 1214
memoization, 1632
memory, 143, 1731, 1733, 1736
memory leak, 1566, 1693
memory leak, definition,
1627
mempty , 891, 893, 902, 1268,
1272, 1419
min, 286
minBound , 143
minimal complete instance,
258, 1285, 1427
minimum , 1277
mod, 69, 71
mod, diÔ¨Äerence from rem, 75
module, 58, 107, 109, 117,
246, 751, 753
module
definition, 239
export, 762
import, 765modules, 175
Monad, 775, 779, 1142‚Äì1144,
1197, 1224, 1233, 1235,
1252, 1327, 1328, 1341,
1345, 1353, 1366, 1516,
1526, 1543, 1563, 1784,
1788, 1798
Monad
(&gt;&gt;), 1402
fail, 1422
IO, 1804
Reader , 1348
composition, 1200
laws, 1188
monad, 828, 839, 866, 1617
monad transformer, 1216,
1235, 1256, 1355, 1378,
1505, 1506, 1508, 1518,
1520, 1523, 1541‚Äì1544,
1547, 1571, 1576, 1591,
1595, 1604
monad transformer,
definition, 1362
monad, definition, 1209
MonadFail , 1422
MonadIO , 1597, 1598, 1600</p>
<p>INDEX 1910
MonadTrans , 1574, 1575, 1582,
1589, 1591
Monoid , 891, 892, 902, 942,
1197, 1215, 1218, 1226,
1262, 1263, 1265
Monoid
Bool, 909, 930, 932
Integer , 895
Maybe, 910‚Äì912
Monoid , of functions, 1218
monoid, 888, 890, 892, 893,
897, 902, 903, 909,
1064, 1071, 1110, 1133,
1152, 1213, 1221, 1233,
1260, 1262, 1263
monoid
commutative, 902
definition, 955
monoidal functor, 1053,
1059, 1066, 1110
monomorphism restriction,
226, 1317
Morse code, 1292
mtl(library), 1383
mutable state, 1760
mutable vector, 1757, 1758mutation, 1366, 1757, 1759,
1761, 1762
MVar, 1792, 1806, 1808
named entities, 175
natural transformation,
1034, 1038, 1132
negate , 77
negation, 84
NegativeLiterals , 630, 631
negative number, 76
nesting, 15, 42, 1161, 1787,
1790, 1798, 1804
network-uri (library), 1252
network (library), 1234, 1866,
1868
network interface, 1475
newtype, 306, 349, 350, 591,
620‚Äì622, 624, 810, 897,
898, 908, 911, 919, 1334,
1338, 1507, 1508, 1578,
1595, 1749, 1775
nf, 1712
NICTA, 1563
nil, 434
NoImplicitPrelude , 766</p>
<p>INDEX 1911
NoMonomorphismRestriction ,
226
non-exhaustive patterns,
267‚Äì269, 385
NonEmpty , 463, 937, 939
nonstrict evaluation, 460,
485‚Äì488, 500, 507
nonstrictness, 47, 196, 508,
542, 546, 561, 1150, 1630,
1632, 1633, 1635,
1657‚Äì1659, 1672, 1694,
1851, 1853
nonstrictness, sharing, 1664
normal form, 20, 21, 42, 49,
490‚Äì492, 499, 637, 639,
640, 1712, 1720, 1727,
1747
normal order, 29, 31, 33
not, 135
null, 1274
nullary, 593, 596, 611, 618
nullary constructor, 729
nullary type, 720
Num, 139, 146, 188, 249, 252,
273, 276, 1240
Numfunctions, 273number, 47
numeric literal, 41, 183, 188,
215, 219, 249, 345, 623,
1240
numeric type, 137
O‚ÄôSullivan, Bryan, 1709
Only, 1879
operator, 51, 890
operator
infix, see infix operator
operator, definition, 96
optimization, 181, 1753
Ord, 148, 150, 251, 261, 272,
284, 286, 289, 290, 292,
293, 312, 369, 371, 682,
851, 1741
Ordfunctions, 284
Ordering , 286
orphan instance, 919,
921‚Äì923, 928
otherwise, 381, 382, 385
overflow, 141, 143
OverloadedStrings , 1214, 1239,
1241, 1243, 1416, 1469,
1485, 1598, 1605, 1767</p>
<p>INDEX 1912
package, 753
parallelism, 1708
param, 1249
parameter, 7, 45, 46, 195, 209,
330‚Äì334, 438, 721
parameter, definition, 95
parametric polymorphism,
174, 209‚Äì211, 213, 239,
310
parametricity, 211, 213, 239,
314, 1039
parentheses, 54, 56, 79, 82,
84, 196, 367, 390, 392,
551, 707
parse error, 62, 64, 66, 826
parsec (library), 1425, 1465,
1468, 1470
Parser (type), 1403, 1422
parser, 1226, 1227, 1250, 1399,
1500, 1565
parser
Hutton-Meijer, 1405
parser combinator, 1399
parser combinator
definition, 1501
parsers (library), 1426, 1429Parsing (typeclass), 1427
parsing, 1396, 1398, 1401,
1460, 1461, 1465, 1468,
1474, 1486
parsing, backtracking, see
backtracking
partial application, 83, 196,
197, 202, 204, 1007, 1319
partial function, 122, 265,
266, 268, 292, 304, 347,
361, 432, 433
pattern match
non-exhaustive, 347, 348
pattern matching, 137, 164,
232, 344‚Äì347, 349, 350,
352‚Äì357, 361, 363, 375,
460, 463, 494, 496, 503,
545, 621, 647, 710, 713,
719, 1031, 1224, 1527,
1644, 1654, 1686, 1850
pattern matching
definition, 406
lazy, 1688
penguins, 355
Peyton-Jones, Simon, 1149
phantom type, 597, 601, 912,</p>
<p>INDEX 1913
1025
pipe, 134, 381, 477, 527, 593,
594
pipes(library), 1567, 1766
pointer, 898, 1749
pointfree, 392‚Äì394, 399,
400, 1673, 1684, 1736
pointfree
definition, 416
polymorphic literal, 1239
polymorphism, 113, 142, 152,
183, 208, 211, 216, 217,
283, 284, 310, 334, 488,
1047, 1317, 1521, 1662,
1681
polymorphism
ad hoc, see constrained
polymorphism
constrained, see
constrained
polymorphism
definition, 174, 239
higher-kinded, 749
parametric, see
parametric
polymorphismpragma, 624, 625
pragma
INLINABLE , 1717
LANGUAGE , 624
MINIMAL , 1261, 1285
UNPACK , 1739
precedence, 53, 55, 76, 79,
389, 1712
prefix, 51
Prelude , 155, 495, 766, 767,
1262, 1283, 1295
primary key, 1875, 1877
primitive type, 1785, 1786
principal type, 239
print it , 288
print, 101, 288, 289, 298, 299,
301, 396, 397, 784
Product (newtype), 896, 898,
901
Product (type), 644, 651, 1272
product, 459, 460, 612, 613
product , 1278
product type, 161, 354, 594,
615, 631‚Äì635, 649, 650,
798, 867
product type, definition, 526</p>
<p>INDEX 1914
profiling, 1727, 1729, 1731,
1733, 1737
prompt, 41
property test, 927
property testing, definition,
885
pseudorandom, 837, 1367,
1369
puppies, 384
pure, 1054, 1144, 1197
pure,IO, 1803
purity, 3, 298, 1798, 1799,
1825
putStr , 101
putStrLn , 101, 784, 1157
quantification
existential, see existential
quantification
universal, 1819
QuasiQuotes , 1433, 1485, 1873
queue, 1778
QuickCheck , 821, 833, 835, 871,
927, 928, 930, 1010,
1012, 1115, 1199, 1308
random (function), 787, 1370random (library), 792, 1367
random number generation,
1223, 1244, 1367, 1382
random values, 793, 837
randomRIO , 795, 797
range syntax, 203, 465, 467,
470, 493, 494
RankNTypes , 1034, 1035
Rational , 139, 145
Read, 251, 303, 304, 1250
Read, is not good, 303, 304
read, 1031
Reader , 989, 1224, 1325, 1327,
1330, 1334, 1335, 1337,
1340, 1341, 1522, 1564,
1566, 1569, 1619
Reader
Functor , 1336
Monad, 1348
ReaderT , 1354, 1355, 1557, 1561,
1564, 1566, 1569, 1585,
1619, 1676, 1808
readFile , 1766
Real, 275
RealWorld , 1785, 1786
record</p>
<p>INDEX 1915
accessor, 635, 665, 1544
syntax, 591, 635, 901
record type, 591
RecordWildCards , 1873
recursion, 420, 421, 428, 439,
494, 500, 504, 534, 535
recursion
definition, 455
guarded, 1724
tail, 587
recursive function, 436, 438,
441, 443‚Äì445, 576
recursive function
evaluation, 425, 440, 446
recursive type, 682
Redis, 1246, 1255
reduce, 3
reducible expression, 42, 48,
49
reduction, 41, 47, 80
referential transparency, 3,
1757, 1760, 1799, 1841
referential transparency, IO,
1799
refutable pattern, 1686
regular expression, 1461:reload , 47
remainder, 68
REPL, 36, 41, 47, 54
replicate , 1854
replicateM , 1245
return , 781, 782, 839, 864,
1032, 1144, 1189, 1591
runtime, 605, 620, 1824
RWST, 1565
scan, 549, 573, 574, 576
Sch√∂nfinkel, Moses, 15
Scientific , 139, 145, 1488
scope, 40, 87, 99, 108, 117, 119,
155, 223, 335, 338, 339,
608, 751, 765
scope
definition, 129
lexical, 337, 339
scotty (web framework),
1214, 1215, 1244, 1247,
1256, 1569, 1576, 1584,
1587, 1595, 1598, 1604,
1609, 1622
sectioning, 81, 83, 202, 204
semantics, 77</p>
<p>INDEX 1916
semantics
IO, 1806
Haskell, 25, 1798
program, 1799
Semigroup , 936, 937, 939, 942
semigroup, 888, 936
semigroup, definition, 955
seq, 1639, 1640, 1643, 1655,
1689, 1693
Sequence (type), 1738, 1744,
1745, 1747, 1748
sequence , 1290, 1294, 1296,
1298
sequenceA , 1285, 1289‚Äì1291,
1308, see also
Traversable
sequencing, 1144, 1149, 1154,
1161, 1227, 1787, see
Monad, 1790
serialization, 296, 303, 1397,
1475, 1486, 1491, 1501
server, 1861, 1867
Set(type), 1738, 1741
set, 133
set theory, 133, 615
Setup.hs , 846shadowing, 336‚Äì339
sharing, 1664, 1668‚Äì1670,
1672, 1677, 1681‚Äì1685,
1733, 1734, 1783, 1786,
1788, 1790, 1791
sharing, IO, 1789, 1791, 1796
Show, 136, 251, 261, 265, 288,
289, 296, 297, 299,
301‚Äì303, 396, 731, 830,
1815
Showfunctions, 297
show, 798
side eÔ¨Äect, see eÔ¨Äects
Simons, 651
smart constructor, 1234
snap(web framework), 1224
snd, 162
snoc, 1776
Snoyman, Michael, 1842
socket, 1234, 1863, 1867, 1869
some, seeAlternative
SomeException , 1817‚Äì1819,
1823, 1824, 1838
source code, 45
spine, 464, 465, 485‚Äì487, 494,
531, 545</p>
<p>INDEX 1917
spine
definition, 529
recursion, 541, 542, 544,
547, 557, 559‚Äì561
spine strict, 490, 494
splitAt , 469, 471
:sprint , 1660, 1676, 1679
SQLite, 1872, 1877, 1881
sqlite-simple (library), 1875,
1879
ST, 1366, 1758‚Äì1760, 1762,
1782, 1785, 1788
Stack, 103, 752, 753, 755, 1239,
1712, 1880
stack.yaml , 755
Stack commands, 754, 784,
846, 1826
Stack commands
build, 755, 760, 824, 827,
833, 1579, 1712, 1887
clean, 1716
exec, 756, 760, 776, 859,
1869
ghci, 36, 755, 824, 862,
1579, 1881
ghciwith options, 766ghc, 1710, 1712, 1729, 1836
init, 824
install , 139
new, 784, 1863
setup, 755
compile a binary, 1836
Stackage, 754
StackOverflow (exception),
1838
State# , 1786
State, 1354, 1366, 1367, 1371,
1378, 1404, 1406, 1564,
1566, 1759, 1761, 1784,
1785
state, 1365, 1371
StateT , 1406, 1561, 1563, 1564,
1566, 1587
static typing, 181
StdGen , 1368
stdin, 1809
stdout , 1809
streaming, 1566, 1567
Strict , 1693
StrictData , 1693
strictness, 488, 494, 497, 508,
538, 545, 561, 1217, 1631,</p>
<p>INDEX 1918
1637‚Äì1639, 1654, 1655,
1657, 1661, 1691, 1695,
1701
String , 99, 100, 106, 113, 119,
126, 128, 259, 289, 296,
297, 301, 303, 304, 482,
1239, 1669, 1670, 1762,
1766
String , definition, 128
strings, 98, 100, 105
subclass, 212
Sum(newtype), 896, 898, 1219
Sum(type), 644, 652, 1272
sum, 497, 534, 1278
sum type, 134, 152, 350, 353,
459, 503, 594, 607, 615,
616, 627, 628, 638, 640,
649, 652, 665, 709, 716,
869, 871
sum type, definition, 526
superclass, 146, 212, 293, 323,
1143
syntactic sugar, 77, 100, 180,
464, 774, 1154
syntactic sugar, definition,
96syntax, 59
System.Environment , 1835
System F, 180
tail, 120, 727
tail call, definition, 587
take, 120, 469, 470, 509, 544,
578
takeWhile , 469, 472
TCP, 1863
Template Haskell, 1435
term level, 133, 152, 161, 175
terminate, 41, 431
testing, 181
testing
property, 820, 833, 861,
862, 873
spec, 820, 822, 828
unit, 819
Text, 1223, 1239, 1247, 1253,
1256, 1670, 1762‚Äì1764,
1766, 1775
text(library), 1223, 1241,
1763, 1774
thread, 1855, 1857
threadDelay , 1840</p>
<p>INDEX 1919
throw, 1840, 1841
throwIO , 1838, 1840‚Äì1842,
1845
thunk, 1628, 1631, 1660, 1662,
1670, 1685, 1693
tie fighter, 1054
tilde, 1688, 1694
time(library), 1789
ToJSON , 1486
token (parsing), 1444, 1460
tokenize, 1460, 1461, 1465
tokenizer, definition, 1501
toList , 1273
top level, 106‚Äì108, 117
total function, 433
trace, 1665, 1677
transformer stack, 1363
transformers (library), 1378,
1383, 1564, 1566, 1569,
1585, 1598, 1610, 1619
Traversable , 1283, 1284, 1306
Traversable laws, 1307
Traversable naturality law,
1307
traverse , 857, 1285, 1287,
1289, 1291, 1292, 1295,1296, 1299, 1307, 1836
tree, binary, see binary tree
trifecta (library), 1400, 1415,
1425, 1465, 1468, 1469
Trivial (type), 258, 259, 596,
597
try(exceptions), 1832, 1833
try(parsing), 1444, 1473
tuple, 161, 198, 256, 356‚Äì358,
445, 471, 480, 613, 632,
633, 640, 721, 989, 1006,
1064, 1229, 1306
tuple
Applicative , 1064
Functor , 1064
constructor, 164
definition, 172
single element, 1879
syntax, 161, 164
typeclass instances, 1306
tuple functions, 162, 163
Turing completeness, 421
twitter-conduit (library), 1831
two‚Äôs complement, 143
type, 98, 100, 101, 132, 133,
249, 591</p>
<p>INDEX 1920
type
concrete, see concrete
type
definition, 129
higher-kinded, see
higher-kinded
lifted, 723
static, 605
unlifted, 723
type alias, 100, 165, 442, 622,
624, 633, 639, 651, 654,
707, 715, 717, 1224, see
also type synonym
type alias, definition, 174
type argument, 459,
594‚Äì597, 606, 608, 609,
613, 619, 633, 650, 674,
680, 681, 721, 722, 725,
729, 1509, 1521
type assignment, 142, 196,
279
type constant, 720, 973
type constructor, 112,
133‚Äì135, 152, 179, 184,
260, 361, 593, 595, 596,
599, 638, 720‚Äì724, 728,748, 974, 979, 1039, 1050,
1507, 1509, 1511, 1521
type constructor
definition, 173
infix, 679
type declaration, 106
type defaulting, 142, 146,
279‚Äì281, 929, 1481, 1681,
1719
type error, 114
type families, 596
type inference, 109, 180, 217,
218, 224, 279, 680, 1719
type inference, definition,
239
type level, 175
type parameter, 161
type signature, 39, 99, 100,
106, 112, 133, 181, 196,
222, 436, 442, 445, 598,
603, 720, 1718
type signature
how to read, 111, 148, 185
type synonym, 106, 442, 443,
1578, see also type alias
type theory, 615</p>
<p>INDEX 1921
type variable, 112, 176, 210,
211, 215, 239, 334, 594,
597, 600, 601
Typeable , 1815, 1823, 1824
TypeApplications , 964, 1068
typechecking, 181
typeclass, 114, 136, 140, 146,
187, 209, 249, 258, 306,
532, 624, 890, 892, 922,
979, 1466
typeclass
definition, 172, 239
dispatched by type, 304,
307, 309
unique pairing, 1039
typeclass constraint, 146, 148,
183, 187, 190, 211, 215,
219, 223, 256, 271, 272,
275, 279, 281, 292, 293,
310, 312‚Äì314, 731, 912,
1029, 1054, 1143, 1662,
1673, 1675, 1676, 1679,
1681
typeclass declaration, 305,
307, 960
typeclass deriving, 257, seealso deriving
typeclass hierarchy, 252
typeclass inheritance, 212,
275, 276
typeclass inheritance,
definition, 323
typeclass instance, 249‚Äì251,
253, 257‚Äì261, 263, 264,
270‚Äì272, 289‚Äì292, 302,
304‚Äì306, 308, 609, 622,
624, 625, 836
typeclass instance
Show, 799
how to read, 262
unique, 923
typeclass instance,
definition, 323
types vs terms, 209, 211, 249,
310, 595, 596, 605, 651
unary, 596, 612, 613, 619, 620
unconditional case, 269
uncurry, 198, 199, 201
uncurry , 1358
undefined, 236, 468, 487,
495, 508, 543, 545, 546,</p>
<p>INDEX 1922
1531, 1658
underscore, 137, 269,
345‚Äì347, 354, 375, 496,
503, 801
unfold, 742
Unicode, 100, 1253, 1769, 1771
unit, 299, 301, 782, 839
unit testing, definition, 885
unmarshalling, 1484, see also
serialization
unmarshalling, definition,
1501
UNPACK , 1739
unsafePerformIO , 1807, 1808
URL shortener, 1237
UTC time, 1789
UTF-16, 1764, 1767, 1769
UTF-8, 1253, 1256, 1415, 1764,
1769, 1773‚Äì1775, 1874
utf8-string (library), 1774
uuid(library), 1223
Validation , 1132, 1133, 1186
value, 3, 41, 45, 47, 99, 133,
135, 330‚Äì333, 595, 599,
600, 604, 618, 1676value, definition, 96
variable, 3, 7, 9, 44, 46, 99,
176, 330, 334
variable
bound, 7, 11, 13
free, 13, 15, 21
naming conventions, 176
single letter, 177
type, see type variable
Vector , 1290, 1741, 1748, 1750,
1752, 1756
Vector , mutable, 1757, 1758
vector, 1767
vector (library), 1290, 1748,
1754
vector
batch updates, 1756
boxed, 1749
slicing, 1750
unboxed, 1749
Vigen√®re cipher, 692, 1809
Wadler, Philip, 209, 249
Wall, 268
-Wall, 267
warning, 268, 269, 348</p>
<p>INDEX 1923
warning
non-exhaustive patterns,
267, 348
out of range, 142
pattern match overlap,
346
shadowing, 348
weak head normal form, 49,
490, 491, 493, 494, 499,
1217, 1640, 1643, 1654,
1661, 1663, 1712, 1713,
1720, 1721, 1725
web application, 1214, 1215,
1225, 1249
web framework, see scotty
web server, 1256
where, 85, 86, 88, 108, 117, 224,
261, 362, 384whitespace, 59
whnf, see weak head normal
form
whnf, 1712
Windows, 1861
Word8, 1767
words, 794
wreq(library), 1300
writeFile , 1826, 1829
Writer , 1564, 1566
WriterT , 1564, 1566
XML, 1397
xmonad , 1216, 1220
Y combinator, 421, 428
zip, 514, 1121
zipList , 1120, 1123
zipWith , 515, 806, 1152</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
